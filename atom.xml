<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SwiftGG]]></title>
  <subtitle><![CDATA[走心的 Swift 翻译组]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://swiftggteam.github.io/"/>
  <updated>2015-11-03T03:58:20.085Z</updated>
  <id>http://swiftggteam.github.io/</id>
  
  <author>
    <name><![CDATA[SwiftGG]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[WatchConnectivity 介绍：告别加载等待]]></title>
    <link href="http://swiftggteam.github.io/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/"/>
    <id>http://swiftggteam.github.io/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/</id>
    <published>2015-11-03T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.085Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p>在 WatchOS 2 上最有价值的新特性就是<code>WatchConnectivity</code>，虽然用户可能看不到，但是这个特性能让你的 WatchOS 应用更加好用。</p>
<a id="more"></a>
<p><code>WatchConnectivity</code>是 WatchOS 2 框架中用于 Watch 应用和 iOS 设备传输数据的。<code>WatchConnectivity</code> 关键的部分是，它使你的应用程序在用户<strong>查看之前</strong>就拿到必要的数据。这意味着用户想要看你的应用时，他们希望马上看到想要的数据，而不是愚蠢的加载等待。</p>
<p>毕竟， Apple Watch 是一个移动中使用的设备。用户们可能想要看一两眼在 iOS 应用上超级可爱的刷新动画，但显然他们不会忍受在手表上看到这样的动画。设想一下，如果用户每次在他们常规的手表上查看时间，引入眼帘的是一个加载等待界面，那将会非常愚蠢，同理，你的应用如果这么做也一样愚蠢。</p>
<p>现在你不必再担心了，<code>WatchConnectivity</code>完全可以解决这个难题，它可以毫无压力地传输你应用上的数据到 Watch 应用上。整个过程都是无缝透明的，以至于你的用户都察觉不到发生了什么。</p>
<p>让我们开始深入吧！<code>WatchConnectivity</code>有两个部分-后台传输（<code>background transfers</code>）和交互式消息（<code>interactive messaging</code>）。我将会在未来的教程里探究它的每一个部分的更多细节，但是这里只是一个概述，思考传输时应该使用哪一种传输模型：</p>
<h2 id="后台传输">后台传输</h2><p>在你的 iOS 或者 Watch 应用不需要马上获得信息时使用后台传输。当然，在你的用户抬起他们的手腕时查看应用里面的最新数据时，它会显示数据，但是此前他们不需要任何数据。</p>
<p>因为后台传输用于传输不是立刻使用数据， Apple 认为使用后台传输的最佳时机是当你需要根据电池容量、网络连接、使用模式传输数据时。</p>
<p>在你的 iOS 和 Watch 应用之间的后台传输数据有三种方式：</p>
<h3 id="应用上下文">应用上下文</h3><p>当你的 Watch 应用只需要展示最新的信息时，使用应用上下文。例如，当你的<code>Glance</code>显示比分时，用户不会在意两分钟以前的 4-2 比分，他们只在乎现在的比分是 4-4 。另一个例子是交通运输应用，你不需要关心五分钟以前最后的一辆公交车在公交站的左边，他们只关心下一辆公交车什么时候到。</p>
<p>所以应用上下文的工作方式是把数据块排成队列，并且如果在传输之前有一个新的可用数据块，原始的数据将会被新数据取代，然后再传输这个数据，除非它又被其它更新的数据块代替。</p>
<p><a href="http://natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="external">Tutorial: Sharing The Latest Data via Application Context</a> </p>
<h3 id="用户信息">用户信息</h3><p>用户信息是用于当你需要确认你的所有数据是被传输过的（不像应用上下文）。用户信息的数据是在一个先进先出（<code>FIFO (first-in-first-out)</code>） 队列中顺序传输，所以没有东西被覆盖。</p>
<p>一个例子是你可能想要在一个文本消息的应用中使用它-对于一个完整的会话和上下文环境来说，最后一条信息和第一条信息是同等重要的。如果用户更新了他们简介信息中的一小部分，Watch 简介中也应该同步这些更新。</p>
<h3 id="文件传输">文件传输</h3><p>顾名思义，在你的 iOS 和 Watch 应用之间使用文件传输去传输文件，例如图片或者<code>plists</code>。文件传输一个很棒的特性是你可以包含一个<code>meta-data</code>字典，其中包含你的文件名和数据，比如说这样你就可以排序你的图片。</p>
<h2 id="交互式消息">交互式消息</h2><p>使用交互式消息能够实时地在你的 iOS 和 Watch 应用之间传输数据！一个绝佳的示例就是愤怒的小鸟应用的 Watch 版本和 iPhone 版本-用户点击 Watch，但是小鸟在手机上飞。按钮点击通过交互式消息被传输到手机上了。</p>
<p><img src="/img/articles/watchconnectivity-introduction-say-goodbye-to-the-spinner/flappybirdwatch.gif1446514271.8482146" alt="这里写图片描述"></p>
<p>一个需要注意的地方是，交互式消息需要 iPhone 开启<code>&quot;reachable&quot;</code>状态。Apple 文档解释道：</p>
<blockquote>
<p>Watch 应用的可达性需要配对的 iOS 设备在重启之后至少解锁一次。</p>
</blockquote>
<h2 id="总结">总结</h2><p>我爱死<a href="http://www.kristinathai.com/watchos-2-how-to-communicate-between-devices-using-watch-connectivity/" target="_blank" rel="external">Kristina Thai’s WatchConnectivity post</a> 里面区别传输的图解了：</p>
<p><img src="/img/articles/watchconnectivity-introduction-say-goodbye-to-the-spinner/Screen-Shot-2015-09-21-at-8.17.29-AM.png1446514277.5708654" alt="这里写图片描述"></p>
<p>同时，本文参考了 Curtis Herbert 的文章 <a href="http://blog.curtisherbert.com/data-synchronization-with-watchos/" target="_blank" rel="external">Getting Data to Your WatchOS 2 App</a> 中最后的 Watch OS 2 observations 部分。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p>在 WatchOS 2 上最有价值的新特性就是<code>WatchConnectivity</code>，虽然用户可能看不到，但是这个特性能让你的 WatchOS 应用更加好用。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
      <category term="WatchOS 2" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/WatchOS-2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchConnectivity：学习 WCSession]]></title>
    <link href="http://swiftggteam.github.io/2015/11/02/watchconnectivity-say-hello-to-wcsession/"/>
    <id>http://swiftggteam.github.io/2015/11/02/watchconnectivity-say-hello-to-wcsession/</id>
    <published>2015-11-01T16:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在读这篇文章之前，请检查一下你是否已经学习了之前两篇关于<code>WatchOS 2</code>的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World</a></li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">WatchConnectivity Introduction: Say Goodbye To The Spinner</a></li>
</ul>
<p><code>WCSession</code>就是<code>WatchConnectivity</code>的魔力源泉，所以让我们赶紧深挖它吧！</p>
<a id="more"></a>
<p><code>WCSession.defaultSession()</code>会返回<code>WCSession</code>的单例，用于在 iOS 和 Watch 应用之间传输数据。但是，在使用<code>WCSession</code>时仍有一些值得注意的地方。</p>
<p>首先，你必须给<code>session</code>设置一个<code>delegate</code>并启动它。</p>
<blockquote>
<p>“默认的<code>session</code>用于两个对应应用的通信（例如 iOS 应用和它的原生 WatchKit 扩展）。这个<code>session</code>提供发送、接收和追踪状态的方法。</p>
<p>启动一个应用时，应该在默认的<code>session</code>上设置一个<code>delegate</code>并启动它。这将允许系统填充状态属性和提供任何优秀的背景传输。”—— Apple 文档说明。</p>
</blockquote>
<p>所以你的代码应该写成这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">session.delegate = <span class="keyword">self</span></span><br><span class="line">session.activateSession()</span><br></pre></td></tr></table></figure>
<p>在这里，我推荐将你的<code>WCSession</code>作为一个单例，这样就可以在应用中随意使用它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that the WCSessionDelegate must be an NSObject </span></span><br><span class="line"><span class="comment">// So no, you cannot use the nice Swift struct here!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Instantiate the Singleton</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Keep a reference for the session, </span></span><br><span class="line">    <span class="comment">// which will be used later for sending / receiving data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Activate Session</span></span><br><span class="line">    <span class="comment">// This needs to be called to activate the session before first use!</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activateSession()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以在<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法中启动你的<code>session</code>，并且可以在应用的任意位置使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated...</span></span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication,</span><br><span class="line">        didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set up and activate your session early here!</span></span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.startSession()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated...</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是启动<code>session</code>是远远不够的。你需要通过<code>WCSession</code>的多重检查，这样你的应用就不需要做额外的格式化传输数据工作。</p>
<h1 id="检查设备是否支持">检查设备是否支持</h1><blockquote>
<p>检查 iOS 设备是否支持 session，WatchOS 也是支持 session 的。</p>
</blockquote>
<p>如果你有一个通用应用，那就需要注意，例如iPad 不支持<code>WCSession</code>（因为 iPad 不能和 Watch 配对）。因此确保在 iOS 项目中做<code>isSupported()</code>检查：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">WCSession</span>.isSupported() &#123;</span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">    session.delegate = <span class="keyword">self</span></span><br><span class="line">    session.activateSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着你的<code>WatchSessionManager</code>单例需要适应不支持<code>WCSession</code>的场景（使用可选值）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modification to the WatchSessionManager in the iOS app only</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated ... see above section</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the session is now an optional, since it might not be supported</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// starting a session has to now deal with it being an optional</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session?.delegate = <span class="keyword">self</span></span><br><span class="line">        session?.activateSession()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Watch_相关的_iOS_App_状态">Watch 相关的 iOS App 状态</h1><p>如果你从 iOS 应用发送数据到 Watch，你需要做一些额外的检查，这样当 Watch 处于无法接受数据的状态时，你就不会浪费 CPU 资源去处理用于传输的数据。</p>
<p><strong>是否配对</strong></p>
<p>显然，为了从 iOS 设备传输数据到 Watch，用户必须有一个 Watch 并且和 iOS 设备配对。</p>
<p><strong>是否安装 Watch 应用</strong></p>
<p>一个用户可能有一对设备，当然可以选择删除手表中的应用，所以为了数据传输，你需要检查你的应用确实有安装在所配对的 Apple Watch 上面。</p>
<p>如果用户有一对设备但是没有对应的应用，那你就可以在合适的时机向用户推荐你的应用，他很可能会安装你的应用。</p>
<p>为了让这些检查更加简单，并且能够在应用中随意使用，我喜欢在 iOS 应用中创建一个<code>validSession</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modification to the WatchSessionManager in the iOS app only</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated... see above</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add a validSession variable to check that the Watch is paired</span></span><br><span class="line">    <span class="comment">// and the Watch App installed to prevent extra computation </span></span><br><span class="line">    <span class="comment">// if these conditions are not met.</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// This is a computed property, since the user can pair their device and / or</span></span><br><span class="line">    <span class="comment">// install your app while using your iOS app, so this can become valid  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validSession: <span class="type">WCSession</span>? &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// paired - the user has to have their device paired to the watch</span></span><br><span class="line">        <span class="comment">// watchAppInstalled - the user must have your watch app installed</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Note: if the device is paired, but your watch app is not installed</span></span><br><span class="line">        <span class="comment">// consider prompting the user to install it for a better experience</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = session <span class="keyword">where</span> session.paired &amp;&amp; session.watchAppInstalled &#123;</span><br><span class="line">            <span class="keyword">return</span> session</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// truncated... see above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>并发是否可用</strong></p>
<p>最后，如果你在应用中有使用并发，你必须检查并发是否可用。我不会在<code>WatchConnectivity</code>教程中介绍过多并发的细节，但是如果你想要知道更多，可以观看超级有用和全面的 <a href="https://developer.apple.com/videos/wwdc/2015/?id=209" target="_blank" rel="external">WWDC 2015 Creating Complications with ClockKit session</a>。</p>
<p><strong>sessionWatchStateDidChange</strong></p>
<p>注意，如果你的 iOS 应用需要<code>WCSession</code>状态变化的信息，这里有一个 delegate 方法，专门用于通知<code>WCSession</code>的状态变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Called when any of the Watch state properties change */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sessionWatchStateDidChange</span><span class="params">(session: WCSession)</span></span> &#123;</span><br><span class="line">        <span class="comment">// handle state change here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>例如，如果你的应用需要安装 Watch 应用，可以实现这个<code>delegate</code>方法，然后去检测你的 Watch 应用是否真正安装了，并且让用户在 iOS 应用中进行设置。</p>
<h1 id="检查设备可达状态">检查设备可达状态</h1><p>为了正确在 iOS 和 Watch 中使用<code>Interactive Messaging</code>传输数据，你需要做一些额外的工作以确保两个应用处于可达状态：</p>
<blockquote>
<p>Watch 应用的可达状态需要所配对的 iOS 设备在重启后至少解锁一次。这个属性能够用于决定 iOS 设备是否需要被解锁。如果<code>reachable</code>设为<code>NO</code>，可能是由于设备重启过，需要解锁。如果处于这种状态，Watch 将会展示一个提示框建议用户去解锁他们配对的 iOS 设备。</p>
</blockquote>
<p>在使用<code>Interactive Messaging</code>时，我喜欢给我的单例增加一个额外的<code>valideReachableSession</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: Interactive Messaging</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Live messaging! App has to be reachable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validReachableSession: <span class="type">WCSession</span>? &#123;</span><br><span class="line">        <span class="comment">// check for validSession on iOS only (see above)</span></span><br><span class="line">        <span class="comment">// in your Watch App, you can just do an if session.reachable check</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = validSession <span class="keyword">where</span> session.reachable &#123;</span><br><span class="line">            <span class="keyword">return</span> session</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>session</code>是不可达的，你可以如 Apple 所建议的那样，提示用户去解锁他们的 iOS 设备。为了获知用户解锁设备，实现<code>sessionReachabilityDidChange</code>的<code>delegate</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sessionReachabilityDidChange</span><span class="params">(session: WCSession)</span></span> &#123;</span><br><span class="line">    <span class="comment">// handle session reachability change</span></span><br><span class="line">    <span class="keyword">if</span> session.reachable &#123;</span><br><span class="line">        <span class="comment">// great! continue on with Interactive Messaging</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 😥 prompt the user to unlock their iOS device</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上！现在你应该已经知道了<code>WCSession</code>的一些要领，所以我们将会学习更加好玩的部分 —— 真正使用它在 iOS 和 Watch 之间接收和发送收据！</p>
<p>你可以在 GitHub 查看完整的<a href="https://gist.github.com/NatashaTheRobot/6bcbe79afd7e9572edf6" target="_blank" rel="external">WatchSessionManager单例</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在读这篇文章之前，请检查一下你是否已经学习了之前两篇关于<code>WatchOS 2</code>的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/">WatchOS 2: Hello, World</a></li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/">WatchConnectivity Introduction: Say Goodbye To The Spinner</a></li>
</ul>
<p><code>WCSession</code>就是<code>WatchConnectivity</code>的魔力源泉，所以让我们赶紧深挖它吧！</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
      <category term="WatchOS 2" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/WatchOS-2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊单子（Monad）]]></title>
    <link href="http://swiftggteam.github.io/2015/10/30/lets-talk-about-monads/"/>
    <id>http://swiftggteam.github.io/2015/10/30/lets-talk-about-monads/</id>
    <published>2015-10-30T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/17/lets-talk-about-monads/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/" target="_blank" rel="external">之前的一篇文章</a>中，我们用<code>map</code>、<code>flatMap</code>这两种基于<code>Optional</code>和<code>Array</code>类型的方法做了很多好玩儿的事情。但你可能并没有意识到，你已经在不自知的情况下使用了单子<em>(单子，即 Monad：一个函数式编程的术语 - 译者注)</em>。那么什么是单子？</p>
<a id="more"></a>
<h3 id="什么是函子（Functors）和单子">什么是函子（Functors）和单子</h3><p>我们在<a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/" target="_blank" rel="external">之前的一篇文章</a>中得知了<code>map</code>和<code>flatMap</code>对于<code>Array</code>和<code>Optional</code>来说有着相似的作用，甚至连函数签名都十分相似。</p>
<p>实际上这并不是一个特例：很多类型都有类似<code>map</code>和<code>flatMap</code>的方法，而这些方法都有那种类型的签名。这是一种十分常见的模式，这种模式的名字叫做<em>单子</em>。</p>
<p>你可能之前在网上看过单子这个术语(也可能叫做函子)，还看过尝试解释该术语的各种比喻。但是大部分比喻都让它更加复杂难懂。</p>
<p><strong>事实上，单子和函子是非常简单的概念。</strong>它可以最终归结为：</p>
<p><strong>一个函子</strong>是一种表示为<code>Type&lt;T&gt;</code>的类型，它：</p>
<ul>
<li>封装了另一种类型（类似于封装了某个<code>T</code>类型的<code>Array&lt;T&gt;</code>或<code>Optional&lt;T&gt;</code>）</li>
<li>有一个具有<code>(T-&gt;U) -&gt; Type&lt;U&gt;</code>签名的<code>map</code>方法</li>
</ul>
<p><strong>一个单子</strong>是一种类型，它：</p>
<ul>
<li>是一个函子（所以它封装了一个<code>T</code>类型，拥有一个<code>map</code>方法）</li>
<li>还有一个具有<code>(T-&gt;Type&lt;U&gt;) -&gt; Type&lt;U&gt;</code>签名的<code>flatMap</code>方法</li>
</ul>
<p>这就是对<em>单子</em>和<em>函子</em>所需要了解的一切！<strong>一个<em>单子</em>就是一种带有<code>flatMap</code>方法的类型，一个<em>函子</em>就是一种带有一个<code>map</code>方法的类型。</strong>很简单，不是么？</p>
<h3 id="各种类型的单子">各种类型的单子</h3><p>你已经学过两种既是<em>函子</em>又是<em>单子</em>的类型，它们是：<code>Array&lt;T&gt;</code>和<code>Optional&lt;T&gt;</code>。当然，这样的类型还有很多。</p>
<p>实际上这些类型的方法会有其他的名字，不限于<code>map</code>和<code>flatMap</code>。例如一个<a href="http://promisekit.org/" target="_blank" rel="external">Promise</a>也是一个单子，而它的相对应的<code>map</code>和<code>flatMap</code>方法叫做<code>then</code>。</p>
<p>仔细看一下<code>Promise&lt;T&gt;</code>的<code>then</code>方法签名，思考一下：它拿到未来返回的值<code>T</code>，进行处理，然后要么返回一个新类型<code>U</code>，要么返回一个封装了这个新类型的、新的<code>Promise&lt;U&gt;</code>… 没错，我们又一次得到了相同的方法签名，所以<code>Promise</code>实际上也是一个<code>单子</code>！</p>
<p>有很多类型都符合单子的定义。比如<code>Result</code>，<code>Signal</code>，… 你还可以想到更多（如果需要的话你甚至可以创建你自己的单子）。</p>
<p>看出相似性了吗？（为方便对比加了空格）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array, Optional, Promise, Result 都是函子</span></span><br><span class="line">   anArray     .<span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">anOptional     .<span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"> aPromise     .then( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt;  <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">   aResult     .<span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt;   <span class="type">Result</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array, Optional, Promise, Result 都是单子</span></span><br><span class="line">   anArray .flatMap( transform: <span class="type">T</span> -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt; ) -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">anOptional .flatMap( transform: <span class="type">T</span> -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt; ) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">  aPromise    .then( transform: <span class="type">T</span> -&gt;  <span class="type">Promise</span>&lt;<span class="type">U</span>&gt; ) -&gt;  <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">   aResult .flatMap( transform: <span class="type">T</span> -&gt;   <span class="type">Result</span>&lt;<span class="type">U</span>&gt; ) -&gt;   <span class="type">Result</span>&lt;<span class="type">U</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="把map()和flatMap()级联起来">把<code>map()</code>和<code>flatMap()</code>级联起来</h3><p>通常你还可以把这两个方法级联，这会使它们更加强大。例如，最开始你有一个<code>Array&lt;T&gt;</code>，通过使用<code>map</code>来对它做<code>转换</code>操作，得到一个<code>Array&lt;U&gt;</code>，然后对这个<code>Array&lt;U&gt;</code>再级联上一个<code>map</code>，对它做另一个<code>转换</code>操作将其转换成一个<code>Array&lt;Z&gt;</code>，等等。这会让你的代码看起来就像是在生产线上一样：把一个初始值拿来，让他经过一系列的黑盒子处理，然后得到一个最终的结果。这时你就可以说你实际上是在做<em>函数式编程</em>了！</p>
<p>下面是一个示范如何将<code>map</code>和<code>flatMap</code>的调用级联起来去做多次转换的例子。我们从一个字符串开始，把它按单词分开，然后依次做如下转换：</p>
<ol>
<li>统计每个单词的字符个数，做计数</li>
<li>把每个计数转换成一个相对应的单词</li>
<li>给每个结果加个后缀</li>
<li>对每个字符串结果做%转义</li>
<li>把每个字符串结果转换成一个<code>NSURL</code></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter = <span class="type">NSNumberFormatter</span>()</span><br><span class="line">formatter.numberStyle = .<span class="type">SpellOutStyle</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"This is Functional Programming"</span></span><br><span class="line"><span class="keyword">let</span> translateURLs = string</span><br><span class="line">    <span class="comment">// Split the characters into words</span></span><br><span class="line">    .characters.<span class="built_in">split</span>(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">// Count the number of characters on each word</span></span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">     <span class="comment">// Spell out this number of chars (`stringFromNumber` can return nil)</span></span><br><span class="line">    .flatMap &#123; (n: <span class="type">Int</span>) -&gt; <span class="type">String</span>? <span class="keyword">in</span> formatter.stringFromNumber(n) &#125;</span><br><span class="line">     <span class="comment">// add " letters" suffix</span></span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>)</span> letters"</span> &#125;</span><br><span class="line">    <span class="comment">// encode the string so it can be used in an NSURL framgment after the # (the stringByAdding… method can return nil)</span></span><br><span class="line">    .flatMap &#123; $<span class="number">0</span>.stringByAddingPercentEncodingWithAllowedCharacters(.<span class="type">URLFragmentAllowedCharacterSet</span>()) &#125;</span><br><span class="line">    <span class="comment">// Build an NSURL using that string (`NSURL(string: …)` is failable: it can return nil)</span></span><br><span class="line">    .flatMap &#123; <span class="type">NSURL</span>(string: <span class="string">"https://translate.google.com/#auto/fr/<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(translateURLs)</span><br><span class="line"><span class="comment">// [https://translate.google.com/#auto/fr/four%20letters, https://translate.google.com/#auto/fr/two%20letters, https://translate.google.com/#auto/fr/ten%20letters, https://translate.google.com/#auto/fr/eleven%20letters]</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码可能需要你研究一会儿，尝试去理解每一个中间阶段的<code>map</code>和<code>flatMap</code>的签名是什么，并搞清楚每一步都发生了什么事。</p>
<p>但无论如何，你能看出来对于描述一系列处理流程来说，这是一种很好的方式。这种方式可以被看做是一条生产线，从<code>原材料</code>开始，然后对它做多种<code>转换</code>，最终在生产线的尽头拿到<code>成品</code>。</p>
<h3 id="结论">结论</h3><p>尽管看起来很吓人，但单子很简单。</p>
<p>但实际上，你怎么叫它们都没关系。只要你知道如果你想把一种封装类型转换成另一种，而某些类型的<code>map</code>和<code>flatMap</code>方法着实能帮到你，这就够了。</p>
<hr>
<p>这篇文章是”Swift编程思想”系列的后记。别担心，我还会写很多文章，论述 Swift 在其他应用场景下的美妙之处，不过我不会再拿这些和 ObjC 比较了（因为 Swift 真的好太多了，你现在应该完全把 ObjC 忘掉了 😄）。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/17/lets-talk-about-monads/">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="http://daizi.me">小袋子</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/">之前的一篇文章</a>中，我们用<code>map</code>、<code>flatMap</code>这两种基于<code>Optional</code>和<code>Array</code>类型的方法做了很多好玩儿的事情。但你可能并没有意识到，你已经在不自知的情况下使用了单子<em>(单子，即 Monad：一个函数式编程的术语 - 译者注)</em>。那么什么是单子？</p>]]>
    
    </summary>
    
      <category term="Crunchy Development" scheme="http://swiftggteam.github.io/tags/Crunchy-Development/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 Swift 进行列表解析及其性能问题]]></title>
    <link href="http://swiftggteam.github.io/2015/10/29/list-comprehensions-and-performance-with-swift/"/>
    <id>http://swiftggteam.github.io/2015/10/29/list-comprehensions-and-performance-with-swift/</id>
    <published>2015-10-29T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Veronica Ray，<a href="http://jamesonquave.com/blog/list-comprehensions-and-performance-with-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-15<br>译者：<a href="http://weibo.com/riven0951" target="_blank" rel="external">riven</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a></p>
<p>本文写于 2015.8.15 适用于 Xcode 6 和 Swift 1.2</p>
</blockquote>
<p>列表解析可以让你用更简洁的方式来创建列表。尽管列表解析没有在 Swift 的语言指南中提及，但你也可以在 Swift 中实现类似列表解析的一些操作。</p>
<a id="more"></a>
<p>如果你想创建一个对元素求平方的列表，像这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> squares = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    squares.append(x*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Python 中，使用列表解析是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = <span class="type">Array</span>(<span class="built_in">map</span>(<span class="number">1</span>..&lt;<span class="number">10</span>) &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>对列表中所有元素进行求和你可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> square <span class="keyword">in</span> squares &#123;</span><br><span class="line">    sum = sum + square</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 reduce 函数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = squares.<span class="built_in">reduce</span>(<span class="number">0</span>, &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>对于其它语言中的列表解析，你可以使用任意的序列或者集合作为输入，而不仅仅是一个区间值。</p>
<p><a href="http://stackoverflow.com/questions/24003584/list-comprehension-in-swift" target="_blank" rel="external">你可以使用 map/reduce/filter/stride 函数创建你想要的列表类型</a></p>
<p>列表解析的两个主要优点是让代码变的更简洁和生成更快的二进制码。</p>
<p>我刚刚模拟的列表解析看起来很简洁吧。但我很好奇是否它也能产生更快的二进制码。</p>
<p><a href="https://medium.com/swift-programming/secret-of-swift-performance-fcc5d2a437a8" target="_blank" rel="external">这篇文章</a> 介绍了如何使用 Hopper 来分析 Swift 的汇编代码，Hopper 是一个 OS X 和 Linux 反编译程序。 你可以免费使用 Hopper ，不需要付任何费用。</p>
<p>没有使用列表解析的代码片段和模拟列表解析的代码片段都产生了同样的汇编代码.</p>
<p><img src="/img/articles/list-comprehensions-and-performance-with-swift/asm.png1446426438.2465854" alt="The assembly code from Hopper"></p>
<p>因为两个代码片段产生的汇编代码是一样的，所以我可以认为它们的执行时间是一样的。我们可以使用 XCTest 来测试我们程序的执行时间并证明这一点。</p>
<p>测试没有使用列表解析的代码片段</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testNoListComprehensionPerformance</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.measureBlock() &#123;</span><br><span class="line">        <span class="keyword">var</span> squares = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">            squares.append(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关的输出是：</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testNoListComprehensionPerformance]’ started.</p>
<p>:0: Test Case ‘-[speedTestTests.speedTestTests testNoListComprehensionPerformance]’ measured [Time, seconds] average: 0.000, relative standard deviation: 236.965%, values: [0.000154, 0.000005, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: “”, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testNoListComprehensionPerformance]’ passed (0.262 seconds).</p>
<p>测试模拟列表解析的代码片段</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testSortaListComprehensionPerformance]’ started.</p>
<p>:0: Test Case ‘-[speedTestTests.speedTestTests testSortaListComprehensionPerformance]’ measured [Time, seconds] average: 0.000, relative standard deviation: 160.077%, values: [0.000045, 0.000005, 0.000004, 0.000003, 0.000003, 0.000003, 0.000003, 0.000004, 0.000003, 0.000003], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: “”, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testSortaListComprehensionPerformance]’ passed (0.255 seconds).</p>
<hr>
<p><strong>他们平均只相差 0.007 秒</strong></p>
<hr>
<p>我见过最酷的列表解析的应用便是拼写检查。Airspeed Velocity 针对 <a href="http://norvig.com/spell-correct.html" target="_blank" rel="external">Peter Norvig 的  Python 版本的拼写检查</a>，<a href="http://airspeedvelocity.net/2015/05/02/spelling/" target="_blank" rel="external">改写了一个 Swift 版本</a>。</p>
<p>在 Swift 中使用类列表解析的操作的主要优点就是简洁性。 <a href="http://www.paulgraham.com/power.html" target="_blank" rel="external">Paul Graham 写了一大篇关于在编程语言中简洁是多么重要的文章。</a> 因为每个程序员每天只能写一定行数的代码，如果你以同样数量的代码行数完成更多功能，那你每天便可以完成更多的工作任务。这种力量也会让你重新思考编写什么样的程序是可能的。在一些更繁琐的语言中，这个拼写检查的例子可能就是一个巨大的项目。我喜欢像拼写检查这种充满技术复杂性和神秘感的事物，并且在 Swift 中可以只用几行代码便能解决。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Veronica Ray，<a href="http://jamesonquave.com/blog/list-comprehensions-and-performance-with-swift/">原文链接</a>，原文日期：2015-08-15<br>译者：<a href="http://weibo.com/riven0951">riven</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/linusling">小铁匠Linus</a></p>
<p>本文写于 2015.8.15 适用于 Xcode 6 和 Swift 1.2</p>
</blockquote>
<p>列表解析可以让你用更简洁的方式来创建列表。尽管列表解析没有在 Swift 的语言指南中提及，但你也可以在 Swift 中实现类似列表解析的一些操作。</p>]]>
    
    </summary>
    
      <category term="Jameson Quave" scheme="http://swiftggteam.github.io/tags/Jameson-Quave/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于 Swift 的 5 个误区]]></title>
    <link href="http://swiftggteam.github.io/2015/10/28/five-myths-about-swift/"/>
    <id>http://swiftggteam.github.io/2015/10/28/five-myths-about-swift/</id>
    <published>2015-10-28T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/five-myths-about-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-19<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 虽然是一门比较新的技术语言，却已经有了很多关于 Swift 的误区。</p>
<a id="more"></a>
<h2 id="误区_1_：“Swift_是弱类型的语言”">误区 1 ：“Swift 是弱类型的语言”</h2><p>很多人认为 Swift 是一种弱类型的语言。他们这么说的原因主要是可以隐式声明一个值，而不管类型是什么：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这代码看上去好像<code>i</code>没有类型，其实并不是这样的。因为 5 是一个整型，所以编译器就会让<code>i</code>成为整型变量。之后，整型变量<code>i</code>不会再被改变，也就是说<code>i</code>永远是整型变量。</p>
<p>当然，我们也可以明确的指定变量的类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>虽然这种方式不是必要的，但它可以提高代码的可读性。</p>
<h2 id="误区_2_：“Swift_和_Objective-C_协作性差”">误区 2 ：“Swift 和 Objective-C 协作性差”</h2><p>很多人不想开始尝试使用 Swift，因为他们认为 Swift 不能兼容现存的 Objective-C 代码和类库。其实并不是这样的。在同一个工程中，同时使用 Swift 和 Objective-C 也是可行的。并且，在 Swift 代码中也可以使用 Objective-C 的第三方库。</p>
<p>可以在所谓的桥接文件中声明 Objective-C 的头文件，然后，所有头文件的内容都会被翻译成 Swfit 的语法，这样在调用 Objective-C 的 API 的时候就不会感觉到什么区别了。甚至 Objective-C 错误处理也被转换成 Swift 的<code>do-try-catch</code>语法了。</p>
<p>苹果的框架仍然是用 Objective-C 写的，如果Swift 和 Objective-C 协作性差的话事情就会变得很糟。</p>
<h2 id="误区_3_：“必须在新的项目中使用_Swift”">误区 3 ：“必须在新的项目中使用 Swift”</h2><p>我觉得在新项目中使用 Swift 是个很好的想法，而且每个 iOS 开发者都应该学 Swift。</p>
<p>但是，你没必要一定要在新项目中开始使用 Swift。现在苹果官方还在支持 Objective-C，至少近几年不会改变。但是，我认为苹果未来对 Objective-C 的支持会越来越少。</p>
<p>可以去我发布的另一篇文章 <a href="http://www.thomashanning.com/should-you-use-objective-c-or-swift/" target="_blank" rel="external">Should You Use Objective-C or Swift?</a> 里看看关于本误区的其他详情。</p>
<h2 id="误区_4_：“只学_Swift_就够用了”">误区 4 ：“只学 Swift 就够用了”</h2><p>Swift 是门很棒的编程语言，它也可以用在生产环境，但是仅仅学 Swift 是不够的。原因大致如下：Swift 和 Objective-C 有很好的协作性，而且项目中也经常会有 Objective-C 的代码，同时，许多的示例代码和教程是用 Objective-C 写的。</p>
<p>因此，为了成为一个优秀的 iOS 开发者，最好能同时学会 Swift 和 Objective-C。</p>
<h2 id="误区_5_：“Swift_还不能用在生产环境”">误区 5 ：“Swift 还不能用在生产环境”</h2><p>很多人认为 Swift 还不能用在生产环境。其中一个原因就是，引进 Swift 到工程中时会有一些问题出现，尤其是 Xcode 会有一些 bug。如果知道一些变通方法的话，还是可以在生产环境使用 Swift 的。</p>
<p>Swift 1.2 和 Swift 2.0 的引进都有对语言的语法进行修改。因此，把现存的 Swift 代码迁移到新的语法上是必要的。当然，这也没什么可指责的，毕竟每个 iOS 版本都有代码在变更。而且，这也是 Swift 在尝试改善的重要标志，特别是在 Swift 发布不久的现阶段。</p>
<h2 id="接下来做什么">接下来做什么</h2><p>如果你想学习更多有关 Swift 的知识，学习<a href="https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11" target="_blank" rel="external">苹果的Swift文档</a>是一个非常好的开始。如果想了解其它的资源，可以关注一下我的博客<a href="http://www.thomashanning.com/how-to-stay-up-to-date-on-ios-development/" target="_blank" rel="external"> “How To Stay Up-To-Date On iOS Development”</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/five-myths-about-swift/">原文链接</a>，原文日期：2015-10-19<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 虽然是一门比较新的技术语言，却已经有了很多关于 Swift 的误区。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解 Swift 模式匹配]]></title>
    <link href="http://swiftggteam.github.io/2015/10/27/swift-pattern-matching-in-detail/"/>
    <id>http://swiftggteam.github.io/2015/10/27/swift-pattern-matching-in-detail/</id>
    <published>2015-10-27T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-20<br>译者：<a href="http://blog.csdn.net/mmoaay" target="_blank" rel="external">mmoaay</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在众多 Swift 提供给 Objective-C 程序员使用的新特性中，有个特性把自己伪装成一个无聊的老头，但是却在如何优雅的解决“鞭尸金字塔“的问题上有着巨大的潜力。很显然我所说的这个特性就是 <code>switch</code> 语句， 对于很多 Objective-C 程序员来说，除了用在 <a href="http://en.wikipedia.org/wiki/Duff%27s_device" target="_blank" rel="external">Duff’s Device</a> 上比较有趣之外，<code>switch</code> 语句非常笨拙，与多个 <code>if</code> 语句相比，它几乎没有任何优势。</p>
<a id="more"></a>
<p>不过 Swift 中的 <code>switch</code> 语句能做的就多了。在接下来的教程里，我会更加详细的讲解这些新特性的各种用途。我会忽略那些与 Objective-C 和 C 中 <code>switch</code> 语句相比没有任何优势的解决方案。这篇文章基础的部分写于 2014 年 7 月，但是很多我写的模式都会导致编译器崩溃，所以我只好推迟这些内容的编写，直到编译器能提供更好的支持。</p>
<p>这篇博客还有如下语言的版本：</p>
<blockquote>
<p><a href="http://qiita.com/mono0926/items/f2875a9eacef53e88122" target="_blank" rel="external">日语</a> （感谢 <a href="https://twitter.com/_mono" target="_blank" rel="external">M Ono</a>！）</p>
</blockquote>
<h1 id="开始咯">开始咯</h1><p> <code>switch</code> 语句主要的特性当然是模式匹配咯，模式匹配可以对值进行解构，然后根据相应 <code>case</code> 的正确匹配值来进行匹配。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 历史上最坏的一个例子：二进制-&gt;十进制的转换</span></span><br><span class="line"><span class="keyword">let</span> bool1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bool2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> (bool1, bool2) &#123;</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>): <span class="built_in">print</span>(<span class="string">"0"</span>)</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">1</span>): <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">0</span>): <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">1</span>): <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模式匹配很早以前就在其他语言中存在了，这些语言包括 Haskell、Erlang、Scala 和 Prolog。这是一个福音，因为它允许我们观察那些语言如何利用模式匹配来解决问题。我们甚至可以通过观察它们的例子来找到最实用的那个。</p>
<h1 id="一个交易引擎">一个交易引擎</h1><p>假设华尔街找到你，他们需要一个新的运行在 iOS 设备上的交易平台。因为是交易平台，所以你需要给交易定义一个 <code>enum</code>。</p>
<h2 id="第一步">第一步</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trades</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时还会提供如下的 API 给你来进行交易处理。<strong>注意销售订单的金额是如何变成负数的</strong>，而且他们还说股票的价格不重要，他们的引擎会在内部选择一个价格。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> - 参数 stock: 股票的名字</span><br><span class="line"> - 参数 amount: 金额, 负数表示销售额, 正数表示购买额</span><br><span class="line">*/</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">process</span><span class="params">(stock: String, <span class="number">_</span> amount: Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"<span class="subst">\(amount)</span> of <span class="subst">\(stock)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步就是对交易进行处理。你会发现模式匹配在写这个业务时所具备的强大处理能力：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aTrade = <span class="type">Trades</span>.<span class="type">Buy</span>(stock: <span class="string">"APPL"</span>, amount: <span class="number">200</span>, stockPrice: <span class="number">115.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aTrade &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Buy</span>(<span class="keyword">let</span> stock, <span class="keyword">let</span> amount, <span class="number">_</span>):</span><br><span class="line">    process(stock, amount)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Sell</span>(<span class="keyword">let</span> stock, <span class="keyword">let</span> amount, <span class="number">_</span>):</span><br><span class="line">    process(stock, amount * -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "buy 200 of APPL"</span></span><br></pre></td></tr></table></figure>
<p>Swift 可以让我们非常方便的从 <code>enum</code> 中解构/提取出我们真正想要的信息。在这个例子中只有 <code>stock</code> 和 <code>amount</code> 被解构出来。</p>
<p>真棒，现在你可以去华尔街展示这个极好的交易平台了。然而，现实往往比美好的想象要残酷得多。你以为交易就是你以为的交易么？</p>
<ul>
<li>你必须根据不同的交易方式计算费用。</li>
<li>机构越小，费用越高</li>
<li>而且，机构越大，优先级越高。</li>
</ul>
<p>华尔街的人也意识到要处理这些问题你需要新的 API，所以他们给了你下面的两个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processSlow</span><span class="params">(stock: String, <span class="number">_</span> amount: Int, <span class="number">_</span> fee: Float)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"slow"</span>) &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFast</span><span class="params">(stock: String, <span class="number">_</span> amount: Int, <span class="number">_</span> fee: Float)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"fast"</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="交易类型">交易类型</h2><p>于是你回到绘图板重新增加了一个 <code>enum</code>。交易类型也是每个交易的一部分。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TraderType</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">SingleGuy</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Company</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trades</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>, type: <span class="type">TraderType</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>, type: <span class="type">TraderType</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，如何更好地实现这一新机制呢？你可以用一个 <code>if / else</code> 分支来实现购买和销售，但是这会导致代码嵌套以至于很快代码就变的不清晰了——而且谁知道那些华尔街人会不会给你找新的麻烦。所以你应该把它定义为模式匹配的一个新要求：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aTrade = <span class="type">Trades</span>.<span class="type">Sell</span>(stock: <span class="string">"GOOG"</span>, amount: <span class="number">100</span>, stockPrice: <span class="number">666.0</span>, type: <span class="type">TraderType</span>.<span class="type">Company</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aTrade &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, -<span class="number">1</span> * amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, amount, <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, -<span class="number">1</span> * amount, <span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的优雅之处在于它非常简洁的描述了不同可能的组合。注意我们把 <code>.Buy(let stock, let amount)</code> 修改成 <code>let .Buy(stock, amount)</code> 来进行简化，这样就可以用更少的语句来像之前一样对 <code>enum</code> 进行解构。</p>
<h2 id="警卫！警卫！呼叫警卫！">警卫！警卫！呼叫警卫！</h2><p>于是你再次向你的华尔街用户展示你的开发成果，而他们又提出了新的问题（你真应该把项目的细节问得更清楚一点）。</p>
<ul>
<li>交易总额超过 1.000.000\$ 的销售订单通常需要更快进行处理，就算是个人客户也得这样。</li>
<li>交易总额小于 1.000\$ 的购买订单通常处理更慢。</li>
</ul>
<p>如果使用传统的 <code>if</code> 语句，这时代码就应该已经有点凌乱了，而 <code>switch</code> 就不会。Swift 为 <code>switch cases</code> 提供了保护机制，这种机制可以让你进一步的对可能匹配的 <code>case</code> 进行约束。</p>
<p>你只需要对 <code>switch</code> 语句稍作修改就可以满足新的变化。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aTrade = <span class="type">Trades</span>.<span class="type">Buy</span>(stock: <span class="string">"GOOG"</span>, amount: <span class="number">1000</span>, stockPrice: <span class="number">666.0</span>, type: <span class="type">TraderType</span>.<span class="type">SingleGuy</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aTrade &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, price, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>)</span><br><span class="line">    <span class="keyword">where</span> price*<span class="type">Float</span>(amount) &gt; <span class="number">1000000</span>:</span><br><span class="line">    processFast(stock, -<span class="number">1</span> * amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, -<span class="number">1</span> * amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, price, <span class="type">TraderType</span>.<span class="type">Company</span>)</span><br><span class="line">    <span class="keyword">where</span> price*<span class="type">Float</span>(amount) &lt; <span class="number">1000</span>:</span><br><span class="line">    processSlow(stock, amount, <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, amount, <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, -<span class="number">1</span> * amount, <span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码结构很清晰，阅读起来也相当简单，对复杂情况的封装也很好。</p>
<p>就是这样，我们已经成功的实现了我们的交易引擎。然而，这个解决方案还是有点繁琐；我们在想是否还有对其进行改进的模式匹配方案。所以，让我们继续深入研究一下模式匹配。</p>
<h1 id="模式匹配进阶">模式匹配进阶</h1><p>现在我们在实战中已经见过了几种模式。但其语法是什么？还能匹配什么？Swift 将这些模式分为 <strong>7</strong> 种。我们现在就来认识一下它们。</p>
<p>所有的这些模式不仅能用在 <code>switch</code> 关键词上，而且可以用在 <code>if</code>，<code>guard</code> 和 <code>for</code> 关键词上。如需了解详情，接着看下面的内容。</p>
<h2 id="1-_通配符模式">1. 通配符模式</h2><p>通配符模式会忽略需要匹配的值，这种 <code>case</code> 下任何值都是有可能的。这和 <code>let _ = fn()</code> 一样的模式，在这个模式下， <code>_</code>  表示你将不再使用这个值。有意思的是这个模式可以匹配包括 <code>nil</code> <a href="#1">1</a>在内的所有值 。如果增加一个 <code>?</code>，它甚至可以匹配可选值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">switch</span> p &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">_</span>?: <span class="built_in">print</span> (<span class="string">"Has String"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>: <span class="built_in">print</span> (<span class="string">"No String"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像你在交易例子里面看到的一样，它也允许你忽略需要匹配的 <code>enum</code> 或者 <code>tuples</code> 中无用的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">15</span>, <span class="string">"example"</span>, <span class="number">3.14</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, <span class="number">_</span>, <span class="keyword">let</span> pi): <span class="built_in">print</span> (<span class="string">"pi: <span class="subst">\(pi)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-_标示模式">2. 标示模式</h2><p>匹配一个具体的值。这个和 Objective-C 的 <code>switch</code> 实现是一样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">5</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">print</span>(<span class="string">"5"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-_值绑定模式">3. 值绑定模式</h2><p>这种模式和通过 <code>let</code> 或者 <code>var</code> 绑定值到变量一样，但是只能用在 <code>switch</code> 中。因为你之前已经见到过，所以我只给出一个非常简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">4</span>, <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> (x, y): <span class="built_in">print</span>(<span class="string">"<span class="subst">\(x)</span> <span class="subst">\(y)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-_元组模式">4. 元组模式</h2><p><a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="external">关于元组我已经写了一整篇博文</a>，这篇博文所提供的信息远远比这里多，但是我还是在这里给出一个简短的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">let</span> job: <span class="type">String</span>? = <span class="string">"Operator"</span></span><br><span class="line"><span class="keyword">let</span> payload: <span class="type">AnyObject</span> = <span class="type">NSDictionary</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (age, job, payload) &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">let</span> age, <span class="number">_</span>?, <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSDictionary</span>):</span><br><span class="line">  <span class="built_in">print</span>(age)</span><br><span class="line">  <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们把 3 个值结合放到一个元组中（假想它们是通过调用不同的 API 得到的），然后一口气匹配它们，注意这个模式完成了三件事情：</p>
<ol>
<li>提取 <code>age</code></li>
<li>确保存在一个 <code>job</code>，就算我们不需要它</li>
<li>确保 <code>payload</code> 的类型是 <code>NSDictionary</code>，尽管我们同样不需要访问它的具体值。</li>
</ol>
<h2 id="5-_枚举_Case_模式（Enumeration_Case_Pattern）">5. 枚举 Case 模式（Enumeration Case Pattern）</h2><p>就如你在交易例子中所见，模式匹配对 Swift 的 <code>enum</code> 支持<strong>相当棒</strong>。这是因为 <code>enum cases</code> 就像密封、不可变且可解构的结构体。这非常像 <code>tuples</code>，你可以打开正好匹配上的某个单独 <code>case</code> 的内容然后只抽取出你需要的信息<a href="#2">2</a>。 </p>
<p>假想你正在用函数式的风格写一个游戏，然后你需要定义一些实体。你可以使用 <code>structs</code> 但是你的实体的状态很少，你觉得这样有点矫枉过正。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Soldier</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tank</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Player</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你需要实现绘图循环。这里我们只需要 X 和 Y 坐标：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> entities() &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Soldier</span>(x, y):</span><br><span class="line">      drawImage(<span class="string">"soldier.png"</span>, x, y)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Tank</span>(x, y):</span><br><span class="line">      drawImage(<span class="string">"tank.png"</span>, x, y)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Player</span>(x, y):</span><br><span class="line">      drawImage(<span class="string">"player.png"</span>, x, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-_类型转换模式">6. 类型转换模式</h2><p>就像名字所表示的一样，这种模式转换或者匹配类型。它有两种不同的关键词：</p>
<ul>
<li><code>is</code> <strong>类型</strong>：匹配右手边内容的运行时类型（或者类型的子类）。它会做类型转换但是不关注返回值。所以你的 <code>case</code> 块不知道所匹配的类型是什么。</li>
<li>模式 <code>as</code> <strong>类型</strong>：和 <code>is</code> 模式做同样的匹配操作，但是如果成功的话会把类型转换到左侧指定的模式中。</li>
</ul>
<p>下面是这两种关键词的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Any</span> = <span class="number">5</span> </span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">  <span class="comment">// 这会失败因为它的类型仍然是 `Any`</span></span><br><span class="line">  <span class="comment">// 错误: binary operator '+' cannot be applied to operands of type 'Any' and 'Int'</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Int</span>: <span class="built_in">print</span> (a + <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 有效并返回 '6'</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> n <span class="keyword">as</span> <span class="type">Int</span>: <span class="built_in">print</span> (n + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>is</code> 前没有 <code>pattern</code>。它直接和 <code>a</code> 做匹配。</p>
<h2 id="7-_表达模式">7. 表达模式</h2><p>表达模式非常强大。它可以把 <code>switch</code> 的值和实现了 <code>~=</code> 操作符的表达式进行匹配。而且对于这个操作符有默认的实现，比如对于范围匹配，你可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">5</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>..<span class="number">10</span>: <span class="built_in">print</span>(<span class="string">"In range 0-10"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更有趣的可能是自己重写操作符，然后使你的自定义类型可以匹配。我们假定你想重写之前写的士兵游戏，而且你无论如何都要使用结构体。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hp: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你想轻松的匹配所有血量为 <strong>0</strong> 的实体。我们可以像下面一样实现 <code>~=</code> 操作符。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~= <span class="params">(pattern: Int, value: Soldier)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern == value.hp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就可以对一个实体做匹配了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> soldier = <span class="type">Soldier</span>(hp: <span class="number">99</span>, x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">switch</span> soldier &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">print</span>(<span class="string">"dead soldier"</span>)</span><br><span class="line">   <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，对元组做全匹配似乎不好使。如果你编写下面的代码，就会出现类型检查错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~= <span class="params">(pattern: <span class="params">(hp: Int, x: Int, y: Int)</span></span></span>, value: <span class="type">Soldier</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> (hp, x, y) = pattern</span><br><span class="line">   <span class="keyword">return</span> hp == value.hp &amp;&amp; x == value.x &amp;&amp; y == value.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个可能解决上述类似问题的方案是给你的 <code>struct</code> 增加一个 <code>unapply</code> 方法然后再进行匹配：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">unapply</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">self</span>.hp, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> ~= <span class="params">(p: <span class="params">(Int, Int, Int)</span></span></span>, t: (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> p.<span class="number">0</span> == t.<span class="number">0</span> &amp;&amp; p.<span class="number">1</span> == t.<span class="number">1</span> &amp;&amp; p.<span class="number">2</span> == t.<span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> soldier = <span class="type">Soldier</span>(hp: <span class="number">99</span>, x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(soldier.unapply() ~= (<span class="number">99</span>, <span class="number">10</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>但是这相当繁琐而且没有利用好模式匹配背后的大量魔法般的效果。</p>
<p>在这篇博文之前的版本中我写过 <code>~=</code> 不适用于协议，但是我错了。我记得我在一个 <code>Playground</code> 中试过。而这个例子（<a href="https://www.reddit.com/r/swift/comments/3hq6id/match_me_if_you_can_swift_pattern_matching_in/cub187r" target="_blank" rel="external">由 reddit 上的 latrodectus 友情提供</a>）是完全可用的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tank</span>: <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.value = value &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Peasant</span>: <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.value = value &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> ~=<span class="params">(pattern: Entity, x: Entity)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.value == x.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="type">Tank</span>(<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Peasant</span>(<span class="number">42</span>): <span class="built_in">print</span>(<span class="string">"Matched"</span>) <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以利用 <code>Expression Patterns</code> 做很多事情。如果想要了解更多表达模式的细节，<a href="http://austinzheng.com/2014/12/17/custom-pattern-matching/" target="_blank" rel="external">看看这篇由 Austin Zheng 写的超棒博文</a>。</p>
<p>现在我们已经讲完了所有可能的 <code>switch</code> 模式。在我们继续讲解之前，还需要讨论最后一件事情。</p>
<h2 id="fallthrough，break_和标签">fallthrough，break 和标签</h2><p>下面的内容和模式匹配没有直接关系，仅仅是和 <code>switch</code> 关键词有关，所以我就简单说了。和 C/C++/Objective-C 不一样的是：<code>switch cases</code> 不会自动进入下一个 <code>case</code>，这也是为什么 Swift 不需要给每个 <code>case</code> 都写上 <code>break</code>。你可以选择使用 <code>fallthrough</code> 关键词来实现传统的自动进入下一个 <code>case</code> 的行为。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">5</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Is 5"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Is a number"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会在命令行输出: "Is 5" "Is a number"</span></span><br></pre></td></tr></table></figure>
<p>另外，你可以使用 <code>break</code> 来提前跳出 <code>switch</code> 语句。既然不会默认进入下一个 <code>case</code>，为什么还需要这么做呢？比如你知道在一个 <code>case</code> 中有一个必须的要求是不满足的，这样你就不能继续执行这个 <code>case</code> 了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userType = <span class="string">"system"</span></span><br><span class="line"><span class="keyword">let</span> userID = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> (userType, userID)  &#123;</span><br><span class="line">   <span class="keyword">case</span> (<span class="string">"system"</span>, <span class="number">_</span>):</span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> userData = getSystemUser(userID) <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"user info: <span class="subst">\(userData)</span>"</span>)</span><br><span class="line">     insertIntoRemoteDB(userData)</span><br><span class="line">   <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br><span class="line">... 其他你需要执行的代码</span><br></pre></td></tr></table></figure>
<p>在这段代码中，当 <code>getSystemUser</code> 返回的结果是 <code>nil</code> 时你不想再继续调用 <code>insertIntoRemoteData</code>。当然，你可以在这里使用 <code>if let</code>，但是如果多个这样的情况结合到一起的时候，很快你就会得到一堆可怕丑陋的 <code>if lets</code> 嵌套代码。</p>
<p>但是如果你是在一个 <code>while</code> 循环中执行你的 <code>switch</code> 语句，然后你想跳出循环，而不是 <code>switch</code> 的时候，你需要怎么做呢？对与这种情况， Swift 允许你定义一个 <code>labels</code> ，然后 <code>break</code> 或者 <code>continue</code> 到这个 <code>labels</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> state() &#123;</span><br><span class="line">     <span class="keyword">case</span> .<span class="type">Waiting</span>: <span class="keyword">continue</span> gameLoop</span><br><span class="line">     <span class="keyword">case</span> .<span class="type">Done</span>: calculateNextState()</span><br><span class="line">     <span class="keyword">case</span> .<span class="type">GameOver</span>: <span class="keyword">break</span> gameLoop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经讨论过 <code>switch</code> 和模式匹配的语法和实现细节。现在，让我们来看一些（多少有点）有趣的真实案例。</p>
<h1 id="真实案例">真实案例</h1><h2 id="可选值">可选值</h2><p><a href="http://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="external">对可选值进行解包的方式有很多种</a>，模式匹配就是其中一种。可能到现在这种方法你已经用得非常频繁了，但还是给一个简短的例子吧：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">String</span>? = secretMethod()</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">None</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"is nothing"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> a:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(a)</span> is a value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 Swift 2.0 的话，这会更简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">String</span>? = secretMethod()</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"is nothing"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> a?:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(a)</span> is a value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，<code>result</code> 可以是一个字符串，但是它也可能是 <code>nil</code>，因为它是 <code>optional</code> 值。通过对 <code>result</code> 执行 <code>switch</code>。我们可以确定它是 <code>.None</code> 或者是一个确定的值。更进一步，如果他是一个确定的值，我们可以在 <code>a</code> 这种情况下马上把这个值绑定到一个变量。这段代码代码的优美之处在于：变量 <code>result</code> 可能存在的两种状态被非常明显的区分开来。</p>
<h2 id="类型匹配">类型匹配</h2><p>做为强类型语言，Swift 通常不会像 Objective-C 那样经常需要运行时类型检查。然而，当你需要与传统的 Objective-C 代码交互时（<a href="https://netguru.co/blog/objective-c-generics" target="_blank" rel="external">这还没有更新到简单泛型的反射一文中</a>），那你就经常会碰到需要做类型检查的代码。假想你得到了一个包含 <code>NSString</code> 和 <code>NSNumber</code> 元素的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u = <span class="type">NSArray</span>(array: [<span class="type">NSString</span>(string: <span class="string">"String1"</span>), <span class="type">NSNumber</span>(int: <span class="number">20</span>), <span class="type">NSNumber</span>(int: <span class="number">40</span>)])</span><br></pre></td></tr></table></figure>
<p>当你遍历这个 <code>NSArray</code> 时，你永远不知道得到的是什么类型。然而， <code>switch</code> 语句可以让你很简单的检查这些类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> u &#123;</span><br><span class="line">    <span class="keyword">switch</span> x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSString</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSNumber</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"number"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unknown types"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按范围做分级">按范围做分级</h2><p>现在你正在给你当地的高校写分级的 iOS 应用。老师想要输入一个 0 到 100 的数值，然后得到一个相应的等级字符（A-F）。模式匹配现在要来拯救你了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aGrade = <span class="number">84</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aGrade &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">90</span>...<span class="number">100</span>: <span class="built_in">print</span>(<span class="string">"A"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>...<span class="number">90</span>: <span class="built_in">print</span>(<span class="string">"B"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">70</span>...<span class="number">80</span>: <span class="built_in">print</span>(<span class="string">"C"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>...<span class="number">70</span>: <span class="built_in">print</span>(<span class="string">"D"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>...<span class="number">60</span>: <span class="built_in">print</span>(<span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Incorrect Grade"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字频率统计">字频率统计</h2><p>有一系列的数据对，每个数据对代表一个字和它在某段文字中出现的频率。我们的目标就是把那些低于或者高于某个固定阈值的数据对过滤掉，然后只返回剩下的不包含其频率的所有字。</p>
<p>这是我们的字集：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wordFreqs = [(<span class="string">"k"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">7</span>), (<span class="string">"b"</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>一个简单的解决方案是使用 <code>map</code> 和 <code>filter</code> 进行建模：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = wordFreqs.<span class="built_in">filter</span>(&#123; (e) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> e.<span class="number">1</span> &gt; <span class="number">3</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="built_in">map</span> &#123; $<span class="number">0.0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>然而，因为 <code>flatmap</code> 只能返回非空元素，所以这个解决方案还有很大的改进空间。首先，我们可以放弃使用 <code>e.1</code> 而利用元组来做适当的解构（你猜对了）。然后我们只需要调用一次 <code>flatmap</code>，这样可以减少先 <code>filter</code> 后 <code>map</code> 所带来的不必要的性能开销。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = wordFreqs.flatMap &#123; (e) -&gt; <span class="type">String</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (s, t) <span class="keyword">where</span> t &gt; <span class="number">3</span>: <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="遍历目录">遍历目录</h2><p>假想你需要遍历一个文件树然后查找以下内容：</p>
<ul>
<li>所有 customer1 和 customer2 创建的 “psd“文件</li>
<li>所有 customer2 创建的 “blend“文件</li>
<li>所有用户创建的 “jpeg“文件</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> enumerator = <span class="type">NSFileManager</span>.defaultManager().enumeratorAtPath(<span class="string">"/customers/2014/"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> enumerator &#123;</span><br><span class="line">    <span class="keyword">switch</span> (url.pathComponents, url.pathExtension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// customer1 和 customer2 创建的 “psd“文件</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">let</span> f, <span class="string">"psd"</span>) </span><br><span class="line">	    <span class="keyword">where</span> f.<span class="built_in">contains</span>(<span class="string">"customer1"</span>) </span><br><span class="line">	    || f.<span class="built_in">contains</span>(<span class="string">"customer2"</span>): <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// customer2 创建的 “blend“文件</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">let</span> f, <span class="string">"blend"</span>) <span class="keyword">where</span> f.<span class="built_in">contains</span>(<span class="string">"customer2"</span>): <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的 “jpeg“文件</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, <span class="string">"jpg"</span>): <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>contains</code> 在第一个匹配就结束然后就不用遍历完整的路径了。同样，模式匹配的代码非常简洁明了。</p>
<h2 id="Fibonacci">Fibonacci</h2><p>同样，来看一下使用模式匹配实现的 fibonacci 算法有多优美<a href="#3">3</a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> n <span class="keyword">where</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> n: <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>当然，如果是大数的话，程序栈会爆掉。</p>
<h2 id="传统的_API_和值提取">传统的 API 和值提取</h2><p>通常情况下，当你从外部源取数据的时候，比如一个库，或者一个 API，它不仅是一种很好的做法，而且通常在解析数据之前需要检查数据的一致性。你需要确保所有的 <code>key</code> 都是存在的、或者数据的类型都正确、或者数组的长度满足要求。如果不这么做就会因为 bug（有的 <code>key</code> 不存在）而导致 app 崩溃（索引不存在的数组项）。而传统的做法通常是嵌套 <code>if</code> 语句。</p>
<p>假想有 API 返回一条用户信息。但是有两种类型的用户：系统用户——如管理员或者邮政局长——和本地用户——如 “John B”、“Bill Gates”等。因为系统的设计和增长，API 的使用者需要处理一些麻烦的事情：</p>
<ul>
<li><code>system</code> 和 <code>local</code> 用户来自同一个 API 调用。</li>
<li>因为早期版本的数据库没有 <code>department</code> 这个字段，所以这个 <code>key</code> 可能是不存在的，而且早期的雇员从来都不需要填写这个字段。</li>
<li>根据用户被创建的时间，<code>name</code> 数组可能包含 4 个元素（username，middlename，lastname 和 firstname）或者 2 个元素（full name，username）</li>
<li><code>age</code> 是代表用户年龄的整型数</li>
</ul>
<p>我们的系统需要给这个 API 返回的所有系统用户创建用户账号，账号信息只包含如下信息：username 和 department。我们只需要 1980 年以前出生的用户。如果没有指定 department，就指定为 “Corp”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">legacyAPI</span><span class="params">(id: Int)</span></span> -&gt; [<span class="type">String</span>: <span class="type">AnyObject</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"type"</span>: <span class="string">"system"</span>, <span class="string">"department"</span>: <span class="string">"Dark Arts"</span>, <span class="string">"age"</span>: <span class="number">57</span>, </span><br><span class="line">	   <span class="string">"name"</span>: [<span class="string">"voldemort"</span>, <span class="string">"Tom"</span>, <span class="string">"Marvolo"</span>, <span class="string">"Riddle"</span>]] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为给定的约束实现一个模式来进行匹配：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item = legacyAPI(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">switch</span> (item[<span class="string">"type"</span>], item[<span class="string">"department"</span>], item[<span class="string">"age"</span>], item[<span class="string">"name"</span>]) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> (sys <span class="keyword">as</span> <span class="type">String</span>, dep <span class="keyword">as</span> <span class="type">String</span>, age <span class="keyword">as</span> <span class="type">Int</span>, name <span class="keyword">as</span> [<span class="type">String</span>]) <span class="keyword">where</span> </span><br><span class="line">      age &lt; <span class="number">1980</span> &amp;&amp;</span><br><span class="line">      sys == <span class="string">"system"</span>:</span><br><span class="line">     createSystemUser(name.<span class="built_in">count</span> == <span class="number">2</span> ? name.last! : name.first!, dep: dep ?? <span class="string">"Corp"</span>)</span><br><span class="line">  <span class="keyword">default</span>:()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 ("voldemort", "Dark Arts")</span></span><br></pre></td></tr></table></figure>
<p>注意这段代码做了一个很危险的假设：就是如果 <code>name</code> 数组元素的个数不是 2 个的话，那么它<strong>一定</strong>包含 4 个元素。如果这种假设不成立，我们获得了包含 0 个元素的数组，这段代码就会崩溃。</p>
<p>除了这一点，模式匹配向你展示了它是如何在只有一个 <code>case</code> 的情况下帮助你编写干净的代码和简化值的提取的。</p>
<p>同样来看看我们是怎么写紧跟在 <code>case</code> 之后 <code>let</code> 的，这样一来就不必在每一次赋值的时候都重复写它。</p>
<h1 id="模式和其他关键词">模式和其他关键词</h1><p>Swift 的文档指出不是所有的模式都可以在 <code>if</code>、<code>for</code> 或者 <code>guard</code> 语句中使用。然而，这个文档似乎不是最新的。所有 7 种模式对这三个关键词都有效。</p>
<p>我为那些感兴趣的人编了一个例子要点，为每个模式和每个关键词都写了一个例子。</p>
<p><a href="https://gist.github.com/terhechte/6eaeb90276bbfcd1ea41" target="_blank" rel="external">你可以在这里查看所有的样例模式</a></p>
<p>来看一个对三个关键词使用 <strong>值绑定</strong>、<strong>元组</strong>和<strong>类型转换</strong>模式的简短例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 到吗编译后只是一个关键词的集合。其本身没有任何意义</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">valueTupleType</span><span class="params">(a: <span class="params">(Int, Any)</span></span></span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// guard case 的例子</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> (x, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>) = a <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for case 的例子</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (a, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>) <span class="keyword">in</span> [a] &#123;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if case 的例子</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> (x, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>) = a &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"if"</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch case example</span></span><br><span class="line">    <span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (a, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>):</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> u: <span class="type">Any</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Any</span> = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(valueTupleType((<span class="number">5</span>, u)))</span><br><span class="line"><span class="built_in">print</span>(valueTupleType((<span class="number">5</span>, b)))</span><br><span class="line"><span class="comment">// 5, 5, "if 5", 5, true, false</span></span><br></pre></td></tr></table></figure>
<p>我们可以带着这个想法详细地看一看每一个关键词。</p>
<h1 id="使用_for_case"><strong>使用</strong> for case</h1><p>到了 Swift 2.0 后，模式匹配变得更加重要，因为它被扩展到不仅可以支持 <code>switch</code> ，还可以支持其他的关键词。比如，让我们写一个简单的只返回非空元素的数组函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">nonnil</span><span class="generics">&lt;T&gt;</span><span class="params">(array: [T?])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">   <span class="keyword">var</span> result: [<span class="type">T</span>] = []</span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> x? <span class="keyword">in</span> array &#123;</span><br><span class="line">      result.append(x)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(nonnil([<span class="string">"a"</span>, <span class="literal">nil</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="literal">nil</span>]))</span><br></pre></td></tr></table></figure>
<p>关键词 <code>case</code> 可以被 <code>for</code> 循环使用，就像 <code>switch</code> 中的 <code>case</code> 一样。下面是另外一个例子。还记得我们之前说的游戏么？经过第一次重构之后，现在我们的实体系统看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EntityType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Soldier</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Player</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Entry</span>(type: <span class="type">EntityType</span>, x: <span class="type">Int</span>, y: <span class="type">Int</span>, hp: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真棒！这可以让我们用更少的代码绘制出所有的项目：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Entity</span>.<span class="type">Entry</span>(t, x, y, <span class="number">_</span>) <span class="keyword">in</span> gameEntities()</span><br><span class="line"><span class="keyword">where</span> x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &#123;</span><br><span class="line">    drawEntity(t, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用一行就解析出了所有必需的属性，然后确保我们不会在 0 一下的范围绘制，最后我们调用渲染方法（<code>drawEntity</code>）。</p>
<p>为了知道选手是否在游戏中胜出，我们想要知道是否有至少一个士兵的血量是大于 0 的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">gameOver</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">case</span> <span class="type">Entity</span>.<span class="type">Entry</span>(.<span class="type">Soldier</span>, <span class="number">_</span>, <span class="number">_</span>, <span class="keyword">let</span> hp) <span class="keyword">in</span> gameEntities() </span><br><span class="line">    <span class="keyword">where</span> hp &gt; <span class="number">0</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(gameOver())</span><br></pre></td></tr></table></figure>
<p>好的是 <code>Soldier</code> 的匹配是 <code>for</code> 查询的一部分。这感觉有点像 <code>SQL</code> 而不是命令循环编程。同时，这也可以让编译器更清晰的知道我们的意图，从而就有了打通调度增强这条路的可能性。另外一个很好的体验就是我们不需要完成的拼写出 <code>Entity.EntityType.Soldier</code>。就算我们像上面一样只写 <code>.Soldier</code>，Swift 也能明白我们的意图。</p>
<h1 id="使用_guard_case"><strong>使用</strong> guard case</h1><p>另外一个支持模式匹配的关键词就是新引入的 <code>guard</code> 关键词。它允许你像 <code>if let</code> 一样把 <code>optionals</code> 绑定到本地范围，而且不需要任何嵌套：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">example</span><span class="params">(a: String?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> a = a <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">"yes"</span>)</span><br></pre></td></tr></table></figure>
<p><code>guard let case</code> 允许你做一些类似模式匹配所介绍的事情。让我们再来看一下士兵的例子。在玩家的血量变满之前，我们需要计算需要增加的血量。士兵不能涨血，所以对于士兵实体而言，我们始终返回 0。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">MAX_HP</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">healthHP</span><span class="params">(entity: Entity)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Entity</span>.<span class="type">Entry</span>(.<span class="type">Player</span>, <span class="number">_</span>, <span class="number">_</span>, hp) = entity </span><br><span class="line">    <span class="keyword">where</span> hp &lt; <span class="type">MAX_HP</span> </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">MAX_HP</span> - hp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Soldier"</span>, healthHP(<span class="type">Entity</span>.<span class="type">Entry</span>(type: .<span class="type">Soldier</span>, x: <span class="number">10</span>, y: <span class="number">10</span>, hp: <span class="number">79</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Player"</span>, healthHP(<span class="type">Entity</span>.<span class="type">Entry</span>(type: .<span class="type">Player</span>, x: <span class="number">10</span>, y: <span class="number">10</span>, hp: <span class="number">57</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="string">"Soldier 0"</span></span><br><span class="line"><span class="string">"Player 43"</span></span><br></pre></td></tr></table></figure>
<p>这是把我们目前讨论的各种机制用到极致的一个例子。</p>
<ul>
<li>它非常清晰，没有牵扯到任何嵌套</li>
<li>状态的逻辑和初始化是在 <code>func</code> 之前处理的，这样可以提高代码的可读性</li>
<li>非常简洁</li>
</ul>
<p>这也是 <code>switch</code> 和 <code>for</code> 的完美结合，可以把复杂的逻辑结构封装成易读的格式。当然，它不会让逻辑变得更容易理解，但是至少会以更清晰的方式展现给你。特别是使用 <code>enums</code> 的时候。</p>
<h1 id="使用_if_case"><strong>使用</strong> if case</h1><p><code>if case</code> 的作用和 <code>guard case</code> 相反。它是一种非常棒的在分支中打开和匹配数据的方式。结合之前 <code>guard</code> 的例子。很显然，我们需要一个 <code>move</code> 函数，这个函数允许我们表示一个实体在朝一个方向移动。因为我们的实体是 <code>enums</code>，所以我们需要返回一个更新过的实体。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">move</span><span class="params">(entity: Entity, xd: Int, yd: Int)</span></span> -&gt; <span class="type">Entity</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">case</span> <span class="type">Entity</span>.<span class="type">Entry</span>(<span class="keyword">let</span> t, <span class="keyword">let</span> x, <span class="keyword">let</span> y, <span class="keyword">let</span> hp) = entity</span><br><span class="line">	<span class="keyword">where</span> (x + xd) &lt; <span class="number">1000</span> &amp;&amp;</span><br><span class="line">	    (y + yd) &lt; <span class="number">1000</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">Entity</span>.<span class="type">Entry</span>(type: t, x: (x + xd), y: (y + yd), hp: hp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entity</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(move(<span class="type">Entity</span>.<span class="type">Entry</span>(type: .<span class="type">Soldier</span>, x: <span class="number">10</span>, y: <span class="number">10</span>, hp: <span class="number">79</span>), xd: <span class="number">30</span>, yd: <span class="number">500</span>))</span><br><span class="line"><span class="comment">// 输出: Entry(main.Entity.EntityType.Soldier, 40, 510, 79)</span></span><br></pre></td></tr></table></figure>
<h1 id="限制">限制</h1><p>一些限制已经在文章中说过，比如有关 <code>Expression Patterns</code> 的问题，看起来它似乎不能匹配 <code>tuples</code> （那样的话就真的很方便了）。在 Scala 和 Clojure 中，模式匹配在集合上同样可用，所以你可以匹配它的头部、尾部和部分等。<a href="#4">4</a>。这在 Swift 中是不支持的（<a href="http://austinzheng.com/2014/12/17/custom-pattern-matching/" target="_blank" rel="external">尽管 Austin Zheng 在我之前链接的博客里差不多实现了这一点</a>）</p>
<p>另外一种不可用的的情况是（这一点 Scala 同样做得很好）对类或者结构体进行解构。Swift 允许我们定义一个 <code>unapply</code> 方法，这个方法做的事情大体和 <code>init</code> 相反。实现这个方法，然后就可以让类型检查器对类进行匹配。而在 Swift 中，它看起来就像下面一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Imaginary</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">   <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">unapply</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="comment">// 实现这个方法之后，理论上来说实现了解构变量所需的所有细节</span></span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后这个就会自动 unapply 然后再进行匹配</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Imaginary</span>(x, y) = anImaginaryObject <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="更新">更新</h1><p><strong>08/21/2015</strong> 结合 <a href="https://www.reddit.com/r/swift/comments/3hq6id/match_me_if_you_can_swift_pattern_matching_in/" target="_blank" rel="external">Reddit 上 foBrowsing 的有用反馈</a></p>
<ul>
<li>增加 <code>guard case let</code></li>
<li>增加简化版的 let 语法（如：<code>let (x, y)</code> 替代 <code>(let x, let y)</code>）</li>
</ul>
<p><strong>08/22/2015</strong> <a href="https://www.reddit.com/r/swift/comments/3hq6id/match_me_if_you_can_swift_pattern_matching_in/" target="_blank" rel="external">似乎有一些东西我没测试好</a>。我列举的一些限制实际上是可用的，另外一个 Reddit 上的评论者（latrodectus）提出了一些非常有用的指正。</p>
<ul>
<li>将之前的修正为：所有的模式对三个关键词都适用，然后增加了一些要点案例</li>
<li>关于协议和表达式模式无效这个限制，其实没有的</li>
<li>增加 “模式可用性“章节</li>
</ul>
<p><strong>08/24/2015</strong> </p>
<ul>
<li>增加 <code>if case</code> 样例，重命名了一些章节。</li>
<li>修复了一些文本拼写错误。尤其我不小心写道：<code>_</code> 不能匹配 <code>nil</code>。那当然是不对的，<code>_</code> 可以匹配所有的东西。（感谢 <a href="https://github.com/obecker" target="_blank" rel="external">obecker</a>）</li>
</ul>
<p><strong>09/18/2015</strong></p>
<ul>
<li>添加了日语翻译的链接</li>
</ul>
<hr>
<p><a name="1">1.可以把它当做 <code>shell</code> 里面的 <code>*</code> 通配符</a></p>
<p><a name="2">2.我不清楚编译器是否在对这点进行了优化，但理论上来说，它应该能计算出所需数据的正确位置，然后忽略 <code>enum</code> 的其他情况并内联这个地址</a></p>
<p><a name="3">3.当然，不是 Haskell实现的对手：<br>fib 0 = 0<br>fib 1 = 1<br>fib n = fib (n-1) + fib (n-2)<br></a></p>
<p><a name="4">4.比如：switch [1, 2, 4, 3] {<br>case [<em>, 2, </em>, 3]:<br>}</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/">原文链接</a>，原文日期：2015-08-20<br>译者：<a href="http://blog.csdn.net/mmoaay">mmoaay</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在众多 Swift 提供给 Objective-C 程序员使用的新特性中，有个特性把自己伪装成一个无聊的老头，但是却在如何优雅的解决“鞭尸金字塔“的问题上有着巨大的潜力。很显然我所说的这个特性就是 <code>switch</code> 语句， 对于很多 Objective-C 程序员来说，除了用在 <a href="http://en.wikipedia.org/wiki/Duff%27s_device">Duff’s Device</a> 上比较有趣之外，<code>switch</code> 语句非常笨拙，与多个 <code>if</code> 语句相比，它几乎没有任何优势。</p>]]>
    
    </summary>
    
      <category term="APPVENTURE" scheme="http://swiftggteam.github.io/tags/APPVENTURE/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的范围和区间]]></title>
    <link href="http://swiftggteam.github.io/2015/10/26/swift-ranges-and-intervals/"/>
    <id>http://swiftggteam.github.io/2015/10/26/swift-ranges-and-intervals/</id>
    <published>2015-10-26T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/09/swift-ranges-and-intervals/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-24<br>译者：<a href="http://www.dianqk.org/" target="_blank" rel="external">靛青K</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>本系列其它文章：</p>
<p>(1)<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/" target="_blank" rel="external">自定义模式匹配</a></p>
<p>(2)范围和区间(即本篇)</p>
<p>(3)<a href="http://oleb.net/blog/2015/09/more-pattern-matching-examples/" target="_blank" rel="external">更多有关模式匹配的例子</a></p>
<blockquote>
<p>下载本篇文章所需要的 <a href="http://oleb.net/media/swift-ranges-and-intervals.playground.zip" target="_blank" rel="external">playground</a> （Xcode7 运行环境）</p>
</blockquote>
<a id="more"></a>
<p>在前一篇<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/" target="_blank" rel="external">有关模式匹配</a>的文章中，我提及标准库中已经针对<strong>范围和区间</strong>使用<code>~=</code>模式匹配操作符进行了重载。</p>
<p>这两个数据类型是相关的，但也有一些重要的区别。对于如何在<code>switch</code>中进行不等式条件匹配的问题，它们不失为一个可选的解决方案，本文将对它们进行深入讨论。</p>
<h2 id="Ranges">Ranges</h2><p>范围是用<a href="http://swiftdoc.org/swift-2/type/Range/" target="_blank" rel="external">Range</a>类型表达的。一个范围就是一个<em>索引</em>集合。</p>
<blockquote>
<p>注意：一个范围就是一个索引集合。</p>
</blockquote>
<p><em>Range</em>在标准库中被频繁使用，特别是处在集合的上下文当中时。当我们查看<code>Range</code>定义时，范围和集合之间的紧密关系一目了然：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&lt;<span class="title">Element</span> : <span class="title">ForwardIndexType</span>&gt; : <span class="title">CollectionType</span>, <span class="title">Indexable</span>, ... </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个范围中的元素必需遵守<code>ForwardIndexType</code>协议，同时<code>CollecitonType</code>协议中的大量功能也是基于它实现的。有一个特殊的类型用来表示集合索引的范围，对于获取一个集合的子集是相当有意义的。例如，我们可以使用范围获取一个数组的部分:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 1..&lt;5 等价于 Range(start: 1, end: 5)</span></span><br><span class="line">numbers[<span class="number">1</span>..&lt;<span class="number">5</span>] <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>正如类型定义中所看到的，<em>Range</em>自身遵循<code>CollectionType</code>协议，所以几乎所有数组可以做的事情，范围也能够适用。比如用<code>for</code>循环遍历元素，或者使用<code>contains(_:)</code>检查一个值是否在这个范围内。</p>
<p>虽然范围主要适用于与其他集合配合使用，但谁也无法阻止你创建一个用于表示数字区间的<code>Range&lt;Int&gt;</code>。毕竟<a href="http://swiftdoc.org/swift-2/type/Int/" target="_blank" rel="external">Int</a>已经实现了<code>ForwardIndexType</code>协议。现在回到我们的模式匹配问题。</p>
<p>我们可以用一个范围<code>(Int.min..&lt;0).contains(x)</code>表示 x &lt; 0 的情况，这是完全等价的，不过执行速度巨慢。毕竟默认需要遍历整个集合，最糟糕的情况下，将执行<a href="https://en.wikipedia.org/wiki/9223372036854775807" target="_blank" rel="external">9,223,372,036,854,775,808次</a>，这相当耗费资源。我们可以为<code>Comparable</code>（比如<code>Int</code>）类型的索引提供一个更好实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Range</span> <span class="title">where</span> <span class="title">Element</span> : <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(element: Element)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element &gt;= startIndex &amp;&amp; element &lt; endIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">(<span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常好的练习，不过在我们案例中可有可无，因为<code>~=</code>操作符为<code>Range</code>实现的匹配足够高效（就像我们的<code>contains(_:)</code>，<code>Comparable</code>只是在索引中工作）。所以我们可以这样的做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> ~= -<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> ~= <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> ~= <span class="number">1</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在这基础上，我们可以写一个<code>switch</code>语句，使用范围查询判断一个数字是否大于，小于还是等于 0，对吗？不幸地是，这并不适用。这段代码会崩溃：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="type">Int</span>.<span class="built_in">max</span>: <span class="comment">// EXC_BAD_INSTRUCTION</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会在<code>case 1...Int.max</code>这一行中得到一个<code>EXC_BAD_INSTRUCTION</code> 错误信息表明“fatal error: Range end index has no valid successor”。导致错误的原因在于:<code>range</code>中的<code>endIndex</code>总是指向范围中最后一个元素的后面。这对于半开区间（用 ..&lt; 操作符创建）和闭合区间（用 … 操作符创建）都是一样的，因为二者的内部实现是一样的，<code>a...b</code>事实上就是<code>a..&lt;b.successor()</code>。 </p>
<blockquote>
<p>注意：一个<code>Range&lt;Int&gt;</code>永远都不能有<code>Int.max</code></p>
</blockquote>
<p>这意味着<code>Int.max</code>永远都不会成为一个<code>Range&lt;Int&gt;</code>的成员，这同样适用于其他有最大值的类型。这个限制使范围不能满足我们所要的需求。所以接下来让我们来看看区间能不能满足我们的要求。</p>
<h2 id="区间">区间</h2><p>范围和区间是基本相同的概念构建的（一个连续元素的系列，有开始有结尾），但使用了不同的方法。范围基于索引，因此可以是个集合，他们的大多数功能都是基本这个特性的。区间<em>不是</em>集合，他们的实现是依赖<code>Comparable</code>协议的。我们只可以为服从<code>Comparable</code>协议的类型创建区间类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IntervalType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Bound</span> : <span class="type">Comparable</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有别于范围的定义，区间使用<code>IntervalType</code>协议呈现，这个协议有两个具体的实现，<code>HalfOpenInterval</code>和<code>ClosedInterval</code>。两个范围操作符也为区间提供了重载：..&lt; 创建一个<code>HalfOpenInterval</code>和 … 创建一个<code>ClosedInterval</code>。由于默认是重载了<code>Range</code>，所以你必须明确变量为区间类型(IntervalType)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> int1: <span class="type">HalfOpenInterval</span> = <span class="number">1</span>..&lt;<span class="number">5</span></span><br><span class="line">int1.<span class="built_in">contains</span>(<span class="number">5</span>) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> int2: <span class="type">ClosedInterval</span> = <span class="number">1</span>...<span class="number">5</span></span><br><span class="line">int2.<span class="built_in">contains</span>(<span class="number">5</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另一件事情就是记得<code>ClosedInterval</code>不可以为空，x…x 总是会包含 x，而 x…(x-1) 会造成运行时错误。</p>
<p>然而闭合区间可以包含一个类型的最大值。这意味着我们现在可以写我们的<code>switch</code>语句了。重复一遍，一定要明确类型，告诉编译器我们想要的是区间而不是范围：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="type">Int</span>.<span class="built_in">max</span> <span class="keyword">as</span> <span class="type">ClosedInterval</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> <span class="keyword">as</span> <span class="type">HalfOpenInterval</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为开区间定制操作符">为开区间定制操作符</h2><p>非常好，但我想摆脱<code>Int.min</code>和<code>Int.max</code>。为了达到这个目的，我们需要为开区间和闭区间自定义前缀操作符和后缀操作符，用于表示所有小于一个上边界的值，或者大于一个下边界的值。这样不仅在语法上要更友善；理想情况下，这些操作符不仅适用于 <code>Int</code> 类型，也可以适合于其它拥有最小和最大值的类型。实现看起来应该是这个样子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...: <span class="comment">// an interval from 1 to Int.max (inclusive)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> ..&lt;<span class="number">0</span>: <span class="comment">// an interval from Int.min to 0 (exclusive)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要为 <code>..&lt;</code> 和 <code>...</code> 分别定义前缀和后缀的实现方式 。下面这段代码基本是基于 <a href="http://natecook.com/" target="_blank" rel="external">Nate Cook</a> 写的 <a href="https://gist.github.com/natecook1000/3b15b8bd974c8c08b3df" target="_blank" rel="external">gist片段</a> ，他已经在 2014 年 11 月使用范围和区间混合实现了它。我把使用区间的部分放在这里。</p>
<p>首先我们必须声明需要解释的操作符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ..&lt; &#123; &#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ... &#123; &#125;</span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> ..&lt; &#123; &#125;</span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> ... &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>紧接着为<code>Int</code>实现第一个运算符的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Forms a half-open interval from `Int.min` to `upperBound`</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; (upperBound: Int) -&gt;</span> <span class="title">HalfOpenInterval</span><span class="generics">&lt;Int&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>.<span class="built_in">min</span>..&lt;upperBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以，但我们应该让它更通用。区间要求它的底层类型都遵循<code>Comparable</code>协议，所以使用相同的条件约束是一个很自然的选择。但在这里我们会碰到一个问题：我们需要知道 T 类型的最小值来创建区间，但这并没有一个通用的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; &lt;T : Comparable&gt;</span><span class="params">(upperBound: T)</span></span> -&gt; <span class="type">HalfOpenInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="built_in">min</span>..&lt;upperBound <span class="comment">// error: type 'T' has no member 'min'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至是在标准库中的其他协议都没有为数字（就比如<code>IntegerType</code>）提供这些–定义在数字类型中的<code>min</code>和<code>max</code>属性。</p>
<p>Nate 想出了一个很酷的解决方案：定义一个<code>MinMaxType</code>的自定义协议，这个协议定义了 <code>min</code> 和 <code>max</code> 两个属性。因为所有整数类型都有这两个属性，让他们遵守新的协议就不用额外写代码了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Conforming types provide static `max` and `min` constants.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MinMaxType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="built_in">min</span>: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="built_in">max</span>: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend relevant types</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int8</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int16</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int32</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int64</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt8</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt16</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt32</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt64</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个值得牢记的技巧。任何时候，当你有几个不相关的类型，但它们具有相同类型的一个或多个方法、属性，你都可以创建一个新的协议给他们提供一个通用接口。</p>
<blockquote>
<p>注意：任何时候，当你有几个不相关的类型，但它们具有相同类型的一个或多个方法、属性，你都可以创建一个新的协议给他们提供一个通用接口。</p>
</blockquote>
<p>告诉我们的通用类型 T 遵守<code>MinMaxType</code>协议以使这个实现可以正常运行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Forms a half-open interval from `T.min` to `upperBound`</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; &lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(upperBound: T)</span></span> -&gt; <span class="type">HalfOpenInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="built_in">min</span>..&lt;upperBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是其他三个操作符的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Forms a closed interval from `T.min` to `upperBound`</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ... <span class="generics">&lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(upperBound: T)</span></span> -&gt; <span class="type">ClosedInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="built_in">min</span>...upperBound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Forms a half-open interval from `lowerBound` to `T.max`</span></span><br><span class="line"><span class="keyword">postfix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; &lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(lowerBound: T)</span></span> -&gt; <span class="type">HalfOpenInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lowerBound..&lt;<span class="type">T</span>.<span class="built_in">max</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Forms a closed interval from `lowerBound` to `T.max`</span></span><br><span class="line"><span class="keyword">postfix</span> <span class="func"><span class="keyword">func</span> ... <span class="generics">&lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(lowerBound: T)</span></span> -&gt; <span class="type">ClosedInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lowerBound...<span class="type">T</span>.<span class="built_in">max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加一些测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">min</span>) <span class="comment">// true</span></span><br><span class="line">(..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">(..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(...<span class="number">0</span>).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">min</span>) <span class="comment">// true</span></span><br><span class="line">(...<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">(...<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">max</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">max</span> - <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>...).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="number">0</span>...).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">(<span class="number">0</span>...).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">max</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>回到我们的<code>switch</code>语句，现在很好地工作了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> ..&lt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结论">结论</h2><p>Swift 中范围和区间都有相似的目的，但有着不同的实现和泛型约束。范围基于索引并且经常用于集合上下文中。这意味着范围不能包含一个类型最大值，这就不适合用在数字的区间上。区间兼容所有的<code>Comparable</code>类型，并且没有最大值的限制。</p>
<p>虽然我们应该对自定义操作符持谨慎的态度，但我认为在这个特定的例子中，他们可以明显地提高可读性而没有降低可理解性–这个前缀和后缀操作符非常接近他们原本的意思，甚至是不熟悉这段代码的读者在理解它的时候也不会有多大的困难。</p>
<p>即便如此，我还是认为在这个特定的例子中，使用自定义操作符来替代标准的 Swift 句法（case _ where x &gt; 0）所得到的好处是很小的，因此在实战代码中还是不值得使用。把这个方法暂时视为思考上的实践，而非推荐使用。</p>
<p>如果你喜欢这篇文章，你可能也会喜欢 Chris Eidhof 和 Airspeed Velocity 的即将出版的书，<a href="https://www.objc.io/books/advanced-swift/" target="_blank" rel="external">Swift 进阶</a>。他们对于相同的在区间下标上下文中的开闭区间主题讨论了很多其它的东西。我是这本书的技术审校，所以我的意见偏向的，但是如果你对 Swift 很感兴趣，我还是非常推荐这本书给你。这本书当前是 beta 状态，但是现在已经可以买到它的早期预览版了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/09/swift-ranges-and-intervals/">原文链接</a>，原文日期：2015-09-24<br>译者：<a href="http://www.dianqk.org/">靛青K</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>本系列其它文章：</p>
<p>(1)<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/">自定义模式匹配</a></p>
<p>(2)范围和区间(即本篇)</p>
<p>(3)<a href="http://oleb.net/blog/2015/09/more-pattern-matching-examples/">更多有关模式匹配的例子</a></p>
<blockquote>
<p>下载本篇文章所需要的 <a href="http://oleb.net/media/swift-ranges-and-intervals.playground.zip">playground</a> （Xcode7 运行环境）</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Ole Begemann" scheme="http://swiftggteam.github.io/tags/Ole-Begemann/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3D Touch之我见]]></title>
    <link href="http://swiftggteam.github.io/2015/10/23/3d-touch-impressions-and-thoughts/"/>
    <id>http://swiftggteam.github.io/2015/10/23/3d-touch-impressions-and-thoughts/</id>
    <published>2015-10-23T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/3d-touch-impressions-and-thoughts" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-26<br>译者：<a href="http://www.brighttj.com" target="_blank" rel="external">saitjr</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<p>Hey，现在有了支持3D Touch的iPhone和iOS9，这是一项伟大的科技杰作。让我们看看这为开发者和用户都带来了什么呢。本文主要是我对3D Touch的理解，然后列举了一些需要注意的点。</p>
<a id="more"></a>
<h2 id="出师不利">出师不利</h2><p>本来我想写一篇入门级关于3D Touch的导读文章，但是遇到一个问题——Xcode7的模拟器并不能模拟3D Touch。</p>
<p>苹果官方的说法是：</p>
<blockquote>
<p>Xcode7.0中，你必须使用支持3D Touch的真机进行开发。因为Xcode7.0的模拟器不支持3D Touch。</p>
</blockquote>
<p>这是个悲伤的故事，但是又有什么办法呢。我想，苹果应该会想办法模拟出来。可能在下一个Xcode发布版本中就能看到。</p>
<p>另一个问题则是新的iPhone还没有在波兰发售，可能还要等2周（译者注：作者写文在波兰iPhone发售以前）。</p>
<p>还有一个办法，我10月要在San Francisco和Palo Alto呆上整整一月，所以我可能会买一部iPhone，但不确定是6s还是6s plus。</p>
<p>如果买了设备，那我肯定会发布一大波3D Touch的文章。</p>
<h2 id="Peek_and_pop操作">Peek and pop操作</h2><p>这是苹果介绍3D Touch的第一个特性——或者说是两个特性。</p>
<ul>
<li>轻压(peek,轻度按压)操作能让用户在不离开当前界面的情况下预览内容。如果轻按某个选项能够弹出一个小的矩形视图，则表明它支持轻压操作。</li>
<li>peek手势弹出的视图应该足够大，这样内容就不会被手指挡住，从而用户可以选择是否重压，即pop操作（译者注：peek操作即轻按，用于预览，pop操作则是重压，用于进一步确认。pop能满足在预览之后，进入特定页面的需求）。</li>
<li>pop则是当用户在peek弹出的视图上加重按压力度，显示更详细的内容。</li>
<li>即使peek能给用户足够多的信息，你也应该让用户将该操作转化为pop。pop所显示的界面应该和用户点击进入界面相同。</li>
<li>请勿在peek预览的界面中放入按钮，因为用户手指一离开预览界面，预览界面就会消失，所以根本点不到按钮。</li>
<li>当用户在预览界面中向上滑动时，peek可以提供一些快捷操作(quick action)。你可以在预览界面中添加一些快捷操作，这样用户就可以上滑，然后选择一个你所提供的操作了。</li>
<li>如果你为某个选项提供了长按手势事件(touch-and-hold，或者叫long press)，那么你可以用peek来代替长按手势，这是一个很好的尝试。</li>
<li>如果你想使用快捷操作、peek和pop，那么记住在使用前先判断3D Touch是否可用。</li>
<li>不是每个设备都支持peek和pop操作的，并且3D Touch也可能处于禁用状态。所以不要让某些事件只能由peek来触发。最好有一个备选方案，即视图也能通过长按手势来展示。</li>
</ul>
<h2 id="快捷操作">快捷操作</h2><p>接下来，介绍一些用户在重压应用图标时的一些快捷操作。</p>
<ul>
<li>弹出框包含了主标题、副标题与图标。</li>
<li>该操作可以在应用程序更新时，显示更新信息。</li>
<li>你的应用在Home界面中，应该至少提供一个快捷选项。这样用户就可以使用手势操作你的应用，方便快捷。</li>
<li>医用最多可以提供四个快捷操作。</li>
<li>不要使用快捷操作来提醒用户更新、变更之类的事。如有需要，通知(<em>Notifications</em>)更能胜任这些任务。</li>
<li>快捷操作的命名应该简洁，如有需要，还应该有副标题和图标。尽量让用户明确该操作的作用。如果提供了副标题，那么标题栏将会更长，如果大小不能适应，系统会自动截取。如果没有副标题，那么主标题过长会自动换行。</li>
</ul>
<h2 id="总结">总结</h2><p>3D Touch是一个非常爽的特性，它提供了全新的交互方式。设备中包含了一个线性振动器(Taptic Engine)，所以按压屏幕时，设备能有一定响应——太好了，迫不及待想要试试。</p>
<p>非常遗憾，苹果没有在最新的Xcode 7 beta 2中解决无法模拟的问题，还是希望他们尽快搞定吧——或许他们不修复是为了增加销量，因为用户已经迫不及待的想要试试这个新特性了，而最简单粗暴的方式，就是买个新设备 :D。</p>
<p>我已经迫不及待的想要尝试基于3D Touch的应用了，如游戏和画图，还有一些我想象不到的应用。或许还可以看到计量重量的应用，比如称一个水果的重量，或是一个放置在屏幕上的物体的重量等等 :&gt;。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/3d-touch-impressions-and-thoughts">原文链接</a>，原文日期：2015-09-26<br>译者：<a href="http://www.brighttj.com">saitjr</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<p>Hey，现在有了支持3D Touch的iPhone和iOS9，这是一项伟大的科技杰作。让我们看看这为开发者和用户都带来了什么呢。本文主要是我对3D Touch的理解，然后列举了一些需要注意的点。</p>]]>
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="http://swiftggteam.github.io/tags/Tomasz-Szulc/"/>
    
      <category term="3D Touch" scheme="http://swiftggteam.github.io/categories/3D-Touch/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/3D-Touch/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 编程思想 Part 4：map all the things!]]></title>
    <link href="http://swiftggteam.github.io/2015/10/22/thinking-in-swift-4/"/>
    <id>http://swiftggteam.github.io/2015/10/22/thinking-in-swift-4/</id>
    <published>2015-10-22T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-11<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="http://www.futantan.com" target="_blank" rel="external">Prayer</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p>系列文章地址：</p>
<ul>
<li><a href="http://swift.gg/2015/09/29/thinking-in-swift-1/" target="_blank" rel="external">Swift 编程思想，第一部分：拯救小马</a></li>
<li><a href="http://swift.gg/2015/10/09/thinking-in-swift-2/" target="_blank" rel="external">Swift 编程思想，第二部分：数组的 Map 方法</a></li>
<li><a href="http://alisoftware.github.io/swift/2015/10/03/thinking-in-swift-3/" target="_blank" rel="external">Swift编程思想第三部分：结构体和类</a></li>
</ul>
<p><a href="http://swift.gg/2015/10/09/thinking-in-swift-2/" target="_blank" rel="external">在本系列之前的文章中</a>我们学到了如何使用<code>map</code>和<code>flatMap</code>来操作数组(arrays)。今天我们继续研究如何对可选类型(Optionals)以及很多其他类型使用<code>map</code>和<code>flatMap</code>。</p>
<a id="more"></a>
<h3 id="数组_vs-_可选类型">数组 vs. 可选类型</h3><p>回顾一下，学完前面的文章后我们已经知道，<code>Array&lt;T&gt;</code>对应的<code>map()</code>和<code>flatMap()</code>函数签名是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用在Array&lt;T&gt;上的方法</span></span><br><span class="line">    <span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt; <span class="type">Array</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">flatMap( transform: <span class="type">T</span> -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt; ) -&gt; <span class="type">Array</span>&lt;<span class="type">U</span>&gt;</span><br></pre></td></tr></table></figure>
<p>意思是你可以用一个给定的<code>transform: T-&gt;U</code>将一个元素类型是<code>T</code>的数组转换成一个元素类型是<code>U</code>的数组。对<code>Array&lt;T&gt;</code>调用<code>map( transform: T-&gt;U )</code>方法就会返回一个<code>Array&lt;U&gt;</code>，就这么简单。</p>
<p>嗯，不出意外，对于<code>Optional&lt;T&gt;</code>来说，<code>map()</code>和<code>flatMap()</code>的函数签名十分类似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用在Optional&lt;T&gt;上的方法</span></span><br><span class="line">    <span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">flatMap( transform: <span class="type">T</span> -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt; ) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt;</span><br></pre></td></tr></table></figure>
<p>是不是很像？</p>
<h3 id="作用在可选类型上的_map()">作用在可选类型上的 map()</h3><p>那么<code>map</code>方法到底对<code>Optional&lt;T&gt;</code>类型(也叫做<code>T?</code>)做了什么？</p>
<p>其实很简单：和作用在<code>Array&lt;T&gt;</code>上的一样，<code>map</code>方法将<code>Optional&lt;T&gt;</code>中的内容取出来，用指定的<code>transform: T-&gt;U</code>方法做出转换，然后把结果包装成一个新的<code>Optional&lt;U&gt;</code>。</p>
<p>如果细想一下，这和<code>Array&lt;T&gt;.map</code>做的事情十分相似：这个方法对<code>Array&lt;T&gt;</code>(与之相应的是<code>Optional&lt;T&gt;</code>)中的每个元素使用<code>transform</code>函数转换，并将转换过的值封装在一个新的<code>Array&lt;U&gt;</code>中(与之相应的是<code>Optional&lt;U&gt;</code>)，作为结果返回。</p>
<h3 id="回到我们的例子">回到我们的例子</h3><p>那么这对我们一直在做的示例代码有什么帮助？</p>
<p>在<a href="http://alisoftware.github.io/swift/2015/10/03/thinking-in-swift-3/#converting-our-class-to-a-struct" target="_blank" rel="external">我们最新版代码中</a>，有一个<code>String?</code>类型的<code>itemDesc[&quot;icon&quot;]</code>，我们当时想把它转换成一个<code>UIImage</code>；但是<code>UIImage(named:)</code>要求传入一个<code>String</code>型的参数，而不是<code>String?</code>型，所以我们需要在可选型中确实有值时(非<code>nil</code>)将内部的<code>String</code>值传入。</p>
<p>一种解决方案是使用可选绑定(Optional Binding)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> icon: <span class="type">UIImage</span>?</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">  icon = <span class="type">UIImage</span>(named: iconName)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  icon = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是对于一个如此简单的操作来说代码量太大。</p>
<p>之前的一个例子中我们用了另外一种(很不优雅的)方式，使用<code>nil</code>-联合操作符<code>??</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line"><span class="keyword">let</span> icon = <span class="type">UIImage</span>(named: iconName ?? <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>这么做是可以，但是之所以能够成功，是因为当<code>iconName</code>是<code>nil</code>时，我们实际上是使用了<code>UIImage(named: &quot;&quot;)</code>的初始化方法，这个初始化方法在传入空字符串时，会返回<code>nil</code>。但是这样的解决办法不是很好，因为我们是依赖于该初始化方法的特性（传入空字符串时，会返回<code>nil</code>）来实现的。</p>
<h3 id="来用_map_吧">来用 map 吧</h3><p>那么为什么不用<code>map</code>呢？本质上，我们是想要在<code>Optional&lt;String&gt;</code>不是<code>nil</code>的时候将其解包，把里面的值转换成一个<code>UIImage</code>对象然后把这个<code>UIImage</code>返回，这不就是一个绝佳的用例么？</p>
<p>试试看：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">item.icon = iconName.<span class="built_in">map</span> &#123; imageName <span class="keyword">in</span> <span class="type">UIImage</span>(named: imageName) &#125;</span><br></pre></td></tr></table></figure>
<p>等会儿…. 编译不通过。能猜出为什么吗？</p>
<h3 id="哪儿有问题？">哪儿有问题？</h3><p>上面的代码中的问题是<code>UIImage(named: …)</code>也返回一个可选类型：如果对给定的<code>name</code>没有相应的图片，就不能创建出一个<code>UIImage</code>，所以这种情况下该初始化方法为<em>可失败的(failable)</em>，并返回<code>nil</code>，是完全合理的。</p>
<p>于是问题就在于我们给<code>map</code>的这个闭包用一个<code>String</code>作为参数而返回…一个<code>UIImage?</code>类型——因为图片的初始化方法是<em>可失败的</em>，会返回<code>nil</code>。再看一下<code>map</code>方法的签名，它想要的是一个<code>T-&gt;U</code>类型的闭包，这个闭包会返回一个<code>U?</code>类型。我们的例子中，<code>U</code>代表<code>UIImage?</code>的话，整个<code>map</code>表达式会返回一个<code>U?</code>类型，也就是…一个<code>UIImage??</code>类型…是的，一个双重可选类型，吓死宝宝了！</p>
<h3 id="flatMap()_来帮忙了">flatMap() 来帮忙了</h3><p><code>flatMap()</code>与<code>map</code>类似，但是做的是一个<code>T-&gt;U?</code>的转换(不是<code>T-&gt;U</code>)，它把结果“扁平化(顾名思义)”成一个单重的可选类型。这恰恰就是我们所需要的！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">item.icon = iconName.flatMap &#123; imageName <span class="keyword">in</span> <span class="type">UIImage</span>(named: imageName) &#125;</span><br></pre></td></tr></table></figure>
<p>实际中<code>flatMap</code>做了如下工作：</p>
<ul>
<li>如果<code>iconName</code>是<code>nil</code>的话，它就直接返回<code>nil</code>(但返回类型还是<code>UIImage?</code>)</li>
<li>如果<code>iconName</code>不是<code>nil</code>，它就把<code>transform</code>作用到<code>iconName</code>的实际的值上，尝试用这个<code>String</code>创建一个<code>UIImage</code>并将结果返回——结果本身已经是一个<code>UIImage?</code>类型，因此如果<code>UIImage</code>初始化方法失败的话，返回结果就是<code>nil</code>。</li>
</ul>
<p>简而言之，<code>item.icon</code>只会在<code>itemDesc[&quot;icon&quot;] as? String</code>非空、并且<code>UIImage(named: imageName)</code>初始化方法成功的情况下才是一个非空值。</p>
<p>和使用<code>??</code>欺骗初始化方法相比，这么做更好，更地道。</p>
<h3 id="把_init_当闭包来用">把 init 当闭包来用</h3><p>更进一步，由于现在 Xcode 7 可以通过类型的<code>.init</code>属性暴露该类型的构造器(constructors)，上面的代码还能写的更加紧凑。</p>
<p>这意味着<code>UIImage.init</code>本质上就已经是一个接收<code>String</code>并返回<code>UIImage?</code>的方法了，所以我们可以把它直接当成参数来调用<code>flatMap</code>，不用把它再包进一个闭包里！</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">item.icon = iconName.flatMap(<span class="type">UIImage</span>.<span class="keyword">init</span>)</span><br></pre></td></tr></table></figure>
<p>哇哦！太魔幻了！</p>
<p><img src="/img/articles/thinking-in-swift-4/magic.gif1445562506.7864432" alt=""></p>
<p>好了，有人说这么写很难读懂，为了让代码更明了更清晰，在这里还是更喜欢用一个显式闭包。但是这只是关乎个人偏好，并且知道这么做可行也是好事。</p>
<h3 id="最终的Swift代码">最终的Swift代码</h3><p>下面就是将本课所学应用到之前代码里的样子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> icon: <span class="type">UIImage</span>?</span><br><span class="line">  <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> url: <span class="type">NSURL</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">listItemsFromJSONData</span><span class="params">(jsonData: NSData?)</span></span> -&gt; [<span class="type">ListItem</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> jsonData = jsonData,</span><br><span class="line">      <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(jsonData, options: []),</span><br><span class="line">      <span class="keyword">let</span> jsonItems = json <span class="keyword">as</span>? <span class="type">Array</span>&lt;<span class="type">NSDictionary</span>&gt; <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> jsonItems.flatMap &#123; (itemDesc: <span class="type">NSDictionary</span>) -&gt; <span class="type">ListItem</span>? <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> title = itemDesc[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">let</span> urlString = itemDesc[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: urlString)</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">      <span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">      <span class="keyword">let</span> icon = iconName.flatMap &#123; <span class="type">UIImage</span>(named: $<span class="number">0</span>) &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">ListItem</span>(icon: icon, title: title, url: url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回头看一眼我们的_ObjC_代码">回头看一眼我们的 ObjC 代码</h3><p>花一点儿时间比较一下我们最终的 Swift 代码和<a href="http://alisoftware.github.io/swift/2015/09/06/thinking-in-swift-1/#the-objc-code" target="_blank" rel="external">最开始的ObjC代码</a>。我们着实改了很大一部分内容。</p>
<p>如果你仔细看一下 ObjC 和 Swift 代码，会发现 Swift 的代码量并不是那么少(ObjC 是 5+15 LoC<sup>1</sup>，对比 Swift 的 19 LoC)，但是<strong>安全性高了太多</strong>。</p>
<p>尤其是我们使用的<code>guard</code>，<code>try?</code>和<code>as?</code>会迫使我们去检查所有类型是否都如所期，ObjC 代码不会关心这些，因此可能崩溃💣💥。所以虽然代码量相当，但 ObjC 代码更危险。</p>
<h3 id="结论">结论</h3><p>通过本系列文章，我希望你能够意识到：不要尝试将你的 ObjC 代码直译成 Swift。相反，你要去重新考虑一下你的代码，重新想象一下你的代码。从一个空白状态开始，脑中秉持着 Swift 的理念重写你的代码总会比你把 ObjC 代码直译过来要好。</p>
<p>我没说过这是件容易的事儿。当你已经习惯了用 ObjC 写代码，熟悉了它的模式和写代码的方式的话，做出思维上的改变会需要一些时间。但是这绝对有更多的好处。</p>
<hr>
<p>以上就是 Swift 编程思想系列的最后一部分内容<sup>2</sup>。现在你要开始为新 Swift 项目发狂了，把 Swift 编程思想全部贯彻到你的脑海中。</p>
<p>祝用 Swift 编程愉快，并且…<br><img src="/img/articles/thinking-in-swift-4/map-all-the-things.jpg1445562507.5226758" alt="MAP 一切，FLATMAP 一切！"></p>
<hr>
<ol>
<li>Lines of Codes，指有多少行代码</li>
<li>我会马上发布一个收尾文章，留一个关于<em>Monads</em>的口风，并把这个系列真正完结。别愁，之后还有很多关于 Swift 的文章会陆续发布。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/">原文链接</a>，原文日期：2015-10-11<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="http://www.futantan.com">Prayer</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p>系列文章地址：</p>
<ul>
<li><a href="http://swift.gg/2015/09/29/thinking-in-swift-1/">Swift 编程思想，第一部分：拯救小马</a></li>
<li><a href="http://swift.gg/2015/10/09/thinking-in-swift-2/">Swift 编程思想，第二部分：数组的 Map 方法</a></li>
<li><a href="http://alisoftware.github.io/swift/2015/10/03/thinking-in-swift-3/">Swift编程思想第三部分：结构体和类</a></li>
</ul>
<p><a href="http://swift.gg/2015/10/09/thinking-in-swift-2/">在本系列之前的文章中</a>我们学到了如何使用<code>map</code>和<code>flatMap</code>来操作数组(arrays)。今天我们继续研究如何对可选类型(Optionals)以及很多其他类型使用<code>map</code>和<code>flatMap</code>。</p>]]>
    
    </summary>
    
      <category term="Crunchy Development" scheme="http://swiftggteam.github.io/tags/Crunchy-Development/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[集合视图重排教程]]></title>
    <link href="http://swiftggteam.github.io/2015/10/21/reordering-collection-view-cells-tutorial/"/>
    <id>http://swiftggteam.github.io/2015/10/21/reordering-collection-view-cells-tutorial/</id>
    <published>2015-10-21T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：ioscreator，<a href="http://www.ioscreator.com/tutorials/reordering-collection-view-cells-tutorial" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-17<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="http://www.dianqk.org/" target="_blank" rel="external">靛青K</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>iOS 9 介绍了 Collection View 单元格的重新排序新特性。该特性默认开启，用户可以通过长按单元格的进行重新排序，调整其在视图中的位置。而我们要做的仅仅只是更新数据源模型。本教程中，我们将显示一些包含字母的单元格并对其进行重新排序。本教程部署于 iOS 9 和 Xcode 7。</p>
<a id="more"></a>
<p>打开 Xcode 并创建一个<strong>Single View Application</strong> ；Product Name 为 <strong>IOS9ReorderingCollectionViewTutorial</strong> ；紧接着在 Organization Name 和 Organization Identidier 两个输入框中填写你惯用的信息；开发语言选 <strong>Swift</strong> 同时确保设备为 <strong>iPhone</strong> 。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=1500w1445389581.348031" alt=""></p>
<p>选中 Main.StoryBoard 文件，删除已有的视图控制器；从对象库中（译者注：Object Library ，快捷键 control+option+command+3 ）拖拽一个 CollectionView Controller 到 Storyboard 中；选中拖入的视图控制器，在 Xcode 上方菜单栏依次选择<code>Editor -&gt; Embed in -&gt; Navagation Controller</code>插入一个 Navigation Controller ；确保选中新插入的导航控制器后，打开属性设置面板（译者注：Attribute Inspector ,快捷键 option+command+4 ），勾选 View Controller 部分中的<code>is Initial View Controller</code>复选框。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389582.5906994" alt=""></p>
<p>双击 Collection View Controller 中的导航栏，将标题改为“Alphabet”。选中 Collection View 后打开尺寸设置面板中（译者：Size Inspector ，快捷键 option+command+5 ）。将 Collection View 部分中的宽高设置为 100 。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389583.365586" alt=""></p>
<p>选中 Collection View Controller 中的单元格，前往属性设置面板（译者注：Attributes inspector ，快捷键 option+command+4 ），将单元格的背景色设为绿色。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389583.9036288" alt=""></p>
<p>前往属性设置面板，将 Collection Reusable View 部分中的 Identifier 设为“Cell”</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389584.315881" alt=""></p>
<p>从对象库中拖拽一个 Label 放置到单元格中。双击该 Label ，输入字母“A”。到目前为止，storyboard 内容如下:</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/CellSize.pngformat=2500w1445389584.655853" alt=""></p>
<p>既然我们已经将视图控制器从 Storyboard 中移除了，那么 ViewController.swift 文件一并删除了吧。添加一个新文件到项目中，选择 File -&gt; New File -&gt; iOS -&gt; Source -&gt; Cocoa Touch Class 点击 Next 跳转下一步，为这个类命名<strong>AlphabetViewController</strong> ，设为 UICollectionViewController 的子类。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=1500w1445389586.0430875" alt=""></p>
<p>接下来，为 Collection View Cell 创建一个类。添加一个新文件到项目中，选择 File -&gt; New File -&gt; iOS -&gt; Source -&gt; Cocoa Touch Class 点击 Next 跳转下一步，为这个类命名 <strong>AlphabetCell</strong> ，设为 UICollectionViewCell 的子类。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=1500w1445389586.6271925" alt=""></p>
<p>这些新创建的类需要和 storyboard 中的对象关联起来。为此，请选中 Storyboard 中的 Collection View Controller ，切换到 Identity Inspector 面板（译者注：快捷键 option+command+3 ），更改自定义类为 AlphabetViewController 。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389587.3706524" alt=""></p>
<p>依葫芦画瓢，选中 Storyboard 中的 Collection View Cell 并转到 Identity Inspector 面板，更改自定义类为 AlphabetCell 。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389587.6798098" alt=""></p>
<p>点击 Assistant Editor 按钮（译者注：快捷键 option+command+enter ），确保 <strong>AlphabetCell.swift</strong> 文件呈现在右侧面板。选中单元 Cell 中的 Label ,按住 Ctrl 键拖线至 <strong>AlphabetCell</strong> 类中创建以下 Outlet 接口:</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=750w1445389588.152526" alt=""></p>
<p>前往 <strong>AlphabetViewController.swift</strong> 文件，在 viewDidLoad 方法中，删除以下行:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.collectionView!.registerClass(<span class="type">UICollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: reuseIdentifier)</span><br></pre></td></tr></table></figure>
<p>由于早前已在视图构建器中设置了重用标识符，因此这里不再需要。此外新增一个属性变量用于存储字母表。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> characterArray = [<span class="type">String</span>]()</span><br></pre></td></tr></table></figure>
<p>修改<strong>viewDidLoad</strong>方法中的内容:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> str:<span class="type">String</span> = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="comment">//原文最后一个字符是X 不知道是不是作者笔误</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str.characters&#123;</span><br><span class="line">        characterArray.append(<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法中将字母表中的每个单词都分配到 characterArray 数组当中。接着，更改以下三个预定义的 Collection View 代理方法中的内容:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInCollectionView</span><span class="params">(collectionView: UICollectionView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="comment">// 1</span></span><br><span class="line">      <span class="comment">// Return the number of sections</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, numberOfItemsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">      <span class="comment">// 2 Return the number of items in the section</span></span><br><span class="line">      <span class="keyword">return</span> characterArray.<span class="built_in">count</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">let</span> cell = collectionView.dequeueReusableCellWithReuseIdentifier(<span class="string">"Cell"</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">AlphabetCell</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// Configure the cell</span></span><br><span class="line">      cell.alphabetLabel.text = characterArray[indexPath.row]</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> cell</span><br><span class="line">  &#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="type">Collection</span> <span class="type">View</span> 仅包含一个 section</span><br><span class="line"><span class="number">2</span>. <span class="type">Collection</span> <span class="type">View</span> 中的每个 section 包含 <span class="number">26</span> 个 item</span><br><span class="line"><span class="number">3</span>. 每一个 <span class="type">Cell</span> 单元格的内容为字母表中的一个字母。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当重新调整单元格位置时，内容也要随之而改变。我们可以在 **<span class="type">CollectionView</span>:moveItemAtIndexPath:toIndexPath** 方法中实现。</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, moveItemAtIndexPath sourceIndexPath: NSIndexPath,toIndexPath destinationIndexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">        <span class="comment">// swap values if sorce and destination</span></span><br><span class="line">        <span class="keyword">let</span> temp = characterArray[sourceIndexPath.row]</span><br><span class="line">        characterArray[sourceIndexPath.row] = characterArray[destinationIndexPath.row]</span><br><span class="line">        characterArray[destinationIndexPath.row] = temp</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>校对注：这里我们可以使用元组的特性完成值的交换<code>(characterArray[sourceIndexPath.row], characterArray[destinationIndexPath.row]) = (characterArray[destinationIndexPath.row], characterArray[sourceIndexPath.row])</code></p>
</blockquote>
<p>构建并运行项目，长按某个单元格后拖动调整它的位置。</p>
<p><img src="/img/articles/reordering-collection-view-cells-tutorial/format=1500w1445389588.5267599" alt=""></p>
<p>你可以从<a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">github</a>上下载 IOS9ReorderingCollectionViewTutorial 的源代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：ioscreator，<a href="http://www.ioscreator.com/tutorials/reordering-collection-view-cells-tutorial">原文链接</a>，原文日期：2015-09-17<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="http://www.dianqk.org/">靛青K</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>iOS 9 介绍了 Collection View 单元格的重新排序新特性。该特性默认开启，用户可以通过长按单元格的进行重新排序，调整其在视图中的位置。而我们要做的仅仅只是更新数据源模型。本教程中，我们将显示一些包含字母的单元格并对其进行重新排序。本教程部署于 iOS 9 和 Xcode 7。</p>]]>
    
    </summary>
    
      <category term="ioscreator" scheme="http://swiftggteam.github.io/tags/ioscreator/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift编程思想第三部分：结构体和类]]></title>
    <link href="http://swiftggteam.github.io/2015/10/20/thinking-in-swift-3/"/>
    <id>http://swiftggteam.github.io/2015/10/20/thinking-in-swift-3/</id>
    <published>2015-10-20T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/03/thinking-in-swift-3/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-03<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
</blockquote>
<p>系列文章地址：</p>
<ul>
<li><a href="http://swift.gg/2015/09/29/thinking-in-swift-1/" target="_blank" rel="external">Swift 编程思想，第一部分：拯救小马</a></li>
<li><a href="http://swift.gg/2015/10/09/thinking-in-swift-2/" target="_blank" rel="external">Swift 编程思想，第二部分：数组的 Map 方法</a></li>
</ul>
<p>继续说咱的”Swift编程思想系列”，今天我们将会做一些小小的改动，使用 <code>struct（结构体）</code> 来使代码得到进一步的简化。</p>
<a id="more"></a>
<h3 id="前面的内容">前面的内容</h3><p>在<a href="http://alisoftware.github.io/swift/2015/09/20/thinking-in-swift-2/" target="_blank" rel="external">这个系列之前的一篇文章里</a>我们学到了对数组(arrays)使用 <code>map</code> 和 <code>flatMap</code>，消除了中间变量(intermediate variables)形式的状态性(statefulness)，并使用了一些函数式编程<sup>1<sup>。</sup></sup></p>
<p>下面是我们之前收工时的代码，贴在这里回顾一下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">UIImage</span>?</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">NSURL</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">listItemsFromJSONData</span><span class="params">(jsonData: NSData?)</span></span> -&gt; [<span class="type">ListItem</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> nonNilJsonData = jsonData,</span><br><span class="line">            <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nonNilJsonData, options: []),</span><br><span class="line">            <span class="keyword">let</span> jsonItems = json <span class="keyword">as</span>? <span class="type">Array</span>&lt;<span class="type">NSDictionary</span>&gt;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonItems.flatMap &#123; (itemDesc: <span class="type">NSDictionary</span>) -&gt; <span class="type">ListItem</span>? <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> title = itemDesc[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">                <span class="keyword">let</span> urlString = itemDesc[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">                <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: urlString)</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="keyword">let</span> li = <span class="type">ListItem</span>()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> icon = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">                li.icon = <span class="type">UIImage</span>(named: icon)</span><br><span class="line">            &#125;</span><br><span class="line">            li.title = title</span><br><span class="line">            li.url = url</span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>今天我们将对例子进行相当简单的改动，使得代码更加精简以及显得”雨燕风”(Swift-er)。</p>
<h3 id="Struct相比Class">Struct相比Class</h3><p>正如上面代码所示，首先考虑使用类(<code>class</code>)是Swift初学者经常犯的一个错误。不过这可以理解，因为在ObjC中我们满世界的用class。</p>
<p>使用<code>class</code>不是什么原则性错误。在Swift中当然也可以继续用。但是<code>Swift</code>的结构体(<code>struct</code>)比它 C 前身的结构体要强大很多：它们不再只是存储一系列的值。</p>
<p>Swift的结构体(<code>structs</code>)和类(<code>Class</code>)具有相同的功能 - 除了继承 - 结构体是<strong>值类型(value-types)</strong> (所以每一次变量赋值都是通过值拷贝的形式，与<code>Int</code>类型很相像)，而类属于<strong>引用类型(reference-types)</strong>，以引用方式传递而非值拷贝，这和Objective-C(以及OC中无处不在的难看的<code>*</code>，也代表着引用)中一样。</p>
<p>我不会在这里展开长篇论述，讨论结构体、值类型和类、引用类型相比较孰胜孰劣：我还是直接强烈建议你看一下<a href="https://realm.io/news/andy-matuschak-controlling-complexity/" target="_blank" rel="external">Andy Matuschak对此话题的精彩论述</a>。我不需要自己再解释了，Andy说的比我好。</p>
<h3 id="把我们的class转换成struct">把我们的class转换成struct</h3><p>在我们的例子中，使用一个结构体看起来更为合适，因为它保存了一些值，并且并不会要对它们做什么改变(更适合拷贝而非引用)。案例中，我们把它用作一个菜单栏的数据源，一旦创建就不再对其更改，所以这也是使用结构体更为合理的一个场景。</p>
<p>还有，这里把<code>class</code>迁移成<code>struct</code>的另一个优势是，如果<code>struct</code>没有定义适合一个构造器，则它会生成一个默认的隐式构造器：所以我们可以非常容易的用默认构造器<code>ListItem(icon: …, title: …, url: …)</code>去创建一个<code>ListItem</code>。</p>
<p>最后一项要点是，由于在之前的文章中我们消除了数据损坏的问题，有问题的<code>ListItem</code>就不会被创建出来了，我们就可以把<code>title</code>的默认值<code>&quot;&quot;</code>消除掉，但更重要的是我们就能把<code>NSURL!</code>转换成<code>NSURL!</code>去<strong><a href="http://alisoftware.github.io/swift/2015/09/06/thinking-in-swift-1/" target="_blank" rel="external">拯救最后一匹小马</a></strong>🐴<sup>2<sup>。</sup></sup></p>
<p>转换之后的代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">UIImage</span>?</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">NSURL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">listItemsFromJSONData</span><span class="params">(jsonData: NSData?)</span></span> -&gt; [<span class="type">ListItem</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> nonNilJsonData = jsonData,</span><br><span class="line">            <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nonNilJsonData, options: []),</span><br><span class="line">            <span class="keyword">let</span> jsonItems = json <span class="keyword">as</span>? <span class="type">Array</span>&lt;<span class="type">NSDictionary</span>&gt; <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonItems.flatMap &#123; (itemDesc: <span class="type">NSDictionary</span>) -&gt; <span class="type">ListItem</span>? <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> title = itemDesc[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">                <span class="keyword">let</span> urlString = itemDesc[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">                <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: urlString)</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">            <span class="keyword">let</span> iconName = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">            <span class="keyword">let</span> icon = <span class="type">UIImage</span>(named: iconName ?? <span class="string">""</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">ListItem</span>(icon: icon, title: title, url: url)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在当一切都就绪之后，我们只在最后一步创建才创建出<code>ListItem</code>实例，如果你不提供任何<code>init</code>方法的话<code>struct</code>会提供一个默认的<code>init</code>方法为它自己的参数段传值。用<code>class</code>的版本可以做相同的事，但是用<code>class</code>的话我们得自己声明<code>init</code>。</p>
<h3 id="联合操作符(Coalescing_operator)">联合操作符(Coalescing operator)</h3><p>上面的例子中我还用了一个新的小技巧，使用<code>??</code>操作符让<code>iconName</code>在是<code>nil</code>的时候给出一个默认值。</p>
<p><code>??</code>操作符和ObjC的<code>opt ?: val</code>表达式很像，了解它的人都知道：<code>opt ?? val</code>如果在<code>opt</code>非空的时候返回它的值，如果是<code>nil</code>的话会返回<code>val</code>。这意味着如果<code>opt</code>是<code>T?</code>类型，<code>val</code>则必须是<code>T</code>类型，整个表达式的结果也会是<code>T</code>类型。</p>
<p>那么这里的<code>iconName ?? &quot;&quot;</code>会允许我们在<code>iconName</code>为<code>nil</code>的时候使用一个空字符<code>&quot;&quot;</code>的图片名称，于是这里会有一个<code>nil</code>的<code>UIImage</code>，并且<code>icon</code>也会是<code>nil</code>。</p>
<p>⚠️注意⚠️：将一个为<code>nil</code>的<code>iconName</code>和一个<code>nil</code>的<code>UIImage</code>作为结果来处理，这并<strong>不是</strong>最佳的、最简洁的做法。实际上使用一个假的<code>&quot;&quot;</code>名字来获得一个空图片看起来有点儿难看，还有点儿欺骗的意味。但是这是给你展示<code>??</code>操作符存在感的一个场合…嘿，我们还是为本系列文章的下一篇保留一些好东西吧(剧透：又涉及到了<code>flatMap</code>)。</p>
<h3 id="结论">结论</h3><p>今天就到这里了。</p>
<p>在第3部分中我们没做太多事情，仅仅就是把<code>class</code>换成了<code>struct</code>。我甚至没讲哪怕一点儿关于两者之间的区别(然而即使我最近特别忙，有段时间没在blog上发东西了，我还是不想你为新文章等待太久)。</p>
<p>但是我们最终丢弃掉<code>NSURL!</code>，将最后一匹小马拯救🎉。在我下一篇文章发布出来前，看一下<a href="https://realm.io/news/andy-matuschak-controlling-complexity/" target="_blank" rel="external">Andy关于《和值类型交朋友》的超棒讨论</a>，你还是有很多东西要去学的。</p>
<p>我承诺在发布第4部分之前不会让你等太久，第4部分又涉及到<code>map</code>和<code>flatMap</code>，但这一次是基于<code>Optionals</code>。</p>
<hr>
<ol>
<li><p>没错，上篇文章中你确实做了一些函数式编程…你自己可能甚至都没有意识到。</p>
</li>
<li><p><code>NSURL!</code>一直纠缠我到现在已经有段时间了，其实我就是太懒了，没去为<code>ListItem</code>类写一个正确的<code>init</code>方法。因为知道我迟早会把它弄掉，所以处理它之前我没想收拾那段代码样本。我们拯救最后一匹小马仅仅是时间问题。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/03/thinking-in-swift-3/">原文链接</a>，原文日期：2015-10-03<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
</blockquote>
<p>系列文章地址：</p>
<ul>
<li><a href="http://swift.gg/2015/09/29/thinking-in-swift-1/">Swift 编程思想，第一部分：拯救小马</a></li>
<li><a href="http://swift.gg/2015/10/09/thinking-in-swift-2/">Swift 编程思想，第二部分：数组的 Map 方法</a></li>
</ul>
<p>继续说咱的”Swift编程思想系列”，今天我们将会做一些小小的改动，使用 <code>struct（结构体）</code> 来使代码得到进一步的简化。</p>]]>
    
    </summary>
    
      <category term="Crunchy Development" scheme="http://swiftggteam.github.io/tags/Crunchy-Development/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Friday Q&A 2015-09-04:让我们来自定义 dispatch_queue]]></title>
    <link href="http://swiftggteam.github.io/2015/10/19/friday-qa-2015-09-04-lets-build-dispatch_queue/"/>
    <id>http://swiftggteam.github.io/2015/10/19/friday-qa-2015-09-04-lets-build-dispatch_queue/</id>
    <published>2015-10-19T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-04<br>译者：<a href="http://blog.csdn.net/yake_099" target="_blank" rel="external">Yake</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
<p>译者注：这篇文章的代码是用 Objective-C 完成的，不过不妨碍大家学习多线程编码的知识。</p>
</blockquote>
<p><code>Grand Central Dispatch</code> 是过去几年中苹果推出过的许多很棒的 API 中的一员。在最新一期的 “Let’s Build” 系列中，我准备去探索 dispatch_queue 一些最基本特性的重新实现，这个主题的建议来自 Rob Rix。<br><a id="more"></a></p>
<h1 id="概述">概述</h1><p>一个调度队列（Dispatch Queue）是存储在全局线程池中的队列任务。通常，提交到队列中的任务会在后台线程中异步地执行。所有的线程共用一个后台线程池，这使得系统更加地高效。</p>
<p>我将重新实现 GCD 中那些必要的 API。为了简单起见，我会忽略掉 GCD 提供的许多有趣的特性。举个例子，全局线程池中的线程数量随着需要处理的任务的数量增大或者减少，这样可以提高 CPU 的使用效率。如果你有一堆任务让 CPU 负载很高，而你又提交了另外一个任务，这时 GCD 将不会为这个任务再创建一个线程。因为 CPU 已经满载运行了，更多的线程只会让性能下降。我会忽略这些实现并且使用硬编码的固定线程数。我也会跳过另外一些有趣的特性比如目标队列（target queues）以及并发队列中的屏障（barriers on concurrent queues）等等。</p>
<p>我们的目标是重写调度队列的核心特性：他们可以是串行的或者并发的，他们可以同步地或者异步地调度任务，并且他们由一个共享的全局线程池提供支持。</p>
<h1 id="代码">代码</h1><p>像往常一样，这篇文章中的代码可以在 Github 上获取：<a href="https://github.com/mikeash/MADispatchQueue" target="_blank" rel="external">代码</a></p>
<p>如果你想边读边跟进，或者是自己进行探索，你都可以在这里找到你想要的。</p>
<h1 id="接口">接口</h1><p>GCD 是一个基于 C 语言的 API。虽然在最近的 OS 发布版本中 GCD 对象被转换成了 Objective-C 对象，API 仍然是纯 C 实现的（加上苹果的 block 扩展）。这种实现对于一个底层 API 来说非常棒，并且 GCD 展示了一种非常简洁的接口，但对我的研究来说，我想用 Objective-C 重写这些接口。</p>
<p>重新实现的 Objective-C 类叫做 “MADispatchQueue”，它只有四个方法：</p>
<ol>
<li>获取一个共享的全局队列的方法。GCD 有许多不同优先级的全局队列，但是简单起见我们只用一个。</li>
<li>一个可以创建并发或者串行队列的初始化方法</li>
<li>异步调度的方法</li>
<li>同步调度的方法</li>
</ol>
<p>下面是接口声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface MADispatchQueue : NSObject&#10;&#10;    + (MADispatchQueue *)globalQueue;&#10;&#10;    - (id)initSerial: (BOOL)serial;&#10;&#10;    - (void)dispatchAsync: (dispatch_block_t)block;&#10;    - (void)dispatchSync: (dispatch_block_t)block;&#10;&#10;    @end</span><br></pre></td></tr></table></figure>
<p>接下来，我们的目标就是要实现这些方法。</p>
<h1 id="线程池接口">线程池接口</h1><p>存储队列的线程池有一个很简洁的接口。这个接口的实现能够实际执行已经提交的任务。队列则负责在合适的时间把那些已经在队列中的任务提交给 CPU 。</p>
<p>线程池只有一项工作：提交将要被运行的任务。对应的，它的接口也只有一个方法：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MAThreadPool</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)addBlock: (dispatch_block_t)block;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>既然这个是核心，让我们首先来实现它。</p>
<h1 id="线程池的实现">线程池的实现</h1><p>首先让我们来看实例变量。线程池将会被多个线程访问，不管是内部的还是外部的。因此它应该是线程安全的。尽管 GCD 一直使用的都是较为快速的原子性操作（atomic operations），但是我将会在我的重新实现中使用一种较好的老式的锁。我需要这个锁等待（wait）以及发信号(signal)的功能，而不仅仅是强制互斥的功能，所以我会使用 <code>NSConditon</code>而不是简单的<code>NSLock</code>。你可能对它不是很熟悉，<code>NSCondition</code> 是一种基本锁，并且包含了一个条件变量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSCondition</span> *_lock;</span><br></pre></td></tr></table></figure>
<p>为了知道什么时候该启用新的工作线程，我需要知道当前线程池中有多少线程，有多少线程正在执行任务，以及可以使用的最大线程数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> _threadCount;</span><br><span class="line"><span class="built_in">NSUInteger</span> _activeThreadCount;</span><br><span class="line"><span class="built_in">NSUInteger</span> _threadCountLimit;</span><br></pre></td></tr></table></figure>
<p>最后，还有一些要被执行的 block 。这是一个 <code>NSMutableArray</code>，它被当作一个队列，你可以从它的末位添加 block，也可以从它的开头移除 block:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *_blocks;</span><br></pre></td></tr></table></figure>
<p>初始化很简单。先初始化锁，接着初始化 block 数组，然后将线程数的限制设置为 128：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">      <span class="keyword">if</span>((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">          _lock = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">          _blocks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">          _threadCountLimit = <span class="number">128</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>工作线程是一个简单的无限循环。只要 block 数组为空，它就会进入等待状态。一旦有一个 block 可用，它就会让 block 从数组中出列并且执行 它。当做这些事的时候，线程池会增加活跃线程的数量，等完成之后会再让其减少。现在让我们开始吧：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)workerThreadLoop: (<span class="keyword">id</span>)ignore &#123;</span><br></pre></td></tr></table></figure>
<p>它做的第一件事就是获取锁。注意这个动作在循环开始<em>之前</em>。在循环结束后我会解释这样做的原因：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure>
<p>接下来进入一个死循环：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br></pre></td></tr></table></figure>
<p>如果队列是空的，让锁进入等待状态：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>([_blocks count] == <span class="number">0</span>) &#123;</span><br><span class="line">	[_lock wait];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里使用了循环来处理的，而不是一个简单的 <code>if</code> 语句。这样做的原因是为了防止<a href="https://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="external">虚假唤醒</a>。简单来说，即使没有信号发出，wait 函数也可能会返回，为了保证正确性，当 wait 返回时，需要再次对条件进行检查。</p>
<p>一旦 block 可用，就让它出列：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_block_t block = [_blocks firstObject];</span><br><span class="line">[_blocks removeObjectAtIndex: <span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>通过增加活跃线程数量来标识该线程正在执行任务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_activeThreadCount++;</span><br></pre></td></tr></table></figure>
<p>现在是时候执行 block 了，但是我们首先需要将锁释放，否则我们不会获得任何并发性，而且会产生各种各样的死锁。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure>
<p>当锁被安全释放之后，就可以执行 block 了:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure>
<p>block 执行完之后，需要减少活跃线程数的数量。这个操作需要在加锁的情况下进行，防止竞争条件的产生，这里就是循环的结尾了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  [_lock lock];</span><br><span class="line">  _activeThreadCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你已经看到了为什么进入循环之前需要加锁。循环中的最后一步是减少活跃线程数量，这就需要我们在这时就持有锁。进入循环的第一件事就是要检查 block 队列。通过在循环的外部运行了第一把锁，后续的循环就可以针对所有的操作使用这把锁，而不需要加锁，解锁，然后突然又加锁了。</p>
<p>现在来看 <code>addBlock</code> :</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addBlock: (dispatch_block_t)block &#123;</span><br></pre></td></tr></table></figure>
<p>这里所做的所有事情都需要先加锁：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_lock lock];</span><br></pre></td></tr></table></figure>
<p>首要的任务是要把新的 block 添加到 block 队列中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_blocks addObject: block];</span><br></pre></td></tr></table></figure>
<p>如果正好有一个空闲的工作线程准备接手这个 block，就没有什么可做的。但是如果没有足够的空闲工作线程来处理这个 block，并且工作线程的数量还没有达到限制，那么就应该再创建一个新的线程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> idleThreads = _threadCount - _activeThreadCount;</span><br><span class="line"><span class="keyword">if</span>([_blocks count] &gt; idleThreads &amp;&amp; _threadCount &lt; _threadCountLimit) &#123;</span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector: <span class="keyword">@selector</span>(workerThreadLoop:)</span><br><span class="line">                             toTarget: <span class="keyword">self</span></span><br><span class="line">                           withObject: <span class="literal">nil</span>];</span><br><span class="line">    _threadCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在一切准备就绪，线程可以开始执行 block 了。为了防止它们都在休眠，唤醒一个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_lock signal];</span><br></pre></td></tr></table></figure>
<p>然后解锁就可以了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就有了一个线程池，这个线程池可以大量生产线程至预设的数量限制，然后在 block 进入的时候执行 block。现在以这个为基础来实现队列。</p>
<h1 id="队列实现">队列实现</h1><p>与线程池一样，队列需要一把锁保护里面的内容。但与线程池不一样的地方是，它不需要任何等待和信号，只是基本的互斥锁，所以它使用<code>NSLock</code>类就行了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *_lock;</span><br></pre></td></tr></table></figure>
<p>与线程池一样，这里使用了<code>NSMutableArray</code>来维护一个待分配 block 的队列：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *_pendingBlocks;</span><br></pre></td></tr></table></figure>
<p>队列需要知道任务是串行的还是并行的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> _serial;</span><br></pre></td></tr></table></figure>
<p>如果是串行的，它同时需要记录现在是否有 block 正在线程池中被执行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> _serialRunning;</span><br></pre></td></tr></table></figure>
<p>而并发队列无论是否有 block 在执行它的行为都是一样的，因此它们不需要记录这些。<br>全局队列被存储在一个全局变量中，就像下面的共享线程池那样。他们都是在<code>+initialize:</code>中创建的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MADispatchQueue *gGlobalQueue;</span><br><span class="line"><span class="keyword">static</span> MAThreadPool *gThreadPool;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span> == [MADispatchQueue class]) &#123;</span><br><span class="line">        gGlobalQueue = [[MADispatchQueue alloc] initSerial: <span class="literal">NO</span>];</span><br><span class="line">        gThreadPool = [[MAThreadPool alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然 <code>+initialize</code> 已经保证创建了 <code>gGlobalQueue</code>，<code>+globalQueue</code> 方法只需要直接返回这个变量即可：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (MADispatchQueue *)globalQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> gGlobalQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码与调用 <code>dispatch_once</code> 类似，但是如果在我实现 GCD API 的时候又使用了另一个 GCD 的 API，这会让人感觉是在作弊，即使这两个 API 并不是一样的。</p>
<p>初始化队列包含了创建锁和待分配 block 队列，还需要设置<code>_serial</code>变量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initSerial: (<span class="built_in">BOOL</span>)serial &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">        _pendingBlocks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        _serial = serial;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们着手实现其它的公共 API 之前，有一个潜在的方法需要被实现，这个方法需要在线程池中调度一个 block，然后再隐式地调用自身去执行另外一个 block：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchOneBlock &#123;</span><br></pre></td></tr></table></figure>
<p>它存在的所有的目的都是为了运行线程池中的任务，所以它就要在这里进行调度：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[gThreadPool addBlock: ^&#123;</span><br></pre></td></tr></table></figure>
<p>接下来它获取到了队列中的第一个 block。当然，这需要在加锁的情况下执行以避免灾难性的崩溃：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[_lock lock];</span><br><span class="line">dispatch_block_t block = [_pendingBlocks firstObject];</span><br><span class="line">[_pendingBlocks removeObjectAtIndex: <span class="number">0</span>];</span><br><span class="line">[_lock unlock];</span><br></pre></td></tr></table></figure>
<p>在获取到了 block 并且锁也释放的时候，block 就可以安全地在后台线程中执行了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block();</span><br></pre></td></tr></table></figure>
<p>如果队列是并发队列，那么这就是它所有需要处理的所有内容。如果是串行队列，还要再进行一些操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_serial) &#123;</span><br></pre></td></tr></table></figure>
<p>在一个串行队列中，添加的 block 会被创建，但是得等到正在处理的 block 完成才会被激活。当一个 block 执行完毕以后，<code>dispatchOneBlock</code> 将会检查是否还有 block 在队列中等待。如果有，它会调用自己执行下一个 block。如果没有，它会把队列的运行状态置为<code>NO</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">            [_lock lock];</span><br><span class="line">            <span class="keyword">if</span>([_pendingBlocks count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span> dispatchOneBlock];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _serialRunning = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [_lock unlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个方法，想要实现<code>dispatchAsync:</code>就相对简单了。将 block 添加到队列中作为等待任务，然后设置状态并在合适的时候激活<code>dispatchOneBlock</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchAsync: (dispatch_block_t)block &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    [_pendingBlocks addObject: block];</span><br></pre></td></tr></table></figure>
<p>如果一个串行队列是<em>空闲</em>的，把它的状态设置为正在运行并调用<code>dispatchOneBlock</code>使一切开始运转：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_serial &amp;&amp; !_serialRunning) &#123;</span><br><span class="line">    _serialRunning = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> dispatchOneBlock];</span><br></pre></td></tr></table></figure>
<p>如果队列是并发的，那么无条件地调用<code>dispatchOneBlock</code>。即使另外一个 block 正在运行，新的 block 也可以被马上执行，因为多个 block 被允许并发地执行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!_serial) &#123;</span><br><span class="line">    [<span class="keyword">self</span> dispatchOneBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个串行队列已经在运行了，那么没有别的什么需要去处理了。已经在执行的 <code>dispatchOneBlock</code> 终将会执行到刚刚被添加到队列中的的 block。现在释放锁：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是 <code>dispatchSync</code> 了。针对这个，GCD 是相当智能的，它可以在调用线程中直接执行 block ，而让队列中的其他 block 停止执行（如果是串行队列）。但是我们不用实现到如此智能。我们只需要对<code>dispatchAsync:</code> 进行包装，让它等一个任务完成之后才开始执行下一个任务。</p>
<p>这里使用了一个局部的 <code>NSCondition</code> 对象，加上一个<code>done</code>变量来表示 block 什么时候执行完毕：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispatchSync: (dispatch_block_t)block &#123;</span><br><span class="line">    <span class="built_in">NSCondition</span> *condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">    __block <span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>然后它就异步的调度一个 block。这个 block 调用了被传入的那个 block，然后设置 done 变量并用 condition 发出信号：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> dispatchAsync: ^&#123;</span><br><span class="line">    block();</span><br><span class="line">    [condition lock];</span><br><span class="line">    done = <span class="literal">YES</span>;</span><br><span class="line">    [condition signal];</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>而在外面的原始的调用线程中，它通过 <code>condition</code> 在等待 <code>done</code> 变量被设置，然后返回：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    [condition lock];</span><br><span class="line">    <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">        [condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">    [condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，block 的执行已经完成了。大功告成！那就是<code>MADispatchQueue</code> API 中的所需要的最后一点儿内容。</p>
<h1 id="结论">结论</h1><p>一个全局线程池可以通过一个拥有任务 block 以及能大量生产线程的队列来实现。使用一个共享的线程池，一个基本的调度队列的 API 就可以被创建，它提供了基本的串行/并行队列下同步/异步任务的调度。这次的重新实现缺少了 GCD 中许多优秀的特征，并且肯定没有 GCD 那么高效，但即便如此它让我们能够看到像这样一种机制的内部原理是怎样的，并且让我们看到那并不是什么魔法（除了<code>dispatch_once</code>，那是绝对的魔法！）。</p>
<p>这就是今天的内容。下次回来看更多有趣的内容。”Friday Q&amp;A”是由用户的想法驱动的，所以如果你希望下次或者将来我可以在这里讨论某些内容，请<a href="mailto:mike@mikeash.com" target="_blank" rel="external">告诉我</a>！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-09-04-lets-build-dispatch_queue.html">原文链接</a>，原文日期：2015-09-04<br>译者：<a href="http://blog.csdn.net/yake_099">Yake</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
<p>译者注：这篇文章的代码是用 Objective-C 完成的，不过不妨碍大家学习多线程编码的知识。</p>
</blockquote>
<p><code>Grand Central Dispatch</code> 是过去几年中苹果推出过的许多很棒的 API 中的一员。在最新一期的 “Let’s Build” 系列中，我准备去探索 dispatch_queue 一些最基本特性的重新实现，这个主题的建议来自 Rob Rix。<br>]]>
    
    </summary>
    
      <category term="Mike Ash" scheme="http://swiftggteam.github.io/tags/Mike-Ash/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中的模式匹配]]></title>
    <link href="http://swiftggteam.github.io/2015/10/16/swift-pattern-matching/"/>
    <id>http://swiftggteam.github.io/2015/10/16/swift-pattern-matching/</id>
    <published>2015-10-16T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-18<br>译者：<a href="undefined">lfb-CD</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<h1 id="Swift中的模式匹配">Swift中的模式匹配</h1><p>更新:<br>2015.9.19: 添加了一些关于Swift语法问题的笔记。把自定义操作符的符号改为了一个我认为更加适合的。在总结中添加了一些对函数式编程的想法。<br>2015.9.25: 添加了关于标准库中已经存在的<code>~&gt;</code>操作符的笔记<br><a id="more"></a><br>这个系列的其他文章：<br>(1)Custom Pattern Matching (就是这篇)<br>(2)<a href="http://oleb.net/blog/2015/09/swift-ranges-and-intervals/" target="_blank" rel="external">Ranges and Intervals</a><br>(3)<a href="http://oleb.net/blog/2015/09/more-pattern-matching-examples/" target="_blank" rel="external">More Pattern Matching Examples</a></p>
<blockquote>
<p><a href="http://oleb.net/media/swift-pattern-matching.playground.zip" target="_blank" rel="external">Download this article as a playground</a> for Xcode 7.</p>
</blockquote>
<p>Swift有一个很好的特性，你可以对模式匹配系统进行扩展。<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html" target="_blank" rel="external">Patterns(模式)</a>是规则值在switch语句中的一个case选项，<code>do-catch</code>语句中的一个<em><code>catch</code></em>分句，或者是一个<em><code>if</code></em>，<em><code>while</code></em>，<em><code>guard</code></em>，<em><code>for-in</code></em>语句中的一个选项。</p>
<p>举个例子，假设你想判断一个整数是否大于,小于或等于零。你可以使用 <code>if-else</code>的结构，但是我认为这段代码并不漂亮：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用<code>switch</code>语句的话会更加好，我更加喜欢这样写代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码 </span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是使用不等式条件的匹配模式，<code>switch</code>语句中默认是不支持的(注:即不支持<code>case &gt;0</code>这种写法)。看看咱们是否可以解决这个问题。为了方便之后的理解，我将使用<code>case greaterThen(0):print(&quot;positive&quot;)</code>的匹配写法替换之前的<code>case &gt; 0</code>在内的所有条件。不过，我将稍后回过头来自定义这个操作符。</p>
<h2 id="扩展模式匹配">扩展模式匹配</h2><p>Swift中的模式匹配是基于<code>~=</code>操作符。如果表达模式<code>~=</code>返回值为<code>true</code>则匹配成功。</p>
<p><a href="http://swiftdoc.org/operator/tildeeq/" target="_blank" rel="external">标准库中对<code>~=</code>有四个重载</a>：一个是<code>Equatable</code>类型，一个是<code>optionals</code>，一个是<code>range</code>，最后一个是<code>interval</code>。虽然<code>range</code>和<code>interval</code>挺接近的，但在这篇文章中我们不用，你也可以在这篇文章中了解下<a href="http://oleb.net/blog/2015/09/swift-ranges-and-intervals/" target="_blank" rel="external">Ranges and Intervals</a>。</p>
<p>所以我们需要实现属于我们自己的<code>~=</code>，函数的形式是这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~=<span class="params">(pattern: ???, value: ???)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>我们知道函数必须返回一个布尔类型(<code>Bool</code>)的结果值，因为我们需要告知传入值是否满足模式匹配条件。接下来还留有一个问题:函数的传入参数类型是什么?</p>
<p>对于<em>value</em>(传入值)来讲，我们只需使用<code>Int</code>类型即可满足上文例程中的需求。但是这里我们使用泛型，使其能接受任何类型的数据。<code>pattern</code>在实例中将以<code>greaterThan(0)</code>或者是<code>lessThan(0)</code>的形式出现。一般来讲，<code>pattern</code>应该是一个函数，将<em>value</em>做为参数传入，如果匹配成功则返回true，其他则返回false。<em>value</em>的类型为T，所以pattern的类型也应该为<code>T -&gt; Bool</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~=<span class="generics">&lt;T&gt;</span><span class="params">(pattern: T -&gt; Bool, value: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要定义<code>greaterThan</code>和<code>lessThan</code>函数，用于返回匹配结果。注意:不要将<code>greaterThan(0)</code>中的<code>0</code>值和传入进行比较的值value混淆了。greaterThan的参数是<code>pattern</code>的一部分，应用于等会第二步要用到的值。比如，<code>greaterThan(0) ~= x</code>和<code>greaterThan(0)(x)</code>是一样的。</p>
<p>我们知道<code>greaterThen(0)</code>函数必须生成一个类型<code>T-&gt;Bool</code>函数作为结果值返回。所以反之，<code>greaterThen</code>必须是一个函数需要另一个值并返回第一个函数。此外，我们对传入参数进行条件约束:必须遵循<code>Comparable</code>协议，这样就能使用<code>Swift</code>中的<code>&gt; 和 &lt;</code>操作符符了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">greaterThan</span><span class="generics">&lt;T : Comparable&gt;</span><span class="params">(a: T)</span></span> -&gt; (<span class="type">T</span> -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; (b: <span class="type">T</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> b &gt; a &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这类接受一个参数，并且又返回一个可以接受余下参数的函数(以此类推)叫做<a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="external">curried functions(柯里化函数)</a>。(这是我去年写的关于柯里化函数的文章:<a href="http://oleb.net/blog/2014/07/swift-instance-methods-curried-functions/" target="_blank" rel="external">instance methods in Swift are a form of (partially) curried functions</a>)。Swift为声明柯里化函数提供了<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID363" target="_blank" rel="external">特殊的语法</a>。使用这样的语句，我们的函数就会像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">greaterThan</span><span class="generics">&lt;T : Comparable&gt;</span><span class="params">(a: T)</span></span>(<span class="number">_</span> b: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b &gt; a</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">lessThan</span><span class="generics">&lt;T : Comparable&gt;</span><span class="params">(a: T)</span></span>(<span class="number">_</span> b: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是在我们第一个版本的switch语句中需要写的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> greaterThan(<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> lessThan(<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当不错吧，除了<code>default</code>那项语句还不完美。如果让编译器检查完所有的情况是不可能的，所以，编译器总是会让我们提供一个<code>default</code>的情况。当然，如果你确定你的选项能覆盖所有的可能，把fatalError()调用在<code>default</code>情况下也是一个好主意，可以用来记录你预料的这段不会被执行的代码。</p>
<h2 id="自定义操作符">自定义操作符</h2><p>滑动到顶部，看一会儿我们之前的伪代码。理想情况下，我们想把<code>greaterThan(0)</code>和<code>lessThan(0)</code>分别换成<code>&gt; 0</code>和<code>&lt; 0</code>。</p>
<p>自定义操作符是一个有争议的话题，倘若读者不熟悉某个特定的操作符时，大大降低了可读性。回到我们的例子中，类似于<code>greaterThan(0)</code>这样的语句可读性是非常好的，所以可以这样认为，自定义操作符是不需要的。但另一方面，每个人都知道<code>&gt; 0</code>是什么意思，所以我们可以尝试着自定义一个类似于这样的操作符。正如我们将会看到的，它不会是完美的。</p>
<p>我们自定义的运算符是一元的 — 它们仅有一个操作数，并且是前缀运算符(与之相对的是后缀运算符，紧跟操作数之后)。一元操作符与其操作数中间是没有空格的，原因在于Swift用空格来消除一元运算符和二元运算符之间的歧义。此外，<code>&lt;</code><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/LexicalStructure.html#//apple_ref/doc/uid/TP40014097-CH30-ID418" target="_blank" rel="external">不允许作为前缀运算作符</a>，所以我们必须退而求其次用其他符号替代之。(<code>&gt;</code>允许作为前缀运算符，但是不能作为后缀运算符。)</p>
<p>我建议使用<code>~&gt;</code>和<code>~&lt;</code>。虽然不太理想，<code>~&gt;</code>看起来很像一个箭头，但是波浪号形象地表示了约等于(<code>~=</code>)这样的关系。另外，我能想到的其他操作符(<code>&gt;&gt;</code>和<code>&lt;&lt;</code>)与移位操作符很容易混淆在一起，所以不建议使用这两个。</p>
<blockquote>
<p><strong>更新9.25.2015</strong>：我从<a href="http://natecook.com/blog/2014/11/swifts-elusive-tilde-gt-operator/" target="_blank" rel="external">Nate Cook的这篇文章中得知</a>操作符<code>~&gt;</code>已经存在于<a href="http://swiftdoc.org/swift-2/operator/tildegt/" target="_blank" rel="external">标准库</a>中了。它并没有任何公开的实现，但是Nate发现它是用来增加集合的索引值的。鉴于有这种用法，完成不同的目的却使用相同的操作符似乎不太合适。我感觉可以随意用其他符号替代。</p>
</blockquote>
<p>实现起来也是比较麻烦的。我们需要做的就是声明运算符以及具体函数的实现，这里仅仅只是委托先前定义的<code>greaterThan</code>和<code>lessThan</code>函数来完成运算符的实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~&gt; &#123; &#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~&lt; &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ~&gt; <span class="generics">&lt;T : Comparable&gt;</span><span class="params">(a: T)</span></span>(<span class="number">_</span> b: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> greaterThan(a)(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ~<span class="generics">&lt; &lt;T : Comparable&gt;</span><span class="params">(a: T)</span></span>(<span class="number">_</span> b: <span class="type">T</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lessThan(a)(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个，我们的<code>switch</code>语句就变成了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> ~&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> ~&lt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次提醒，注意运算符和操作数之间是没有空格的。</p>
<p>这是我们能写得最好的了，非常接近我们之前想要实现的了，但这段代码也并不是完美的了。</p>
<blockquote>
<p><strong>2015.9.19更新</strong>：<a href="https://twitter.com/jl_hfl/status/644992487346581504" target="_blank" rel="external">Joseph Lord</a>提醒我，Swift已经有类似语法用于实现先前的的匹配模式：</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">_</span> <span class="keyword">where</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">_</span> <span class="keyword">where</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(<em><code>default</code>选项仍然是用来确保编译器能安全工作，我已经提交了这个bug，rdar://22765436</em>)</p>
<p><em>这种语法，尽管没有我们自定义解决方案显得简明，但是它却不需要额外自定义一个运算符，看起来还是不错的。不管怎样，该设计方式非常通用，应用范围广。请继续阅读。</em></p>
<h2 id="其他方面的应用">其他方面的应用</h2><p>顺便说一句，这里提出的解决方案是非常通用的。我们重载的操作符<code>~=</code>适用于任何类型的<code>T</code>和任何接受一个参数<code>T</code>并且返回一个<code>Bool</code>类型的函数。也就是说,我们使<code>pattern(value)</code>变成了<code>pattern ~=</code>这样的语法糖。同时，通过扩展，把<code>if pattern(value) { ... }</code>变成了<code>switch value { case pattern: ... }</code>这样的语法糖。</p>
<h2 id="检查一个数字是偶数还是奇数">检查一个数字是偶数还是奇数</h2><p>下面是一些使用范例。第一个简单示例用于说明知识点，但实际应用意义不大。假设你有一个<code>isEven</code>函数用来检查一个数是否是偶数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">isEven</span><span class="generics">&lt;T : IntegerType&gt;</span><span class="params">(a: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> isEven(x) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">true</span>: <span class="built_in">print</span>(<span class="string">"even"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="literal">false</span>: <span class="built_in">print</span>(<span class="string">"odd"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> isEven: <span class="built_in">print</span>(<span class="string">"even"</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="built_in">print</span>(<span class="string">"odd"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次注意<code>default</code>选项。以下代码无法正常工作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> isEven: <span class="built_in">print</span>(<span class="string">"even"</span>)</span><br><span class="line"><span class="keyword">case</span> isOdd: <span class="built_in">print</span>(<span class="string">"odd"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: Switch must be exhaustive, consider adding a default clause</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串匹配">字符串匹配</h1><p>这儿有一个更实际的例子，假设你想检查一个字符串是否包含前缀或者是后缀。我们先写两个函数，<code>hasPrefix</code>和<code>hasSuffix</code>，将两个字符串作为它们的参数，检查第一个参数是否是第二个参数的前缀或者后缀。这些只是改变了一下标准库中已经存在的<a href="https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/structm/String/s:FSS9hasPrefixFSSFSSSb" target="_blank" rel="external"><code>String.hasPrefix</code></a>和<a href="https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/structm/String/s:FSS9hasSuffixFSSFSSSb" target="_blank" rel="external"><code>String.hasSuffix</code></a>方法——把参数排了下顺序（前缀/后缀为第一个参数，全字符串为第二个参数）。如果你使用<code>Partial Applied Function</code>（偏应用函数，可以缺少部分参数的函数）传递给其他的函数的情况很多，你会发现你经常得去适配被调用的接口。这可能让人觉得很烦，但这也不会很难。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">hasPrefix</span><span class="params">(<span class="keyword">prefix</span>: String)</span></span>(value: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.hasPrefix(<span class="keyword">prefix</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">hasSuffix</span><span class="params">(suffix: String)</span></span>(value: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.hasSuffix(suffix)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我看来，以下实现方式大大提高了代码可读性:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line"><span class="keyword">switch</span> str &#123;</span><br><span class="line"><span class="keyword">case</span> hasPrefix(<span class="string">"B"</span>), hasPrefix(<span class="string">"C"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Starts with B or C"</span>)</span><br><span class="line"><span class="keyword">case</span> hasPrefix(<span class="string">"D"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Starts with D"</span>)</span><br><span class="line"><span class="keyword">case</span> hasSuffix(<span class="string">"Z"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Ends with Z"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Something else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>针对我们最初问题的一个通用的解决方案，我们提出了可以应用于很多不同的问题的解决方案。我发现这种情况很普遍：当你将函数作为值时可以到处传递并且通常用于你不想使用它们的地方。函数式编程提高了代码的可组合性，这是在参数使用的一个核心理念。</p>
<p>在内置的数据类型或者是你自定义的数据类型的基础上，可以给Swift的模式匹配系统扩展出可以非常强大的新功能。但是，请不要过度地去扩展。虽然它看起来比原始的解决方案更加清晰，但是对那些不熟悉它的人来说，自定义的语法会使你的代码可读性变差。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/">原文链接</a>，原文日期：2015-09-18<br>译者：<a href="undefined">lfb-CD</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<h1 id="Swift中的模式匹配">Swift中的模式匹配</h1><p>更新:<br>2015.9.19: 添加了一些关于Swift语法问题的笔记。把自定义操作符的符号改为了一个我认为更加适合的。在总结中添加了一些对函数式编程的想法。<br>2015.9.25: 添加了关于标准库中已经存在的<code>~&gt;</code>操作符的笔记<br>]]>
    
    </summary>
    
      <category term="Ole Begemann" scheme="http://swiftggteam.github.io/tags/Ole-Begemann/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchOS 2: Hello, World]]></title>
    <link href="http://swiftggteam.github.io/2015/10/15/watchos-2-hello-world/"/>
    <id>http://swiftggteam.github.io/2015/10/15/watchos-2-hello-world/</id>
    <published>2015-10-15T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>欢迎学习我的<code>WatchOS 2</code>系列教程。我会从最简单的部分开始带你学习<code>WatchOS 2</code>。一个 “Hello,World” app，没错，这个程序虽然非常简单，还是有一些要注意的地方。</p>
<a id="more"></a>
<p>首先，创建一个新的<code>Single View Application</code>。我将假设你已经知道如何创建一个基本的<code>Xcode</code>项目。现在进入有趣的部分：</p>
<ol>
<li>在 <code>Xcode</code> 中, 打开 <code>File -&gt; New -&gt; Target</code></li>
</ol>
<p><img src="/img/articles/watchos-2-hello-world/Screen_Shot_2015-09-21_at_7_23_42_AM.png1444874958.106001" alt=""></p>
<ol>
<li>选择<code>watchOS -&gt; Application</code>。注意在<code>iOS</code>菜单下面有一个<code>Apple Watch</code>选项。不要选择这个选项！因为我曾经做过 <code>WatchKit apps</code>，所以系统自动选择了这个错误的选项 :( 。</li>
</ol>
<p><img src="/img/articles/watchos-2-hello-world/ItsAWatchWorld_xcodeproj.png1444874960.646429" alt=""></p>
<ol>
<li>选择<code>WatchKit App</code> 然后点击<code>Next</code>。注意<strong>你的 Watch App 项目名称不能和 iOS 名称相同</strong> - 因为这会创建两个名字相同的<code>target</code>！你可以随时在<code>Info.plist</code>中修改<code>Bundle Display Name</code>。同时还要注意，不要勾选<code>Include Complication</code>选项 :) 。</li>
</ol>
<p><img src="/img/articles/watchos-2-hello-world/Screenshot_9_21_15__7_35_AM.png1444874962.648526" alt=""></p>
<ol>
<li>点击<code>Finish</code>。就酱！来看一下你的新 <code>App</code> 和 <code>Extension</code> 吧。跟 <code>WatchKit</code> 一样，这里有一个用于 Watch 的 <code>target</code>，并且附带了一个 <code>Storyboard</code>，以及用于编写程序逻辑的 <code>Extension</code>。</li>
</ol>
<p><img src="/img/articles/watchos-2-hello-world/Menubar_and_ItsAWatchWorld_xcodeproj_and_MyPlayground_6_36_06_PM_playground.png1444874964.5578082" alt=""></p>
<p>开心地编程吧！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchos-2-hello-world/">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="http://www.swiftyper.com/">小锅</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>欢迎学习我的<code>WatchOS 2</code>系列教程。我会从最简单的部分开始带你学习<code>WatchOS 2</code>。一个 “Hello,World” app，没错，这个程序虽然非常简单，还是有一些要注意的地方。</p>]]>
    
    </summary>
    
      <category term="Natasha the Robot" scheme="http://swiftggteam.github.io/tags/Natasha-the-Robot/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode6 中模版的介绍]]></title>
    <link href="http://swiftggteam.github.io/2015/10/14/templates-in-xcode-6/"/>
    <id>http://swiftggteam.github.io/2015/10/14/templates-in-xcode-6/</id>
    <published>2015-10-14T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/templates-in-xcode-6/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-27<br>译者：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
</blockquote>
<p><code>Xcode</code> 为我们提供一整套的项目模板。在这篇文章中，我们将对这些模版进行讨论。</p>
<a id="more"></a>
<h3 id="主-从视图应用程序(Master-Detail_Application)">主-从视图应用程序(Master-Detail Application)</h3><blockquote>
<p>这种模版提供了主-从视图应用程序的入口。它提供一个由导航控制器控制的用户界面，用于显示一组项目，在 iPad 中，则显示为分割视图（split view）。</p>
<p>-Apple</p>
</blockquote>
<p>这是一个对学习分割视图控制器(<code>split view controllers</code>)和列表视图控制器(<code>table view controllers</code>)基础知识很有帮助的模版。如果你只在 <code>iPhone</code> 设备中使用，该模版中的分割视图控制器将不起作用，只能使用导航控制器来导航的主-从视图控制器。这种视图对于新手开发者来说这是一个好的开始。</p>
<p><img src="/img/articles/templates-in-xcode-6/Bildschirmfoto-2015-08-25-um-18.28.35.png1444784411.7165086" alt="icon"></p>
<h3 id="Page_Based_应用程序">Page Based 应用程序</h3><blockquote>
<p>这种模板提供了一个 page-based 应用程序的入口，该模版使用一个页面视图控制器（<code>page base viewcontroller</code>）</p>
<p>-Apple</p>
</blockquote>
<p>这个模版有点特别，它会创建一个有12个页面的页面视图控制器。同样的，这种模板对于学习基本的 iOS 开发也是很有帮助的。</p>
<p><img src="/img/articles/templates-in-xcode-6/Bildschirmfoto-2015-08-25-um-18.40.16.png1444784413.1235225" alt="icon"></p>
<h3 id="单视图应用程序（Single_View_Application）">单视图应用程序（Single View Application）</h3><p>这是最基础的模版。</p>
<blockquote>
<p>这个模版提供了使用单视图应用的入口，并且提供了一个视图控制器去管理视图和包含这个视图的 storyboard 或 nib。</p>
<p>-Apple</p>
</blockquote>
<p>它不仅仅是只用在单视图应用程序，而且还是复杂应用程序最好的解决方案。如果你想一切尽在你的掌握中，这种模板是最好的选择。 很多应用程序都会选择这种模版。</p>
<h1 id="Tabbed_应用程序">Tabbed 应用程序</h1><blockquote>
<p>这种模版提供选项卡(tab bar)应用程序的入口。它提供了用户界面，用来配置选项卡控制器和对应项的视图控制器。</p>
</blockquote>
<p>这是非常基础的模版，它会创建一个含有两个视图控制器的选项卡(<code>tab bar</code>)控制器。</p>
<p><img src="/img/articles/templates-in-xcode-6/Bildschirmfoto-2015-08-25-um-18.42.57.png1444784413.9353302" alt="icon"></p>
<h1 id="Game">Game</h1><blockquote>
<p>这种模版提供了游戏开发的入口。</p>
<p>-Apple</p>
</blockquote>
<p>这是一个非常复杂的模版。你可以选择 <code>SceneKit</code>, <code>SpriteKit</code>, <code>Open GL ES</code> 或 <code>Metal</code> 的模版。如果你想了解游戏开发，这种模版可以让你有一个好的开始。</p>
<p><img src="/img/articles/templates-in-xcode-6/Bildschirmfoto-2015-08-25-um-18.45.48.png1444784414.774583" alt="icon"></p>
<h1 id="总结">总结</h1><p>模版是学习关于 iOS 开发基础知识最好的一种方式。然而对于实际的项目你应该更多的使用 “单视图应用程序(<code>Single View Application</code>)” 模版，因为使用这种模版最容易搭建你的项目架构。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/templates-in-xcode-6/">原文链接</a>，原文日期：2015-08-27<br>译者：<a href="https://github.com/chenmingbiao">CMB</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
</blockquote>
<p><code>Xcode</code> 为我们提供一整套的项目模板。在这篇文章中，我们将对这些模版进行讨论。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[try? 的替代实现]]></title>
    <link href="http://swiftggteam.github.io/2015/10/13/alternatives-to-try-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/10/13/alternatives-to-try-swiftlang/</id>
    <published>2015-10-13T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/09/03/alternatives-to-try-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-03<br>译者：<a href="http://blog.csdn.net/nsnirvana" target="_blank" rel="external">我偏笑</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<p><code>try？</code> 语法的优点在于你不必把可能会抛出错误的函数写在一个 <code>do-catch</code> 代码块当中。如果你使用了 <code>try?</code>，该函数的返回值就会是一个可选类型：成功返回 <code>.Some</code>，失败则返回 <code>.None</code>。你可以配合着 <code>if-let</code> 或者 <code>guard</code> 语句来使用 <code>try?</code> 语法。<br><a id="more"></a><br><code>try?</code> 语法的不足则在于它对错误的简化，让你难以了解到错误是什么以及错误发生的时间。这可不是件好事。</p>
<p>但你可以试着自己写出 <code>try?</code> 的替代方法。比如实现一个简单的枚举<code>Result</code>：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="keyword">case</span> <span class="constant">Value</span>(<span class="constant">T</span>)
    <span class="keyword">case</span> <span class="constant">Error</span>(<span class="constant">ErrorType</span>)
}
</code></pre><p>就像上面的代码写的那样，我喜欢分成 <code>Value</code> 和 <code>Error</code> 而不是 <code>err</code> 和 <code>ok</code> ，枚举的不同状态可以按你自己的喜好来命名。</p>
<p>然后你可以写个函数来执行 <code>do-catch</code> 语句，然后把执行结果包含在上面定义的枚举中返回。</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">tryit</span><span class="generics">&lt;T&gt;</span><span class="params">(block: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">T</span>&gt; {
    <span class="keyword">do</span> {
        <span class="keyword">let</span> value = <span class="keyword">try</span> block()
        <span class="keyword">return</span> <span class="type">Result</span>.<span class="type">Value</span>(value)
    } <span class="keyword">catch</span> {<span class="keyword">return</span> <span class="type">Result</span>.<span class="type">Error</span>(error)}
}
</code></pre><p>实际上我也不太喜欢 tryit 这个名字，你可以你喜欢的名字代替。</p>
<p>这个函数的调用有点啰嗦。原来的写法是：</p>
<pre><code><span class="keyword">let</span> <span class="literal">result</span> = <span class="keyword">try</span> myFailableCoinToss()
</code></pre><p>新的写法是：</p>
<p><del><code>let result = tryit{try myFailableCoinToss()}</code></del> <em>感谢bigonotetaker指出错误</em><br><code>let result = tryit(myFailableCoinToss)</code></p>
<p>读者glessard提供给我一个很棒的替代方式，建议我给<code>Result</code>添加一个初始化方法而不是用 tryit：</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; {</span>
    <span class="keyword">case</span> <span class="constant">Value</span>(<span class="constant">T</span>)
    <span class="keyword">case</span> <span class="constant">Error</span>(<span class="constant">ErrorType</span>)

    init(_ <span class="symbol">block:</span> () throws -&gt; <span class="constant">T</span>) {
        <span class="keyword">do</span> {
            let value = try block()
            <span class="keyword">self</span> = <span class="constant">Result</span>.<span class="constant">Value</span>(value)
        } catch {
            <span class="keyword">self</span> = <span class="constant">Result</span>.<span class="constant">Error</span>(error)
        }
    }
}
</code></pre><p>然后你直接这么调用就行了：</p>
<pre><code><span class="keyword">let</span> <span class="literal">result</span> = <span class="type">Result</span>(myFailableCoinToss)
</code></pre><p>你需要用 <code>if-let</code> 和 <code>guard</code> 之外的语句来拆包你的返回值，可以用 <code>switch</code>：</p>
<p><del><code>let result = tryit{try myFailableCoinToss()}</code></del><br>    let result = tryit(myFailableCoinToss)<br>    switch result {<br>    case .Value(let value): print(“Success:”, value)<br>    case .Error(let error): print(“Failure:”, error)<br>    }</p>
<p>或者直接用模式匹配：</p>
<pre><code><span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Value</span>(<span class="keyword">let</span> value) = <span class="literal">result</span> {
    print(<span class="string">"Success:"</span>, value)
} <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Error</span>(<span class="keyword">let</span> error) = <span class="literal">result</span> {
    print(<span class="string">"Failure:"</span>, error)
}
</code></pre><p>你也可以添加一些退出作用域的代码来模仿 <code>guard</code>，这的确可行，但是代码太难看了。</p>
<pre><code><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">case</span> <span class="type">Value</span>(<span class="type">T</span>)
    <span class="keyword">case</span> <span class="type">Error</span>(<span class="type">ErrorType</span>)

    <span class="func"><span class="keyword">func</span> <span class="title">unwrap</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span> {
        <span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Value</span>(<span class="keyword">let</span> value) = <span class="keyword">self</span> {<span class="keyword">return</span> value}
        <span class="keyword">throw</span> <span class="string">"Unable to unwrap result"</span>
    }

    <span class="func"><span class="keyword">func</span> <span class="title">handleError</span><span class="params">(errorHandler: ErrorType -&gt; Void)</span></span> -&gt; <span class="type">Bool</span> {
        <span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Error</span>(<span class="keyword">let</span> error) = <span class="keyword">self</span> {
            errorHandler(error)
            <span class="keyword">return</span> <span class="literal">true</span>
        }
        <span class="keyword">return</span> <span class="literal">false</span>
    }
}

<span class="func"><span class="keyword">func</span> <span class="title">tryit</span><span class="generics">&lt;T&gt;</span><span class="params">(block: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">T</span>&gt; {
    <span class="keyword">do</span> {
        <span class="keyword">let</span> value = <span class="keyword">try</span> block()
        <span class="keyword">return</span> <span class="type">Result</span>.<span class="type">Value</span>(value)
    } <span class="keyword">catch</span> {<span class="keyword">return</span> <span class="type">Result</span>.<span class="type">Error</span>(error)}
}
</code></pre><p><del><code>let result = tryit{try myFailableCoinToss()}</code></del><br>    let result = tryit(myFailableCoinToss)</p>
<pre><code>// guard error
<span class="keyword">if</span> <span class="literal">result</span>.handleError({
    error <span class="keyword">in</span>
    print(<span class="string">"Error is \(error)"</span>)
}) {fatalError()} // leave scope on <span class="literal">true</span>

// force <span class="keyword">try</span> <span class="keyword">for</span> success <span class="keyword">case</span>
<span class="keyword">let</span> unwrappedResult = <span class="keyword">try</span>! <span class="literal">result</span>.unwrap()

// <span class="literal">result</span> <span class="keyword">is</span> now usable at top level scope
print(<span class="string">"Result is \(unwrappedResult)"</span>)
</code></pre><p>这还有另外一种更像 <code>try?</code> 的方式，但是需要打印了所有产生的错误信息。</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">tryit</span><span class="generics">&lt;T&gt;</span><span class="params">(block: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Optional</span>&lt;<span class="type">T</span>&gt;{
    <span class="keyword">do</span> {
        <span class="keyword">return</span> <span class="keyword">try</span> block()
    } <span class="keyword">catch</span> {
        <span class="built_in">print</span>(error)
        <span class="keyword">return</span> <span class="literal">nil</span>
    }
}
</code></pre><p>这种替代 <code>try?</code> 的方法不仅拥有了 <code>if-let</code> 和 <code>guard</code> 的语句特性，还能返回错误。你可以用之前<code>Result</code>调用的方式使用它：</p>
<p><del><code>let result = tryit{try myFailableCoinToss()}</code></del><br><code>let result = tryit(myFailableCoinToss)</code></p>
<p>你仍然不能基于错误类型和错误细节来制定错误处理策略，但是这种实现方式也不像 <code>try?</code> 那样把错误信息完全丢弃掉了。</p>
<p>你也可以修改<code>tryit</code>函数，让它也能接受做错误处理的<code>block</code>，但因为会有两个闭包，这个函数就会变得相当臃肿。我尝试过几种不同的实现方式，但都做的不太好，就不在这分享出来了。最大的问题是，就算你把做错误处理的<code>block</code>传给<code>tryit</code>了，你也不能像 <code>guard</code>语句那样退出作用域，而且也没有这样的<code>guard</code>的替代形式能接受<code>try?</code>的错误来作退出作用域<code>block</code>的参数。</p>
<p>我觉得我最后实现的应该类似于下面的这种形式，在顶层作用域中执行条件赋值，并采用  <code>guard</code> 语句的方式来替代普通的 <code>try</code>：</p>
<pre><code>guard <span class="keyword">let</span> <span class="literal">result</span> = <span class="keyword">try</span>!! myFailableCoinToss() <span class="keyword">else</span> {error <span class="keyword">in</span> ...}
</code></pre><p>之所以这么做是因为我们想知道我们的程序到底会不会出错，如果不出错的话，直接就能得到返回值了。</p>
<pre><code><span class="keyword">let</span> <span class="literal">result</span> = <span class="keyword">try</span> myFailableCoinToss()
</code></pre><p>在当前的状态下，如果要用 <code>try</code> （而且又需要进行错误处理的话），你就必须得用 <code>do-catch</code> 或者像<code>Result</code>枚举之类的变通方法。</p>
<p>非常感谢<a href="http://mikeash.com/" target="_blank" rel="external">Mike Ash</a>的帮忙！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/09/03/alternatives-to-try-swiftlang/">原文链接</a>，原文日期：2015-09-03<br>译者：<a href="http://blog.csdn.net/nsnirvana">我偏笑</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<p><code>try？</code> 语法的优点在于你不必把可能会抛出错误的函数写在一个 <code>do-catch</code> 代码块当中。如果你使用了 <code>try?</code>，该函数的返回值就会是一个可选类型：成功返回 <code>.Some</code>，失败则返回 <code>.None</code>。你可以配合着 <code>if-let</code> 或者 <code>guard</code> 语句来使用 <code>try?</code> 语法。<br>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Swift 中测试 UIAlertController]]></title>
    <link href="http://swiftggteam.github.io/2015/10/12/how-to-test-uialertcontroller-in-swift/"/>
    <id>http://swiftggteam.github.io/2015/10/12/how-to-test-uialertcontroller-in-swift/</id>
    <published>2015-10-12T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/how-to-test-uialertcontroller-in-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-18<br>译者：<a href="undefined">DianQK</a>；校对：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
</blockquote>
<p>最近我读了一篇在 Objective-C 中使用 control swizzling 测试<code>UIAlertController</code>的<a href="http://qualitycoding.org/testing-uialertcontrollers/" target="_blank" rel="external">文章</a>。这样的文章总是促使我寻找一种不使用 control swizzling 也可以测试同样东西的方法。虽然，我知道 swizzling 是开发者的一个非常有力的工具，但我个人是尽可能去避免去使用它的。事实上，在最近的六年时间里，我只在一个应用上用了 swizzling。所以我相信我们现在可以不使用 swizzling 来实现测试。</p>
<p>那么问题来了，如何在 Swift 中不使用 swizzling 来对<code>UIAlertController</code> 进行测试？</p>
<a id="more"></a>
<p>我们先从我们要测试的代码开始吧。我已经添加一个按钮到 Storyboard 中。（我之所以使用 Storyboard 为了让那些不想用代码写界面的小伙伴有个更直观的感受）当按下这个按钮就会出现一个弹窗(alert)，它有标题、消息内容，还有两个按钮，分别是 OK 和取消(Cancel)。下面是这段代码：   </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> actionString: <span class="type">String</span>?</span><br><span class="line">  </span><br><span class="line">  <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">showAlert</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertViewController = <span class="type">UIAlertController</span>(title: <span class="string">"Test Title"</span>, message: <span class="string">"Message"</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> okAction = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.actionString = <span class="string">"OK"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cancelAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .<span class="type">Cancel</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.actionString = <span class="string">"Cancel"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    alertViewController.addAction(cancelAction)</span><br><span class="line">    alertViewController.addAction(okAction)</span><br><span class="line">    </span><br><span class="line">    presentViewController(alertViewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在这个例子中弹窗动作没有做什么具体的操作，他们只表示能验证单元测试。</p>
<p>让我们开始一个简单的测试：测试这个弹窗控制器的标题和消息内容。</p>
<p>测试的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> XCTest</span><br><span class="line"><span class="preprocessor">@testable</span> <span class="keyword">import</span> TestingAlertExperiment</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestingAlertExperimentTests</span>: <span class="title">XCTestCase</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> sut: <span class="type">ViewController</span>!</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.setUp()</span><br><span class="line">  </span><br><span class="line">    sut = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="literal">nil</span>).instantiateInitialViewController() <span class="keyword">as</span>! <span class="type">ViewController</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">UIApplication</span>.sharedApplication().keyWindow?.rootViewController = sut</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tearDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Put teardown code here. This method is called after the invocation of each test method in the class.</span></span><br><span class="line">    <span class="keyword">super</span>.tearDown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要设置 sut 为根视图控制器，否则视图控制器不能弹出这个弹窗视图控制器。</p>
<p>添加 UIAlertController 测试标题的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testAlert_HasTitle</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sut.showAlert(<span class="type">UIButton</span>())</span><br><span class="line">    </span><br><span class="line">  <span class="type">XCTAssertTrue</span>(sut.presentedViewController <span class="keyword">is</span> <span class="type">UIAlertController</span>)</span><br><span class="line">  <span class="type">XCTAssertEqual</span>(sut.presentedViewController?.title, <span class="string">"Test Title"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这很简单。现在让我们测试 UIAlertController 的取消按钮。这里有一个问题：无法获取弹窗动作的闭包。因此我们需要模拟弹窗动作，为了存储这个 handler 并在测试中调用它，看弹窗动作是否和我们预期的一样。在测试用例中添加这样一个类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockAlertAction</span> : <span class="title">UIAlertAction</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Handler</span> = ((<span class="type">UIAlertAction</span>) -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">var</span> handler: <span class="type">Handler</span>?</span><br><span class="line">  <span class="keyword">var</span> mockTitle: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">var</span> mockStyle: <span class="type">UIAlertActionStyle</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(title: <span class="type">String</span>?, style: <span class="type">UIAlertActionStyle</span>, handler: ((<span class="type">UIAlertAction</span>) -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">    </span><br><span class="line">    mockTitle = title</span><br><span class="line">    mockStyle = style</span><br><span class="line">    <span class="keyword">self</span>.handler = handler</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">    mockStyle = .<span class="type">Default</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模拟类的主要工作是捕获 handler 块，以备后用。现在我们需要将这个模拟的类插入到实现代码中。将视图控制器中的代码换成下面这个：   </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> <span class="type">Action</span> = <span class="type">UIAlertAction</span>.<span class="keyword">self</span></span><br><span class="line">  <span class="keyword">var</span> actionString: <span class="type">String</span>?</span><br><span class="line">  </span><br><span class="line">  <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">showAlert</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertViewController = <span class="type">UIAlertController</span>(title: <span class="string">"Test Title"</span>, message: <span class="string">"Message"</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> okAction = <span class="type">Action</span>.<span class="keyword">init</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.actionString = <span class="string">"OK"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cancelAction = <span class="type">Action</span>.<span class="keyword">init</span>(title: <span class="string">"Cancel"</span>, style: .<span class="type">Cancel</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">self</span>.actionString = <span class="string">"Cancel"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    alertViewController.addAction(cancelAction)</span><br><span class="line">    alertViewController.addAction(okAction)</span><br><span class="line">    </span><br><span class="line">    presentViewController(alertViewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们添加了一个类变量<code>Action</code>，并设置为<code>UIAlertAction.self</code>。这个变量我们会在初始化弹窗动作时使用。这就能让我们在测试时可以重写它。像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testAlert_FirstActionStoresCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sut.<span class="type">Action</span> = <span class="type">MockAlertAction</span>.<span class="keyword">self</span></span><br><span class="line">  </span><br><span class="line">  sut.showAlert(<span class="type">UIButton</span>())</span><br><span class="line">  <span class="keyword">let</span> alertController = sut.presentedViewController <span class="keyword">as</span>! <span class="type">UIAlertController</span></span><br><span class="line">  <span class="keyword">let</span> action = alertController.actions.first <span class="keyword">as</span>! <span class="type">MockAlertAction</span></span><br><span class="line">  action.handler!(action)</span><br><span class="line">  </span><br><span class="line">  <span class="type">XCTAssertEqual</span>(sut.actionString, <span class="string">"Cancel"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们插入了这个弹窗动作。之后我们调用代码弹出弹窗视图控制器。我们从呈现的视图控制器中获取了取消动作，并且成功调用了捕获的 handler 块。最后一步就是去断言当前的动作是否和我们预期的一样。</p>
<p>就是这样，一种很简单的又不使用 swizzling 来测试 UIAlertViewController 的方式。</p>
<p>文章中的代码已经放到 <a href="https://github.com/dasdom/TestingAlertExperiment" target="_blank" rel="external">github</a> 。 </p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/how-to-test-uialertcontroller-in-swift/">原文链接</a>，原文日期：2015-09-18<br>译者：<a href="undefined">DianQK</a>；校对：<a href="http://weibo.com/linusling">小铁匠Linus</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
</blockquote>
<p>最近我读了一篇在 Objective-C 中使用 control swizzling 测试<code>UIAlertController</code>的<a href="http://qualitycoding.org/testing-uialertcontrollers/">文章</a>。这样的文章总是促使我寻找一种不使用 control swizzling 也可以测试同样东西的方法。虽然，我知道 swizzling 是开发者的一个非常有力的工具，但我个人是尽可能去避免去使用它的。事实上，在最近的六年时间里，我只在一个应用上用了 swizzling。所以我相信我们现在可以不使用 swizzling 来实现测试。</p>
<p>那么问题来了，如何在 Swift 中不使用 swizzling 来对<code>UIAlertController</code> 进行测试？</p>]]>
    
    </summary>
    
      <category term="dom" scheme="http://swiftggteam.github.io/tags/dom/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 元组高级用法和最佳实践]]></title>
    <link href="http://swiftggteam.github.io/2015/10/10/tuples-swift-advanced-usage-best-practices/"/>
    <id>http://swiftggteam.github.io/2015/10/10/tuples-swift-advanced-usage-best-practices/</id>
    <published>2015-10-10T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：terhechte，<a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="external">原文链接</a>，原文日期：2015/07/19<br>译者：<a href="http://blog.csdn.net/mmoaay" target="_blank" rel="external">mmoaay</a>；校对：<a href="http://weibo.com/lfbWb" target="_blank" rel="external">lfb_CD</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>作为 Swift 中比较少见的语法特性，元组只是占据了结构体和数组之间很小的一个位置。此外，它在 Objective-C（或者很多其他语言）中没有相应的结构。最后，标准库以及 Apple 示例代码中对元组的使用也非常少。可能它在 Swift 中给人的印象就是用来做模式匹配，但我并不这么认为。</p>
<p>和元组相关的大部分教程都只关注三种使用场景（模式匹配、返回值和解构），且浅尝辄止。本文会详细介绍元组，并讲解元组使用的最佳实践，告诉你何时该用元组，何时不该用元组。同时我也会列出那些你不能用元组做的事情，免得你老是去 StackOverflow 提问。好了，进入正题。</p>
<a id="more"></a>
<h1 id="绝对基础">绝对基础</h1><p>因为这部分内容你可能已经知道得七七八八了，所以我就简单介绍下。</p>
<p>元组允许你把不同类型的数据结合到一起。它是可变的，尽管看起来像序列，但是它不是，因为不能直接遍历所有内容。我们首先通过一个简单的入门示例来学习如何创建和使用元组。</p>
<h1 id="创建和访问元组">创建和访问元组</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个简单的元组</span></span><br><span class="line"><span class="keyword">let</span> tp1 = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> tp2 = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个命名元组</span></span><br><span class="line"><span class="keyword">let</span> tp3 = (x: <span class="number">5</span>, y: <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的类型</span></span><br><span class="line"><span class="keyword">let</span> tp4 = (name: <span class="string">"Carl"</span>, age: <span class="number">78</span>, pets: [<span class="string">"Bonny"</span>, <span class="string">"Houdon"</span>, <span class="string">"Miki"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元组元素</span></span><br><span class="line"><span class="keyword">let</span> tp5 = (<span class="number">13</span>, <span class="number">21</span>)</span><br><span class="line">tp5.<span class="number">0</span> <span class="comment">// 13</span></span><br><span class="line">tp5.<span class="number">1</span> <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tp6 = (x: <span class="number">21</span>, y: <span class="number">33</span>)</span><br><span class="line">tp6.x <span class="comment">// 21</span></span><br><span class="line">tp6.y <span class="comment">// 33</span></span><br></pre></td></tr></table></figure>
<h1 id="使用元组做模式匹配">使用元组做模式匹配</h1><p>就像之前所说，这大概是元组最常见的使用场景。Swift 的 <code>switch</code> 语句提供了一种极强大的方法，可以在不搞乱源代码的情况下简单的定义复杂条件句。这样就可以在一个语句中匹配类型、实例以及多个变量的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特意造出来的例子</span></span><br><span class="line"><span class="comment">// 这些是多个方法的返回值</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">let</span> job: <span class="type">String</span>? = <span class="string">"Operator"</span></span><br><span class="line"><span class="keyword">let</span> payload: <span class="type">AnyObject</span> = <span class="type">NSDictionary</span>()</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们想要找一个 30 岁以下的工作者和一个字典 <code>payload</code>。假设这个 <code>payload</code> 是 Objective-C 世界中的一些东西，它可能是字典、数组或者数字。现在你不得不和下面这段别人很多年前写的烂代码打交道：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (age, job, payload) &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">let</span> age, <span class="number">_</span>?, <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSDictionary</span>) <span class="keyword">where</span> age &lt; <span class="number">30</span>:</span><br><span class="line">  <span class="built_in">print</span>(age)</span><br><span class="line">  <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 <code>switch</code> 的参数构建为元组 <code>(age, job, payload)</code>，我们就可以用精心设计的约束条件来一次性访问元组中所有特定或不特定的属性。</p>
<h1 id="把元组做为返回类型">把元组做为返回类型</h1><p>这可能是元组第二多的应用场景。因为元组可以即时构建，它成了在方法中返回多个值的一种简单有效的方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">abc</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span>, <span class="number">5</span>, <span class="string">"Carl"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="元组解构">元组解构</h1><p>Swift 从不同的编程语言汲取了很多灵感，这也是 Python 做了很多年的事情。之前的例子大多只展示了如何把东西塞到元组中，解构则是一种迅速把东西从元组中取出的方式，结合上面的 <code>abc</code> 例子，我们写出如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (a, b, <span class="built_in">c</span>) = abc()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>另外一个例子是把多个方法调用写在一行代码中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (a, b, <span class="built_in">c</span>) = (a(), b(), <span class="built_in">c</span>())</span><br></pre></td></tr></table></figure>
<p>或者，简单的交换两个值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line">(b, a) = (a, b)</span><br></pre></td></tr></table></figure>
<h1 id="进阶">进阶</h1><h2 id="元组做为匿名结构体">元组做为匿名结构体</h2><p>元组和结构体一样允许你把不同的类型结合到一个类型中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vs.</span></span><br><span class="line"><span class="keyword">let</span> user = (name: <span class="string">"Carl"</span>, age: <span class="number">40</span>)</span><br></pre></td></tr></table></figure>
<p>正如你所见，这两个类型很像，只是结构体通过结构体描述声明，声明之后就可以用这个结构体来定义实例，而元组仅仅是一个实例。如果需要在一个方法或者函数中定义临时结构体，就可以利用这种相似性。就像 Swift 文档中所说：</p>
<blockquote>
<p>“需要临时组合一些相关值的时候，元组非常有用。（…）如果数据结构需要在临时范围之外仍然存在。那就把它抽象成类或者结构体（…）”</p>
</blockquote>
<p>下面来看一个例子：需要收集多个方法的返回值，去重并插入到数据集中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">zipForUser</span><span class="params">(userid: String)</span></span> -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"12124"</span> &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">streetForUser</span><span class="params">(userid: String)</span></span> -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"Charles Street"</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数据集中找出所有不重复的街道</span></span><br><span class="line"><span class="keyword">var</span> streets: [<span class="type">String</span>: (<span class="built_in">zip</span>: <span class="type">String</span>, street: <span class="type">String</span>, <span class="built_in">count</span>: <span class="type">Int</span>)] = [:]</span><br><span class="line"><span class="keyword">for</span> userid <span class="keyword">in</span> users &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">zip</span> = zipForUser(userid)</span><br><span class="line">    <span class="keyword">let</span> street = streetForUser(userid)</span><br><span class="line">    <span class="keyword">let</span> key = <span class="string">"<span class="subst">\(<span class="built_in">zip</span>)</span>-<span class="subst">\(street)</span>"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> (<span class="number">_</span>, <span class="number">_</span>, <span class="built_in">count</span>) = streets[key] &#123;</span><br><span class="line">	streets[key] = (<span class="built_in">zip</span>, street, <span class="built_in">count</span> + <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	streets[key] = (<span class="built_in">zip</span>, street, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drawStreetsOnMap(streets.values)</span><br></pre></td></tr></table></figure>
<p>这里，我们在短暂的临时场景中使用结构简单的元组。当然也可以定义结构体，但是这并不是必须的。</p>
<p>再看另外一个例子：在处理算法数据的类中，你需要把某个方法返回的临时结果传入到另外一个方法中。定义一个只有两三个方法会用的结构体显然是不必要的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编造算法</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">calculateInterim</span><span class="params">(values: [Int])</span></span> -&gt; (r: <span class="type">Int</span>, alpha: <span class="type">CGFloat</span>, chi: (<span class="type">CGFloat</span>, <span class="type">CGFLoat</span>)) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">expandInterim</span><span class="params">(interim: <span class="params">(r: Int, alpha: CGFloat, chi: <span class="params">(CGFloat, CGFLoat)</span></span></span></span>)) -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这行代码非常优雅。单独为一个实例定义结构体有时候过于复杂，而定义同一个元组 4 次却不使用结构体也同样不可取。所以选择哪种方式取决于各种各样的因素。</p>
<h2 id="私有状态">私有状态</h2><p>除了之前的例子，元组还有一种非常实用的场景：在临时范围以外使用。Rich Hickey 说过：“如果树林中有一棵树倒了，会发出声音么？“因为作用域是私有的，元组只在当前的实现方法中有效。使用元组可以很好的存储内部状态。</p>
<p>来看一个简单的例子：保存一个静态的 <code>UITableView</code> 结构，这个结构用来展示用户简介中的各种信息以及信息对应值的 <code>keypath</code>，同时还用<code>editable</code>标识表示点击 <code>Cell</code> 时是否可以对这些值进行编辑。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tableViewValues = [(title: <span class="string">"Age"</span>, value: <span class="string">"user.age"</span>, editable: <span class="literal">true</span>),</span><br><span class="line">(title: <span class="string">"Name"</span>, value: <span class="string">"user.name.combinedName"</span>, editable: <span class="literal">true</span>),</span><br><span class="line">(title: <span class="string">"Username"</span>, value: <span class="string">"user.name.username"</span>, editable: <span class="literal">false</span>),</span><br><span class="line">(title: <span class="string">"ProfilePicture"</span>, value: <span class="string">"user.pictures.thumbnail"</span>, editable: <span class="literal">false</span>)]</span><br></pre></td></tr></table></figure>
<p>另一种选择就是定义结构体，但是如果数据的实现细节是纯私有的，用元组就够了。</p>
<p>更酷的一个例子是：你定义了一个对象，并且想给这个对象添加多个变化监听器，每个监听器都包含它的名字以及发生变化时被调用的闭包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addListener</span><span class="params">(name: String, action: <span class="params">(change: AnyObject?)</span></span></span> -&gt; ())</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeListener</span><span class="params">(name: String)</span></span></span><br></pre></td></tr></table></figure>
<p>你会如何在对象中保存这些监听器呢？显而易见的解决方案是定义一个结构体，但是这些监听器只能在三种情况下用，也就是说它们使用范围极其有限，而结构体只能定义为 <code>internal</code> ，所以，使用元组可能会是更好的解决方案，因为它的解构能力会让事情变得很简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listeners: [(<span class="type">String</span>, (<span class="type">AnyObject</span>?) -&gt; ())]</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addListener</span><span class="params">(name: String, action: <span class="params">(change: AnyObject?)</span></span></span> -&gt; ()) &#123;</span><br><span class="line">   <span class="keyword">self</span>.listeners.append((name, action))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeListener</span><span class="params">(name: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> idx = listeners.indexOf(&#123; e <span class="keyword">in</span> <span class="keyword">return</span> e.<span class="number">0</span> == name &#125;) &#123;</span><br><span class="line">	listeners.removeAtIndex(idx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(change: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="number">_</span>, listener) <span class="keyword">in</span> listeners &#123;</span><br><span class="line">	listener(change)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像你在 <code>execute</code> 方法中看到的一样，元组的解构能力让它在这种情况下特别好用，因为内容都是在局部作用域中直接解构。</p>
<h2 id="把元组作为固定大小的序列">把元组作为固定大小的序列</h2><p>元组的另外一个应用领域是：固定一个类型所包含元素的个数。假设需要用一个对象来计算一年中所有月份的各种统计值，你需要分开给每个月份存储一个确定的 <code>Integer</code> 值。首先能想到的解决方案会是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monthValues: [<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>
<p>然而，这样的话我们就不能确定这个属性刚好包含 12 个元素。使用这个对象的用户可能不小心插入了 13 个值，或者 11 个。我们没法告诉类型检查器这个对象是固定 12 个元素的数组（有意思的是，这是 C 都支持的事情）。但是如果使用元组，可以很简单地实现这种特殊的约束：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> monthValues: (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br></pre></td></tr></table></figure>
<p>还有一种选择就是在对象的功能中加入约束逻辑（即通过新的 <code>guard</code> 语句），然而这个是在运行时检查。元组的检查则是在编译期间；当你想给对象赋值 11 个月时，编译都通不过。</p>
<h2 id="元组当做复杂的可变参数类型">元组当做复杂的可变参数类型</h2><p>可变参数（比如可变函数参数）是在函数参数的个数不定的情况下非常有用的一种技术。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统例子</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sumOf</span><span class="params">(numbers: Int...)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 + 操作符把所有数字加起来</span></span><br><span class="line">    <span class="keyword">return</span> numbers.<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>) <span class="comment">// 24</span></span><br></pre></td></tr></table></figure>
<p>如果你的需求不单单是 <code>integer</code>，元组就会变的很有用。下面这个函数做的事情就是批量更新数据库中的 <code>n</code> 个实体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">batchUpdate</span><span class="params">(updates: <span class="params">(String, Int)</span></span></span>...) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.db.begin()</span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> updates &#123;</span><br><span class="line">	<span class="keyword">self</span>.db.<span class="keyword">set</span>(key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.db.end()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们假想数据库是很复杂的</span></span><br><span class="line">batchUpdate((<span class="string">"tk1"</span>, <span class="number">5</span>), (<span class="string">"tk7"</span>, <span class="number">9</span>), (<span class="string">"tk21"</span>, <span class="number">44</span>), (<span class="string">"tk88"</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<h1 id="高级用法">高级用法</h1><h2 id="元组迭代">元组迭代</h2><p>在之前的内容中，我试图避免把元组叫做序列或者集合，因为它确实不是。因为元组中每个元素都可以是不同的类型，所以无法使用类型安全的方式对元组的内容进行遍历或者映射。或者说至少没有优雅的方式。</p>
<p>Swift 提供了有限的反射能力，这就允许我们检查元组的内容然后对它进行遍历。不好的地方就是类型检查器不知道如何确定遍历元素的类型，所以所有内容的类型都是 <code>Any</code>。你需要自己转换和匹配那些可能有用的类型并决定要对它们做什么。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = (a: <span class="number">5</span>, b: <span class="string">"String"</span>, <span class="built_in">c</span>: <span class="type">NSDate</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mirror = <span class="type">Mirror</span>(reflecting: t)</span><br><span class="line"><span class="keyword">for</span> (label, value) <span class="keyword">in</span> mirror.children &#123;</span><br><span class="line">    <span class="keyword">switch</span> value &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Int</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"int"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">String</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">NSDate</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"nsdate"</span>)</span><br><span class="line">    <span class="keyword">default</span>: ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这当然没有数组迭代那么简单，但是如果确实需要，可以使用这段代码。</p>
<h2 id="元组和泛型">元组和泛型</h2><p>Swift 中并没有 <code>Tuple</code> 这个类型。如果你不知道为什么，可以这样想：每个元组都是完全不同的类型，它的类型取决于它包含元素的类型。</p>
<p>所以，与其定义一个支持泛型的元组，还不如根据自己需求定义一个包含具体数据类型的元组。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">wantsTuple</span><span class="generics">&lt;T1, T2&gt;</span><span class="params">(tuple: <span class="params">(T1, T2)</span></span></span>) -&gt; <span class="type">T1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tuple.<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wantsTuple((<span class="string">"a"</span>, <span class="string">"b"</span>)) <span class="comment">// "a"</span></span><br><span class="line">wantsTuple((<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过 <code>typealiases</code> 使用元组，从而允许子类指定具体的类型。这看起来相当复杂而且无用，但是我已经碰到了需要特意这样做的使用场景。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = (<span class="type">A</span>, <span class="type">B</span>)</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">addElement</span><span class="params">(elm: Element)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(elm)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerClass</span>&lt;<span class="title">B</span>&gt; : <span class="title">BaseClass</span>&lt;<span class="title">Int</span>, <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> example = <span class="type">IntegerClass</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">example.addElement((<span class="number">5</span>, <span class="string">""</span>))</span><br><span class="line"><span class="comment">// Prints (5, "")</span></span><br></pre></td></tr></table></figure>
<h2 id="定义具体的元组类型">定义具体的元组类型</h2><p>在之前好几个例子中，我们多次重复一些已经确定的类型，比如 <code>(Int, Int, String)</code>。这当然不需要每次都写，你可以为它定义一个 <code>typealias</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Example</span> = (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">String</span>)</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">add</span><span class="params">(elm: Example)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果需要如此频繁的使用一个确定的元组结构，以至于你想给它增加一个 <code>typealias</code>，那么最好的方式是定义一个结构体。</p>
<h2 id="用元组做函数参数">用元组做函数参数</h2><p>就像 <a href="http://www.paulrobinson.net/function-parameters-are-tuples-in-swift/" target="_blank" rel="external">Paul Robinson 的文章</a> 中说到的一样，<code>(a: Int, b: Int, c: String) -&gt;</code> 和 <code>(a: Int, b: Int, c:String)</code> 之间有一种奇妙的相似。确实，对于 Swift 的编译器而言，方法/函数的参数头无非就是一个元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 Paul Robinson 的博客拷贝来的, 你也应该去读读这篇文章:</span></span><br><span class="line"><span class="comment">// http://www.paulrobinson.net/function-parameters-are-tuples-in-swift/</span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a: Int, <span class="number">_</span> b: Int, <span class="number">_</span> name: String)</span></span> -&gt; <span class="type">Int</span>     </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arguments = (<span class="number">4</span>, <span class="number">3</span>, <span class="string">"hello"</span>)</span><br><span class="line">foo(arguments) <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure>
<p>这看起来很酷是不是？但是等等…这里的函数签名有点特殊。当我们像元组一样增加或者移除标签的时候会发生什么呢？哦了，我们现在开始实验：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让我们试一下带标签的:</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">foo2</span><span class="params">(a a: Int, b: Int, name: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arguments = (<span class="number">4</span>, <span class="number">3</span>, <span class="string">"hello"</span>)</span><br><span class="line">foo2(arguments) <span class="comment">// 不能用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arguments2 = (a: <span class="number">4</span>, b: <span class="number">3</span>, name: <span class="string">"hello"</span>)</span><br><span class="line">foo2(arguments2) <span class="comment">// 可以用 (4)</span></span><br></pre></td></tr></table></figure>
<p>所以如果函数签名带标签的话就可以支持带标签的元组。</p>
<p>但我们是否需要明确的把元组写入到变量中呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo2((a: <span class="number">4</span>, b: <span class="number">3</span>, name: <span class="string">"hello"</span>)) <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure>
<p>好吧，比较倒霉，上面的代码是不行的，但是如果是通过调用函数返回的元组呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a: Int, <span class="number">_</span> b: Int, <span class="number">_</span> name: String)</span></span> -&gt; <span class="type">Int</span>     </span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">get_tuple</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">4</span>, <span class="number">4</span>, <span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(get_tuple()) <span class="comment">// 可以用! 返回 4!</span></span><br></pre></td></tr></table></figure>
<p>太棒了！这种方式可以！</p>
<p>这种方式包含了很多有趣的含义和可能性。如果对类型进行很好的规划，你甚至可以不需要对数据进行解构，然后直接把它们当作参数在函数间传递。</p>
<p>更妙的是，对于函数式编程，你可以直接返回一个含多个参数的元组到一个函数中，而不需要对它进行解构。</p>
<h1 id="元组做不到啊~">元组做不到啊~</h1><p>最后，我们把一些元组不能实现事情以列表的方式呈现给大家。</p>
<h2 id="用元组做字典的_Key">用元组做字典的 <code>Key</code></h2><p>如果你想做如下的事情：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p: [(<span class="type">Int</span>, <span class="type">Int</span>): <span class="type">String</span>]</span><br></pre></td></tr></table></figure>
<p>那是不可能的，因为元组不符合哈希协议。这真是一件令人伤心的事，因为这种写法有很多应用场景。可能会有疯狂的类型检查器黑客对元组进行扩展以使它符合哈希协议，但是我还真的没有研究过这个，所以如果你刚好发现这是可用的，请随时通过我的 <a href="http://twitter.com/terhechte" target="_blank" rel="external">twitter</a> 联系我。</p>
<h2 id="元组的协议合规性">元组的协议合规性</h2><p>给定如下的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PointProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> y: <span class="type">Int</span> &#123; <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你没法告诉类型检查器这个 <code>(x: 10, y: 20)</code> 元组符合这个协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addPoint</span><span class="params">(point: PointProtocol)</span></span></span><br><span class="line">addPoint((x: <span class="number">10</span>, y: <span class="number">20</span>)) <span class="comment">// 不可用。</span></span><br></pre></td></tr></table></figure>
<h1 id="附录">附录</h1><p>就这样了。如果我忘了说或者说错一些事情，如果你发现了确切的错误，或者有一些其他我忘了的事情，请随时<a href="http://twitter.com/terhechte" target="_blank" rel="external">联系我</a></p>
<h1 id="更新">更新</h1><p><strong>07/23/2015</strong> 添加<strong>用元组做函数参数</strong>章节</p>
<p><strong>08/06/2015</strong> 更新反射例子到最新的 Swift beta 4（移除了对 <code>reflect</code> 的调用)</p>
<p><strong>08/12/2015</strong> 更新<strong>用元组做函数参数</strong>章节，加入更多的例子和信息</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：terhechte，<a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/">原文链接</a>，原文日期：2015/07/19<br>译者：<a href="http://blog.csdn.net/mmoaay">mmoaay</a>；校对：<a href="http://weibo.com/lfbWb">lfb_CD</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>作为 Swift 中比较少见的语法特性，元组只是占据了结构体和数组之间很小的一个位置。此外，它在 Objective-C（或者很多其他语言）中没有相应的结构。最后，标准库以及 Apple 示例代码中对元组的使用也非常少。可能它在 Swift 中给人的印象就是用来做模式匹配，但我并不这么认为。</p>
<p>和元组相关的大部分教程都只关注三种使用场景（模式匹配、返回值和解构），且浅尝辄止。本文会详细介绍元组，并讲解元组使用的最佳实践，告诉你何时该用元组，何时不该用元组。同时我也会列出那些你不能用元组做的事情，免得你老是去 StackOverflow 提问。好了，进入正题。</p>]]>
    
    </summary>
    
      <category term="APPVENTURE" scheme="http://swiftggteam.github.io/tags/APPVENTURE/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 编程思想，第二部分：数组的 Map 方法]]></title>
    <link href="http://swiftggteam.github.io/2015/10/09/thinking-in-swift-2/"/>
    <id>http://swiftggteam.github.io/2015/10/09/thinking-in-swift-2/</id>
    <published>2015-10-09T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/09/20/thinking-in-swift-2/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-20<br>译者：<a href="http://blog.csdn.net/nsnirvana" target="_blank" rel="external">我偏笑</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>在<a href="http://alisoftware.github.io/swift/2015/09/06/thinking-in-swift-1/" target="_blank" rel="external">本系列的第一篇文章</a>中，介绍了如何避免对可选类型强制解包以及拯救“小马”🐴 。在第二部分中，我们将会精简前文代码来让它看起来更有”雨燕风”(<em>Swift-er</em> : Swift编程语言风格)，同时向你介绍 <code>map()</code> 和 <code>flatMap()</code> 方法。</p>
<a id="more"></a>
<blockquote>
<p>今天这篇文章我们将要讨论数组的 <code>map()</code> 和 <code>flatMap()</code> 方法。</p>
</blockquote>
<h1 id="前情提要1">前情提要<a href="thinking-in-swift-2/#note1"><sup>1</sup></a></h1><p>友情提示: 以下为<a href="http://alisoftware.github.io/swift/2015/09/06/thinking-in-swift-1/" target="_blank" rel="external">前文</a>留下的代码:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> icon: <span class="type">UIImage</span>?</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">NSURL</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">listItemsFromJSONData</span><span class="params">(jsonData: NSData?)</span></span> -&gt; [<span class="type">ListItem</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> nonNilJsonData = jsonData,</span><br><span class="line">            <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nonNilJsonData, options: []),</span><br><span class="line">            <span class="keyword">let</span> jsonItems = json <span class="keyword">as</span>? <span class="type">Array</span>&lt;<span class="type">NSDictionary</span>&gt;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 倘若JSON序列化失败，或者转换类型失败</span></span><br><span class="line">                <span class="comment">// 返回一个空数组结果</span></span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> items = [<span class="type">ListItem</span>]()</span><br><span class="line">        <span class="keyword">for</span> itemDesc <span class="keyword">in</span> jsonItems &#123;</span><br><span class="line">            <span class="keyword">let</span> item = <span class="type">ListItem</span>()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> icon = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">                item.icon = <span class="type">UIImage</span>(named: icon)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> title = itemDesc[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">                item.title = title</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> urlString = itemDesc[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="type">String</span>, <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: urlString) &#123;</span><br><span class="line">                item.url = url</span><br><span class="line">            &#125;</span><br><span class="line">            items.append(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> items</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文的目标是使用更多“雨燕风”的模式和语法，使得代码看起来更棒并且简洁。</p>
<h1 id="map()方法介绍">map()方法介绍</h1><p><code>map()</code> 是 <code>Array</code> 提供的方法，通过接收一个函数作为传入参数，对数组中每个元素进行函数变换得到新的结果值。这样只需要提供<code>X-&gt;Y</code>的映射关系，就能将数组<code>[X]</code>变换到新数组<code>[Y]</code>，而无需创建一个临时可变数组(注:即上面代码中的<code>items</code>变量)。</p>
<p>本例中，我们不再像之前一样用 <code>for</code> 来做循环，而是对 <code>jsonItems</code>(<em>JSON</em>数据:存储于类型为字典的数组中)使用 <code>map()</code> 方法，并传入一个变换函数(闭包)，将每个 <code>NSDictionary</code> 类型数组元素转换成我们所需的 <code>ListItem</code> 实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> jsonItems.map &#123; (itemDesc: NSDictionary) -&gt; ListItem <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> item = ListItem()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> icon = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="built_in">String</span> &#123;</span><br><span class="line">        item.icon = UIImage(named: icon)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> title = itemDesc[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="built_in">String</span> &#123;</span><br><span class="line">        item.title = title</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> urlString = itemDesc[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="built_in">String</span>, <span class="keyword">let</span> url = NSURL(string: urlString) &#123;</span><br><span class="line">        item.url = url</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这看起来只是个很小的改动，但是它让我们专注于怎样把 <code>NSDictionary</code> 转化成 <code>ListItem</code>，毕竟这是解决问题的核心。更为重要的是，避免了像在 ObjC 里做的那样，新建一个中间数组。我们应该尽可能地避免这种情况发生。</p>
<h3 id="错误数据">错误数据</h3><p>目前代码还存在一个问题：即便输入的数据是不可用的，我们依然创建了一个 <code>ListItem</code> 实例(并返回添加到结果数组<code>jsonItems</code>当中)。所以，倘若某些 <code>NSDictionary</code>是无效的，最终的输出数组中，就会添加一些毫无意义的<code>ListItem()</code>空实例。<br>更重要的是，我们仍在杀死一些小马 🐴 。当我们使用<code>NSURL!</code>时，代码允许我们创建那些没有 <code>NSURL</code> 的 <code>ListItem()</code> 实例（我们没有一个有效的<code>url</code>键值，所以访问<code>item.url</code>不起作用），当我们访问无效的<code>NSURL!</code>时，程序将会崩溃。</p>
<p>为了解决这个问题，我们对变换函数稍加修改，当输入值无效时，返回一个值为<code>nil</code>的<code>ListItem</code>，这比返回一个错误或无内容的<code>ListItem</code>更为合适。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> jsonItems.map &#123; <span class="function"><span class="params">(itemDesc: NSDictionary)</span> -&gt;</span> ListItem? <span class="keyword">in</span></span><br><span class="line">    guard …<span class="comment">/* condition for valid data */</span>… <span class="keyword">else</span> &#123; <span class="keyword">return</span> nil &#125;</span><br><span class="line">    <span class="keyword">let</span> realValidItem = ListItem()</span><br><span class="line">    … <span class="comment">/* fill the ListItem with the values */</span></span><br><span class="line">    <span class="keyword">return</span> realValidItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果 <code>jsonItems.map</code> 里面传入的函数参数类型为 <code>NSDictionary -&gt; ListItem?</code>，最后我们得到的是一个 <code>[ListItem?]</code> 数组，那些原来是不可用 <code>NSDictionary</code> 的位置就被我们替换成了 <code>nil</code>。比原来要好一些了，但还不够。</p>
<h1 id="使用flatMap()">使用flatMap()</h1><p>这个时候就轮到 <code>flatMap()</code> 来救场了。</p>
<p><code>flatMap()</code> 与 <code>map()</code> 相似，但 <code>flatMap()</code> 用的是 <code>T-&gt;U?</code> 变换而不是 <code>T-&gt;U</code> 转化，而且倘若变换后的数组元素值为 <code>nil</code><a href="thinking-in-swift-1/#note2"><sup>2</sup></a>，则不会被添加到最后的结果数组里面。</p>
<p>从语法上，你可以这么理解，<code>flatMap</code> 就是先使用 <code>map</code>处理数组，接着将结果数组“压平”（顾名思义)，也就是从输出数组里剔除值为<code>nil</code>的元素。</p>
<p>通过<code>flatMap</code>方法改写后的实例代码如下:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> jsonItems.flatMap &#123; (itemDesc: NSDictionary) -&gt; ListItem? <span class="keyword">in</span></span><br><span class="line">    guard <span class="keyword">let</span> title = itemDesc[<span class="string">"title"</span>] <span class="keyword">as</span>? <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">let</span> urlString = itemDesc[<span class="string">"url"</span>] <span class="keyword">as</span>? <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">let</span> url = NSURL(string: urlString)</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> nil &#125;</span><br><span class="line">    <span class="keyword">let</span> li = ListItem()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> icon = itemDesc[<span class="string">"icon"</span>] <span class="keyword">as</span>? <span class="built_in">String</span> &#123;</span><br><span class="line">        li.icon = UIImage(named: icon)</span><br><span class="line">    &#125;</span><br><span class="line">    li.title = title</span><br><span class="line">    li.url = url</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们只返回所有键都存在<a href="/thinking-in-swift-1/#note3"><sup>3</sup></a>并有效的 <code>ListItem</code>对象（保证 <code>NSURL</code>不为<code>nil</code>）。否则执行<code>guard</code>语句，返回<code>nil</code>值通知<code>flatMap</code>不要将这些无效元素添加到返回结果数组中。</p>
<p>这样做就更好更安全了，对吧？，我们解决了数据异常的问题，当有错误输入时候，避免了无效的<code>ListItem</code>项添加到数组当中。</p>
<h1 id="结论">结论</h1><p>我们仍然有很多工作要做，但是今天就先做这些吧（让我们为本系列文章的下一篇准备一下材料！）</p>
<p>在这篇文章里面，我们学到了怎么用<code>map</code>或者<code>flatMap</code>来替换掉<code>for</code>循环，确保即便输入数据是不可用的的情况下，输出数组也不会出问题。这确实已经算是很大的进步了。</p>
<p>在下一篇文章里，将介绍如何用结构体(<code>struct</code>)重写<code>ListItem</code>类有助于探索 <code>map</code> 和 <code>flatMap</code> 的其它用法 – 尤其是在处理 <code>Optionals</code> 的时候。</p>
<p>同时，希望你花点时间来深入了解一下 <code>map()</code> 和 <code>flatMap()</code> 在数组上的应用，我知道你第一次学的时候可能觉得它们很复杂，但是一旦你学会了，你什么时候都会想用它们。</p>
<p><img src="/img/articles/thinking-in-swift-2/map-everywhere.jpg1444352409.5202105" alt=""></p>
<p><a href="#note1">1</a>: 请脑补一些作秀节目的用词</p>
<p><a href="#note2">2</a>: <code>flatMap</code>还有其他一些作用。比如把一个二维数组变换为一维数组，比如，[[T]] -&gt; [T]。但是在这里，我们只需要关注在如何使用 T-&gt;U? 的变换把 [T] 变成 [U]。</p>
<p><a href="#note3">3</a>: 注意到我们的代码中，允许<code>NSDictionary</code>没有<code>icon</code>键，这意味着我们认为一个<code>ListItem</code>可以不需要有任何<code>icon</code>。但是其他键是必须的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/09/20/thinking-in-swift-2/">原文链接</a>，原文日期：2015-09-20<br>译者：<a href="http://blog.csdn.net/nsnirvana">我偏笑</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
</blockquote>
<p>在<a href="http://alisoftware.github.io/swift/2015/09/06/thinking-in-swift-1/">本系列的第一篇文章</a>中，介绍了如何避免对可选类型强制解包以及拯救“小马”🐴 。在第二部分中，我们将会精简前文代码来让它看起来更有”雨燕风”(<em>Swift-er</em> : Swift编程语言风格)，同时向你介绍 <code>map()</code> 和 <code>flatMap()</code> 方法。</p>]]>
    
    </summary>
    
      <category term="Crunchy Development" scheme="http://swiftggteam.github.io/tags/Crunchy-Development/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 iOS 9 中创建 Stack View]]></title>
    <link href="http://swiftggteam.github.io/2015/10/08/stack-view-tutorial/"/>
    <id>http://swiftggteam.github.io/2015/10/08/stack-view-tutorial/</id>
    <published>2015-10-08T01:00:00.000Z</published>
    <updated>2015-11-03T03:58:20.081Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="http://www.ioscreator.com/tutorials/stack-view-tutorial/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-14<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://www.swiftyper.com/" target="_blank" rel="external">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>在 iOS 9 之前，即使是创建相对简单的用户界面(User Interface)，也需要在使用自动布局(Auto Layout)时添加大量的约束(Constraint)。在 iOS 9 中，苹果官方引进了 Stack View，它会为每个新增的子视图自动添加自动布局的约束。在本教程中，我们会创建一个包含三个子视图的纵向 Stack View。本教程使用 Xcode 7 和 iOS 9 实现。</p>
<a id="more"></a>
<p>打开 Xcode 并创建 Single View Application，product name 填写 <strong>IO9StackViewTutorial</strong>，然后填好 Organization Name 和 Organization Identifier，Language 选择 Swift，Devices 选择 iPhone，具体设置如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=1500w1444269943.108628" alt=""></p>
<p>进入 <strong>Storyboard</strong>，从界面右下角的 Object Library 里拖一个 Label 控件到主视图的上部。双击该 Label 并设置 title 为 “Swift”。从 Object Library 再拖一个 Image View，并放在 Label 下面。点击<a href="http://www.ioscreator.com/s/Apple_Swift_Logo2x.png" target="_blank" rel="external">下载</a>这张图片，把它添加到工程。选中 Image View 点击 Attribute Inspector。在 Image View 区域的 Image 字段选择 Apple_Swift_Logo.png，同时在 View 区域的 Mode 字段选择 Aspect Fit，具体如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=750w1444269943.275595" alt=""></p>
<p>最后，再拖一个 Button，并放在 Image View 下面。双击该 Button 并设置 title 为 “Start Coding”。Storyboard 如下图所示。</p>
<p><img src="/img/articles/stack-view-tutorial/format=1500w1444269943.340582" alt=""></p>
<p>按住 Ctrl 键并选择主视图里的三个控件，点击 Storyboard 右下角的 Stack View 按钮，如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=300w1444269943.463557" alt=""></p>
<p>此时，Stack View 已经创建好了，唯一要做的事情就是设置自动布局约束(Auto Layout Constraints)。点选 Stack View 后点击 Pin 按钮，并设置 top constraint 为 50，点击”Add 1 Constraint”，如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=750w1444269943.529544" alt=""></p>
<p>点击 Align menu 按钮，并选择”Horizontally in Container”，点击”Add 1 Constraint”，如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=750w1444269943.693511" alt=""></p>
<p>按上面的步骤操作后，可能需要更新 frame，点击”Resolve Auto Layout Issues”按钮，然后再点击”Update Frames”，如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=750w1444269943.858478" alt=""></p>
<p>可以在 Stack View 里改变子视图之间的间距(spacing)。选择 Stack View 然后切换到 Attribute Inspector 选项卡，修改 Spacing 的值为 20，如下图。</p>
<p><img src="/img/articles/stack-view-tutorial/format=750w1444269943.973455" alt=""></p>
<p>编译并运行工程。在模拟器里旋转设备，可以看到 Stack View 能很好地适应不同方向。</p>
<p><img src="/img/articles/stack-view-tutorial/format=1500w1444269944.038442" alt=""></p>
<p>你可以在 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">Github</a> 下载 <strong>IO9StackViewTutorial</strong> 工程的源代码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="http://www.ioscreator.com/tutorials/stack-view-tutorial/">原文链接</a>，原文日期：2015-09-14<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://www.swiftyper.com/">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>在 iOS 9 之前，即使是创建相对简单的用户界面(User Interface)，也需要在使用自动布局(Auto Layout)时添加大量的约束(Constraint)。在 iOS 9 中，苹果官方引进了 Stack View，它会为每个新增的子视图自动添加自动布局的约束。在本教程中，我们会创建一个包含三个子视图的纵向 Stack View。本教程使用 Xcode 7 和 iOS 9 实现。</p>]]>
    
    </summary>
    
      <category term="IOSCREATOR" scheme="http://swiftggteam.github.io/tags/IOSCREATOR/"/>
    
      <category term="iOS9" scheme="http://swiftggteam.github.io/categories/iOS9/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/iOS9/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
