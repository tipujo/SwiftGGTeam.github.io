<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SwiftGG]]></title>
  <subtitle><![CDATA[走心的 Swift 翻译组]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://swiftggteam.github.io/"/>
  <updated>2015-11-20T03:44:34.802Z</updated>
  <id>http://swiftggteam.github.io/</id>
  
  <author>
    <name><![CDATA[SwiftGG]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift 中枚举高级用法及实践]]></title>
    <link href="http://swiftggteam.github.io/2015/11/20/advanced-practical-enum-examples/"/>
    <id>http://swiftggteam.github.io/2015/11/20/advanced-practical-enum-examples/</id>
    <published>2015-11-19T16:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到<a href="https://github.com/colourful987/Topic_Demo/tree/master/Advanced%20%26%20Practical%20Enum%20usage%20in%20Swift" target="_blank" rel="external">这个github地址上进行下载</a>，这个代码由翻译组的另一位小伙伴 <a href="http://blog.csdn.net/colouful987" target="_blank" rel="external">ppt</a> 提供。</p>
</blockquote>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>
<a id="more"></a>
<p>和<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">switch语句</a>类似，<code>Swift</code>中的枚举乍看之下更像是<code>C</code>语言中枚举的进阶版本，即允许你定义一种类型，用于表示普通事情中某种用例。不过深入挖掘之后，凭借<code>Swift</code>背后特别的设计理念，相比较<code>C</code>语言枚举来说其在实际场景中的应用更为广泛。特别是作为强大的工具，<code>Swift</code>中的枚举能够清晰表达代码的意图。</p>
<p>本文中，我们将首先了解基础语法和使用枚举的可能性，接着通过实战教你如何以及何时使用枚举。最后我们还会大致了解下<code>Swift</code>标准库中枚举是如何被使用的。</p>
<p>正式开始学习之前，先给出枚举的定义。之后我们将回过头再来讨论它。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<h2 id="深入理解(Diving_In)">深入理解(Diving In)</h2><p>简要概述如何定义和使用枚举。</p>
<h3 id="定义基本的枚举类型(Defining_Basic_Enums)">定义基本的枚举类型(Defining Basic Enums)</h3><p>试想我们正在开发一款游戏，玩家能够朝四个方向移动。所以喽，玩家的运动轨迹受到了限制。显然，我们能够使用枚举来表述这一情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span></span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Left</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Right</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Top</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Bottom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，你可以使用<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">多种模式匹配结构</a>获取到<code>Movement</code>的枚举值，或者按照特定情况执行操作:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aMovement = <span class="type">Movement</span>.<span class="type">Left</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 分情况处理</span></span><br><span class="line"><span class="keyword">switch</span> aMovement&#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Left</span>: <span class="built_in">print</span>(<span class="string">"left"</span>)</span><br><span class="line"><span class="keyword">default</span>:()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确的case情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Left</span> = aMovement&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"left"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> aMovement == .<span class="type">Left</span> &#123; <span class="built_in">print</span>(<span class="string">"left"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>案例中，我们无须明确指出<code>enum</code>的实际名称(即<code>case Move.Left:print(&quot;Left&quot;)</code>)。因为类型检查器能够自动为此进行类型推算。这对于那些<strong>UIKit</strong>以及<strong>AppKit</strong>中错综复杂的枚举是灰常有用的。</p>
<h3 id="枚举值(Enum_Values)">枚举值(Enum Values)</h3><p>当然，你可能想要为<code>enum</code>中每个<code>case</code>分配一个值。这相当有用，比如枚举自身实际与某事或某物挂钩时，往往这些东西又需要使用不同类型来表述。在<code>C</code>语言中，你只能为枚举<code>case</code>分配整型值，而<code>Swift</code>则提供了更多的灵活性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射到整型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样你可以与字符串一一对应</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">House</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Baratheon</span> = <span class="string">"Ours is the Fury"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Greyjoy</span> = <span class="string">"We Do Not Sow"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Martell</span> = <span class="string">"Unbowed, Unbent, Unbroken"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Stark</span> = <span class="string">"Winter is Coming"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tully</span> = <span class="string">"Family, Duty, Honor"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tyrell</span> = <span class="string">"Growing Strong"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者float double都可以(同时注意枚举中的花式unicode)</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Constants</span>: <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> π = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">case</span> e = <span class="number">2.71828</span></span><br><span class="line">    <span class="keyword">case</span> φ = <span class="number">1.61803398874</span></span><br><span class="line">    <span class="keyword">case</span> λ = <span class="number">1.30357</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>String</code>和<code>Int</code>类型来说，你甚至可以忽略为枚举中的<code>case</code>赋值，<code>Swift</code>编译器也能正常工作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mercury = 1, Venus = 2, ... Neptune = 8</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// North = "North", ... West = "West"</span></span><br><span class="line"><span class="comment">// 译者注: 这个是swift2.0新增语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Swift</code>枚举中支持以下四种关联值类型:</p>
<ul>
<li>整型(Integer)</li>
<li>浮点数(Float Point)</li>
<li>字符串(String)</li>
<li>布尔类型(Boolean)</li>
</ul>
<p>因此你无法<a href="#c1"><sup>1<sup></sup></sup></a>为枚举分配诸如<code>CGPoint</code>类型的值。</p>
<p>倘若你想要读取枚举的值，可以通过<code>rawValue</code>属性来实现:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bestHouse = <span class="type">House</span>.<span class="type">Stark</span></span><br><span class="line"><span class="built_in">print</span>(bestHouse.rawValue)</span><br><span class="line"><span class="comment">// prints "Winter is coming"</span></span><br></pre></td></tr></table></figure>
<p>不过某种情形下，你可能想要通过一个已有的<code>raw value</code>来创建一个<code>enum case</code>。这种情况下，枚举提供了一个指定构造方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个movement.Right 用例,其raw value值为1</span></span><br><span class="line"><span class="keyword">let</span> rightMovement = <span class="type">Movement</span>(rawValue: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>倘若使用<code>rawValue</code>构造器，切记它是一个可失败构造器(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID376" target="_blank" rel="external">failable initializer</a>)。换言之，构造方法返回值为<a href="http://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="external">可选类型值</a>,因为有时候传入的值可能与任意一个<code>case</code>都不匹配。比如<code>Movement(rawValue:42)</code>。</p>
<p>如果你想要以底层 C 二进制编码形式呈现某物或某事，使得更具可读性，这是一个非常有用的功能。例如，可以看一下<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/kqueue.2.html" target="_blank" rel="external">BSD kqeue library</a>中的<strong>VNode Flags</strong>标志位的编码方式:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VNodeFlags</span> : <span class="title">UInt32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Delete</span> = <span class="number">0x00000001</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Write</span> = <span class="number">0x00000002</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Extended</span> = <span class="number">0x00000004</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Attrib</span> = <span class="number">0x00000008</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Link</span> = <span class="number">0x00000010</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rename</span> = <span class="number">0x00000020</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Revoke</span> = <span class="number">0x00000040</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> = <span class="number">0x00000080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此便可以使你的<strong>Delete</strong>或<strong>Write</strong>用例声明一目了然，稍后一旦需要，只需将<strong>raw value</strong>传入 C 函数中即可。</p>
<h3 id="嵌套枚举(Nesting_Enums)">嵌套枚举(Nesting Enums)</h3><p>如果你有特定子类型的需求，可以对<code>enum</code>进行嵌套。这样就允许你为实际的<code>enum</code>中包含其他明确信息的<code>enum</code>。以<strong>RPG</strong>游戏中的每个角色为例，每个角色能够拥有武器，因此所有角色都可以获取同一个武器集合。而游戏中的其他实例则无法获取这些武器(比如食人魔,它们仅使用棍棒)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Helmet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Wooden</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Iron</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Diamond</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过层级结构来描述角色允许访问的项目条。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> character = <span class="type">Character</span>.<span class="type">Thief</span></span><br><span class="line"><span class="keyword">let</span> weapon = <span class="type">Character</span>.<span class="type">Weapon</span>.<span class="type">Bow</span></span><br><span class="line"><span class="keyword">let</span> helmet = <span class="type">Character</span>.<span class="type">Helmet</span>.<span class="type">Iron</span></span><br></pre></td></tr></table></figure>
<h3 id="包含枚举(Containing_Enums)">包含枚举(Containing Enums)</h3><p>同样地，你也能够在<code>structs</code>或<code>classes</code>中内嵌枚举。接着上面的例子:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">CharacterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> type: <span class="type">CharacterType</span></span><br><span class="line">  <span class="keyword">let</span> weapon: <span class="type">Weapon</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> warrior = <span class="type">Character</span>(type: .<span class="type">Warrior</span>, weapon: .<span class="type">Sword</span>)</span><br></pre></td></tr></table></figure>
<p>同样地，这也将有助于我们将相关的信息集中在一个位置。</p>
<h3 id="关联值(Associated_Value)">关联值(Associated Value)</h3><p>关联值是将额外信息附加到<code>enum case</code>中的一种极好的方式。打个比方，你正在开发一款交易引擎，可能存在<strong>买</strong>和<strong>卖</strong>两种不同的交易类型。除此之外每手交易还要制定明确的股票名称和交易数量:</p>
<h4 id="简单例程(Simple_Example)">简单例程(Simple Example)</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">trade</span><span class="params">(tradeType: Trade, stock: String, amount: Int)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然而股票的价值和数量显然从属于交易，让他们作为独立的参数显得模棱两可。你可能已经想到要往<code>struct</code>中内嵌一个枚举了，不过关联值提供了一种更清爽的解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">trade</span><span class="params">(type: Trade)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模式匹配(Pattern_Mathching)">模式匹配(Pattern Mathching)</h4><p>如果你想要访问这些值，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">模式匹配</a>再次救场:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> trade = <span class="type">Trade</span>.<span class="type">Buy</span>(stock: <span class="string">"APPL"</span>, amount: <span class="number">500</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Trade</span>.<span class="type">Buy</span>(stock, amount) = trade &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"buy <span class="subst">\(amount)</span> of <span class="subst">\(stock)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签(Labels)">标签(Labels)</h4><p>关联值不需要附加标签的声明:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span>(<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span>(<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若你添加了，那么，每当创建枚举用例时，你都需要将这些标签标示出来。</p>
<h4 id="(元组参数)Tuple_as_Arguments">(元组参数)Tuple as Arguments</h4><p>更重要的是,<code>Swift</code>内部相关信息其实是一个元组,所以你可以像下面这样做:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tp = (stock: <span class="string">"TSLA"</span>, amount: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> trade = <span class="type">Trade</span>.<span class="type">Sell</span>(tp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Trade</span>.<span class="type">Sell</span>(stock, amount) = trade &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"buy <span class="subst">\(amount)</span> of <span class="subst">\(stock)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints: "buy 100 of TSLA"</span></span><br></pre></td></tr></table></figure>
<p>语法允许您将元组当作一个简单的数据结构,稍后元组将自动转换到高级类型，就比如<code>enum case</code>。想象一个应用程序可以让用户来配置电脑:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Config</span> = (<span class="type">RAM</span>: <span class="type">Int</span>, <span class="type">CPU</span>: <span class="type">String</span>, <span class="type">GPU</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each of these takes a config and returns an updated config</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">selectRAM</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: <span class="number">32</span>, <span class="type">CPU</span>: config.<span class="type">CPU</span>, <span class="type">GPU</span>: config.<span class="type">GPU</span>)&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">selectCPU</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: config.<span class="type">RAM</span>, <span class="type">CPU</span>: <span class="string">"3.2GHZ"</span>, <span class="type">GPU</span>: config.<span class="type">GPU</span>)&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">selectGPU</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: config.<span class="type">RAM</span>, <span class="type">CPU</span>: <span class="string">"3.2GHZ"</span>, <span class="type">GPU</span>: <span class="string">"NVidia"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Desktop</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Cube</span>(<span class="type">Config</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Tower</span>(<span class="type">Config</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Rack</span>(<span class="type">Config</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aTower = <span class="type">Desktop</span>.<span class="type">Tower</span>(selectGPU(selectCPU(selectRAM((<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>) <span class="keyword">as</span> <span class="type">Config</span>))))</span><br></pre></td></tr></table></figure>
<p>配置的每个步骤均通过递交元组到<code>enum</code>中进行内容更新。倘若我们从<strong>函数式编程</strong><a href="#c2"><sup>2<sup></sup></sup></a>中获得启发，这将变得更好。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="generics">&lt;^&gt;</span><span class="params">(a: Config, f: <span class="params">(Config)</span></span></span> -&gt; <span class="type">Config</span>) -&gt; <span class="type">Config</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> f(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以将不同配置步骤串联起来。这在配置步骤繁多的情况下相当有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = (<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>) &lt;^&gt; selectRAM  &lt;^&gt; selectCPU &lt;^&gt; selectGPU</span><br><span class="line"><span class="keyword">let</span> aCube = <span class="type">Desktop</span>.<span class="type">Cube</span>(config)</span><br></pre></td></tr></table></figure>
<h4 id="使用案例(Use_Case_Example)">使用案例(Use Case Example)</h4><p>关联值可以以多种方式使用。常言道：一码胜千言, 下面就上几段简单的示例代码，这几段代码没有特定的顺序。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拥有不同值的用例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OpenURL</span>(url: <span class="type">NSURL</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">SwitchProcess</span>(processId: <span class="type">UInt32</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Restart</span>(time: <span class="type">NSDate</span>?, intoCommandLine: <span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你在实现一个功能强大的编辑器，这个编辑器允许多重选择，</span></span><br><span class="line"><span class="comment">// 正如 Sublime Text : https://www.youtube.com/watch?v=i2SVJa2EGIw</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Single</span>(<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Multiple</span>([<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者映射不同的标识码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(numberSystem: <span class="type">Int</span>, manufacturer: <span class="type">Int</span>, product: <span class="type">Int</span>, check: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(productCode: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者假设你在封装一个 C 语言库，正如 Kqeue BSD/Darwin 通知系统:</span></span><br><span class="line"><span class="comment">// https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KqueueEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserEvent</span>(identifier: <span class="type">UInt</span>, fflags: [<span class="type">UInt32</span>], data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReadFD</span>(fd: <span class="type">UInt</span>, data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">WriteFD</span>(fd: <span class="type">UInt</span>, data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">VnodeFD</span>(fd: <span class="type">UInt</span>, fflags: [<span class="type">UInt32</span>], data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorEvent</span>(code: <span class="type">UInt</span>, message: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后, 一个 RPG 游戏中的所有可穿戴装备可以使用一个枚举来进行映射，</span></span><br><span class="line"><span class="comment">// 可以为一个装备增加重量和持久两个属性</span></span><br><span class="line"><span class="comment">// 现在可以仅用一行代码来增加一个"钻石"属性，如此一来我们便可以增加几件新的镶嵌钻石的可穿戴装备</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Wearable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weight</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Light</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mid</span> = <span class="number">4</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Heavy</span> = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Armor</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Light</span> = <span class="number">2</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Strong</span> = <span class="number">8</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Heavy</span> = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Helmet</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Breastplate</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shield</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> woodenHelmet = <span class="type">Wearable</span>.<span class="type">Helmet</span>(weight: .<span class="type">Light</span>, armor: .<span class="type">Light</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法和属性(Methods_and_properties)">方法和属性(Methods and properties)</h3><p>你也可以在<code>enum</code>中像这样定义方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Wearable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weight</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Light</span> = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Armor</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">case</span> <span class="type">Light</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Helmet</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">()</span></span> -&gt; (weight: <span class="type">Int</span>, armor: <span class="type">Int</span>) &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	         <span class="keyword">case</span> .<span class="type">Helmet</span>(<span class="keyword">let</span> w, <span class="keyword">let</span> a): <span class="keyword">return</span> (weight: w.rawValue * <span class="number">2</span>, armor: w.rawValue * <span class="number">4</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> woodenHelmetProps = <span class="type">Wearable</span>.<span class="type">Helmet</span>(weight: .<span class="type">Light</span>, armor: .<span class="type">Light</span>).attributes()</span><br><span class="line"><span class="built_in">print</span> (woodenHelmetProps)</span><br><span class="line"><span class="comment">// prints "(2, 4)"</span></span><br></pre></td></tr></table></figure>
<p>枚举中的方法为每一个<code>enum case</code>而“生”。所以倘若想要在特定情况执行特定代码的话，你需要分支处理或采用<code>switch</code>语句来明确正确的代码路径。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> iPad, iPhone, <span class="type">AppleTV</span>, <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">introduced</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	     <span class="keyword">case</span> <span class="type">AppleTV</span>: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2006"</span></span><br><span class="line">	     <span class="keyword">case</span> iPhone: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2007"</span></span><br><span class="line">	     <span class="keyword">case</span> iPad: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2010"</span></span><br><span class="line">	     <span class="keyword">case</span> <span class="type">AppleWatch</span>: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2014"</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="type">Device</span>.iPhone.introduced())</span><br><span class="line"><span class="comment">// prints: "iPhone was introduced 2007"</span></span><br></pre></td></tr></table></figure>
<h4 id="属性(Properties)">属性(Properties)</h4><p>尽管增加一个存储属性到枚举中不被允许，但你依然能够创建计算属性。当然，计算属性的内容都是建立在枚举值下或者枚举关联值得到的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> iPad, iPhone</span><br><span class="line">  <span class="keyword">var</span> year: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	    <span class="keyword">case</span> iPhone: <span class="keyword">return</span> <span class="number">2007</span></span><br><span class="line">	    <span class="keyword">case</span> iPad: <span class="keyword">return</span> <span class="number">2010</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态方法(Static_Methods)">静态方法(Static Methods)</h4><p>你也能够为枚举创建一些静态方法(<code>static methods</code>)。换言之通过一个非枚举类型来创建一个枚举。在这个示例中,我们需要考虑用户有时将苹果设备叫错的情况(比如AppleWatch叫成iWatch)，需要返回一个合适的名称。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fromSlang</span><span class="params">(term: String)</span></span> -&gt; <span class="type">Device</span>? &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="type">Device</span>.fromSlang(<span class="string">"iWatch"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="可变方法(Mutating_Methods)">可变方法(Mutating Methods)</h4><p>方法可以声明为<code>mutating</code>。这样就允许改变隐藏参数<code>self</code>的<code>case</code>值了<a href="#c3"><sup>3<sup></sup></sup></a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">Low</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Low</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">High</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">High</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于.On</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于.Off</span></span><br></pre></td></tr></table></figure>
<h3 id="小结(To_Recap)">小结(To Recap)</h3><p>至此，我们已经大致了解了Swift中枚举语法的基本用例。在开始迈向进阶之路之前，让我们重新审视文章开篇给出的定义，看看现在是否变得更清晰了。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<p>现在我们已经对这个定义更加清晰了。确实，如果我们添加关联值和嵌套，<code>enum</code>就看起来就像一个封闭的、简化的<code>struct</code>。相比较<code>struct</code>，前者优势体现在能够为分类与层次结构编码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Struct Example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123; <span class="keyword">let</span> x: <span class="type">Int</span>, <span class="keyword">let</span> y: <span class="type">Int</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123; <span class="keyword">let</span> x: <span class="type">Int</span>, <span class="keyword">let</span> y: <span class="type">Int</span>, <span class="keyword">let</span> width: <span class="type">Int</span>, <span class="keyword">let</span> height: <span class="type">Int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum Example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GeometricEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Point</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Rect</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法和静态方法的添加允许我们为<code>enum</code>附加功能，这意味着无须依靠额外函数就能实现<a href="#c4"><sup>4<sup></sup></sup></a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C-Like example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">order</span><span class="params">(trade: Trade)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift Enum example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">order</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举进阶(Advanced_Enum_Usage）">枚举进阶(Advanced Enum Usage）</h2><h3 id="协议(Protocols)">协议(Protocols)</h3><p>我已经提及了<code>structs</code>和<code>enums</code>之间的相似性。除了附加方法的能力之外，<code>Swift</code>也允许你在枚举中使用<strong>协议(Protocols)</strong>和<strong>协议扩展(Protocol Extension)</strong>。</p>
<p><code>Swift</code>协议定义一个接口或类型以供其他数据结构来遵循。<code>enum</code>当然也不例外。我们先从<code>Swift</code>标准库中的一个例子开始.</p>
<p><code>CustomStringConvertible</code>是一个以打印为目的的自定义格式化输出的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该协议只有一个要求，即一个只读(<code>getter</code>)类型的字符串(<code>String</code>类型)。我们可以很容易为<code>enum</code>实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span>, <span class="type">Sell</span></span><br><span class="line">   <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> <span class="type">Buy</span>: <span class="keyword">return</span> <span class="string">"We're buying something"</span></span><br><span class="line">	   <span class="keyword">case</span> <span class="type">Sell</span>: <span class="keyword">return</span> <span class="string">"We're selling something"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> action = <span class="type">Trade</span>.<span class="type">Buy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"this action is <span class="subst">\(action)</span>"</span>)</span><br><span class="line"><span class="comment">// prints: this action is We're buying something</span></span><br></pre></td></tr></table></figure>
<p>一些协议的实现可能需要根据内部状态来相应处理要求。例如定义一个管理银行账号的协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AccountCompatible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> remainingFunds: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">addFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">removeFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会简单地拿<code>struct</code>实现这个协议，但是考虑应用的上下文，<code>enum</code>是一个更明智的处理方法。不过你无法添加一个存储属性到<code>enum</code>中，就像<code>var remainingFuns:Int</code>。那么你会如何构造呢？答案灰常简单，你可以使用关联值完美解决:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Funds</span>(remaining: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overdraft</span>(amount: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> remainingFunds: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Funds</span>(<span class="keyword">let</span> remaining): <span class="keyword">return</span> remaining</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保持代码清爽，我们可以在<code>enum</code>的协议扩展(<code>protocl extension</code>)中定义必须的协议函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Account</span>: <span class="title">AccountCompatible</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">addFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newAmount = amount</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Funds</span>(remaining) = <span class="keyword">self</span> &#123;</span><br><span class="line">      newAmount += remaining</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> newAmount &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">Error</span>.<span class="type">Overdraft</span>(amount: -newAmount)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> newAmount == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .<span class="type">Empty</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .<span class="type">Funds</span>(remaining: newAmount)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">removeFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">self</span>.addFunds(amount * -<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> account = <span class="type">Account</span>.<span class="type">Funds</span>(remaining: <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"add: "</span>, <span class="keyword">try</span>? account.addFunds(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"remove 1: "</span>, <span class="keyword">try</span>? account.removeFunds(<span class="number">15</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"remove 2: "</span>, <span class="keyword">try</span>? account.removeFunds(<span class="number">55</span>))</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// : add:  Optional(())</span></span><br><span class="line"><span class="comment">// : remove 1:  Optional(())</span></span><br><span class="line"><span class="comment">// : remove 2:  nil</span></span><br></pre></td></tr></table></figure>
<p>正如你所看见的，我们通过将值存储到<code>enum cases</code>中实现了协议所有要求项。如此做法还有一个妙不可言的地方:现在整个代码基础上你只需要一个模式匹配就能测试空账号输入的情况。你不需要关心剩余资金是否等于零。</p>
<p>同时，我们也在<strong>账号(Accout)</strong>中内嵌了一个遵循<code>ErrorType</code>协议的枚举，这样我们就可以使用<code>Swift2.0</code>语法来进行错误处理了。这里给出更详细的<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/#errortype" target="_blank" rel="external">使用案例</a>教程。</p>
<h3 id="扩展(Extensions)">扩展(Extensions)</h3><p>正如刚才所见，枚举也可以进行扩展。最明显的用例就是将枚举的<code>case</code>和<code>method</code>分离，这样阅读你的代码能够简单快速地消化掉<code>enum</code>内容，紧接着转移到方法定义:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Soldier</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tank</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Player</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们为<code>enum</code>扩展方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">move</span><span class="params">(dist: CGVector)</span></span> &#123;&#125;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">attack</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你同样可以通过写一个扩展来遵循一个特定的协议:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entities</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Soldier</span>(x, y): <span class="keyword">return</span> <span class="string">"<span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span></span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Tank</span>(x, y): <span class="keyword">return</span> <span class="string">"<span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span></span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Player</span>(x, y): <span class="keyword">return</span> <span class="string">"<span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举泛型(Generic_Enums)">枚举泛型(Generic Enums)</h3><p>枚举也支持泛型参数定义。你可以使用它们以适应枚举中的关联值。就拿直接来自<code>Swift</code>标准库中的简单例子来说，即<code>Optional</code>类型。你主要可能通过以下几种方式使用它:可选链(<code>optional chaining(?)</code>)、<code>if-let</code>可选绑定、<code>guard let</code>、或<code>switch</code>，但是从语法角度来说你也可以这么使用<code>Optional</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aValue = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Some</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> noValue = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">None</span></span><br><span class="line"><span class="keyword">if</span> noValue == <span class="type">Optional</span>.<span class="type">None</span> &#123; <span class="built_in">print</span>(<span class="string">"No value"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这是<code>Optional</code>最直接的用例，并未使用任何语法糖，但是不可否认<code>Swift</code>中语法糖的加入使得你的工作更简单。如果你观察上面的实例代码，你恐怕已经猜到<code>Optional</code>内部实现是这样的<a href="#c5"><sup>5<sup></sup></sup></a>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simplified implementation of Swift's Optional</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyOptional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有啥特别呢？注意枚举的关联值采用泛型参数<code>T</code>作为自身类型，这样可选类型构造任何你想要的返回值。</p>
<p>枚举可以拥有多个泛型参数。就拿熟知的<code>Either</code>类为例，它并非是<code>Swift</code>标准库中的一部分，而是实现于众多开源库以及<br>其他函数式编程语言，比如<strong>Haskell</strong>或<strong>F#</strong>。设计想法是这样的:相比较仅仅返回一个值或没有值(née Optional)，你更期望返回一个成功值或者一些反馈信息(比如错误值)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The well-known either type is, of course, an enum that allows you to return either</span></span><br><span class="line"><span class="comment">// value one (say, a successful value) or value two (say an error) from a function</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Either</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Left</span>(<span class="type">T1</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Right</span>(<span class="type">T2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<code>Swift</code>中所有在<code>class</code>和<code>struct</code>中奏效的类型约束，在<code>enum</code>中同样适用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Totally nonsensical example. A bag that is either full (has an array with contents)</span></span><br><span class="line"><span class="comment">// or empty.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Bag</span>&lt;<span class="title">T</span>: <span class="title">SequenceType</span> <span class="title">where</span> <span class="title">T</span>.<span class="title">Generator</span>.<span class="title">Element</span>==<span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Full</span>(contents: <span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归_/_间接(Indirect)类型">递归 / 间接(Indirect)类型</h3><p>间接类型是 Swift 2.0 新增的一个类型。 它们允许将枚举中一个 case 的关联值再次定义为枚举。举个例子，假设我们想定义一个文件系统，用来表示文件以及包含文件的目录。如果将<em>文件</em>和<em>目录</em>定义为枚举的 case，则<em>目录</em> case 的关联值应该再包含一个<em>文件</em>的数组作为它的关联值。因为这是一个递归的操作，编译器需要对此进行一个特殊的准备。Swift 文档中是这么写的：</p>
<blockquote>
<p>枚举和 case 可以被标记为间接的(indrect)，这意味它们的关联值是被间接保存的，这允许我们定义递归的数据结构。</p>
</blockquote>
<p>所以，如果我们要定义 <code>FileNode</code> 的枚举，它应该会是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FileNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">File</span>(name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Folder</span>(name: <span class="type">String</span>, files: [<span class="type">FileNode</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 <code>indrect</code> 关键字告诉编译器间接地处理这个枚举的 case。也可以对整个枚举类型使用这个关键字。<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="external">作为例子，我们来定义一个二叉树</a>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">Tree</span>&lt;<span class="title">Element</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">Tree</span>&lt;<span class="type">Element</span>&gt;,<span class="type">Element</span>,<span class="type">Tree</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很强大的特性，可以让我们用非常简洁的方式来定义一个有着复杂关联的数据结构。</p>
<h3 id="使用自定义类型作为枚举的值">使用自定义类型作为枚举的值</h3><p>如果我们忽略关联值，则枚举的值就只能是整型，浮点型，字符串和布尔类型。如果想要支持别的类型，则可以通过实现 <code>StringLiteralConvertible</code> 协议来完成，这可以让我们通过对字符串的序列化和反序列化来使枚举支持自定义类型。</p>
<p>作为一个例子，假设我们要定义一个枚举来保存不同的 iOS 设备的屏幕尺寸：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: <span class="title">CGSize</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> iPhone3GS = <span class="type">CGSize</span>(width: <span class="number">320</span>, height: <span class="number">480</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone5 = <span class="type">CGSize</span>(width: <span class="number">320</span>, height: <span class="number">568</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone6 = <span class="type">CGSize</span>(width: <span class="number">375</span>, height: <span class="number">667</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone6Plus = <span class="type">CGSize</span>(width: <span class="number">414</span>, height: <span class="number">736</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这段代码不能通过编译。因为 CGPoint 并不是一个常量，不能用来定义枚举的值。我们需要为想要支持的自定义类型增加一个扩展，让其实现 <code>StringLiteralConvertible</code> 协议。这个协议要求我们实现三个<em>构造方法</em>，这三个方法都需要使用一个<code>String</code>类型的参数，并且我们需要将这个字符串转换成我们需要的类型(此处是<code>CGSize</code>)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">StringLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以来实现我们需要的枚举了，不过这里有一个缺点：初始化的值必须写成字符串形式，因为这就是我们定义的枚举需要接受的类型(记住，我们实现了 StringLiteralConvertible，因此<strong>String</strong>可以转化成<code>CGSize</code>类型)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: <span class="title">CGSize</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> iPhone3GS = <span class="string">"&#123;320, 480&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone5 = <span class="string">"&#123;320, 568&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone6 = <span class="string">"&#123;375, 667&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone6Plus = <span class="string">"&#123;414, 736&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，我们可以使用 CGPoint 类型的枚举了。需要注意的是，当要获取真实的 CGPoint 的值的时候，我们需要访问枚举的是 <code>rawValue</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Devices</span>.iPhone5</span><br><span class="line"><span class="keyword">let</span> b = a.rawValue</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the phone size string is <span class="subst">\(a)</span>, width is <span class="subst">\(b.width)</span>, height is <span class="subst">\(b.height)</span>"</span>)</span><br><span class="line"><span class="comment">// prints : the phone size string is iPhone5, width is 320.0, height is 568.0</span></span><br></pre></td></tr></table></figure>
<p>使用字符串序列化的形式，会让使用自定义类型的枚举比较困难，然而在某些特定的情况下，这也会给我们增加不少便利(比较使用<strong>NSColor</strong> / <strong>UIColor</strong>的时候)。不仅如此，我们完全可以对自己定义的类型使用这个方法。</p>
<h3 id="对枚举的关联值进行比较">对枚举的关联值进行比较</h3><p>在通常情况下，枚举是很容易进行相等性判断的。一个简单的 <code>enum T { case a, b }</code> 实现默认支持相等性判断 <code>T.a == T.b, T.b != T.a</code></p>
<p>然而，一旦我们为枚举增加了关联值，Swift 就没有办法正确地为两个枚举进行相等性判断，需要我们自己实现 <code>==</code> 运行符。这并不是很困难：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> ==<span class="params">(lhs: Trade, rhs: Trade)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Buy</span>(stock1, amount1), .<span class="type">Buy</span>(stock2, amount2))</span><br><span class="line">	   <span class="keyword">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Sell</span>(stock1, amount1), .<span class="type">Sell</span>(stock2, amount2))</span><br><span class="line">	   <span class="keyword">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，我们通过 switch 语句对两个枚举的 case 进行判断，并且只有当它们的 case 是匹配的时候(比如 Buy 和 Buy)才对它们的真实关联值进行判断。</p>
<h3 id="自定义构造方法">自定义构造方法</h3><p>在 <strong>静态方法</strong> 一节当中我们已经提到它们可以作为从不同数据构造枚举的方便形式。在之前的例子里也展示过，对出版社经常误用的苹果设备名返回正确的名字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fromSlang</span><span class="params">(term: String)</span></span> -&gt; <span class="type">Device</span>? &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用自定义构造方法来替换静态方法。枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 <code>self</code>  属性设置为正确的 case。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">init</span>?(term: <span class="type">String</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">self</span> = .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了可失败(failable)的构造方法。但是，普通的构造方法也可以工作得很好：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NumberCategory</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Small</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Medium</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Big</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Huge</span></span><br><span class="line">   <span class="keyword">init</span>(number n: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">10000</span> &#123; <span class="keyword">self</span> = .<span class="type">Small</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">1000000</span> &#123; <span class="keyword">self</span> = .<span class="type">Medium</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">100000000</span> &#123; <span class="keyword">self</span> = .<span class="type">Big</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="keyword">self</span> = .<span class="type">Huge</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aNumber = <span class="type">NumberCategory</span>(number: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(aNumber)</span><br><span class="line"><span class="comment">// prints: "Small"</span></span><br></pre></td></tr></table></figure>
<h3 id="对枚举的_case_进行迭代">对枚举的 case 进行迭代</h3><p>一个特别经常被问到的问题就是如何对枚举中的 case 进行迭代。可惜的是，枚举并没有遵守<code>SequenceType</code>协议，因此没有一个官方的做法来对其进行迭代。取决于枚举的类型，对其进行迭代可能也简单，也有可能很困难。在<a href="http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type" target="_blank" rel="external">StackOverflow</a>上有一个很好的讨论贴。贴子里面讨论到的不同情况太多了，如果只在这里摘取一些会有片面性，而如果将全部情况都列出来，则会太多。</p>
<h3 id="对_Objective-C_的支持">对 Objective-C 的支持</h3><p>基于整型的枚举，如 <code>enum Bit: Int { case Zero = 0; case One = 1 }</code> 可以通过 <code>@objc</code> 标识来将其桥接到 Objective-C 当中。然而，一旦使用整型之外的类型(如 <code>String</code>)或者开始使用<strong>关联值</strong>，我们就无法在 Objective-C 当中使用这些枚举了。</p>
<p>有一个名为<a href="http://nshint.io/blog/2015/10/07/easy-cast-with-_ObjectiveCBridgeable/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_11" target="_blank" rel="external">_ObjectiveCBridgeable的隐藏协议</a>，可以让规范我们以定义合适的方法，如此一来，Swift 便可以正确地将枚举转成 Objective-C 类型，但我猜这个协议被隐藏起来一定是有原因的。然而，从理论上来讲，这个协议还是允许我们将枚举(包括其实枚举值)正确地桥接到 Objective-C 当中。</p>
<p>但是，我们并不一定非要使用上面提到的这个方法。为枚举添加两个方法，使用 <code>@objc</code> 定义一个替代类型，如此一来我们便可以自由地将枚举进行转换了，并且这种方式不需要遵守私有协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型也可以定义在 Objective-C 的代码中</span></span><br><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">OTrade</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> stock: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(type: <span class="type">Int</span>, stock: <span class="type">String</span>, amount: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span>.type = type</span><br><span class="line">	<span class="keyword">self</span>.stock = stock</span><br><span class="line">	<span class="keyword">self</span>.amount = amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Trade</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">toObjc</span><span class="params">()</span></span> -&gt; <span class="type">OTrade</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount):</span><br><span class="line">	    <span class="keyword">return</span> <span class="type">OTrade</span>(type: <span class="number">0</span>, stock: stock, amount: amount)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount):</span><br><span class="line">	    <span class="keyword">return</span> <span class="type">OTrade</span>(type: <span class="number">1</span>, stock: stock, amount: amount)</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fromObjc</span><span class="params">(source: OTrade)</span></span> -&gt; <span class="type">Trade</span>? &#123;</span><br><span class="line">	<span class="keyword">switch</span> (source.type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="type">Trade</span>.<span class="type">Buy</span>(stock: source.stock, amount: source.amount)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="type">Trade</span>.<span class="type">Sell</span>(stock: source.stock, amount: source.amount)</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有一个的缺点，我们需要将枚举映射为 Objective-C 中的 <code>NSObject</code> 基础类型(我们也可以直接使用 <code>NSDictionary</code>)，但是，当我们碰到一些确实<strong>需要</strong>在 Objective-C 当中获取有关联值的枚举时，这是一个可以使用的方法。</p>
<h3 id="枚举底层">枚举底层</h3><p>Erica Sadun 写过一篇很流弊的<a href="http://ericasadun.com/2015/07/12/swift-enumerations-or-how-to-annoy-tom/" target="_blank" rel="external">关于枚举底层的博客</a>，涉及到枚举底层的方方面面。在生产代码中绝不应该使用到这些东西，但是学习一下还是相当有趣的。在这里，我准备只提到那篇博客中一条，如果想了解更多，请移步到原文：</p>
<blockquote>
<p>枚举通常都是一个字节长度。[…]如果你真的很傻很天真，你当然可以定义一个有成百上千个 case 的枚举，在这种情况下，取决于最少所需要的比特数，枚举可能占据两个字节或者更多。</p>
</blockquote>
<h2 id="Swift_标准库中的枚举">Swift 标准库中的枚举</h2><p>在我们准备继续探索枚举在项目中的不同用例之前，先看一下在 Swift 标准库当中是如何使用枚举可能会更诱人，所以现在让我们先来看看。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit" target="_blank" rel="external">Bit</a> 这个枚举有两个值，<strong>One</strong> 和 <strong>Zero</strong>。它被作为 <code>CollectionOfOne&lt;T&gt;</code> 中的 <code>Index</code> 类型。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_" target="_blank" rel="external">FloatingPointClassification</a> 这个枚举定义了一系列 IEEE 754 可能的类别，比如 <code>NegativeInfinity</code>, <code>PositiveZero</code> 或 <code>SignalingNaN</code>。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation" target="_blank" rel="external">Mirror.AncestorRepresentation</a> 和 <a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle" target="_blank" rel="external">Mirror.DisplayStyle</a> 这两个枚举被用在 Swift 反射 API 的上下文当中。</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq" target="_blank" rel="external">Optional</a> 这个就不用多说了</p>
<p><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process" target="_blank" rel="external">Process</a> 这个枚举包含了当前进程的命令行参数(<code>Process.argc</code>, <code>Process.arguments</code>)。这是一个相当有趣的枚举类型，因为在 Swift 1.0 当中，它是被作为一个结构体来实现的。</p>
<h2 id="实践用例">实践用例</h2><p>我们已经在前面几个小节当中看过了许多有用的枚举类型。包括 <code>Optional</code>，<code>Either</code>, <code>FileNode</code> 还有二叉树。然而，还存在很多场合，使用枚举要胜过使用结构体和类。一般来讲，如果问题可以被分解为有限的不同类别，则使用枚举应该就是正确的选择。即使只有两种 case，这也是一个使用枚举的完美场景，正如 Optional 和 Either 类型所展示的。</p>
<p>以下列举了一些枚举类型在实战中的使用示例，可以用来点燃你的创造力。</p>
<h3 id="错误处理">错误处理</h3><p>说到枚举的实践使用，当然少不了在 Swift 2.0 当中新推出的错误处理。标记为可抛出的函数可以抛出任何遵守了 <code>ErrorType</code> 空协议的类型。正如 Swift 官方文档中所写的：</p>
<blockquote>
<p>Swift 的枚举特别适用于构建一组相关的错误状态，可以通过关联值来为其增加额外的附加信息。</p>
</blockquote>
<p>作为一个示例，我们来看下流行的<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="external">JSON解析框架 Argo</a>。当 JSON 解析失败的时候，它有可能是以下两种主要原因：</p>
<ol>
<li>JSON 数据缺少某些最终模型所需要的键(比如你的模型有一个 <code>username</code> 的属性，但是 JSON 中缺少了)</li>
<li>存在类型不匹配，比如说 <code>username</code> 需要的是 String 类型，而 JSON 中包含的是 <code>NSNull</code><a href="#c6"><sup>6</sup></a>。</li>
</ol>
<p>除此之外，Argo 还为不包含在上述两个类别中的错误提供了自定义错误。它们的 <code>ErrorType</code> 枚举是类似这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DecodeError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TypeMismatch</span>(expected: <span class="type">String</span>, actual: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MissingKey</span>(<span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Custom</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 case 都有一个关联值用来包含关于错误的附加信息。</p>
<p>一个更加通用的用于完整 HTTP / REST API 错误处理的<code>ErrorType</code>应该是类似这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">APIError</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Can't connect to the server (maybe offline?)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ConnectionError</span>(error: <span class="type">NSError</span>)</span><br><span class="line">    <span class="comment">// The server responded with a non 200 status code</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ServerError</span>(statusCode: <span class="type">Int</span>, error: <span class="type">NSError</span>)</span><br><span class="line">    <span class="comment">// We got no data (0 bytes) back from the server</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoDataError</span></span><br><span class="line">    <span class="comment">// The server response can't be converted from JSON to a Dictionary</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONSerializationError</span>(error: <span class="type">ErrorType</span>)</span><br><span class="line">    <span class="comment">// The Argo decoding Failed</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONMappingError</span>(converstionError: <span class="type">DecodeError</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>ErrorType</code> 实现了完整的 REST 程序栈解析有可能出现的错误，包含了所有在解析结构体与类时会出现的错误。</p>
<p>如果你看得够仔细，会发现在<code>JSONMappingError</code>中，我们将<strong>Argo</strong>中的<code>DecodeError</code>封装到了我们的<code>APIError</code>类型当中，因为我们会用 Argo 来作实际的 JSON 解析。</p>
<p>更多关于<code>ErrorType</code>以及此种枚举类型的示例可以参看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="观察者模式">观察者模式</h3><p>在 Swift 当中，有许多方法来构建观察模式。如果使用 <code>@objc</code> 兼容标记，则我们可以使用 <code>NSNotificationCenter</code> 或者 <strong>KVO</strong>。即使不用这个标记，<code>didSet</code>语法也可以很容易地实现简单的观察模式。在这里可以使用枚举，它可以使被观察者的变化更加清晰明了。设想我们要对一个集合进行观察。如果我们稍微思考一下就会发现这只有几种可能的情况：一个或多个项被插入，一个或多个项被删除，一个或多个项被更新。这听起来就是枚举可以完成的工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Insertion</span>(items: [<span class="type">Item</span>])</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Deletion</span>(items: [<span class="type">Item</span>])</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Update</span>(items: [<span class="type">Item</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，观察对象就可以使用一个很简洁的方式来获取已经发生的事情的详细信息。这也可以通过为其增加 <strong>oldValue</strong> 和 <strong>newValue</strong> 的简单方法来扩展它的功能。</p>
<h3 id="状态码">状态码</h3><p>如果我们正在使用一个外部系统，而这个系统使用了状态码(或者错误码)来传递错误信息，类似 HTTP 状态码，这种情况下枚举就是一种很明显并且很好的方式来对信息进行封装<a href="#c7"><sup>7</sup></a> 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HttpError</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code400</span> = <span class="string">"Bad Request"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code401</span> = <span class="string">"Unauthorized"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code402</span> = <span class="string">"Payment Required"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code403</span> = <span class="string">"Forbidden"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code404</span> = <span class="string">"Not Found"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果类型映射(Map_Result_Types)">结果类型映射(Map Result Types)</h3><p>枚举也经常被用于将 JSON 解析后的结果映射成 Swift 的原生类型。这里有一个简短的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONString</span>(<span class="type">Swift</span>.<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONNumber</span>(<span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONObject</span>([<span class="type">String</span> : <span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONArray</span>([<span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONBool</span>(<span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONNull</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，如果我们解析了其它的东西，也可以使用这种方式将解析结果转化我们 Swift 的类型。</p>
<h3 id="UIKit_标识">UIKit 标识</h3><p>枚举可以用来将字符串类型的重用标识或者 storyboard 标识映射为类型系统可以进行检查的类型。假设我们有一个拥有很多原型 Cell 的 UITableView：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CellType</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ButtonValueCell</span> = <span class="string">"ButtonValueCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnitEditCell</span> = <span class="string">"UnitEditCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LabelCell</span> = <span class="string">"LabelCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ResultLabelCell</span> = <span class="string">"ResultLabelCell"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单位">单位</h3><p>单位以及单位转换是另一个使用枚举的绝佳场合。可以将单位及其对应的转换率映射起来，然后添加方法来对单位进行自动的转换。以下是一个相当简单的示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Liquid</span>: <span class="title">Float</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> ml = <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">case</span> l = <span class="number">1000.0</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(amount amount: Float, to: Liquid)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.rawValue &lt; to.rawValue &#123;</span><br><span class="line">	 <span class="keyword">return</span> (<span class="keyword">self</span>.rawValue / to.rawValue) * amount</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="keyword">return</span> (<span class="keyword">self</span>.rawValue * to.rawValue) * amount</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Convert liters to milliliters</span></span><br><span class="line"><span class="built_in">print</span> (<span class="type">Liquid</span>.l.convert(amount: <span class="number">5</span>, to: <span class="type">Liquid</span>.ml))</span><br></pre></td></tr></table></figure>
<p>另一个示例是货币的转换。以及数学符号(比如角度与弧度)也可以从中受益。</p>
<h3 id="游戏">游戏</h3><p>游戏也是枚举中的另一个相当好的用例，屏幕上的大多数实体都属于一个特定种族的类型(敌人，障碍，纹理，…)。相对于本地的 iOS 或者 Mac 应用，游戏更像是一个白板。即开发游戏我们可以使用全新的对象以及全新的关联创造一个全新的世界，而 iOS 或者 OSX 需要使用预定义的 UIButtons，UITableViews，UITableViewCells 或者 NSStackView.</p>
<p>不仅如此，由于枚举可以遵守协议，我们可以利用协议扩展和基于协议的编程为不同为游戏定义的枚举增加功能。这里是一个用来展示这种层级的的简短示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FlyingBeast</span> </span>&#123; <span class="keyword">case</span> <span class="type">Dragon</span>, <span class="type">Hippogriff</span>, <span class="type">Gargoyle</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Horde</span> </span>&#123; <span class="keyword">case</span> <span class="type">Ork</span>, <span class="type">Troll</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Player</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mage</span>, <span class="type">Warrior</span>, <span class="type">Barbarian</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NPC</span> </span>&#123; <span class="keyword">case</span> <span class="type">Vendor</span>, <span class="type">Blacksmith</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Element</span> </span>&#123; <span class="keyword">case</span> <span class="type">Tree</span>, <span class="type">Fence</span>, <span class="type">Stone</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Hurtable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Killable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flying</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Obstacle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FlyingBeast</span>: <span class="title">Hurtable</span>, <span class="title">Killable</span>, <span class="title">Flying</span>, <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Horde</span>: <span class="title">Hurtable</span>, <span class="title">Killable</span>, <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Player</span>: <span class="title">Hurtable</span>, <span class="title">Obstacle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NPC</span>: <span class="title">Hurtable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Element</span>: <span class="title">Obstacle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串类型化">字符串类型化</h3><p>在一个稍微大一点的 Xcode 项目中，我们很快就会有一大堆通过字符串来访问的资源。在前面的小节中，我们已经提过重用标识和 storyboard 的标识，但是除了这两样，还存在很多资源：图像，Segues，Nibs，字体以及其它资源。通常情况下，这些资源都可以分成不同的集合。如果是这样的话，一个类型化的字符串会是一个让编译器帮我们进行类型检查的好方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DetailViewImages</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Background</span> = <span class="string">"bg1.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sidebar</span> = <span class="string">"sbg.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ActionButton1</span> = <span class="string">"btn1_1.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ActionButton2</span> = <span class="string">"btn2_1.png"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 iOS 开发者，<a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="external">R.swift</a>这个第三方库可以为以上提到的情况自动生成结构体。但是有些时候你可能需要有更多的控制(或者你可能是一个Mac开发者<a href="#c8"><sup>8</sup></a>)。</p>
<h3 id="API_端点">API 端点</h3><p>Rest API 是枚举的绝佳用例。它们都是分组的，它们都是有限的 API 集合，并且它们也可能会有附加的查询或者命名的参数，而这可以使用关联值来实现。</p>
<p>这里有个 <a href="https://instagram.com/developer/endpoints/media/" target="_blank" rel="external">Instagram API</a> 的简化版：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Instagram</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Media</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Popular</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shortcode</span>(id: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Search</span>(lat: <span class="type">Float</span>, min_timestamp: <span class="type">Int</span>, lng: <span class="type">Float</span>, max_timestamp: <span class="type">Int</span>, <span class="built_in">distance</span>: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">User</span>(id: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Feed</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Recent</span>(id: <span class="type">String</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Moya/Moya" target="_blank" rel="external">Ash Furrow的<strong>Moya</strong>框架</a>就是基本这个思想，使用枚举对 rest 端点进行映射。</p>
<h3 id="链表">链表</h3><p>Airspeed Velocity有一篇<a href="http://airspeedvelocity.net/tag/swift/" target="_blank" rel="external">极好的文章</a>说明了如何使用枚举来实现一个链表。那篇文章中的大多数代码都超出了枚举的知识，并涉及到了大量其它有趣的主题<a href="#c9"><sup>9</sup></a>，但是，链表最基本的定义是类似这样的(我对其进行了一些简化)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">End</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">Int</span>, next: <span class="type">List</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个节点(Node) case 都指向了下一个 case， 通过使用枚举而非其它类型，我们可以避免使用一个可选的 next 类型以用来表示链表的结束。</p>
<p>Airspeed Velocity 还写过一篇超赞的博客，关于如何使用 Swift 的间接枚举类型来实现红黑树，所以如果你已经阅读过关于链表的博客，你可能想继续阅读<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="external">这篇关于红黑树的博客</a>。</p>
<h3 id="设置字典(Setting_Dictionaries)">设置字典(Setting Dictionaries)</h3><p>这是 Erica Sadun 提出的<a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="external">非常非常机智的解决方案</a>。简单来讲，就是任何我们需要用一个属性的字典来对一个项进行设置的时候，都应该使用一系列有关联值的枚举来替代。使用这方法，类型检查系统可以确保配置的值都是正确的类型。</p>
<p><a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="external">关于更多的细节，以及合适的例子，可以阅读下她的文章</a>。</p>
<h2 id="局限">局限</h2><p>与之前类似，我将会用一系列枚举的局限性来结束本篇文章。</p>
<h3 id="提取关联值">提取关联值</h3><p>David Owens写过一篇<a href="http://owensd.io/2015/09/15/associated-enum-cases-as-types.html" target="_blank" rel="external">文章</a>，他觉得当前的关联值提取方式是很笨重的。我墙裂推荐你去看一下他的原文，在这里我对它的要旨进行下说明：为了从一个枚举中获取关联值，我们必须使用模式匹配。然而，关联值就是关联在特定枚举 case 的高效元组。而元组是可以使用更简单的方式来获取它内部值，即 <code>.keyword 或者 .0</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enums</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ex</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mode</span>(ab: <span class="type">Int</span>, cd: <span class="type">Int</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="type">Ex</span>.<span class="type">Mode</span>(<span class="keyword">let</span> ab, <span class="keyword">let</span> cd) = <span class="type">Ex</span>.<span class="type">Mode</span>(ab: <span class="number">4</span>, cd: <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ab)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vs tuples:</span></span><br><span class="line"><span class="keyword">let</span> tp = (ab: <span class="number">4</span>, cd: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tp.ab)</span><br></pre></td></tr></table></figure>
<p>如果你也同样觉得我们应该使用相同的方法来对枚举进行解构(deconstruct)，这里有个 rdar: <a href="http://openradar.me/22704262" target="_blank" rel="external">rdar://22704262</a> (译者注：一开始我不明白 rdar 是啥意思，后来我 google 了下，如果你也有兴趣，也可以自己去搜索一下)</p>
<h3 id="相等性">相等性</h3><p>拥有关联值的枚举没有遵守 <code>equatable</code> 协议。这是一个遗憾，因为它为很多事情增加了不必要的复杂和麻烦。深层的原因可能是因为关联值的底层使用是使用了元组，而元组并没有遵守 <code>equatable</code> 协议。然而，对于限定的 case 子集，如果这些关联值的类型都遵守了 <code>equatable</code> 类型，我认为编译器应该默认为其生成 <code>equatable</code> 扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int 和 String 是可判等的, 所以 Mode 应该也是可判等的</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ex</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mode</span>(ab: <span class="type">Int</span>, cd: <span class="type">String</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 应该能够自动生成这个函数</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> == <span class="params">(lhs: Ex.Mode, rhs: Ex.Mode)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">       <span class="keyword">case</span> (.<span class="type">Mode</span>(<span class="keyword">let</span> a, <span class="keyword">let</span> b), .<span class="type">Mode</span>(<span class="keyword">let</span> <span class="built_in">c</span>, <span class="keyword">let</span> d)):</span><br><span class="line">	   <span class="keyword">return</span> a == <span class="built_in">c</span> &amp;&amp; b == d</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元组(Tuples)">元组(Tuples)</h3><p>最大的问题就是对<a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="external">元组的支持</a>。我喜欢使用元组，它们可以使很多事情变得更简单，但是他们目前还处于无文档状态并且在很多场合都无法使用。在枚举当中，我们无法使用元组作为枚举的值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: (<span class="title">intro</span>: <span class="title">Int</span>, <span class="title">name</span>: <span class="title">String</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> iPhone = (intro: <span class="number">2007</span>, name: <span class="string">"iPhone"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AppleTV</span> = (intro: <span class="number">2006</span>, name: <span class="string">"Apple TV"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AppleWatch</span> = (intro: <span class="number">2014</span>, name: <span class="string">"Apple Watch"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这似乎看起来并不是一个最好的示例，但是我们一旦开始使用枚举，就会经常陷入到需要用到类似上面这个示例的情形中。</p>
<h3 id="迭代枚举的所有case">迭代枚举的所有case</h3><p>这个我们已经在前面讨论过了。目前还没有一个很好的方法来获得枚举中的所有 case 的集合以使我们可以对其进行迭代。</p>
<h3 id="默认关联值">默认关联值</h3><p>另一个会碰到的事是枚举的关联值总是类型，但是我们却无法为这些类型指定默认值。假设有这样一种情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Characters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Mage</span>(health: <span class="type">Int</span> = <span class="number">70</span>, magic: <span class="type">Int</span> = <span class="number">100</span>, strength: <span class="type">Int</span> = <span class="number">30</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Warrior</span>(health: <span class="type">Int</span> = <span class="number">100</span>, magic: <span class="type">Int</span> = <span class="number">0</span>, strength: <span class="type">Int</span> = <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Neophyte</span>(health: <span class="type">Int</span> = <span class="number">50</span>, magic: <span class="type">Int</span> = <span class="number">20</span>, strength: <span class="type">Int</span> = <span class="number">80</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然可以使用不同的值创建新的 case，但是角色的默认设置依然会被映射。</p>
<h2 id="变化">变化</h2><h3 id="10/26/2015">10/26/2015</h3><ul>
<li>增加局限性示例(相等性 &amp; 获取关联值)</li>
<li>增加 Erica Sadun 的关联枚举示例</li>
</ul>
<h3 id="10/22/2015">10/22/2015</h3><ul>
<li>合并<a href="https://github.com/terhechte/appventure-blog/pull/6" target="_blank" rel="external">来自 #6 @mabidakun</a>的PR</li>
<li>增加枚举底层的链接</li>
<li>将帐号示例拆分为两个更容易理解的片段。</li>
</ul>
<h3 id="10/21/2015">10/21/2015</h3><ul>
<li>合并<a href="https://github.com/terhechte/appventure-blog/pull/4" target="_blank" rel="external">来自 #4 @blixt</a>和<a href="https://github.com/terhechte/appventure-blog/pull/2" target="_blank" rel="external">#2 @kandelvijayavolare</a>和<a href="https://github.com/terhechte/appventure-blog/pull/3" target="_blank" rel="external">#3 @sriniram</a>以及<a href="https://github.com/terhechte/appventure-blog/pull/5" target="_blank" rel="external">#5 @SixFiveSoftware</a>的PR</li>
<li>为帐号示例添加调用代码</li>
<li>增加 <code>ErrorType</code> 示例</li>
</ul>
<h2 id="解释">解释</h2><p><a name="c1"></a></p>
<ul>
<li><p>1、可以使用一些小技术来达到这个目的，具体的请参照下面的文章内容<br><a name="c2"></a></p>
</li>
<li><p>2、为了演示的缘故，这个示例的实现经过的简化。在真实的开发中，应该使用可选类型以及反向顺序的参数。可以参考一下现在十分流行的函数式编程库，如 <a href="https://github.com/typelift/Swiftz" target="_blank" rel="external">Swiftz</a> 和 <a href="https://github.com/ankurp/Dollar.swift" target="_blank" rel="external">Dollar</a><br><a name="c3"></a></p>
</li>
<li><p>3、这个示例直接采用了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" target="_blank" rel="external">Swift 官方文档的示例</a><br><a name="c4"></a></p>
</li>
<li><p>4、经常使得他们定义的位置很难被发现<br><a name="c5"></a></p>
</li>
<li><p>5、这是一个简化版的，当然，Swift 为我们加了很多的语法糖<br><a name="c6"></a></p>
</li>
<li><p>6、如果你在应用中使用过 JSON，应该也曾经碰到过这个问题<br><a name="c6"></a></p>
</li>
<li><p>7、顺便一提，不能直接使用数字做为枚举 case 的名称，因此直接使用 400 是不行的<br><a name="c8"></a></p>
</li>
<li><p>8、虽然如此，不过支持 Mac 版的 R.swift 好像就快推出了<br><a name="c9"></a></p>
</li>
<li><p>9、这句话可以解释为: 打开链接，并开始阅读文章</p>
</li>
</ul>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到<a href="https://github.com/colourful987/Topic_Demo/tree/master/Advanced%20%26%20Practical%20Enum%20usage%20in%20Swift">这个github地址上进行下载</a>，这个代码由翻译组的另一位小伙伴 <a href="http://blog.csdn.net/colouful987">ppt</a> 提供。</p>
</blockquote>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>]]>
    
    </summary>
    
      <category term="APPVENTURE" scheme="http://swiftggteam.github.io/tags/APPVENTURE/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3D Touch介绍：电子秤App与快捷操作]]></title>
    <link href="http://swiftggteam.github.io/2015/11/19/3d-touch-tutorial/"/>
    <id>http://swiftggteam.github.io/2015/11/19/3d-touch-tutorial/</id>
    <published>2015-11-19T02:31:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Maxime Defauw，<a href="http://www.appcoda.com/3d-touch-tutorial/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/09<br>译者：<a href="http://www.brighttj.com" target="_blank" rel="external">saitjr</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>随着 iPhone6s 与 6s plus 的到来，苹果给我们展现了一种全新的交互方式：重按手势。你可能知道，这个特性已经在 Apple Watch 和 MacBook 上推出了，不过那时叫 Force Touch，就是字面上的意思，给用户的交互添加一种新的维度。</p>
<p>如果你很好奇 iPhone 的 Force Touch 为啥要更名为 3D Touch，那告诉你吧，you’re not alone（译者注：请用 MJ 的调子唱出来…）。不久前，之前也对这名字纠结不已的 Craig Federighi（译者注：Apple 高级副总裁）介绍了这个新特性，第一条微博就这样产生了。也不知道 Force Touch 这名字有啥不好的，就因为有太多星球大战的梗？（译者注：其实我不知道这梗…）（校对注：译者是个妹子）（定稿注：还是单身）</p>
<a id="more"></a>
<p>但是，Force Touch 和 3d Touch 确实不一样！Force Touch 只能识别重按。这方面 3D Touch 要灵敏多了，它能够识别按压的力度。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3dtouch-intro.jpg" alt=""></p>
<p>虽然说，这点不同看起来无足轻重，但是这使开发者能开发更多精确计量方面的 App。比如这一款名为<a href="https://medium.com/swlh/turning-the-iphone-6s-into-a-digital-scale-f2197dc2b6e7" target="_blank" rel="external">Gravity</a>的应用，它利用 Force Touch 让你的 iPhone 成为了一个电子秤。虽然这款 App 被 Apple 拒了，但是这创意简直太棒了。为了展示 3D Touch 的工作流程，我们来做一个简单的 App。</p>
<p>先去下载这个<a href="https://www.dropbox.com/s/i3xwostpd87rqci/ScaleStarter.zip?dl=0" target="_blank" rel="external">初始案例</a>。初始案例中只有一个空的 Single View。我在里面创建了 App 必要的 UI 元素（<code>UILabel</code>和<code>UIImage</code>），并关联了<code>ViewController.swift</code>。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3dtouch-storyboard.png" alt=""></p>
<p>这个 App 的设计很简单：ViewController 上有两个 Label：一个标题和一个显示按压百分比的文本。</p>
<p>那…开始写代码吧！在 iPhone6s 和 6s Plus 上，<code>UITouch</code>对象多了两个<code>CGFloat</code>类型的属性，分别是<code>force</code>和<code>maximumPossibleForce</code>。<code>force</code>表示按得有多重，<code>1.0</code>表示常规状态的值。<code>maximumPossibleForce</code>表示能承受的最大压力值。</p>
<p>无论什么情况，当用户触摸屏幕时，<code>touchesBegan</code>方法会被调用，接着就是<code>touchesMoved</code>（如果用户手指在屏幕上滑动，那么<code>touchedCancelled</code>与<code>TouchesEnded</code>也会被调用）。在这个App中，我们只需要关注<code>touchesMoved</code>方法。<code>touchesMoved</code>有两个参数：<code>touches</code>和<code>event</code>。<code>touches</code>是一个装着<code>UITouch</code>对象的<code>NSSet</code>类型集合（集合无序，并且无重复）。我们必须要确保在<code>touches</code>中只有一个<code>UITouch</code>对象，但也有考虑不完全的时候，所以强烈建议大家先利用可选绑定来判断<code>touches.first</code>（<code>touches</code>中的第一个<code>UITouch</code>对象）是否是空。在<code>ViewController.swift</code>中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</span><br><span class="line">            <span class="keyword">if</span> traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">                <span class="comment">// 3D Touch capable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个<code>if</code>判断中，还需要添加判断当前设备是否支持 3D Touch 的代码。如果你只是做来玩，那就没必要验证。但是，如果是要上架的 App，那就必须要判断，毕竟像 iPhone6 这些旧设备不支持 3D Touch。</p>
<p>除此之外，我还使用了<code>#available</code>语句（Swift 2.0）对当前系统是否是 iOS9+ 做了判断。（如果你想学习更多 Swift 2.0 相关的知识，我就更加推荐你阅读这篇文章了。）同样，如果你的编译环境是 iOS9.0+，那么这个判断可以省略。</p>
<p>要得到按压百分比？那太简单了，只需要用<code>force</code>属性除以<code>maximumPossibleForce</code>就可以了（例如：<code>touch.maximumPossibleForce</code>），<code>maximumPossibleForce</code>表示能承受的最大压力值。然后，更新文本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</span><br><span class="line">            <span class="keyword">if</span> traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">                <span class="comment">// 3D Touch capable</span></span><br><span class="line">                <span class="keyword">let</span> force = touch.force/touch.maximumPossibleForce</span><br><span class="line">                forceLabel.text = <span class="string">"<span class="subst">\(force)</span>% force"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在 iPhone6s/6s Plus 上跑这个程序，按屏幕时就能看到压力百分比了。但是，其实我们更想知道放在 iPhone 上物体的重量，而不是百分比。根据<a href="https://medium.com/swlh/turning-the-iphone-6s-into-a-digital-scale-f2197dc2b6e7" target="_blank" rel="external">Ryan McLeod</a>的 App 可以知道，传感器的计量范围的最大值是 385g。因此，<code>maximumPossibleForce</code>就相当于 385g（相当于3.8N）。通过简单的计算，就可以把压力百分比转为克。需要做的仅仅是用百分比*385。对于重于 385g 的物体，就把  label 改成类似于“385+ grams”这样的文本好了。</p>
<p>到此，<code>touchesMoved</code>方法中的代码更新为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</span><br><span class="line">            <span class="keyword">if</span> traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> touch.force &gt;= touch.maximumPossibleForce &#123;</span><br><span class="line">                    forceLabel.text = <span class="string">"385+ grams"</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> force = touch.force/touch.maximumPossibleForce</span><br><span class="line">                    <span class="keyword">let</span> grams = force * <span class="number">385</span></span><br><span class="line">                    <span class="keyword">let</span> roundGrams = <span class="type">Int</span>(grams)</span><br><span class="line">                    forceLabel.text = <span class="string">"<span class="subst">\(roundGrams)</span> grams"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后…你就有了一个电子秤 App…</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-scale-app-492x1024.png" alt=""></p>
<p>还有一个小问题：当物体或者触摸事件结束之后，文本没有重置。你可以实现<code>touchesEnded</code>方法来达到效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    forceLabel.text = <span class="string">"0 gram"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主屏幕上的快捷操作">主屏幕上的快捷操作</h2><p>另一个 3D Touch 的用法是主屏幕上的快捷操作。快捷操作可以让用户从快捷方式直接跳转到 App 的某个地方。按压 App icon 快捷方式就会出现。在介绍 3D Touch 的时候，Twitter、Instagram 等 App 就展示了这个新特性。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-quick-action.png" alt=""></p>
<p>让我们来给刚才的电子秤 App 添加一个快捷操作吧（把白色背景换成蓝色）。要添加快捷操作，先打开工程目录中的<code>info.plist</code>（在导航栏上点击工程名，在<code>TARTGET</code>中找到<code>info</code>选项卡）。在这个文件中，添加<code>UIApplicationShortcutItems</code>数组。数组中的元素是包含一个快捷操作配置的字典：</p>
<ul>
<li><code>UIApplicationShortcutItemType</code>(必填)：快捷操作的<strong>唯一</strong>标识符（String 类型）。建议将 bundle ID 或者其他唯一字符串作为标识符前缀。</li>
<li><code>UIApplicationShortcutItemTitle</code>（必填）：相当于快捷操作的 title（String 类型），用户可以看到。例如“显示最近一张照片”之类的文本。</li>
<li><code>UIApplicationShortcutItemSubtitle</code>（可选）：快捷操作的副标题（String 类型）。例如“昨天拍摄的照片”。如果你想要给快捷操作添加一个 icon，可以自定义，也可以使用系统自带的。</li>
<li><code>UIApplicationShortcutItemIconType</code>（可选）：表示你要选择哪种系统图标作为快捷操作的 icon（String 类型）。</li>
<li><code>UIApplicationShortcutItemIconFile</code>（可选）：表示给快捷操作添加自定义 icon（String 类型）。</li>
<li><code>UIApplicationShortcutItemUserInfo</code>（可选）：在快捷操作交互时传递的额外信息（译者注：类似于通知的 UserInfo 参数）（Dictionary 类型）。</li>
</ul>
<p>在这个数组中，我们将会给自定义的快捷操作添加 4 个配置。然后，你的<code>info.plist</code>文件看起来应该是这样滴：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-infoplist-600x102.png" alt=""></p>
<blockquote>
  <figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt;   注意，我用到了<span class="escape">`$</span>(PRODUCT_BUNDLE_IDENTIFIER)<span class="escape">`来</span>代替<span class="escape">`c</span>om.appcoda.Scale<span class="escape">`（</span>就是替代的 bundle ID）。这是出于安全考虑：无论在什么情况下，如果我在<span class="escape">`G</span>eneral<span class="escape">`中</span>修改了 bundle ID，那整个工程的 bundle ID 就都变了，这势必会给项目带来不晓得影响。这样的话，我就需要手动去修改每个 bundle ID。在<span class="escape">`i</span>nfo.plist<span class="escape">`里</span>面可以看到，其实每个 Bundle Identifier 配置项都是用的<span class="escape">`$</span>(PRODUCT_BUNDLE_IDENTIFIER)<span class="escape">`来</span>表示 bundle ID 在工程中的路径。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后一件事，就是实现用户触发快捷操作的处理流程。快捷方式需要在<code>AppDelegate.swift</code>的<code>performActionForShortcutItem</code>方法中处理。当使用快捷操作启动时，这个方法会被调用。所以，实现这个方法，并在方法中处理快捷操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle quick actions</span></span><br><span class="line">    completionHandler(handleQuickAction(shortcutItem))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法需要调用<code>completionHandler</code>，并传入布尔值，这个布尔值取决于快捷操作成功与否。这里我们封装了一个<code>handleQuickAction</code>方法来处理快捷方式。如果有多个快捷操作，最好的方式是使用枚举，<code>UIApplicationShortcutItemType</code>作为枚举的<code>rawValue</code>（译者注：对枚举不熟悉可以参考<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/08_Enumerations.html" target="_blank" rel="external">这篇文章</a>）。定义一个枚举，并实现<code>handleQuickAction</code>方法，在方法中修改背景色为蓝色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shortcut</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> openBlue = <span class="string">"OpenBlue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">handleQuickAction</span><span class="params">(shortcutItem: UIApplicationShortcutItem)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> quickActionHandled = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> type = shortcutItem.type.componentsSeparatedByString(<span class="string">"."</span>).last!</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> shortcutType = <span class="type">Shortcut</span>.<span class="keyword">init</span>(rawValue: type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> shortcutType &#123;</span><br><span class="line">        <span class="keyword">case</span> .openBlue:</span><br><span class="line">            <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">151.0</span>/<span class="number">255.0</span>, green: <span class="number">187.0</span>/<span class="number">255.0</span>, blue: <span class="number">255.0</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">            quickActionHandled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickActionHandled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切都是这么简单。现在把程序跑起来，使用快捷操作来启动 App，就可以看到背景已经是蓝色了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-scale-blue.png" alt=""></p>
<h2 id="还有一件事">还有一件事</h2><p>还有一个问题你别忘了…在程序启动顺序方面，<strong>启动</strong>程序和使用快捷操作<strong>唤醒</strong>是有区别的。我们都知道，程序启动会调用<code>willFinishLaunchingWithOptions</code>和<code>didFinishLaunchingWithOptions</code>方法。但是当使用快捷操作唤醒时，只会触发<code>performActionForShortcutItem</code>方法（译者注：这就意味着，使用快捷操作来<strong>启动</strong>会走三个方法，而使用快捷操作<strong>唤醒</strong>只会走一个，具体的方法列表如下图）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-quickaction-methods.png" alt=""></p>
<p>如果你回头看<code>didFinishLaunchingWithOptions</code>方法，会发现里面我写了一行设置背景色为白色的代码。这个是在直接启动程序时用的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions:</span><br><span class="line">    [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了：当使用快捷操作唤醒程序时，<code>willFinish</code>，<code>didFinish</code>和<code>performActionForShortcutItem</code>都会被调用。所以背景色会先设置成白色，接着又被设置成了蓝色。显然你不想在使用快捷操作启动时，背景色被设置成白色。</p>
<p>要解决这个问题，我们需要在<code>didFinishLaunchingWithOptions</code>方法的实现中添加条件判断：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions:</span><br><span class="line">    [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"didFinishLaunchingWithOptions called"</span>)</span><br><span class="line">    <span class="keyword">var</span> isLaunchedFromQuickAction = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if it's launched from Quick Action</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> shortcutItem = launchOptions?[<span class="type">UIApplicationLaunchOptionsShortcutItemKey</span>] <span class="keyword">as</span>? <span class="type">UIApplicationShortcutItem</span> &#123;</span><br><span class="line"></span><br><span class="line">        isLaunchedFromQuickAction = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// Handle the sortcutItem</span></span><br><span class="line">        handleQuickAction(shortcutItem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return false if the app was launched from a shortcut, so performAction... will not be called.</span></span><br><span class="line">    <span class="keyword">return</span> !isLaunchedFromQuickAction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断可选值的<code>UIApplicationLaunchOptionsShortcutItemKey</code>得到用户是否是通过快捷操作启动。<code>UIApplicationShortcutItem</code>可以作为可选值的类型。如果程序是通过快捷操作启动的，我们可以直接调用<code>handleQuickAction</code>方法将背景色改为蓝色。</p>
<p>因为我们已经在<code>didFinishLaunchingWithOption</code>方法中调用了<code>handleQuickAction</code>，所以没必要再在<code>performActionForShortcutItem</code>方法中调用一次。所以最后我们返回了一个<code>false</code>，告诉系统不要再去调用<code>performActionForShortcutItem</code>方法。</p>
<p>再次运行程序！完美！</p>
<h2 id="最后">最后</h2><p>3D Touch 是给程序添加另一种交互方式的好方法。但是你还是不要忘了，目前还不是所有设备都支持 3D Touch。</p>
<p>通过这篇文章，你应该能给你的 App 添加快捷操作，也能计量按压力度了。</p>
<p>顺便，你可以在<a href="https://www.dropbox.com/s/yf8nkupi9yt01hk/ScaleFinal.zip?dl=0" target="_blank" rel="external">这里</a>下载程序的最终版。同样，欢迎大家留言。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Maxime Defauw，<a href="http://www.appcoda.com/3d-touch-tutorial/">原文链接</a>，原文日期：2015/11/09<br>译者：<a href="http://www.brighttj.com">saitjr</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>随着 iPhone6s 与 6s plus 的到来，苹果给我们展现了一种全新的交互方式：重按手势。你可能知道，这个特性已经在 Apple Watch 和 MacBook 上推出了，不过那时叫 Force Touch，就是字面上的意思，给用户的交互添加一种新的维度。</p>
<p>如果你很好奇 iPhone 的 Force Touch 为啥要更名为 3D Touch，那告诉你吧，you’re not alone（译者注：请用 MJ 的调子唱出来…）。不久前，之前也对这名字纠结不已的 Craig Federighi（译者注：Apple 高级副总裁）介绍了这个新特性，第一条微博就这样产生了。也不知道 Force Touch 这名字有啥不好的，就因为有太多星球大战的梗？（译者注：其实我不知道这梗…）（校对注：译者是个妹子）（定稿注：还是单身）</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchConnectivity：通过用户信息共享所有数据]]></title>
    <link href="http://swiftggteam.github.io/2015/11/18/watchconnectivity-user-info/"/>
    <id>http://swiftggteam.github.io/2015/11/18/watchconnectivity-user-info/</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-user-info/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在看这篇文章之前，确认你已经看过之前发布的几篇 WatchOS 2 的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World</a>(<a href="http://swift.gg/2015/10/15/watchos-2-hello-world/" target="_blank" rel="external">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">WatchConnectivity Introduction: Say Goodbye To The Spinner</a>(<a href="http://swift.gg/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">WatchConnectivity: Say Hello to WCSession</a>(<a href="http://swift.gg/2015/11/02/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">译文链接</a>)</li>
</ul>
<p>通过 User Info 实现后台数据传输应该在你确保所有数据被传输的情况下（不仅仅像<a href="http://natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="external">Application Context</a>）。用户信息数据是在FIFO（先进先出）队列中排队传输的，所以不会有东西被重写。</p>
<a id="more"></a>
<p>一个典型的例子是在短信应用中使用它 —— 最后一条信息要确保能看到完整对话和上下文的重要部分。亦或者如果用户更新了他们文件信息的一小部分，则他们的个人信息和所有的修改应该被同步到 Watch 文件。</p>
<p>在这个教程中，我将会构建一个食物 emoji （表情符号）社交应用，因为我是个吃货，并且我喜欢🍦！</p>
<p>另外，这个应用可以成为一个基于食品杂货店展示的 Apple Watch 应用 —— 你在手机上选择打算购买的食物 emoji ，然后跳转到应用上，这样你就好像在食品杂货店上浏览商品了！</p>
<p><img src="/img/articles/watchconnectivity-user-info/Screen-Shot-2015-10-21-at-5.16.42-AM.png1447813695.0476735" alt=""></p>
<h2 id="免责声明">免责声明</h2><p>对于这个应用需要知道的是，我将会写很多抽象的数据更新层用于整个应用，因为 UI 中的多个地方需要有数据源更新，所以在示例应用中将会过度设计。</p>
<p>我同样尝试了不同的架构，尤其是 Swift，所以如果你知道如何在 Swift 中更好地抽象数据层，请在评论中提出。</p>
<h2 id="步骤">步骤</h2><p>在这个教程中，我假设你已经知道如何在<strong> Xcode 创建一个简单的单视图应用</strong>，以及创建一个简单的<strong>食物 Emoji 列表的表视图</strong>。如果你有任何问题，可以参考这个 <a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo/blob/master/WCUserInfoDemo/FoodSelectionViewController.swift" target="_blank" rel="external">FoodSelectionViewController</a> 。</p>
<p>同样地，我也假设你知道如何<strong>创建一个 Watch 应用并且在 Interface.storyboard 中做过基本的样式</strong>。如果你需要帮助，请查看<a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World tutorial</a> 和 <a href="http://natashatherobot.com/watchkit-create-table/" target="_blank" rel="external">WatchKit: Let’s Create a Table tutorial</a>.</p>
<p>最后，你需要知道如何创建基础的用于管理 <code>WCSession</code> 的单例，以及在 <code>AppleDelegate</code> 中的<code>application:didFinishLaunchingWithOptions</code>和在Watch 扩展中<code>ExtensionDelegate</code> 的<code>applicationDidFinishLaunching</code>中启动它。如果你不清楚，请查看 <a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">WatchConnectivity: Say Hello to WCSession tutorial</a>。</p>
<p>你的 iOS 应用看起来应该像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your iOS app</span></span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validSession: <span class="type">WCSession</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// paired - the user has to have their device paired to the watch</span></span><br><span class="line">        <span class="comment">// watchAppInstalled - the user must have your watch app installed</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Note: if the device is paired, but your watch app is not installed</span></span><br><span class="line">        <span class="comment">// consider prompting the user to install it for a better experience</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = session <span class="keyword">where</span> session.paired &amp;&amp; session.watchAppInstalled &#123;</span><br><span class="line">            <span class="keyword">return</span> session</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session?.delegate = <span class="keyword">self</span></span><br><span class="line">        session?.activateSession()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和在 Watch 应用中这样的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span> = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activateSession()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你需要额外的提示，可以参考这个 <a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo" target="_blank" rel="external">教程的源码</a>。</p>
<p>现在让我们开始有趣的部分吧 🚀。</p>
<h2 id="发送数据">发送数据</h2><p>在我的应用中，每当用户选择一个食物项，都需要在后台传输给 Watch 应用。这意味着<strong> iOS 应用是发送者</strong>。显然这是非常简单的。</p>
<p>只需扩展 iOS 应用的 WatchSessionManager 单例去传输用户数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your iOS app</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: User Info</span></span><br><span class="line"><span class="comment">// use when your app needs all the data</span></span><br><span class="line"><span class="comment">// FIFO queue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sender</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">transferUserInfo</span><span class="params">(userInfo: [String : AnyObject])</span></span> -&gt; <span class="type">WCSessionUserInfoTransfer</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> validSession?.transferUserInfo(userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以现在，当用户选择一个食物的 cell，你只需简单地调用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FoodSelectionViewController.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodSelectionViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> food = [<span class="string">"🍦"</span>, <span class="string">"🍮"</span>, <span class="string">"🍤"</span>,<span class="string">"🍉"</span>, <span class="string">"🍨"</span>, <span class="string">"🍏"</span>, <span class="string">"🍌"</span>, <span class="string">"🍰"</span>, <span class="string">"🍚"</span>, <span class="string">"🍓"</span>, <span class="string">"🍪"</span>, <span class="string">"🍕"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Table Data Source methods truncated</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: Table view delegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> foodItem = food[indexPath.row]</span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.transferUserInfo([<span class="string">"foodItem"</span> : foodItem])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是酱紫！已选择的食物项就在 FIFO 队列中了，并且将会发送给 Watch 应用！</p>
<h2 id="接收数据">接收数据</h2><p><strong>现在 Watch 应用必须接收数据</strong>。这也很简单，只需要实现<code>WCSessionDelegate</code>中的<code>session:didReceiveUserInfo:</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: User Info</span></span><br><span class="line"><span class="comment">// use when your app needs all the data</span></span><br><span class="line"><span class="comment">// FIFO queue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Receiver</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveUserInfo userInfo: [String : AnyObject])</span></span> &#123;</span><br><span class="line">        <span class="comment">// handle receiving user info</span></span><br><span class="line">        <span class="comment">// this will be filled in in the Updating Data section below</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新数据">更新数据</h2><p>现在你接收到了数据，我们开始处理最棘手的部分。尝试去更新你的 Watch 扩展的 <code>InterfaceController</code> 以及其他视图或者数据源。一种方式是使用 <code>NSNotificationCenter</code>，但是我会尝试使用不同的方法。这个部分可以用多种方法来做，并且对于这个应用来说有点过度设计，因此要先说清楚。</p>
<p>因为我们正在写 Swift，我的目标是尽量使用值类型模型。不幸的是，正如我在 <code>WCSession</code> 中所提到的，<code>WCSessionDelegate</code>只能在一个<code>NSObject</code> 中实现。变通一下，我创建了一个可以携带用户信息数据的 <code>DataSource</code> 值，然后把它转换为可供多个交互控制器使用的可变的东西。因为用户信息是在一个 FIFO 队列顺序接收的，<code>DataSource</code> 应该持续追踪在队列中接收的数据。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// in your WatchKit Extension</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items: [<span class="type">Item</span>]</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Food</span>(<span class="type">String</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Unknown</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(items: [<span class="type">Item</span>] = [<span class="type">Item</span>]()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">insertItemFromData</span><span class="params">(data: [String : AnyObject])</span></span> -&gt; <span class="type">DataSource</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> updatedItems: [<span class="type">Item</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> foodItem = data[<span class="string">"foodItem"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            updatedItems = [.<span class="type">Food</span>(foodItem)] + items</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            updatedItems = [.<span class="type">Unknown</span>] + items</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">DataSource</span>(items: updatedItems)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我可以现在设置一个 protocol ，通过更新的数据源更新所有需要知道数据改变的部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"><span class="comment">//  WatchSessionManager.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DataSourceChangedDelegate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dataSourceDidUpdate</span><span class="params">(dataSource: DataSource)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们进入有趣的部分！你的<code>WatchSessionManager</code>将会以某种方式去追踪所有的<code>dataSourceChangedDelegates</code>。这可以通过一个数组以及一组可以添加和删除数组delegate的方法实现。<code>WatchSessionManager</code>还需要持续追踪最近的<code>DataSource</code>拷贝，这样就可以使用<code>DataSource</code>中的数据创建一个包含最新数据的<code>DataSource</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line">   <span class="comment">//  WatchSessionManager.swift</span></span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">       <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span> = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> dataSource = <span class="type">DataSource</span>()</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> dataSourceChangedDelegates = [<span class="type">DataSourceChangedDelegate</span>]()</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">       session.delegate = <span class="keyword">self</span></span><br><span class="line">       session.activateSession()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">addDataSourceChangedDelegate</span><span class="params">(delegate: T)</span></span> &#123;</span><br><span class="line">       dataSourceChangedDelegates.append(delegate)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">removeDataSourceChangedDelegate</span><span class="params">(delegate: T)</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (index, dataSourceDelegate) <span class="keyword">in</span> dataSourceChangedDelegates.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> dataSourceDelegate = dataSourceDelegate <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">where</span> dataSourceDelegate == delegate &#123;</span><br><span class="line">               dataSourceChangedDelegates.removeAtIndex(index)</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面实现接收用户信息的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"><span class="comment">//  WatchSessionManager.swift</span></span><br><span class="line"><span class="comment">// MARK: User Info</span></span><br><span class="line"><span class="comment">// use when your app needs all the data</span></span><br><span class="line"><span class="comment">// FIFO queue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line"><span class="comment">// Receiver</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveUserInfo userInfo: [String : AnyObject])</span></span> &#123;</span><br><span class="line">    <span class="comment">// handle receiving user info</span></span><br><span class="line">    dispatch_async(dispatch_get_main_queue()) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dataSource = <span class="keyword">self</span>?.dataSource.insertItemFromData(userInfo) &#123;</span><br><span class="line">            <span class="keyword">self</span>?.dataSource = dataSource</span><br><span class="line">            <span class="keyword">self</span>?.dataSourceChangedDelegates.forEach &#123;</span><br><span class="line">                $<span class="number">0</span>.dataSourceDidUpdate(dataSource)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们只需要确保我们的<code>InterfaceController</code>继承了<code>DataSourceChangedDelegate</code>，并且被<code>WatchSessionManager</code>持续追踪：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// in your WatchKit Extension</span></span><br><span class="line">    <span class="comment">//  InterfaceController.swift</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="title">WKInterfaceController</span>, <span class="title">DataSourceChangedDelegate</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> foodTable: <span class="type">WKInterfaceTable</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">awakeWithContext</span><span class="params">(context: AnyObject?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeWithContext(context)</span><br><span class="line"></span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.addDataSourceChangedDelegate(<span class="keyword">self</span>)</span><br><span class="line">        loadTableData(<span class="type">DataSource</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didDeactivate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remove InterfaceController as a dataSourceChangedDelegate</span></span><br><span class="line">        <span class="comment">// to prevent memory leaks</span></span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.removeDataSourceChangedDelegate(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">super</span>.didDeactivate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: DataSourceUpdatedDelegate</span></span><br><span class="line">    <span class="comment">// update the table once the data is changed!</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dataSourceDidUpdate</span><span class="params">(dataSource: DataSource)</span></span> &#123;</span><br><span class="line">        loadTableData(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">extension</span> <span class="title">InterfaceController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">loadTableData</span><span class="params">(dataSource: DataSource)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        foodTable.setNumberOfRows(dataSource.items.<span class="built_in">count</span>, withRowType: <span class="string">"FoodTableRowController"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index, item) <span class="keyword">in</span> dataSource.items.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> row = foodTable.rowControllerAtIndex(index) <span class="keyword">as</span>? <span class="type">FoodTableRowController</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> item &#123;</span><br><span class="line">                <span class="keyword">case</span> .<span class="type">Food</span>(<span class="keyword">let</span> foodItem):</span><br><span class="line">                    row.foodLabel.setText(foodItem)</span><br><span class="line">                <span class="keyword">case</span> .<span class="type">Unknown</span>:</span><br><span class="line">                    row.foodLabel.setText(<span class="string">"¯\\_(ツ)_/¯"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样啦！<br><a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo" target="_blank" rel="external">你可以在Github上查看完整源代码！</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-user-info/">原文链接</a>，原文日期：2015-10-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在看这篇文章之前，确认你已经看过之前发布的几篇 WatchOS 2 的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/">WatchOS 2: Hello, World</a>(<a href="http://swift.gg/2015/10/15/watchos-2-hello-world/">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/">WatchConnectivity Introduction: Say Goodbye To The Spinner</a>(<a href="http://swift.gg/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/">WatchConnectivity: Say Hello to WCSession</a>(<a href="http://swift.gg/2015/11/02/watchconnectivity-say-hello-to-wcsession/">译文链接</a>)</li>
</ul>
<p>通过 User Info 实现后台数据传输应该在你确保所有数据被传输的情况下（不仅仅像<a href="http://natashatherobot.com/watchconnectivity-application-context/">Application Context</a>）。用户信息数据是在FIFO（先进先出）队列中排队传输的，所以不会有东西被重写。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="WatchOS 2" scheme="http://swiftggteam.github.io/categories/WatchOS-2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的函数式编程]]></title>
    <link href="http://swiftggteam.github.io/2015/11/17/functional-programming-in-swift/"/>
    <id>http://swiftggteam.github.io/2015/11/17/functional-programming-in-swift/</id>
    <published>2015-11-17T04:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/functional-programming-in-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/13<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 一个强有力的语言特性就是能够用多样的函数式风格去编写代码。这在社区看来非常激动人心。</p>
<p>我在去年年底花费了一些时间学习函数式编程，所以我可以写更好的 Swift 代码。因此，我非常推荐你们也花时间去学习一下！</p>
<p>另外，我非常推荐推荐你们去看 <a href="http://2014.funswiftconf.com/" target="_blank" rel="external">Functional Swift conference</a>上的每一个视频。</p>
<p>所以在花了这么多时间后，我想要总结一下个人有关于函数式编程在 Swift 应用的一些思考。</p>
<a id="more"></a>
<h2 id="跟着概念走">跟着概念走</h2><p>函数式编程是令人生畏的，这要归咎于单子（monads）和 函数子（functors）！然而，一旦你领悟了它的核心概念，那么函数式编程的思想会超级简单：</p>
<blockquote>
<p>“函数式编程是一个编程范例…它把计算作为数学函数的评估，并避免改变状态和可变数据。”— <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>所以核心就是你应该用数学的方式去编写代码。你的函数应该有清晰的输入和输出，并且不会像可变对象一样有全局副作用。这就是了！</p>
<h2 id="避免可变状态">避免可变状态</h2><p>这和上述的注意点类似。函数式编程要编写的是没有副作用的数学代码。</p>
<p>在 Swift 中使用结构体和协议帮助你避免可变状态。</p>
<p>我极度推荐观看 <a href="https://twitter.com/andy_matuschak" target="_blank" rel="external">@andy_matuschak</a>的  <a href="https://realm.io/news/andy-matuschak-controlling-complexity/" target="_blank" rel="external">Controlling Complexity in Swift</a>，这可以让你理解如何去实现以及最终的代码会如何地强大。</p>
<h2 id="可读性第一">可读性第一</h2><p>我发现很多高级的函数式代码，通常由于五个以上的习惯性编程而变得特别难以阅读。如果你遵从函数式编程的概念，有很多方法让你的代码变得更清楚。</p>
<p>但是在今天结束之前，还要多说一句，如果你在一个团队中工作，最重要的事就是让代码可读性更强。如果一个内部或者一个新的开发者加入你们的团队，他们会不会完全迷失了？如果你专注于编写易读的代码（取代好玩和花哨的写法），他们可能会很快就有产出。</p>
<p>记住一点，可读性的优先级永远比花哨的代码高（除非你的目标就是用一个好玩的副作用去实现好玩和花哨的程序）。</p>
<h2 id="不要和_framework_作对">不要和 framework 作对</h2><p>当然，在 iOS 编程中，由于 Cocoa framework 的建立和用户的输入输出，没有副作用显然是不可能的（在纯粹的数学世界，确实存在完全没有外部副作用，但那不是我们生活的世界！）。</p>
<p>例如，如果你创建了一个通用的转换器（formatter）（例如货币转换器），并用在代码中的一些地方，用单例是一个很好的方法。你还必须为UI Layer 使用 <code>UIViewControllers</code> 以及 <code>UIViews</code>。总有办法去脱离你的逻辑，进而让很好的不可变组件去帮助你可变化这些东西，但是不要过火地把 freamwork 改变为面目全非（可读，不可读）的状态。</p>
<h2 id="深入学习函数式编程">深入学习函数式编程</h2><p>再次强调，你不应该执着于在你的 Swift 代码中使用花哨的技巧（除非你只是为了试验、或者好玩）。我非常推荐深入学习函数式编程的思想，从而理解那些高级概念，并且更好地应用在你的代码中。</p>
<p>推荐阅读 <a href="https://www.objc.io/books/fpinswift/" target="_blank" rel="external">Functional Programming in Swift</a> ！这里有<a href="http://natashatherobot.com/reading-functional-programming/" target="_blank" rel="external">更多的资源</a>去帮助你开始学习！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/functional-programming-in-swift/">原文链接</a>，原文日期：2015/11/13<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 一个强有力的语言特性就是能够用多样的函数式风格去编写代码。这在社区看来非常激动人心。</p>
<p>我在去年年底花费了一些时间学习函数式编程，所以我可以写更好的 Swift 代码。因此，我非常推荐你们也花时间去学习一下！</p>
<p>另外，我非常推荐推荐你们去看 <a href="http://2014.funswiftconf.com/">Functional Swift conference</a>上的每一个视频。</p>
<p>所以在花了这么多时间后，我想要总结一下个人有关于函数式编程在 Swift 应用的一些思考。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[捕获上下文信息]]></title>
    <link href="http://swiftggteam.github.io/2015/11/16/capturing-context-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/11/16/capturing-context-swiftlang/</id>
    <published>2015-11-16T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/08/27/capturing-context-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-27<br>译者：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>假设你正在使用一个类型，当有错误时发生时你想要输出异常发生时的上下文。通常你会使用一些内置的编译器关键字：<code>__FUNCTION__</code> ， <code>__LINE__</code> 和 <code>__FILE__</code> ，这些关键词提供了有关函数调用详细的文本插值：</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">String</span>; <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> reason: <span class="type">String</span>, source: <span class="type">String</span> = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">        file: <span class="type">String</span> = <span class="keyword">__FILE__</span>, line: <span class="type">Int</span> = <span class="keyword">__LINE__</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.reason = reason; <span class="keyword">self</span>.source = <span class="string">"<span class="subst">\(source)</span>:<span class="subst">\(file)</span>:<span class="subst">\(line)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一行典型的 <code>Error</code> 输出如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Error</span>(source: <span class="string">"myFunction():&lt;EXPR&gt;:14"</span>, reason: <span class="string">"An important reason"</span>)</span><br></pre></td></tr></table></figure>
<p>虽然这种结构能够让你捕获出现异常的函数、文件和行号，但你无法捕捉没有类型参数的原始父类型。为了捕获该类型，需要在 <code>Error</code> 结构体构造器中包含“原始类型”，并向构造器中传递 <code>self.dynamicType</code> 参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">String</span>; <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> reason: <span class="type">String</span>, type: <span class="type">Any</span> = <span class="string">""</span>, </span><br><span class="line">        source: <span class="type">String</span> = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">        file: <span class="type">String</span> = <span class="keyword">__FILE__</span>, </span><br><span class="line">        line: <span class="type">Int</span> = <span class="keyword">__LINE__</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.reason = reason; <span class="keyword">self</span>.source = <span class="string">"<span class="subst">\(source)</span>:<span class="subst">\(file)</span>:<span class="subst">\(line)</span>:<span class="subst">\(type)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我很不喜欢这种额外添加类型参数的方式，它唯一的作用就是简化错误生成。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"An important reason"</span>, type: <span class="keyword">self</span>.<span class="keyword">dynamicType</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;<span class="keyword">try</span> <span class="type">Parent</span>().myFunction()&#125; <span class="keyword">catch</span>&#123;<span class="built_in">print</span>(error)&#125;</span><br><span class="line"><span class="comment">// Error(source: "myFunction():&lt;EXPR&gt;:14:Parent", reason: "An important reason")</span></span><br></pre></td></tr></table></figure>
<p>我更喜欢扩展 <code>Contextualizable</code> 来实现自动捕获类型上下文。注意，默认实现的协议方法中用到了 <code>self.dynamicType</code>，它不能被用在方法签名中（译者注：也就是说不能当做函数参数或者返回值）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Contextualizable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Contextualizable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">currentContext</span><span class="params">(file : String = <span class="keyword">__FILE__</span>, function : String = <span class="keyword">__FUNCTION__</span>, line : Int = <span class="keyword">__LINE__</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(file)</span>:<span class="subst">\(function)</span>:<span class="subst">\(line)</span>:<span class="subst">\(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上述两种方法可以简化整个过程轻松实现我们的目标。共享 <code>Error</code> 类型之后就可以把变量改成常量，并且把上下文相关代码从 <code>Error</code> 构造器移动到遵循协议的类型中，这样就可以自动继承 <code>currentContext</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">String</span>; <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> source: <span class="type">String</span> = <span class="keyword">__FILE__</span>, <span class="number">_</span> reason: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.reason = reason; <span class="keyword">self</span>.source = source</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Parent</span>: <span class="title">Contextualizable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Error</span>(currentContext(), <span class="string">"An important reason"</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>更新之后，错误输出中会包含原始类型。</p>
<p>正如读者 <code>Kametrixom</code> 所指出的，你还可以扩展 <code>Contextualizable</code> 协议并创建你自己的错误。（他还写了一个<a href="https://gist.github.com/Kametrixom/21da650bd7c7006a70e3" target="_blank" rel="external">非常棒的错误类型</a>，可以选择是否添加上下文。）</p>
<p>本文的所有代码可以在 <a href="https://gist.github.com/erica/b6f4884ed5d70c269107" target="_blank" rel="external">这个 Gist</a> 中找到（译者注：Gist 已经被墙，需要翻墙查看）。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/08/27/capturing-context-swiftlang/">原文链接</a>，原文日期：2015-08-27<br>译者：<a href="https://github.com/chenmingbiao">CMB</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>假设你正在使用一个类型，当有错误时发生时你想要输出异常发生时的上下文。通常你会使用一些内置的编译器关键字：<code>__FUNCTION__</code> ， <code>__LINE__</code> 和 <code>__FILE__</code> ，这些关键词提供了有关函数调用详细的文本插值：</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给初学者的 Swift 教程 Part 1]]></title>
    <link href="http://swiftggteam.github.io/2015/11/13/swift-tutorial-for-beginners-part-1/"/>
    <id>http://swiftggteam.github.io/2015/11/13/swift-tutorial-for-beginners-part-1/</id>
    <published>2015-11-13T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-tutorial-for-beginners-part-1/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-29<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 是苹果官方新推出的编程语言，它可以为 iOS、 watchOS、 tvOS 和 Mac OS 开发应用。在本教程中，你将会学到所有的基础操作。</p>
<a id="more"></a>
<h2 id="你将在这个“Swift_初学者教程”中学到些什么呢？">你将在这个“Swift 初学者教程”中学到些什么呢？</h2><p>本教程包含了以下这些话题：</p>
<ul>
<li>下载 Xcode</li>
<li>Playgrounds</li>
<li>Hello World!</li>
<li>变量</li>
<li>常量</li>
<li>类型标注</li>
<li>条件语句</li>
<li>循环语句</li>
<li>可选类型</li>
<li>函数</li>
</ul>
<p>将会有更多内容出现在“写给初学者的 Swift 教程”系列中。</p>
<p>本教程源码下载: <a href="https://github.com/kevin833752/MyTranslationPlaygrounds/tree/master/Swift_Tutorial_For_Beginners_Part_1.playground" target="_blank" rel="external">来自小铁匠的代码</a></p>
<h2 id="下载_Xcode">下载 Xcode</h2><p>成为 Swift 大牛的第一步当然是下载 Xcode 啦。你可以直接从 App Store 里下载。Xcode 是苹果官方的 IDE 工具，它可以为 iOS、 watchOS、 tvOS 和 Mac OS 这些平台开发应用。</p>
<h2 id="Playgrounds">Playgrounds</h2><p>你会把大部分编程的时间花在具体项目上。但是，Xcode 有一个非常有趣的特性，可以给初学者和大牛带来巨大帮助，它就是 Playgrounds。你可以在 Playground 里写 Swift 代码，写完就直接能看到执行的结果。因此，如果你想要学一些新特性或试验一些新功能，可以打开 Playground 直接编写，不用像在工程里那样先编译再执行。</p>
<p>如果你正在写一个项目，那也可以同时打开一个 Playground，你可以在 Playground 里快速试验一些小功能。</p>
<p>言归正传，讲讲如何使用 Playground。第一步打开 Xcode，接着在欢迎界面点击“Get started with a playground”。如果你没有看到这个欢迎界面，可以按 File -&gt; New -&gt; Playground 这样的路径打开 Playground。指定 Playground 的文件名和保存位置之后，你就可以开始写代码啦。</p>
<h2 id="Hello_World!">Hello World!</h2><p>在大多数的编程书籍中，都把打印“Hello World!”作为第一个项目。我们也不会打破这个传统的，哈哈。</p>
<p>因此，我们在 playground 里写下如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure>
<p>输完这行代码，你就可以在 playground 的右边看到输出的结果。</p>
<p><img src="/img/articles/swift-tutorial-for-beginners-part-1/Screen-Shot-2015-10-03-at-18.26.55-1024x636.png1447379896.6408916" alt=""></p>
<p>恭喜，你已经成功编写了第一个 Swift 程序！</p>
<h2 id="变量">变量</h2><p>在打印出第一句代码后，我们可以开始真正的编程啦。你需要从变量开始。变量可以存储一个值，比如数字或字符串。可以使用<code>var</code>关键字来定义变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aNumber = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这样，我们就有了一个叫<code>aNumber</code>的变量，它的值为 5。接着，我们可以尝试着改变这个变量的值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aNumber = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>我们也可以把一个数学表示式的结果存到这个变量里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aNumber = <span class="number">5</span> + <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>当然也可以把变量的值打印出来，这需要用到特殊的术语，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The number is equal <span class="subst">\(aNumber)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>变量可以有不同的类型。你可以为变量指定类型，比如字符串、浮点数或者布尔值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aString = <span class="string">"A String"</span></span><br><span class="line"><span class="keyword">var</span> aDoble = <span class="number">13.3</span></span><br><span class="line"><span class="keyword">var</span> aBool = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>但是，一旦你给变量赋了某一类型的值之后，就只能为变量赋相同类型的值了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aBool = <span class="string">"A String"</span> <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>编译器是一段可以把你写的代码翻译成机器码的程序。如果你写了一段编译器不能理解或者违反编程规则的代码，编译器就会报错。</p>
<h2 id="常量">常量</h2><p>顾名思义，变量的值是可以改变的，而常量的值在第一次赋值后就不能修改了。对于常量，你可以使用关键字<code>let</code>来定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aConstantNumber = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>如果你尝试修改一个常量的值，就会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aConstantNumber = <span class="number">10</span> <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure>
<p>那为什么还要有常量呢？因为，有时候并不希望一个值在第一次赋值后被修改，比如，在指定一个人的姓名后，就不希望这个值被再次修改。</p>
<h2 id="类型标注">类型标注</h2><p>我们已经知道，变量在第一次赋值之后会确定类型。当然，我们也可以在赋值时直接指定变量或常量的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aNumber: <span class="type">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这个代码的结果和之前的是一样的，但是现在这段代码更加容易读懂。第一眼就知道这个变量的类型是<code>Int</code>。当然， 除了<code>Int</code>，还有许多其他的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aString: <span class="type">String</span> = <span class="string">"A String"</span></span><br><span class="line"><span class="keyword">var</span> aDouble: <span class="type">Double</span> = <span class="number">13.3</span></span><br><span class="line"><span class="keyword">var</span> aBool: <span class="type">Bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="条件语句">条件语句</h2><p>一个程序如果总是做相同的事情，这很无聊。因此，出现了所谓的条件语句来控制程序的流向。比如，你想要根据计算的结果有不同的输出。能控制程序流向的，也是最普遍的条件语句是<code>if</code>条件语句，举例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is smaller than number2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段示例代码中，我们通过<code>if</code>条件语句来判断<code>number1</code>是否小于<code>number2</code>。如果满足这个条件的话，程序就会执行到大括号括起来的 if 代码块里。你也可以在代码块里添加你想要执行的代码。</p>
<p>另外，你还可以在<code>if</code>条件判断返回<code>false</code>的代码块里写相应代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is smaller than number2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is not smaller than number2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你可以写多个<code>if</code>条件语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is smaller than number2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number2 &lt; number1 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number2 is than number2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is equal number2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 里另外一种条件语句是<code>switch</code>条件语句。<code>switch</code>语句的形式就是把某个值与一个或若干个值作比较，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> name &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Mick"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name is Mick"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"John"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name is John"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name is neither Mick nor John"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>关键字后写上需要匹配的值<code>name</code>。然后，每个<code>case</code>后跟上可能匹配的值。如果<code>name</code>匹配了某一个值，对应<code>case</code>里的代码将被执行；否则，继续进行匹配。假如没有一个值能够匹配，就会执行<code>default</code>后的代码。对于初学者来说，知道<code>switch</code>条件语句有很多可能匹配的值就足够了。</p>
<h2 id="循环">循环</h2><p>除了条件语句意外，还有一个控制程序流的重要结构：循环。循环的作用主要是能多次执行代码块里的代码。Swift 有三种循环的类型：while 循环, repeat-while 循环和 for 循环.</p>
<h3 id="while_循环">while 循环</h3><p>下面的例子使用了 while 循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while 循环以<code>while</code>关键字开始，在<code>while</code>关键字后跟上判断条件。如果条件为 true，会重复运行代码块里的一系列代码，比如本例子里的循环打印”Hello World”十次。如果没有修改变量<code>i</code>的值，循环将一直进行下去。</p>
<h3 id="repeat-while_循环">repeat-while 循环</h3><p>repeat-while 循环和 while 循环很相似。但是，不再像 while 循环那样先判断循环条件，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>为什么要使用repeat-while 循环而不是 while 循环？repeat-while 循环和 while 循环的主要区别是在判断循环条件之前，先执行一次循环的代码块。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">11</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，尽管判断条件永远是 false，但是还是会打印一次“Hello World”。因此，有时候需要先判断，而有时候不想要先判断，这就要根据具体的情况决定到底使用哪种循环。</p>
<h3 id="for_循环">for 循环</h3><p>for 循环很好用，它可以对一个集合里面的每个元素执行一系列语句。同时，也有好几种遍历的方式，先来看一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This iteration number <span class="subst">\(i)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果像上面的例子一样使用三个点号（闭区间操作符）的话，最后一个数字（10）也会被包含。此外，也可以像下面的例子一样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This iteration number <span class="subst">\(i)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，最后一个数字（10）不会被包含进去。另外，还有一种方式可以写 for 循环，就是标准 C 样式的 for 循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This iteration number <span class="subst">\(i)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环会执行十次。分号将循环的定义分为 3 个部分：首先，循环首次启动时，变量会被初始化，并赋一个起始值；其次，条件判断表达式被调用，如果表达式调用结果为true，则会执行大括号内部的代码；最后，执行所有语句之后，执行递增表达式，在本例中，变量<code>i</code>每次增加 1。其中，<code>i++</code>等同于<code>i = i + 1</code>。</p>
<h2 id="可选类型">可选类型</h2><p>可选类型是 Swift 里很特殊的新特性，它非常重要，因此我们在一开始就要介绍它。试想一下，一个变量有可能没有值，比如，一个变量用来存储一个人的 middle name，那某人没有 middle name 的话该怎么表示呢？我们很自然的能想到赋值一个空字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middleName: <span class="type">String</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>然而，如果我们让<code>middleName</code>成为可选类型，我们就可以为变量指定表示“这里没有值”的<code>nil</code>。可选类型的定义是在类型后面跟上问号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middleName: <span class="type">String</span>? = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>可选类型的变量可以有非空的值。但是，如果你像普通变量那样访问可选类型的变量，就会编译出错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherName: <span class="type">String</span> = middleName <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure>
<p>你可以通过解包来访问，使用感叹号进行解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherName: <span class="type">String</span> = middleName!</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果你对一个非<code>nil</code>的值进行解包，可以得到具体的值；否则，就会在运行时报错，因为不能对<code>nil</code>进行解包。</p>
<p>因此，最好在使用可选类型变量前先判断是否是<code>nil</code>，使用所谓的可选绑定（optional binding）就可以搞定了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middleName: <span class="type">String</span>? = <span class="string">"John"</span></span><br><span class="line"><span class="keyword">var</span> anotherName: <span class="type">String</span> = <span class="string">"Michael"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = middleName &#123;</span><br><span class="line">    anotherName = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，这段代码可能看起来会有点奇怪，实际上很简单，意思也很明确：如果<code>middleName</code>等于<code>nil</code>的话，对应的代码块就不会执行。如果<code>middleName</code>不等于<code>nil</code>的话，变量<code>name</code>就会获得<code>middleName</code>的值，对应的代码块就会被执行。在代码块里，<code>name</code>就不再是可选变量了，因此可以给其他变量赋值。</p>
<h2 id="函数">函数</h2><p>你可能经常会遇到，一些代码可以应用于许多不同的情况。而函数就是用来完成特定任务的独立的代码块，并且当函数需要执行的时候，这个名字会被用于“调用”函数。先从简单打印“Hello World”的函数开始吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，你把上面那段代码写到 playground 里，界面右边是没有输出的。如果你通过下面的方式调用这个函数的话，就会有对应的输出了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printHelloWorld()</span><br></pre></td></tr></table></figure>
<p>如果你调用这个函数两次的话，你会看到界面右边会出现两次输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printHelloWorld()</span><br><span class="line">printHelloWorld()</span><br></pre></td></tr></table></figure>
<p>你也可以给函数传递额外的信息，即传递参数。每个参数都需要指定参数名和类型，然后你就可以在函数里访问这些参数的值了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printANumber</span><span class="params">(number:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number is <span class="subst">\(number)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你就可以像下面的方式调用有参数的函数了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printANumber</span><span class="params">(number:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number is <span class="subst">\(number)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printANumber(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>本例中，对应的输出就是：“The number is 5”。</p>
<p>你甚至可以指定多个参数。然后，你在调用函数时，除了不需要写第一个参数的参数名之外，其他参数都需要写参数名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(number1:Int, number2:Int, number3:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number are <span class="subst">\(number1)</span>, <span class="subst">\(number2)</span>, <span class="subst">\(number3)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printNumbers(<span class="number">5</span>, number2:<span class="number">10</span>, number3:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p>另外，函数最重要的一点就是返回值。如果需要函数有返回值，你就要指定返回值的类型，同时，返回值由<code>return</code>关键字返回。</p>
<p>举个例子：你需要写一个函数，实现返回两个数字中更大者的功能。大体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">maxOfNumbers</span><span class="params">(number1: Int, number2: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">        <span class="keyword">return</span> number2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">maxOfNumbers(<span class="number">5</span>, number2: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为 10。</p>
<h2 id="接下来该干什么">接下来该干什么</h2><p>现在已经基本熟悉 Swift 中大部分的基本语法了。这对之后的学习是个很重要的基础。接下来可以自己动手在 Playground 里试着写一些小功能，也可以看看关于本文知识点的其他文章：</p>
<ul>
<li><a href="http://www.thomashanning.com/should-you-use-objective-c-or-swift/" target="_blank" rel="external">该使用 Objective-C 还是 Swift？</a></li>
<li><a href="http://www.thomashanning.com/constants-in-swift/" target="_blank" rel="external">Swift 中的常量</a></li>
<li><a href="http://www.thomashanning.com/optionals-in-swift/" target="_blank" rel="external">Swift 中的可选类型</a></li>
</ul>
<p>在本系列的后续部分，我们会讨论更多关于 Swift 的新特性。请继续关注!</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-tutorial-for-beginners-part-1/">原文链接</a>，原文日期：2015-10-29<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 是苹果官方新推出的编程语言，它可以为 iOS、 watchOS、 tvOS 和 Mac OS 开发应用。在本教程中，你将会学到所有的基础操作。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数和方法命名规范]]></title>
    <link href="http://swiftggteam.github.io/2015/11/12/naming-methods-and-functions/"/>
    <id>http://swiftggteam.github.io/2015/11/12/naming-methods-and-functions/</id>
    <published>2015-11-12T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/08/31/naming-methods-and-functions/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-31<br>译者：<a href="http://weibo.com/u/2916092907" target="_blank" rel="external">天才175</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p>请各位随意批判。同时请看<a href="https://realm.io/news/swift-summit-swifty-methods-clarity-brevity/" target="_blank" rel="external">这里</a>和<a href="http://radex.io/swift/methods/" target="_blank" rel="external">这里</a>。</p>
<p><strong>简单明了</strong>。根据上下文给动词和介词加上名词。请使用<code>removeObject(object, atIndex: index)</code>，而不是<code>remove(object, at: index)</code>。不要为了过度的简洁而影响清晰准确性。</p>
<a id="more"></a>
<p><strong>避免缩写</strong>。使用<code>printError(myError)</code>而不是<code>printErr(myErr)</code>以及<code>setBackgroundImage(myImage)</code>而不是<code>setBGImage(myImg)</code>。虽然苹果提供了一系列“可接受”的缩写，但是请不要在 Swift 中使用像 max 和 min 这样的缩写。</p>
<p><strong>避免歧义</strong>。考虑一下函数或者方法的命名是否存在多种解释。举个栗子，在<code>displayName</code>中，display 是名词还是动词呢？如果命名不清晰的话，请重新命名来消除混淆。</p>
<p><strong>保持一致性</strong>。在你的应用和库中使用相同的术语来描述概念。避免在一个方法里使用<code>fetchBezierElements()</code>，却在另外一个里使用<code>listPathComponents()</code>。</p>
<p><strong>不要引用类型关键字</strong>。避免命名中出现 struct、enum、class、instance 以及 object。请使用<code>buildDeckofCards()</code>而不是<code>buildDeckofCardsStruct()</code>。</p>
<p><strong>方法命名使用小写</strong>。虽然大多数开发者使用小写命名全局函数，但你可以大写，这并不是什么罪过。虽然这种函数命名过时了，但大写的函数名却能立刻将函数与方法区别开来。有一段时间我也改变过想法，但是最终还是决定奋起抗争，使用小写。这种做法曾经和命名空间一样普及，但是突然间就销声匿迹了。就像一百万个喊着大写的人突然沉默。</p>
<p><strong>省略”get”</strong>。获取状态信息的函数应该描述他们要返回的东西。请使用<code>extendedExecutionIsEnabled()</code>或<code>isExtendedExecutionEnabled()</code>而不是<code>getExtendedExecutionIsEnabled()</code>。通过参数返回数据的函数例外。</p>
<p><strong>使用标签描述参数</strong>。建议结合函数名和标签来描述函数本身，这样创建出来的会是包括介词（with、of、between 等等）的描述符。你会”construct color with red, green, and blue”（译者注：使用红绿蓝构建颜色），测试”length of string”（译者注：字符串的长度），或者”test equality between x and y”（译者注：判断 x 和 y 是否相等）。</p>
<p>好的函数名和标签可以告诉人们如何使用函数。结果会是自文档化，不用依靠记忆或查找来确定需要传入的参数。请使用<code>withTag:</code>而不是<code>tag:</code>。</p>
<p><strong>使用介词，避免”and”</strong>。<code>And</code> 是 Apple 特别声称要避免的一个词。避免使用”view and position”，使用”view, position”。 </p>
<p>如果你必须使用<code>and</code>，请确保一组参数有语义联系，如使用”red, green and blue”构建颜色。哪怕之后调整了关键字，也显然不可能中断这些项的联系。在这种情况下，即使是代码洁癖患者也不会认为你的代码有问题。</p>
<p>Apple 支持使用 and 的一个例子是在一个方法中描述两种截然不同的动作，比如<code>openFile(withApplication:, andDeactivate:)</code>。</p>
<p><strong>在基于类型的名字后面加上<code>value</code> </strong>。请使用<code>toIntValue</code>而不是<code>toInt</code>，以及<code>withCGRectValue</code>而不是<code>withCGRect</code>。</p>
<p><strong>使用美国标准短语</strong>。由于这些词是由 Apple 提供的，请使用 initialize 而不是 initialise 以及 color 而不是 colour。</p>
<p><strong>有疑惑，找 Apple</strong>。使用相似的概念搜索 Apple API 接口并模仿其方法签名。尽量参考 Objective-C  命名，因为 Swift 中的 Apple API 并没有全部通过人工审查。自动转换过来的 API 可能并不是一个好例子。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/08/31/naming-methods-and-functions/">原文链接</a>，原文日期：2015-08-31<br>译者：<a href="http://weibo.com/u/2916092907">天才175</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p>请各位随意批判。同时请看<a href="https://realm.io/news/swift-summit-swifty-methods-clarity-brevity/">这里</a>和<a href="http://radex.io/swift/methods/">这里</a>。</p>
<p><strong>简单明了</strong>。根据上下文给动词和介词加上名词。请使用<code>removeObject(object, atIndex: index)</code>，而不是<code>remove(object, at: index)</code>。不要为了过度的简洁而影响清晰准确性。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Swift 2.0 当中使用 C 语言回调]]></title>
    <link href="http://swiftggteam.github.io/2015/11/11/c-callbacks-in-swift/"/>
    <id>http://swiftggteam.github.io/2015/11/11/c-callbacks-in-swift/</id>
    <published>2015-11-11T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.802Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/06/c-callbacks-in-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-06-22<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>更新:</p>
</blockquote>
<ul>
<li><p>2015-06-25<br>增加关于传递另一个（可以捕获外部变量的）闭包到 <code>userInfo</code> 参数的备注。</p>
</li>
<li><p>2015-07-01<br>针对 Xcode 7 beta 2 更新从 <code>CGPathElement</code> 创建一个 <code>PathElement</code> 类型的代码。</p>
</li>
</ul>
<p>几年前，我曾经写过一篇关于如何获取 <code>CGPath</code> 和 <code>UIBezierPath</code> 中元素的<a href="http://oleb.net/blog/2012/12/accessing-pretty-printing-cgpath-elements/" target="_blank" rel="external">文章</a>。可以通过调用 <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGPath/index.html#//apple_ref/c/func/CGPathApply" target="_blank" rel="external">CGPathApply</a> 函数，并给这个函数传入一个回调的函数指针来达到这个目的。 随后 <code>CGPathApply</code> 会对 path(CGPath 或 UIBezierPath) 中的每一个元素调用这个回调函数。  </p>
<a id="more"></a>
<p>很不幸，我们无法在 Swift 1.x 中做到这件事，因为我们没办法将 Swift 函数桥接到 C 语言函数。我们需要使用 C 或者 Objective-C 写一个小小的包装层来对这个回调函数进行封装。</p>
<p>而在 Swift 2 当中，可以直接使用原生的 Swift 来完成这件事。Swift 将 C 语言的函数指针<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html" target="_blank" rel="external">作为闭包来导入</a>。在任何需要传入 C 语言函数指针的地方，我们都可以传入与该函数指针参数相匹配的 Swift 闭包或者函数 —— 除了一个特殊情况：与闭包不同的是，C 语言的函数指针没有捕获状态(capturing state)的概念。因此，编译器只允许传入不捕获任何外部变量的 Swift 闭包来对C语言函数指针进行桥接。Swift 使用了新的 <code>@convention(c)</code> 注解来标识这一约定。</p>
<blockquote>
<p>下载本篇文章的<a href="http://oleb.net/media/c-callbacks-in-swift.playground.zip" target="_blank" rel="external">playground</a>，要求 Swift 2/Xcode 7。</p>
</blockquote>
<h2 id="获取_UIBezierPath_中的元素">获取 UIBezierPath 中的元素</h2><p>让我们使用迭代一个 path 中元素这个熟悉的任务来作为例子。</p>
<h3 id="一个_Swift_化后的数据结构">一个 Swift 化后的数据结构</h3><p>首先，考虑一下我们必须处理的数据结构。<code>CGPathApply</code> 会将一个 <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGPath/index.html#//apple_ref/c/tdef/CGPathElement" target="_blank" rel="external">CGPathElement</a> 的指针传递给回调函数（或者闭包）。<code>CGPathElement</code> 是一个结构体，这个结构体包含了一个标识 path 元素类型的的常量，以及一个 <code>CGPoint</code> 类型的C语言数组。这个数组中的点(point)的个数将在 0 到 3 之间，取决于元素的类型。</p>
<p>在 Swift 当中直接使用 <code>CGPathElement</code> 很不方便。C语言数组在 Swift 中是被当作 <code>UnsafeMutablePointer&lt;CGPoint&gt;</code> 来导入的，并且它的生命周期被限制在该回调函数中，因此，如果想在别的地方使用这个数组，我们就得将它的内容复制并保存。更进一步地，如果有一个更安全的方式来获取每个元素中点(point)的个数就更好了。</p>
<p>一个关联了点(point)个数的 Swift 枚举，会是达到这个目的的理想类型。我们同时还要定义一个从 <code>CGPathElement</code> 转换的自定义构造器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A Swiftified representation of a `CGPathElement`</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Simpler and safer than `CGPathElement` because it doesn’t use a</span></span><br><span class="line"><span class="comment">/// C array for the associated points.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PathElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MoveToPoint</span>(<span class="type">CGPoint</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AddLineToPoint</span>(<span class="type">CGPoint</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AddQuadCurveToPoint</span>(<span class="type">CGPoint</span>, <span class="type">CGPoint</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AddCurveToPoint</span>(<span class="type">CGPoint</span>, <span class="type">CGPoint</span>, <span class="type">CGPoint</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">CloseSubpath</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(element: <span class="type">CGPathElement</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> element.type &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">MoveToPoint</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">MoveToPoint</span>(element.points[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">AddLineToPoint</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">AddLineToPoint</span>(element.points[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">AddQuadCurveToPoint</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">AddQuadCurveToPoint</span>(element.points[<span class="number">0</span>], element.points[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">AddCurveToPoint</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">AddCurveToPoint</span>(element.points[<span class="number">0</span>], element.points[<span class="number">1</span>], element.points[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">CloseSubpath</span>:</span><br><span class="line">            <span class="keyword">self</span> = .<span class="type">CloseSubpath</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，为我们的新数据类型定义一个格式化的输出，这将使我们调试时更加方便：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PathElement</span> : <span class="title">CustomDebugStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">MoveToPoint</span>(point):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(point.x)</span> <span class="subst">\(point.y)</span> moveto"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">AddLineToPoint</span>(point):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(point.x)</span> <span class="subst">\(point.y)</span> lineto"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">AddQuadCurveToPoint</span>(point1, point2):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(point1.x)</span> <span class="subst">\(point1.y)</span> <span class="subst">\(point2.x)</span> <span class="subst">\(point2.y)</span> quadcurveto"</span></span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">AddCurveToPoint</span>(point1, point2, point3):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(point1.x)</span> <span class="subst">\(point1.y)</span> <span class="subst">\(point2.x)</span> <span class="subst">\(point2.y)</span> <span class="subst">\(point3.x)</span> <span class="subst">\(point3.y)</span> curveto"</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">CloseSubpath</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"closepath"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接再厉，来将 <code>PathElement</code> 实现为可比较的(Equatable)（因为我们<a href="https://developer.apple.com/videos/wwdc/2015/?id=414" target="_blank" rel="external">始终应该这样做</a>）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PathElement</span> : <span class="title">Equatable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> ==<span class="params">(lhs: PathElement, rhs: PathElement)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(lhs, rhs) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">MoveToPoint</span>(l), .<span class="type">MoveToPoint</span>(r)):</span><br><span class="line">        <span class="keyword">return</span> l == r</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">AddLineToPoint</span>(l), .<span class="type">AddLineToPoint</span>(r)):</span><br><span class="line">        <span class="keyword">return</span> l == r</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">AddQuadCurveToPoint</span>(l1, l2), .<span class="type">AddQuadCurveToPoint</span>(r1, r2)):</span><br><span class="line">        <span class="keyword">return</span> l1 == r1 &amp;&amp; l2 == r2</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">AddCurveToPoint</span>(l1, l2, l3), .<span class="type">AddCurveToPoint</span>(r1, r2, r3)):</span><br><span class="line">        <span class="keyword">return</span> l1 == r1 &amp;&amp; l2 == r2 &amp;&amp; l3 == r3</span><br><span class="line">    <span class="keyword">case</span> (.<span class="type">CloseSubpath</span>, .<span class="type">CloseSubpath</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, <span class="number">_</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举_Path_元素">枚举 Path 元素</h3><p>现在到了有趣的部分了。我们要对 <code>UIBezierPath</code> 增加一个名为 <code>elements</code> 的计算属性，它会迭代 path 并且返回一个 <code>PathElement</code> 类型的数组。我们需要调用 <code>CGPathApply()</code> 并传递给它一个闭包参数，它会对每个元素都调用这个闭包。在这个闭包内部，我们需要将 <code>CGPathElement</code> 转化为 <code>PathElement</code> 并将它存储在一个数组当中。 最后一部分的实现并不像听起来的那么简单，因为 C 函数指针的调用约定不允许我们对外部上下文中的变量进行捕获。</p>
<p>这个 API 的纯 C 实现也面临着同样的问题，因此 <code>CGPathApply</code> 接收了一个额外的 <code>void *</code> 类型的参数并将这个指针传递给回调函数。这使得调用者可以传递一个任意类型的数据（比如一个指向数组的指针）给回调函数 —— 这正是我们所需要的。</p>
<p><code>void *</code> 类型在 Swift 当中是被作为 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_UnsafeMutablePointer_Structure/" target="_blank" rel="external">UnsafeMutablePointer<void></void></a> 引入的。我们先创建一个 Swift 数组用于存储 <code>PathElement</code> 的值，然后使用 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Functions/index.html#//apple_ref/swift/func/s:FSs24withUnsafeMutablePointeru0_rFTRq_FGVSs20UnsafeMutablePointerq__q0__q0_" target="_blank" rel="external">withUnsafeMutablePointer()</a> 来获得指向这个数组的指针，这个指针会作为参数传递到该函数的闭包中。在该闭包当中，我们就可以开始调用 <code>CGPathApply</code>。在 <code>CGPathApply</code> 的内部闭包中最后一步是要将 void 指针转型回 <code>UnsafeMutablePointer&lt;[PathElement]&gt;</code>，并通过 <code>memory</code> 属性来直接获取底层的数组。（注：我不是很确定这是不是将一个数组传递到闭包中的最好方法，如果你知道有更好的方法，请让我知道）</p>
<p>完整的实现看起来是这样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: [<span class="type">PathElement</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> pathElements = [<span class="type">PathElement</span>]()</span><br><span class="line">        <span class="built_in">withUnsafeMutablePointer</span>(&amp;pathElements) &#123; elementsPointer <span class="keyword">in</span></span><br><span class="line">            <span class="type">CGPathApply</span>(<span class="type">CGPath</span>, elementsPointer) &#123; (userInfo, nextElementPointer) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> nextElement = <span class="type">PathElement</span>(element: nextElementPointer.memory)</span><br><span class="line">                <span class="keyword">let</span> elementsPointer = <span class="type">UnsafeMutablePointer</span>&lt;[<span class="type">PathElement</span>]&gt;(userInfo)</span><br><span class="line">                elementsPointer.memory.append(nextElement)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pathElements</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新：在<a href="https://forums.developer.apple.com/message/15725#15725" target="_blank" rel="external">苹果开发者论坛中的一个帖子</a>里，苹果员工 Quinn “The Eskimo!” 提出了一个稍微不同的方法：我们可以传递指向另一个闭包的指针给 <code>userInfo</code> 参数，而非我们想要操作的数组的指针。因为这个闭包没有被C调用约定所限制，因此它是可以捕获外部变量的。</p>
<p>创建一个闭包的指针会涉及到丑陋的 <code>@convention(block)</code> 注解和 <code>unsafeBitCast</code> 魔法（或者是将闭包包装到一个包装类型中），我不太确定我是否会喜欢这种形式。不过使用这种方法确实是相当方便的。</p>
<h2 id="收尾">收尾</h2><p>现在，我们有了一个包含 path 元素的数组，很自然地，我们会想要将 UIBezierPath 转化成一个序列。这使得用户可以使用 <code>for-in</code> 循环来对 path 进行迭代，或者直接对它调用 <code>map</code> 或 <code>filter</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> : <span class="title">SequenceType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">AnyGenerator</span>&lt;<span class="type">PathElement</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">anyGenerator</span>(elements.generate())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，这是一个便于 UIBezierPath 调试的格式化输出的实现，这个实现参考了 OS X 上的 NSBezierPath 的输出格式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIBezierPath</span> : <span class="title">CustomDebugStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cgPath = <span class="keyword">self</span>.<span class="type">CGPath</span>;</span><br><span class="line">        <span class="keyword">let</span> bounds = <span class="type">CGPathGetPathBoundingBox</span>(cgPath);</span><br><span class="line">        <span class="keyword">let</span> controlPointBounds = <span class="type">CGPathGetBoundingBox</span>(cgPath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> description = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>)</span>\n"</span></span><br><span class="line">            + <span class="string">"    Bounds: <span class="subst">\(bounds)</span>\n"</span></span><br><span class="line">            + <span class="string">"    Control Point Bounds: <span class="subst">\(controlPointBounds)</span>"</span></span><br><span class="line">            + elements.<span class="built_in">reduce</span>(<span class="string">""</span>, combine: &#123; (acc, element) <span class="keyword">in</span></span><br><span class="line">                acc + <span class="string">"\n    <span class="subst">\(String(reflecting: element)</span>)"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">return</span> description</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在用一个示例 path 来进行一下试验：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> path = <span class="type">UIBezierPath</span>()</span><br><span class="line">path.moveToPoint(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>))</span><br><span class="line">path.addLineToPoint(<span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">0</span>))</span><br><span class="line">path.addLineToPoint(<span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">100</span>))</span><br><span class="line">path.closePath()</span><br><span class="line">path.moveToPoint(<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">100</span>))</span><br><span class="line">path.addQuadCurveToPoint(<span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>),</span><br><span class="line">    controlPoint: <span class="type">CGPoint</span>(x: <span class="number">50</span>, y: <span class="number">200</span>))</span><br><span class="line">path.closePath()</span><br><span class="line">path.moveToPoint(<span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">0</span>))</span><br><span class="line">path.addCurveToPoint(<span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">0</span>),</span><br><span class="line">    controlPoint1: <span class="type">CGPoint</span>(x: <span class="number">125</span>, y: <span class="number">100</span>),</span><br><span class="line">    controlPoint2: <span class="type">CGPoint</span>(x: <span class="number">175</span>, y: -<span class="number">100</span>))</span><br><span class="line">path.closePath()</span><br></pre></td></tr></table></figure>
<p><img src="/img/articles/c-callbacks-in-swift/uibezierpath-example.png1447203254.48282" alt="The example path"></p>
<p>也可以迭代 path 中的每一个元素，然后打印出每个元素的描述(description)字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> path &#123;</span><br><span class="line">    <span class="built_in">debugPrint</span>(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">0.0 0.0 moveto</span><br><span class="line">100.0 0.0 lineto</span><br><span class="line">50.0 100.0 lineto</span><br><span class="line">closepath</span><br><span class="line">0.0 100.0 moveto</span><br><span class="line">50.0 200.0 100.0 100.0 quadcurveto</span><br><span class="line">closepath</span><br><span class="line">100.0 0.0 moveto</span><br><span class="line">125.0 100.0 175.0 -100.0 200.0 0.0 curveto</span><br><span class="line">closepath</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>或者，我们也可以计算 path 中的闭合路径(closepath)的个数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> closePathCount = path.<span class="built_in">filter</span> &#123;</span><br><span class="line">        element <span class="keyword">in</span> element == <span class="type">PathElement</span>.<span class="type">CloseSubpath</span></span><br><span class="line">    &#125;.<span class="built_in">count</span></span><br><span class="line"><span class="comment">// -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>Swift 2 中自动地将 C 语言函数指针桥接到为闭包。这使得对大量的接收函数指针的 C 语言API 进行操作成为可能（并且相当方便）。因为 C 语言的调用约定，这种类型的闭包无法捕获外部的状态，所以我们经常需要将回调闭包中需要用到的数据通过一个外部的 <code>void</code> 类型的指针传入，而这正是很多基于C语言的 API 的做法。在 Swift 当中进行这样的操作会有点绕，不过却是完全可能的。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/06/c-callbacks-in-swift/">原文链接</a>，原文日期：2015-06-22<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>更新:</p>
</blockquote>
<ul>
<li><p>2015-06-25<br>增加关于传递另一个（可以捕获外部变量的）闭包到 <code>userInfo</code> 参数的备注。</p>
</li>
<li><p>2015-07-01<br>针对 Xcode 7 beta 2 更新从 <code>CGPathElement</code> 创建一个 <code>PathElement</code> 类型的代码。</p>
</li>
</ul>
<p>几年前，我曾经写过一篇关于如何获取 <code>CGPath</code> 和 <code>UIBezierPath</code> 中元素的<a href="http://oleb.net/blog/2012/12/accessing-pretty-printing-cgpath-elements/">文章</a>。可以通过调用 <a href="https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CGPath/index.html#//apple_ref/c/func/CGPathApply">CGPathApply</a> 函数，并给这个函数传入一个回调的函数指针来达到这个目的。 随后 <code>CGPathApply</code> 会对 path(CGPath 或 UIBezierPath) 中的每一个元素调用这个回调函数。  </p>]]>
    
    </summary>
    
      <category term="Ole Begemann" scheme="http://swiftggteam.github.io/tags/Ole-Begemann/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 NSUndoManager 来进行撤销和重做]]></title>
    <link href="http://swiftggteam.github.io/2015/11/10/ios-undo-and-redo-with-nsundomanager/"/>
    <id>http://swiftggteam.github.io/2015/11/10/ios-undo-and-redo-with-nsundomanager/</id>
    <published>2015-11-10T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-undo-and-redo-with-nsundomanager/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-13<br>译者：<a href="http://blog.csdn.net/yake_099" target="_blank" rel="external">Yake</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<p>在相当长的一段时间内 NSUndoManager 对我来说都是一个很神秘的东西。我想学习使用它，但是一直没有时间。一直到今天，我写了一个简单的应用，这个应用创建了一个可以移动的矩形，并且还可以修改矩形的属性，例如背景色或者圆角。</p>
<a id="more"></a>
<p>你可以在<a href="https://github.com/tomkowz/undo-manager-practice" target="_blank" rel="external">这儿</a>获取到示例应用<br><a href="https://youtu.be/3Pk85X8bugk" target="_blank" rel="external">这儿</a>是一段小视频，你可以看看这个示例应用是怎么工作的。</p>
<p><img src="/img/articles/ios-undo-and-redo-with-nsundomanager/Screen-Shot-2015-09-13-at-17.24.19.png1447290433.4454885" alt="Screen-Shot-2015-09-13-at-17.24.19.png"></p>
<h2 id="NSUndoManager">NSUndoManager</h2><p><code>NSUndoManager</code>允许记录用户执行的操作并且反转这类操作。</p>
<p>当你调用一个可以改变一些东西的方法或者是执行一个改变属性值的动作（例如 setter 方法）时，你可以注册这个操作来进行撤销。</p>
<p>一个撤销操作包含了接收消息的对象，发送消息以及参数 - 通常你会传入原始值。</p>
<p><code>NSUndoManager</code>实例支持重做操作，所以才能逆转操作。你可以认为这个管理器拥有两个栈。实际上，它管理两个栈，<code>undo</code>(撤销)栈和<code>redo</code>（重做）栈 - 对应<code>NSUndoManager</code>的私有属性<code>_undoStack</code>和<code>_redoStack</code>，里面存储着一些操作。</p>
<p>注册<code>undo</code>操作时，它会被添加到<code>undo</code>栈中。当调用<code>undo()</code>方法时管理器就会进行撤销，执行栈中的操作并把这个操作移动到<code>redo</code>栈中，这样你就可以重做它。当你拥有多个<code>undo</code>操作时，按照逆序来撤销和重做这些操作。你肯定不会将操作直接注册到<code>redo</code>栈中，实际上这根本无法实现。</p>
<p>你可以为<code>undo</code>操作设置一个级别，这指的是一个管理器可以在它的栈中存储多少<code>undo</code>操作。如果添加的<code>undo</code>操作数量超过了这个级别，最早加入的那个操作将会从栈中移除。</p>
<p>你可以通过<code>canUndo</code>和<code>canRedo</code>来检查<code>undo</code>和<code>redo</code>栈的状态。这些状态很重要，你可能会基于这些栈的状态来更新 UI。</p>
<p>假设你已经设置了<code>undo</code>操作的级别并且<code>redo</code>栈中还有一个操作，如果<code>undo</code>操作超过了这个级别，那你就需要使用<code>canUndo</code>和<code>canRedo</code>来检测可用性。之所以要这样做，是因为在这种情况下<code>NSUndoManager</code>将会移除<code>redo</code>操作，因为它是历史操作中最新的<code>undo</code>操作。（校对注：这里确实很绕，大家可以类比一下编辑器的撤销和重做操作，如果你在撤销之后进行了新的改动，那之前撤销过的操作其实已经无法再被重做了，因此可以被直接删掉，从而把更多的空间留给<code>undo</code>操作。）</p>
<h2 id="注册undo操作">注册<code>undo</code>操作</h2><p>API提供了两种注册操作的方法。</p>
<p>第一种是使用<code>registerUndoWithTarget(_:selector:object:)</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerUndoAddFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    undoManager.registerUndoWithTarget(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(“removeFigure:”), object: figure)</span><br><span class="line">    undoManager.setActionName(“<span class="type">Add</span> <span class="type">Figure</span>”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种撤销方法是基于<code>NSInvocation</code>。你可以使用<code>prepareWithInvocationTarget(_:)</code>方法来注册此类操作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerUndoAddFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    undoManager.prepareWithInvocationTarget(<span class="keyword">self</span>).removeFigure(figure)</span><br><span class="line">    undoManager.setActionName(<span class="string">"Add Figure"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你将会得到一个<code>NSUndoManagerProxy</code>类型对象，可以用它调用任何方法（但是只能调用目标对象遵守的那些协议方法，否则应用会抛出运行时异常）。注册之后代理对象将会在内部创建<code>NSInvocation</code>对象来记录你的操作，这个对象会在传入的目标对象执行<code>undo</code>操作时被调用。</p>
<p>值得强调的是，在注册过程中目标对象没有被持有，需要你去管理它。如果<code>undo</code>操作被调用而目标对象已经被销毁，就会产生运行时异常。</p>
<p>当对象将要被销毁时你需要调用<code>removeAllActionsWithTarget(_:)</code>来移除与目标对象相关联的一些操作，或者调用<code>removeAllActions()</code>来移除<code>undo</code>和<code>redo</code>栈中所有的操作</p>
<h2 id="将操作分组">将操作分组</h2><p>分组操作是一件很有用的事情。默认情况下操作是通过事件进行分组的。这就意味着操作将会通过每一轮运行时循环来分组。你可以关闭自动分组，调用<code>beginUndoGrouping()</code>和<code>endUndoGrouping()</code>方法来手动操作分组。</p>
<h2 id="命名并显示操作">命名并显示操作</h2><p><code>NSUndoManager</code>支持存储操作的名称。你可以调用<code>setActionName(_:)</code>方法来为操作命名。管理器已经包含<code>Undo</code>和<code>Redo</code>这两个单词的多语言版本，可以使用 API 直接获取对应语言的<code>Undo/Redo</code>字符串。</p>
<p>下面这个方法来自示例应用，每一个新的<code>undo</code>操作被注册或者<code>undo``redo</code>操作被执行之后，将会更新<code>undo</code>和<code>redo</code>按钮。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">updateUndoAndRedoButtons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    undoButton.enabled = undoManager.canUndo == <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> undoManager.canUndo &#123;</span><br><span class="line">        undoButton.setTitle(undoManager.undoMenuTitleForUndoActionName(undoManager.undoActionName), forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        undoButton.setTitle(undoManager.undoMenuItemTitle, forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    redoButton.enabled = undoManager.canRedo == <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> undoManager.canRedo &#123;</span><br><span class="line">        redoButton.setTitle(undoManager.redoMenuTitleForUndoActionName(undoManager.redoActionName), forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redoButton.setTitle(undoManager.redoMenuItemTitle, forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通知">通知</h2><p>管理器有几个你可以观察的通知类型。在示例应用中我关注的是<code>NSUndoManagerDidUndoChangeNotification</code>和<code>NSUndoManagerDidRedoChangeNotification</code>。为了让应用完美运行，我可能需要观察所有<code>will</code>或者<code>did</code>类型的通知，因为操作可能要执行一段时间，并且一部分代码可能是异步的。在这些情况下应用要正确展示 UI 就需要使用这些通知来刷新<code>Undo</code>和<code>Redo</code>按钮。</p>
<h2 id="上下文">上下文</h2><p>应用在不同的上下文中可能有不同的管理器。示例应用在不同的上下文中用了两个管理器。</p>
<p>第一个上下文是块展板，展板用来展示矩形并且可以在上面移动这个矩形。在这个展板上下文中可能发生的操作就是添加、移动或者移除一个矩形。</p>
<p>第二个上下文是这个矩形自己。你可以改变它的颜色和圆角。我决定追踪展板的背景色以及圆角，忽略掉它在展板中的位置。</p>
<p>这样你就可以添加一个矩形，移动它，改变它的颜色和圆角，使用<code>undo</code>来撤销移动操作但是不会撤销掉背景色和圆角的改变。你所使用的上下文数量取决于你的应用是怎么样的。</p>
<h2 id="响应链">响应链</h2><p>每一个<code>UIView</code>对象继承自<code>UIResponder</code>类型，这个类定义了响应对象的接口并且处理事件。</p>
<p><code>UIResponder</code>类声明了<code>undoManager</code>属性。当应用接收到<code>undo</code>事件，<code>UIResponder</code>搭建起响应者链并通过<code>undoManager</code>返回一个<code>NSUndoManager</code>类型的对象来找到这个响应者。找到的第一个响应者将被用来处理<code>undo</code>或者<code>redo</code>操作。</p>
<p>为了使用响应者链你需要重载<code>canBecomeFirstResponder()</code>属性并且设置返回值为<code>true</code>，然后通过调用<code>becomeFirstResponder()</code>方法使持有<code>undoManager</code>的对象成为第一响应者。如果你已经正确设置好了一切，可以执行一个摇晃手势，应用会出现一个警告框询问你是否要执行<code>undo</code>操作。</p>
<p><img src="/img/articles/ios-undo-and-redo-with-nsundomanager/undo-event.png1447290437.6564598" alt="图片二.png"></p>
<h2 id="示例代码">示例代码</h2><p>当我写这个示例代码的时候我注意自己花费了很多时间去考虑“具有唯一目的”的方法。当你需要支持撤销和重做操作时这其实很重要，因为你调用那些方法就是出于特定的目的。</p>
<p>下面的示例代码来自那个示例应用，它展示了在展板中的添加，移除以及移动操作都是怎么实现的。下面是所有与<code>undo manager</code>相关的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MARK: Actions on Figures</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    registerUndoAddFigure(figure)</span><br><span class="line">    </span><br><span class="line">    boardView.addSubview(figure)</span><br><span class="line">    figures.append(figure)</span><br><span class="line">    </span><br><span class="line">    updateUndoAndRedoButtons()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">removeFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    registerUndoRemoveFigure(figure)</span><br><span class="line">    </span><br><span class="line">    figure.removeFromSuperview()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = figures.indexOf(figure) &#123;</span><br><span class="line">        figures.removeAtIndex(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">moveFigure</span><span class="params">(figure: FigureView, center: CGPoint)</span></span> &#123;</span><br><span class="line">    registerUndoMoveFigure(figure)</span><br><span class="line">    figure.center = center</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// MARK: Undo Manager</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">canBecomeFirstResponder</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _undoManager = <span class="type">NSUndoManager</span>()</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> undoManager: <span class="type">NSUndoManager</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _undoManager</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">observeUndoManager</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"updateUndoAndRedoButtons"</span>), name: <span class="type">NSUndoManagerDidUndoChangeNotification</span>, object: undoManager)</span><br><span class="line">    <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"updateUndoAndRedoButtons"</span>), name: <span class="type">NSUndoManagerDidRedoChangeNotification</span>, object: undoManager)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">@objc</span> <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">updateUndoAndRedoButtons</span><span class="params">()</span></span> &#123;</span><br><span class="line">    undoButton.enabled = undoManager.canUndo == <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> undoManager.canUndo &#123;</span><br><span class="line">        undoButton.setTitle(undoManager.undoMenuTitleForUndoActionName(undoManager.undoActionName), forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        undoButton.setTitle(undoManager.undoMenuItemTitle, forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    redoButton.enabled = undoManager.canRedo == <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> undoManager.canRedo &#123;</span><br><span class="line">        redoButton.setTitle(undoManager.redoMenuTitleForUndoActionName(undoManager.redoActionName), forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redoButton.setTitle(undoManager.redoMenuItemTitle, forState: .<span class="type">Normal</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// MARK: Undo Manager Actions</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerUndoAddFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    undoManager.prepareWithInvocationTarget(<span class="keyword">self</span>).removeFigure(figure)</span><br><span class="line">    undoManager.setActionName(<span class="string">"Add Figure"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerUndoRemoveFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    undoManager.prepareWithInvocationTarget(<span class="keyword">self</span>).addFigure(figure)</span><br><span class="line">    undoManager.setActionName(<span class="string">"Remove Figure"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerUndoMoveFigure</span><span class="params">(figure: FigureView)</span></span> &#123;</span><br><span class="line">    undoManager.prepareWithInvocationTarget(<span class="keyword">self</span>).moveFigure(figure, center: figure.center)</span><br><span class="line">    undoManager.setActionName(<span class="string">"Move to <span class="subst">\(figure.center)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我创建了一些<code>undo</code>相关的简单方法。这样做效果很好，注册<code>undo</code>操作的逻辑和操作本身的逻辑相分离，代码精简为一句函数调用。</p>
<p>我决定放弃使用<code>registerUndoWithTarget(_:selector:object:)</code>方法，因为<code>Selector</code>是一个字符串，这样做很危险。而<code>prepareWithInvocationTarget(_:)</code>看起来更好一些，既安全又便于使用。</p>
<p>不过，当你需要设置属性时可能要用带<code>Selector</code>的方法。</p>
<p>你需要直接调用想要记录的方法，但是这样做不能设置属性（因为只能调用方法）。有两种解决方法：第一种是添加类似<code>setPropertyName(_:)</code>的方法，第二种是使用<code>registerUndoWithTarget(_:selector:object:)</code>方法并将<code>Selector</code>设置为<code>setPropertyName:</code>，作为参数传入。</p>
<h2 id="结论">结论</h2><p><code>NSUndoManager</code>是一种强大的机制，我们可以简单地向应用中加入<code>undo</code>和<code>redo</code>方法。它需要你谨慎地设计应用的结构，因为你需要使用“具有唯一目的性”的方法来将用户的操作设置为<code>undo</code>或者是<code>redo</code>。但是总体来说这是个好事，不是吗？这会改善代码设计。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-undo-and-redo-with-nsundomanager/">原文链接</a>，原文日期：2015-09-13<br>译者：<a href="http://blog.csdn.net/yake_099">Yake</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<p>在相当长的一段时间内 NSUndoManager 对我来说都是一个很神秘的东西。我想学习使用它，但是一直没有时间。一直到今天，我写了一个简单的应用，这个应用创建了一个可以移动的矩形，并且还可以修改矩形的属性，例如背景色或者圆角。</p>]]>
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="http://swiftggteam.github.io/tags/Tomasz-Szulc/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[好代码是怎样炼成的]]></title>
    <link href="http://swiftggteam.github.io/2015/11/09/what-makes-good-code/"/>
    <id>http://swiftggteam.github.io/2015/11/09/what-makes-good-code/</id>
    <published>2015-11-09T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/10/28/what-makes-good-code/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-28<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>最近有个人发 Email 问我：“好代码是怎样炼成的”。之前，我身体有点不舒服，所以我漫无边际的说了下。现在好多了，所以我想分享一下以下这些想法，因为我觉得这些对于这次重要的讨论来说是一个有趣的起点。</p>
<a id="more"></a>
<p>当时，我写道：</p>
<ul>
<li><p>好代码并不只是可以编译而已，它还会沟通。它会和现在的你交谈，也会和以后维护代码的你交谈。它对于你的团队和任何外部来查看的人来说都是可以被理解的。</p>
</li>
<li><p>好代码对可靠性和可测试性的要求胜过聪明的小技巧。如果需要清晰的表明自己的意图和结果，好代码会更倾向于使用一个或多个额外的步骤来表达。</p>
</li>
<li><p>好代码也考虑其使用程度，一段代码一次跑一百万遍和只跑一遍的要求是不同的，就好比在树林里的一棵树和孤零零的一棵树那样。</p>
</li>
<li><p>好代码即使被分解了也可以成为合理的单元，而不是大规模的单一的实现。</p>
</li>
<li><p>好代码不仅仅是实现一次或两次，而且还要审查和重构。这才有可能让它成为最好的和最健壮的实现。</p>
</li>
<li><p>好代码会考虑到全球化，并提供给不同文化的潜在用户。添加国际化以及相关的可访问性，这些真的是代码层面的事情，而不是嘴上说说的马后炮而已。</p>
</li>
<li><p>好代码不仅仅考虑今天具体运行在什么环境上，也考虑如何适应这些可能随时间变化的环境。</p>
</li>
</ul>
<p>以上是我想到的，你对我关于这个“好代码是怎样炼成的”话题列出的清单有什么想添加、删除、修改的？期待看到你们的想法。</p>
<p><strong>更新</strong></p>
<p>Seivan Heidari 建议添加：好代码会在作为 API 为外面调用时，不提供内部的实现细节。</p>
<p>Anonymous 建议添加：好代码是浑然天成的。好代码可以照你需要的样子执行，且能被按时交付，其余的都是扯蛋哈哈。</p>
<p>Dave DeLong 建议添加：好代码会让读的人产生敬畏，并使读的人受到启发从而也去写自己的好代码。</p>
<p>Paul Cantrell 建议添加：好代码会注意权衡。它会根据工程来权衡,而不是按照绝对的教条。它也不会让工具或技术成为组内状态标记(in-group status markers)。</p>
<p>Rainer Brockerhoff 建议添加：好代码可以被很轻松的重用（即使是在几年之后），也能只用几行代码来进行扩展或改编。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/10/28/what-makes-good-code/">原文链接</a>，原文日期：2015-10-28<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>最近有个人发 Email 问我：“好代码是怎样炼成的”。之前，我身体有点不舒服，所以我漫无边际的说了下。现在好多了，所以我想分享一下以下这些想法，因为我觉得这些对于这次重要的讨论来说是一个有趣的起点。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[If-Let 赋值运算符]]></title>
    <link href="http://swiftggteam.github.io/2015/11/06/if-let-assignment/"/>
    <id>http://swiftggteam.github.io/2015/11/06/if-let-assignment/</id>
    <published>2015-11-06T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Weston Hanners，<a href="http://www.alloc-init.com/2015/10/if-let-assignment/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-29<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>(AKA：你希望使用一个自定义操作符)</p>
<p>有多少次你是以这种匹配模式实现的呢？</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> value = someOptionalValue <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.value = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我一直使用这种方式进行JSON数据解析或者NSCoding的实现。但我觉得这对于Swift来说有点啰嗦，坚信肯定存在某种更好的方式。</p>
<p><a href="http://nshipster.com/swift-operators/" target="_blank" rel="external">NSHipster</a>提出自定义逻辑或赋值运算符(<code>||=</code>)，这看起来很不错。不管怎样，它似乎还未为泛型实现(作者:如果这里我理解错了，请告诉我).我想我可以先试一试…</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ||= &#123; <span class="keyword">associativity</span> <span class="keyword">right</span> <span class="keyword">precedence</span> <span class="number">90</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 译者注: 测试只有加上&lt;T&gt;才能正常运行</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> ||= <span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: T, <span class="keyword">right</span>: T?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123;</span><br><span class="line">        <span class="keyword">left</span> = <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上它能够很好地工作，我将原代码简化如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.value ||= someOptionalValue <span class="keyword">as</span>? <span class="type">String</span></span><br></pre></td></tr></table></figure>
<p>或许这有点微不足道，但是当你需要连续处理一系列任务时，这节省了大量代码，变得更具可读性。</p>
<p>还有件事…我依然尝试去弄清楚这是怎么回事，但我最终定义了第二个方法用于可选类型赋值。而唯一的不同是现在左侧参数类型为<code>T?</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ||= <span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: T?, <span class="keyword">right</span>: T?)</span></span> &#123; <span class="comment">// The left param is now Optional</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="keyword">right</span> &#123;</span><br><span class="line">        <span class="keyword">left</span> = <span class="keyword">right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someOptionalString: <span class="type">String</span>?</span><br><span class="line"></span><br><span class="line">someOptionalString ||= newValue <span class="comment">// Will assign when newValue is not optional</span></span><br></pre></td></tr></table></figure>
<p>如果你有兴趣看看这个，请点击<a href="http://www.alloc-init.com/wp-content/uploads/2015/10/if-let-operator.playground.zip" target="_blank" rel="external">Playground</a>下载。</p>
<p>温馨提示: 文章测试环境是Swift2.0。</p>
<p><strong>更新日志 11/01/2015:</strong></p>
<p>twitter上有人提醒我: ruby中<code>||=</code>等价于<code>left = left || right</code>，与我想要实现的<code>left = right || left</code>不同。我对这种用法不是很了解，为了避免混淆，我可能使用另外一个操作符<code>?=</code>替代。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ?= &#123; <span class="keyword">associativity</span> <span class="keyword">right</span> <span class="keyword">precedence</span> <span class="number">90</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> ?=<span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: T, <span class="keyword">right</span>: T?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value = <span class="keyword">right</span> &#123;</span><br><span class="line">        <span class="keyword">left</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> ?=<span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> <span class="keyword">left</span>: T?, <span class="keyword">right</span>: T?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value = <span class="keyword">right</span> &#123;</span><br><span class="line">        <span class="keyword">left</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Weston Hanners，<a href="http://www.alloc-init.com/2015/10/if-let-assignment/">原文链接</a>，原文日期：2015-10-29<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>(AKA：你希望使用一个自定义操作符)</p>
<p>有多少次你是以这种匹配模式实现的呢？</p>]]>
    
    </summary>
    
      <category term="Weston Hanners" scheme="http://swiftggteam.github.io/tags/Weston-Hanners/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift Playground: 三门问题的解法]]></title>
    <link href="http://swiftggteam.github.io/2015/11/05/swift-playground-the-monty-hall-problem/"/>
    <id>http://swiftggteam.github.io/2015/11/05/swift-playground-the-monty-hall-problem/</id>
    <published>2015-11-05T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-27<br>译者：<a href="https://github.com/SergioChan" target="_blank" rel="external">SergioChan</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p>三门问题是一个超级让人摸不着头脑的概率问题。我们会在 Swift Playground 里来演示它的解法，而不是通过枯燥的数学解释。</p>
<a id="more"></a>
<h2 id="三门问题">三门问题</h2><p>这个问题的核心很简单。在 1990 年的<a href="https://en.wikipedia.org/wiki/Parade_(magazine" target="_blank" rel="external">Parade</a>)杂志中是这么解释的：</p>
<blockquote>
<p>假设你正在参加一个游戏节目，需要在三扇门中选择一扇。其中一扇后面有一辆车，其余两扇后面则是羊。你选择了一扇门，假设是 1 号门，主持人知道门后面是什么，他开启了另一扇后面有羊的门，假设是3号门。然后他问你：“你想选择 2 号门吗？”这时候你改变决策是有利的吗？</p>
</blockquote>
<p>实际上，结果是有利的。如果你选择另外一扇门，你就有2/3的概率赢得汽车。相反，如果你不改变你的选择，赢得汽车的概率就只有 1/3。当然你可以从数学的角度去证明，但是这里我们希望验证一下。</p>
<h2 id="算法">算法</h2><p>算法很简单。首先，你选择一扇门。然后主持人打开一扇后面有羊的门。如果你的第一次选择就选中了有车的门，他就要在剩下两扇门中随机选择一扇开启。如果你的第一次选择选中的是有羊的门，他就要把剩下一扇也是羊的门打开。最后，你是否改变选择取决于你采取的策略。</p>
<h2 id="Playground">Playground</h2><p>我们来编写一个简单的 Playground 程序。我们会对每种选择策略执行 100000 次测试来得出大致的概率。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Change</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Stay</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">play</span><span class="params">(strategy:Strategy,repeats:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wins = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;repeats &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> car = <span class="type">Int</span>(arc4random_uniform(<span class="number">3</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> playerChoice = <span class="type">Int</span>(arc4random_uniform(<span class="number">3</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> strategy == <span class="type">Strategy</span>.<span class="type">Change</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> playerChoice == car &#123;</span><br><span class="line">                <span class="keyword">var</span> remainingDoors = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">                remainingDoors.removeAtIndex(playerChoice)</span><br><span class="line">                playerChoice = remainingDoors[<span class="type">Int</span>(arc4random_uniform(<span class="number">2</span>))]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                playerChoice = car</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> car == playerChoice &#123;</span><br><span class="line">            wins++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wins</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> repeats = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> winsStrategyChange = play(.<span class="type">Change</span>, repeats: repeats)</span><br><span class="line"><span class="keyword">var</span> winsStrategyStay = play(.<span class="type">Stay</span>, repeats: repeats)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> quoteStrategyChange = <span class="type">Double</span>(winsStrategyChange) / <span class="type">Double</span>(repeats)</span><br><span class="line"><span class="keyword">var</span> quoteStrategyStay = <span class="type">Double</span>(winsStrategyStay) / <span class="type">Double</span>(repeats)</span><br></pre></td></tr></table></figure>
<h2 id="结果">结果</h2><p>每次运行这个 Playground 得到的结果都不完全相同，但是都很接近的。例如，其中一次结果是：</p>
<ul>
<li>改变选择且赢得汽车的次数: 66,461</li>
<li>不改变选择且赢得汽车的次数: 33,509</li>
<li>改变选择且赢得汽车的概率: 0,66461</li>
<li>不改变选择且赢得汽车的概率: 0,33509</li>
</ul>
<p>结果正如理论所预计的那样。如果你不改变你的选择，你就只有百分之 33 的概率赢得汽车。如果你改变了你的选择，这个概率就上升到了百分之 66。</p>
<h2 id="结论">结论</h2><p>在 Playground 中做实验是十分有趣的。在这种情况下，我们可以验证那些乍一看摸不着头脑的理论。</p>
<h2 id="引用">引用</h2><p>图片: @ Lim ChewHow / shutterstock.com</p>
<p>维基百科: <a href="https://en.wikipedia.org/wiki/Monty_Hall_problem" target="_blank" rel="external">Monty Hall Problem</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-playground-the-monty-hall-problem/">原文链接</a>，原文日期：2015-09-27<br>译者：<a href="https://github.com/SergioChan">SergioChan</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p>三门问题是一个超级让人摸不着头脑的概率问题。我们会在 Swift Playground 里来演示它的解法，而不是通过枯燥的数学解释。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift：使用本地闭包]]></title>
    <link href="http://swiftggteam.github.io/2015/11/04/swift-using-local-closures/"/>
    <id>http://swiftggteam.github.io/2015/11/04/swift-using-local-closures/</id>
    <published>2015-11-04T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-using-local-closures/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-22<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>闭包一般是用来作为函数的参数。不过某些情况下，使用本地闭包也是十分方便的。</p>
<p>假设有一个 <code>ViewController</code>，里面包含了两种 GUI 模式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GUIMode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mode1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mode2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>对于每一种 GUI 模式，我们都需要对三个 label 设置某些属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> guiMode: <span class="type">GUIMode</span> = .<span class="type">Mode1</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;              </span><br><span class="line">        <span class="keyword">switch</span> guiMode &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Mode1</span>:</span><br><span class="line">            label1.text = <span class="string">"1"</span></span><br><span class="line">            label1.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">            label1.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">10</span>)</span><br><span class="line">                </span><br><span class="line">            label2.text = <span class="string">"2"</span></span><br><span class="line">            label2.textColor = <span class="type">UIColor</span>.blueColor()</span><br><span class="line">            label2.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">12</span>)</span><br><span class="line">                </span><br><span class="line">            label3.text = <span class="string">"3"</span></span><br><span class="line">            label3.textColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">            label3.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">11</span>)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Mode2</span>:</span><br><span class="line">            label1.text = <span class="string">"4"</span></span><br><span class="line">            label1.textColor = <span class="type">UIColor</span>.yellowColor()</span><br><span class="line">            label1.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">11</span>)</span><br><span class="line">                </span><br><span class="line">            label2.text = <span class="string">"5"</span></span><br><span class="line">            label2.textColor = <span class="type">UIColor</span>.blueColor()</span><br><span class="line">            label2.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">9</span>)</span><br><span class="line">                </span><br><span class="line">            label3.text = <span class="string">"6"</span></span><br><span class="line">            label3.textColor = <span class="type">UIColor</span>.brownColor()</span><br><span class="line">            label3.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size: <span class="number">10</span>)</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有很多重复的代码。你可以创建一个函数，在函数里对一个 label 的属性进行设置，但是这个函数我们基本不会在别的地方再次使用。因此，在这种情况下使用闭包就是一个相当不错的解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> guiMode: <span class="type">GUIMode</span> = .<span class="type">Mode1</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;      </span><br><span class="line">        <span class="keyword">let</span> styleLabel: (label:<span class="type">UILabel</span>,text:<span class="type">String</span>,color:<span class="type">UIColor</span>,size:<span class="type">CGFloat</span>) -&gt; () = &#123; (label,text,color,size) <span class="keyword">in</span></span><br><span class="line">            label.text = text</span><br><span class="line">            label.textColor = color</span><br><span class="line">            label.font = <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue"</span>, size:size)</span><br><span class="line">        &#125;</span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">switch</span> guiMode &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Mode1</span>:</span><br><span class="line">            styleLabel(label: label1, text: <span class="string">"1"</span>, color: <span class="type">UIColor</span>.redColor(), size:<span class="number">10</span>)</span><br><span class="line">            styleLabel(label: label2, text: <span class="string">"2"</span>, color: <span class="type">UIColor</span>.blueColor(), size:<span class="number">12</span>)</span><br><span class="line">            styleLabel(label: label3, text: <span class="string">"3"</span>, color: <span class="type">UIColor</span>.yellowColor(), size:<span class="number">11</span>)</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Mode2</span>:</span><br><span class="line">            styleLabel(label: label1, text: <span class="string">"4"</span>, color: <span class="type">UIColor</span>.yellowColor(), size:<span class="number">11</span>)</span><br><span class="line">            styleLabel(label: label2, text: <span class="string">"5"</span>, color: <span class="type">UIColor</span>.blackColor(), size:<span class="number">9</span>)</span><br><span class="line">            styleLabel(label: label3, text: <span class="string">"6"</span>, color: <span class="type">UIColor</span>.brownColor(), size:<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，代码就少了很多，看起来也更加简洁了。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-using-local-closures/">原文链接</a>，原文日期：2015-10-22<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>闭包一般是用来作为函数的参数。不过某些情况下，使用本地闭包也是十分方便的。</p>
<p>假设有一个 <code>ViewController</code>，里面包含了两种 GUI 模式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GUIMode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mode1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mode2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchConnectivity 介绍：告别加载等待]]></title>
    <link href="http://swiftggteam.github.io/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/"/>
    <id>http://swiftggteam.github.io/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/</id>
    <published>2015-11-03T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在 WatchOS 2 上最有价值的新特性就是<code>WatchConnectivity</code>，虽然用户可能看不到，但是这个特性能让你的 WatchOS 应用更加好用。</p>
<a id="more"></a>
<p><code>WatchConnectivity</code>是 WatchOS 2 中的新框架，用于 Watch 应用和 iOS 设备传输数据的。<code>WatchConnectivity</code> 关键的部分是，它使你的应用程序在用户<strong>查看之前</strong>就拿到必要的数据。这意味着用户想要看你的应用时，他们希望马上看到想要的数据，而不是愚蠢的加载等待。</p>
<p>毕竟， Apple Watch 是一个移动中使用的设备。用户们可能想要看一两秒在 iOS 应用上超级可爱的刷新动画，但显然他们不会忍受在手表上看到这样的动画。设想一下，如果用户每次在他们常规的手表上查看时间，引入眼帘的是一个加载等待界面，那将会非常愚蠢，同理，你的应用如果这么做也一样愚蠢。</p>
<p>现在你不必再担心了，<code>WatchConnectivity</code>完全可以解决这个难题，它可以毫无压力地传输你应用上的数据到 Watch 应用上。整个过程都是无缝透明的，以至于你的用户都察觉不到发生了什么。</p>
<p>那么就让我们一探究竟吧！<code>WatchConnectivity</code>有两个部分-后台传输（<code>background transfers</code>）和交互式消息（<code>interactive messaging</code>）。我将会在未来的教程里探究它的每一个部分的更多细节，但是这里只是一个概述，思考传输时应该使用哪一种传输模型：</p>
<h2 id="后台传输">后台传输</h2><p>在你的 iOS 或者 Watch 应用不需要马上获得信息时使用后台传输。当然，在你的用户抬起他们的手腕时查看应用里面的最新数据时，它会显示数据，但是此前他们不需要任何数据。</p>
<p>因为后台传输用于传输不是立刻使用数据， Apple 认为使用后台传输的最佳时机是当你需要根据电池容量、网络连接、使用模式传输数据等的时候。</p>
<p>在你的 iOS 和 Watch 应用之间的后台传输数据有三种方式：</p>
<h3 id="应用上下文">应用上下文</h3><p>当你的 Watch 应用只需要展示最新的信息时，使用应用上下文。例如，当你的<code>Glance</code>显示比分时，用户不会在意两分钟以前的比分是 4-2 ，他们只在乎现在的比分是 4-4 。另一个例子是交通运输应用，用户不关心末班车五分钟前离开了车站，他们只关心下一辆公交车什么时候到。</p>
<p>所以应用上下文的工作方式是把数据块排成队列，并且如果在传输之前有一个新的可用数据块，原始的数据将会被新数据取代，然后再传输这个数据，除非它又被其它更新的数据块代替。</p>
<p><a href="http://natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="external">Tutorial: Sharing The Latest Data via Application Context</a> </p>
<h3 id="用户信息">用户信息</h3><p>用户信息是用于当你需要确认你的所有数据是被传输过的（不像应用上下文）。用户信息的数据是在一个先进先出（<code>FIFO (first-in-first-out)</code>） 队列中顺序传输，所以没有东西被覆盖。</p>
<p>一个例子是你可能想要在一个文本消息的应用中使用它-对于一个完整的会话和上下文环境来说，最后一条信息和第一条信息是同等重要的。如果用户更新了他们简介信息中的一小部分，Watch 简介中也应该同步这些更新。</p>
<h3 id="文件传输">文件传输</h3><p>顾名思义，在你的 iOS 和 Watch 应用之间使用文件传输去传输文件，例如图片或者<code>plists</code>。文件传输的优点是你可以包含一个<code>meta-data</code>字典，其中包含你的文件名和数据，比如说这样你就可以排序你的图片。</p>
<h2 id="交互式消息">交互式消息</h2><p>使用交互式消息能够实时地在你的 iOS 和 Watch 应用之间传输数据！一个绝佳的示例就是<a href="https://github.com/NilStack/WappyBird" target="_blank" rel="external">《像素鸟 Flappy Bird》应用的 Watch 版本和 iPhone 版本</a>-用户点击 Watch，但是小鸟在手机上飞。按钮点击通过交互式消息被传输到手机上了。</p>
<p><img src="/img/articles/watchconnectivity-introduction-say-goodbye-to-the-spinner/flappybirdwatch.gif1447732453.5579317" alt="Flappy Bird"></p>
<p>一个需要注意的地方是，交互式消息需要 iPhone 开启<code>&quot;reachable&quot;</code>状态。根据 Apple 文档的解释是：</p>
<blockquote>
<p>Watch 应用的可达性需要配对的 iOS 设备在重启之后至少解锁一次。</p>
</blockquote>
<h2 id="总结">总结</h2><p>我爱死<a href="http://www.kristinathai.com/watchos-2-how-to-communicate-between-devices-using-watch-connectivity/" target="_blank" rel="external">Kristina Thai’s WatchConnectivity post</a> 里面区别传输的图解了：</p>
<p><img src="/img/articles/watchconnectivity-introduction-say-goodbye-to-the-spinner/Screen-Shot-2015-09-21-at-8.17.29-AM.png1447732460.5724132" alt="这里写图片描述"></p>
<p>同时，本文参考了 Curtis Herbert 的文章 <a href="http://blog.curtisherbert.com/data-synchronization-with-watchos/" target="_blank" rel="external">Getting Data to Your WatchOS 2 App</a> 中最后的 Watch OS 2 observations 部分。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在 WatchOS 2 上最有价值的新特性就是<code>WatchConnectivity</code>，虽然用户可能看不到，但是这个特性能让你的 WatchOS 应用更加好用。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
      <category term="WatchOS 2" scheme="http://swiftggteam.github.io/categories/WatchOS-2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchConnectivity：学习 WCSession]]></title>
    <link href="http://swiftggteam.github.io/2015/11/02/watchconnectivity-say-hello-to-wcsession/"/>
    <id>http://swiftggteam.github.io/2015/11/02/watchconnectivity-say-hello-to-wcsession/</id>
    <published>2015-11-01T16:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在读这篇文章之前，请检查一下你是否已经学习了之前两篇关于<code>WatchOS 2</code>的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World</a></li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">WatchConnectivity Introduction: Say Goodbye To The Spinner</a></li>
</ul>
<p><code>WCSession</code>就是<code>WatchConnectivity</code>的魔力源泉，所以让我们赶紧深挖它吧！</p>
<a id="more"></a>
<p><code>WCSession.defaultSession()</code>会返回<code>WCSession</code>的单例，用于在 iOS 和 Watch 应用之间传输数据。但是，在使用<code>WCSession</code>时仍有一些值得注意的地方。</p>
<p>首先，你必须给<code>session</code>设置一个<code>delegate</code>并启动它。</p>
<blockquote>
<p>“默认的<code>session</code>用于两个对应应用的通信（例如 iOS 应用和它的原生 WatchKit 扩展）。这个<code>session</code>提供发送、接收和追踪状态的方法。</p>
<p>启动一个应用时，应该在默认的<code>session</code>上设置一个<code>delegate</code>并启动它。这将允许系统填充状态属性和提供任何优秀的背景传输。”—— Apple 文档说明。</p>
</blockquote>
<p>所以你的代码应该写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">session.delegate = <span class="keyword">self</span></span><br><span class="line">session.activateSession()</span><br></pre></td></tr></table></figure>
<p>在这里，我推荐将你的<code>WCSession</code>作为一个单例，这样就可以在应用中随意使用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that the WCSessionDelegate must be an NSObject </span></span><br><span class="line"><span class="comment">// So no, you cannot use the nice Swift struct here!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Instantiate the Singleton</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Keep a reference for the session, </span></span><br><span class="line">    <span class="comment">// which will be used later for sending / receiving data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Activate Session</span></span><br><span class="line">    <span class="comment">// This needs to be called to activate the session before first use!</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activateSession()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以在<code>AppDelegate</code>的<code>application:didFinishLaunchingWithOptions</code>方法中启动你的<code>session</code>，并且可以在应用的任意位置使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated...</span></span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication,</span><br><span class="line">        didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set up and activate your session early here!</span></span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.startSession()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated...</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是启动<code>session</code>是远远不够的。你需要通过<code>WCSession</code>的多重检查，这样你的应用就不需要做额外的格式化传输数据工作。</p>
<h1 id="检查设备是否支持">检查设备是否支持</h1><blockquote>
<p>检查 iOS 设备是否支持 session，WatchOS 也是支持 session 的。</p>
</blockquote>
<p>如果你有一个通用应用，那就需要注意，例如iPad 不支持<code>WCSession</code>（因为 iPad 不能和 Watch 配对）。因此确保在 iOS 项目中做<code>isSupported()</code>检查：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">WCSession</span>.isSupported() &#123;</span><br><span class="line">    <span class="keyword">let</span> session = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">    session.delegate = <span class="keyword">self</span></span><br><span class="line">    session.activateSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着你的<code>WatchSessionManager</code>单例需要适应不支持<code>WCSession</code>的场景（使用可选值）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Modification to the WatchSessionManager in the iOS app only</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated ... see above section</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// the session is now an optional, since it might not be supported</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// starting a session has to now deal with it being an optional</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session?.delegate = <span class="keyword">self</span></span><br><span class="line">        session?.activateSession()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Watch_相关的_iOS_App_状态">Watch 相关的 iOS App 状态</h1><p>如果你从 iOS 应用发送数据到 Watch，你需要做一些额外的检查，这样当 Watch 处于无法接受数据的状态时，你就不会浪费 CPU 资源去处理用于传输的数据。</p>
<p><strong>是否配对</strong></p>
<p>显然，为了从 iOS 设备传输数据到 Watch，用户必须有一个 Watch 并且和 iOS 设备配对。</p>
<p><strong>是否安装 Watch 应用</strong></p>
<p>一个用户可能有一对设备，当然可以选择删除手表中的应用，所以为了数据传输，你需要检查你的应用确实有安装在所配对的 Apple Watch 上面。</p>
<p>如果用户有一对设备但是没有对应的应用，那你就可以在合适的时机向用户推荐你的应用，他很可能会安装你的应用。</p>
<p>为了让这些检查更加简单，并且能够在应用中随意使用，我喜欢在 iOS 应用中创建一个<code>validSession</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Modification to the WatchSessionManager in the iOS app only</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// truncated... see above</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add a validSession variable to check that the Watch is paired</span></span><br><span class="line">    <span class="comment">// and the Watch App installed to prevent extra computation </span></span><br><span class="line">    <span class="comment">// if these conditions are not met.</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// This is a computed property, since the user can pair their device and / or</span></span><br><span class="line">    <span class="comment">// install your app while using your iOS app, so this can become valid  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validSession: <span class="type">WCSession</span>? &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// paired - the user has to have their device paired to the watch</span></span><br><span class="line">        <span class="comment">// watchAppInstalled - the user must have your watch app installed</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Note: if the device is paired, but your watch app is not installed</span></span><br><span class="line">        <span class="comment">// consider prompting the user to install it for a better experience</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = session <span class="keyword">where</span> session.paired &amp;&amp; session.watchAppInstalled &#123;</span><br><span class="line">            <span class="keyword">return</span> session</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// truncated... see above</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>并发是否可用</strong></p>
<p>最后，如果你在应用中有使用并发，你必须检查并发是否可用。我不会在<code>WatchConnectivity</code>教程中介绍过多并发的细节，但是如果你想要知道更多，可以观看超级有用和全面的 <a href="https://developer.apple.com/videos/wwdc/2015/?id=209" target="_blank" rel="external">WWDC 2015 Creating Complications with ClockKit session</a>。</p>
<p><strong>sessionWatchStateDidChange</strong></p>
<p>注意，如果你的 iOS 应用需要<code>WCSession</code>状态变化的信息，这里有一个 delegate 方法，专门用于通知<code>WCSession</code>的状态变化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Called when any of the Watch state properties change */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sessionWatchStateDidChange</span><span class="params">(session: WCSession)</span></span> &#123;</span><br><span class="line">        <span class="comment">// handle state change here</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>例如，如果你的应用需要安装 Watch 应用，可以实现这个<code>delegate</code>方法，然后去检测你的 Watch 应用是否真正安装了，并且让用户在 iOS 应用中进行设置。</p>
<h1 id="检查设备可达状态">检查设备可达状态</h1><p>为了正确在 iOS 和 Watch 中使用<code>Interactive Messaging</code>传输数据，你需要做一些额外的工作以确保两个应用处于可达状态：</p>
<blockquote>
<p>Watch 应用的可达状态需要所配对的 iOS 设备在重启后至少解锁一次。这个属性能够用于决定 iOS 设备是否需要被解锁。如果<code>reachable</code>设为<code>NO</code>，可能是由于设备重启过，需要解锁。如果处于这种状态，Watch 将会展示一个提示框建议用户去解锁他们配对的 iOS 设备。</p>
</blockquote>
<p>在使用<code>Interactive Messaging</code>时，我喜欢给我的单例增加一个额外的<code>valideReachableSession</code>变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: Interactive Messaging</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Live messaging! App has to be reachable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validReachableSession: <span class="type">WCSession</span>? &#123;</span><br><span class="line">        <span class="comment">// check for validSession on iOS only (see above)</span></span><br><span class="line">        <span class="comment">// in your Watch App, you can just do an if session.reachable check</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = validSession <span class="keyword">where</span> session.reachable &#123;</span><br><span class="line">            <span class="keyword">return</span> session</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>session</code>是不可达的，你可以如 Apple 所建议的那样，提示用户去解锁他们的 iOS 设备。为了获知用户解锁设备，实现<code>sessionReachabilityDidChange</code>的<code>delegate</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sessionReachabilityDidChange</span><span class="params">(session: WCSession)</span></span> &#123;</span><br><span class="line">    <span class="comment">// handle session reachability change</span></span><br><span class="line">    <span class="keyword">if</span> session.reachable &#123;</span><br><span class="line">        <span class="comment">// great! continue on with Interactive Messaging</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 😥 prompt the user to unlock their iOS device</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上！现在你应该已经知道了<code>WCSession</code>的一些要领，所以我们将会学习更加好玩的部分 —— 真正使用它在 iOS 和 Watch 之间接收和发送收据！</p>
<p>你可以在 GitHub 查看完整的<a href="https://gist.github.com/NatashaTheRobot/6bcbe79afd7e9572edf6" target="_blank" rel="external">WatchSessionManager单例</a>。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/">原文链接</a>，原文日期：2015-09-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在读这篇文章之前，请检查一下你是否已经学习了之前两篇关于<code>WatchOS 2</code>的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/">WatchOS 2: Hello, World</a></li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/">WatchConnectivity Introduction: Say Goodbye To The Spinner</a></li>
</ul>
<p><code>WCSession</code>就是<code>WatchConnectivity</code>的魔力源泉，所以让我们赶紧深挖它吧！</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
      <category term="WatchOS 2" scheme="http://swiftggteam.github.io/categories/WatchOS-2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊单子（Monad）]]></title>
    <link href="http://swiftggteam.github.io/2015/10/30/lets-talk-about-monads/"/>
    <id>http://swiftggteam.github.io/2015/10/30/lets-talk-about-monads/</id>
    <published>2015-10-30T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/17/lets-talk-about-monads/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/" target="_blank" rel="external">之前的一篇文章</a>中，我们用<code>map</code>、<code>flatMap</code>这两种基于<code>Optional</code>和<code>Array</code>类型的方法做了很多好玩儿的事情。但你可能并没有意识到，你已经在不自知的情况下使用了单子<em>(单子，即 Monad：一个函数式编程的术语 - 译者注)</em>。那么什么是单子？</p>
<a id="more"></a>
<h3 id="什么是函子（Functors）和单子">什么是函子（Functors）和单子</h3><p>我们在<a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/" target="_blank" rel="external">之前的一篇文章</a>中得知了<code>map</code>和<code>flatMap</code>对于<code>Array</code>和<code>Optional</code>来说有着相似的作用，甚至连函数签名都十分相似。</p>
<p>实际上这并不是一个特例：很多类型都有类似<code>map</code>和<code>flatMap</code>的方法，而这些方法都有那种类型的签名。这是一种十分常见的模式，这种模式的名字叫做<em>单子</em>。</p>
<p>你可能之前在网上看过单子这个术语(也可能叫做函子)，还看过尝试解释该术语的各种比喻。但是大部分比喻都让它更加复杂难懂。</p>
<p><strong>事实上，单子和函子是非常简单的概念。</strong>它可以最终归结为：</p>
<p><strong>一个函子</strong>是一种表示为<code>Type&lt;T&gt;</code>的类型，它：</p>
<ul>
<li>封装了另一种类型（类似于封装了某个<code>T</code>类型的<code>Array&lt;T&gt;</code>或<code>Optional&lt;T&gt;</code>）</li>
<li>有一个具有<code>(T-&gt;U) -&gt; Type&lt;U&gt;</code>签名的<code>map</code>方法</li>
</ul>
<p><strong>一个单子</strong>是一种类型，它：</p>
<ul>
<li>是一个函子（所以它封装了一个<code>T</code>类型，拥有一个<code>map</code>方法）</li>
<li>还有一个具有<code>(T-&gt;Type&lt;U&gt;) -&gt; Type&lt;U&gt;</code>签名的<code>flatMap</code>方法</li>
</ul>
<p>这就是对<em>单子</em>和<em>函子</em>所需要了解的一切！<strong>一个<em>单子</em>就是一种带有<code>flatMap</code>方法的类型，一个<em>函子</em>就是一种带有一个<code>map</code>方法的类型。</strong>很简单，不是么？</p>
<h3 id="各种类型的单子">各种类型的单子</h3><p>你已经学过两种既是<em>函子</em>又是<em>单子</em>的类型，它们是：<code>Array&lt;T&gt;</code>和<code>Optional&lt;T&gt;</code>。当然，这样的类型还有很多。</p>
<p>实际上这些类型的方法会有其他的名字，不限于<code>map</code>和<code>flatMap</code>。例如一个<a href="http://promisekit.org/" target="_blank" rel="external">Promise</a>也是一个单子，而它的相对应的<code>map</code>和<code>flatMap</code>方法叫做<code>then</code>。</p>
<p>仔细看一下<code>Promise&lt;T&gt;</code>的<code>then</code>方法签名，思考一下：它拿到未来返回的值<code>T</code>，进行处理，然后要么返回一个新类型<code>U</code>，要么返回一个封装了这个新类型的、新的<code>Promise&lt;U&gt;</code>… 没错，我们又一次得到了相同的方法签名，所以<code>Promise</code>实际上也是一个<code>单子</code>！</p>
<p>有很多类型都符合单子的定义。比如<code>Result</code>，<code>Signal</code>，… 你还可以想到更多（如果需要的话你甚至可以创建你自己的单子）。</p>
<p>看出相似性了吗？（为方便对比加了空格）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Array, Optional, Promise, Result 都是函子</span></span><br><span class="line">   anArray     .<span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">anOptional     .<span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"> aPromise     .then( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt;  <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">   aResult     .<span class="built_in">map</span>( transform: <span class="type">T</span> -&gt;          <span class="type">U</span>  ) -&gt;   <span class="type">Result</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array, Optional, Promise, Result 都是单子</span></span><br><span class="line">   anArray .flatMap( transform: <span class="type">T</span> -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt; ) -&gt;    <span class="type">Array</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">anOptional .flatMap( transform: <span class="type">T</span> -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt; ) -&gt; <span class="type">Optional</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">  aPromise    .then( transform: <span class="type">T</span> -&gt;  <span class="type">Promise</span>&lt;<span class="type">U</span>&gt; ) -&gt;  <span class="type">Promise</span>&lt;<span class="type">U</span>&gt;</span><br><span class="line">   aResult .flatMap( transform: <span class="type">T</span> -&gt;   <span class="type">Result</span>&lt;<span class="type">U</span>&gt; ) -&gt;   <span class="type">Result</span>&lt;<span class="type">U</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="把map()和flatMap()级联起来">把<code>map()</code>和<code>flatMap()</code>级联起来</h3><p>通常你还可以把这两个方法级联，这会使它们更加强大。例如，最开始你有一个<code>Array&lt;T&gt;</code>，通过使用<code>map</code>来对它做<code>转换</code>操作，得到一个<code>Array&lt;U&gt;</code>，然后对这个<code>Array&lt;U&gt;</code>再级联上一个<code>map</code>，对它做另一个<code>转换</code>操作将其转换成一个<code>Array&lt;Z&gt;</code>，等等。这会让你的代码看起来就像是在生产线上一样：把一个初始值拿来，让他经过一系列的黑盒子处理，然后得到一个最终的结果。这时你就可以说你实际上是在做<em>函数式编程</em>了！</p>
<p>下面是一个示范如何将<code>map</code>和<code>flatMap</code>的调用级联起来去做多次转换的例子。我们从一个字符串开始，把它按单词分开，然后依次做如下转换：</p>
<ol>
<li>统计每个单词的字符个数，做计数</li>
<li>把每个计数转换成一个相对应的单词</li>
<li>给每个结果加个后缀</li>
<li>对每个字符串结果做%转义</li>
<li>把每个字符串结果转换成一个<code>NSURL</code></li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter = <span class="type">NSNumberFormatter</span>()</span><br><span class="line">formatter.numberStyle = .<span class="type">SpellOutStyle</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">"This is Functional Programming"</span></span><br><span class="line"><span class="keyword">let</span> translateURLs = string</span><br><span class="line">    <span class="comment">// Split the characters into words</span></span><br><span class="line">    .characters.<span class="built_in">split</span>(<span class="string">" "</span>)</span><br><span class="line">    <span class="comment">// Count the number of characters on each word</span></span><br><span class="line">    .<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line">     <span class="comment">// Spell out this number of chars (`stringFromNumber` can return nil)</span></span><br><span class="line">    .flatMap &#123; (n: <span class="type">Int</span>) -&gt; <span class="type">String</span>? <span class="keyword">in</span> formatter.stringFromNumber(n) &#125;</span><br><span class="line">     <span class="comment">// add " letters" suffix</span></span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>)</span> letters"</span> &#125;</span><br><span class="line">    <span class="comment">// encode the string so it can be used in an NSURL framgment after the # (the stringByAdding… method can return nil)</span></span><br><span class="line">    .flatMap &#123; $<span class="number">0</span>.stringByAddingPercentEncodingWithAllowedCharacters(.<span class="type">URLFragmentAllowedCharacterSet</span>()) &#125;</span><br><span class="line">    <span class="comment">// Build an NSURL using that string (`NSURL(string: …)` is failable: it can return nil)</span></span><br><span class="line">    .flatMap &#123; <span class="type">NSURL</span>(string: <span class="string">"https://translate.google.com/#auto/fr/<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(translateURLs)</span><br><span class="line"><span class="comment">// [https://translate.google.com/#auto/fr/four%20letters, https://translate.google.com/#auto/fr/two%20letters, https://translate.google.com/#auto/fr/ten%20letters, https://translate.google.com/#auto/fr/eleven%20letters]</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码可能需要你研究一会儿，尝试去理解每一个中间阶段的<code>map</code>和<code>flatMap</code>的签名是什么，并搞清楚每一步都发生了什么事。</p>
<p>但无论如何，你能看出来对于描述一系列处理流程来说，这是一种很好的方式。这种方式可以被看做是一条生产线，从<code>原材料</code>开始，然后对它做多种<code>转换</code>，最终在生产线的尽头拿到<code>成品</code>。</p>
<h3 id="结论">结论</h3><p>尽管看起来很吓人，但单子很简单。</p>
<p>但实际上，你怎么叫它们都没关系。只要你知道如果你想把一种封装类型转换成另一种，而某些类型的<code>map</code>和<code>flatMap</code>方法着实能帮到你，这就够了。</p>
<hr>
<p>这篇文章是”Swift编程思想”系列的后记。别担心，我还会写很多文章，论述 Swift 在其他应用场景下的美妙之处，不过我不会再拿这些和 ObjC 比较了（因为 Swift 真的好太多了，你现在应该完全把 ObjC 忘掉了 😄）。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/2015/10/17/lets-talk-about-monads/">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="http://daizi.me">小袋子</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><a href="http://alisoftware.github.io/swift/2015/10/11/thinking-in-swift-4/">之前的一篇文章</a>中，我们用<code>map</code>、<code>flatMap</code>这两种基于<code>Optional</code>和<code>Array</code>类型的方法做了很多好玩儿的事情。但你可能并没有意识到，你已经在不自知的情况下使用了单子<em>(单子，即 Monad：一个函数式编程的术语 - 译者注)</em>。那么什么是单子？</p>]]>
    
    </summary>
    
      <category term="Crunchy Development" scheme="http://swiftggteam.github.io/tags/Crunchy-Development/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用 Swift 进行列表解析及其性能问题]]></title>
    <link href="http://swiftggteam.github.io/2015/10/29/list-comprehensions-and-performance-with-swift/"/>
    <id>http://swiftggteam.github.io/2015/10/29/list-comprehensions-and-performance-with-swift/</id>
    <published>2015-10-29T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Veronica Ray，<a href="http://jamesonquave.com/blog/list-comprehensions-and-performance-with-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-15<br>译者：<a href="http://weibo.com/riven0951" target="_blank" rel="external">riven</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a></p>
<p>本文写于 2015.8.15 适用于 Xcode 6 和 Swift 1.2</p>
</blockquote>
<p>列表解析可以让你用更简洁的方式来创建列表。尽管列表解析没有在 Swift 的语言指南中提及，但你也可以在 Swift 中实现类似列表解析的一些操作。</p>
<a id="more"></a>
<p>如果你想创建一个对元素求平方的列表，像这样:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> squares = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    squares.append(x*x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Python 中，使用列表解析是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，你可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> squares = <span class="type">Array</span>(<span class="built_in">map</span>(<span class="number">1</span>..&lt;<span class="number">10</span>) &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>对列表中所有元素进行求和你可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> square <span class="keyword">in</span> squares &#123;</span><br><span class="line">    sum = sum + square</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用 reduce 函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = squares.<span class="built_in">reduce</span>(<span class="number">0</span>, &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>对于其它语言中的列表解析，你可以使用任意的序列或者集合作为输入，而不仅仅是一个区间值。</p>
<p><a href="http://stackoverflow.com/questions/24003584/list-comprehension-in-swift" target="_blank" rel="external">你可以使用 map/reduce/filter/stride 函数创建你想要的列表类型</a></p>
<p>列表解析的两个主要优点是让代码变的更简洁和生成更快的二进制码。</p>
<p>我刚刚模拟的列表解析看起来很简洁吧。但我很好奇是否它也能产生更快的二进制码。</p>
<p><a href="https://medium.com/swift-programming/secret-of-swift-performance-fcc5d2a437a8" target="_blank" rel="external">这篇文章</a> 介绍了如何使用 Hopper 来分析 Swift 的汇编代码，Hopper 是一个 OS X 和 Linux 反编译程序。 你可以免费使用 Hopper ，不需要付任何费用。</p>
<p>没有使用列表解析的代码片段和模拟列表解析的代码片段都产生了同样的汇编代码.</p>
<p><img src="/img/articles/list-comprehensions-and-performance-with-swift/asm.png1446426438.2465854" alt="The assembly code from Hopper"></p>
<p>因为两个代码片段产生的汇编代码是一样的，所以我可以认为它们的执行时间是一样的。我们可以使用 XCTest 来测试我们程序的执行时间并证明这一点。</p>
<p>测试没有使用列表解析的代码片段</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testNoListComprehensionPerformance</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.measureBlock() &#123;</span><br><span class="line">        <span class="keyword">var</span> squares = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">            squares.append(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关的输出是：</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testNoListComprehensionPerformance]’ started.</p>
<p>:0: Test Case ‘-[speedTestTests.speedTestTests testNoListComprehensionPerformance]’ measured [Time, seconds] average: 0.000, relative standard deviation: 236.965%, values: [0.000154, 0.000005, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004, 0.000004], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: “”, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testNoListComprehensionPerformance]’ passed (0.262 seconds).</p>
<p>测试模拟列表解析的代码片段</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testSortaListComprehensionPerformance]’ started.</p>
<p>:0: Test Case ‘-[speedTestTests.speedTestTests testSortaListComprehensionPerformance]’ measured [Time, seconds] average: 0.000, relative standard deviation: 160.077%, values: [0.000045, 0.000005, 0.000004, 0.000003, 0.000003, 0.000003, 0.000003, 0.000004, 0.000003, 0.000003], performanceMetricID:com.apple.XCTPerformanceMetric_WallClockTime, baselineName: “”, baselineAverage: , maxPercentRegression: 10.000%, maxPercentRelativeStandardDeviation: 10.000%, maxRegression: 0.100, maxStandardDeviation: 0.100</p>
<p>Test Case ‘-[speedTestTests.speedTestTests testSortaListComprehensionPerformance]’ passed (0.255 seconds).</p>
<hr>
<p><strong>他们平均只相差 0.007 秒</strong></p>
<hr>
<p>我见过最酷的列表解析的应用便是拼写检查。Airspeed Velocity 针对 <a href="http://norvig.com/spell-correct.html" target="_blank" rel="external">Peter Norvig 的  Python 版本的拼写检查</a>，<a href="http://airspeedvelocity.net/2015/05/02/spelling/" target="_blank" rel="external">改写了一个 Swift 版本</a>。</p>
<p>在 Swift 中使用类列表解析的操作的主要优点就是简洁性。 <a href="http://www.paulgraham.com/power.html" target="_blank" rel="external">Paul Graham 写了一大篇关于在编程语言中简洁是多么重要的文章。</a> 因为每个程序员每天只能写一定行数的代码，如果你以同样数量的代码行数完成更多功能，那你每天便可以完成更多的工作任务。这种力量也会让你重新思考编写什么样的程序是可能的。在一些更繁琐的语言中，这个拼写检查的例子可能就是一个巨大的项目。我喜欢像拼写检查这种充满技术复杂性和神秘感的事物，并且在 Swift 中可以只用几行代码便能解决。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Veronica Ray，<a href="http://jamesonquave.com/blog/list-comprehensions-and-performance-with-swift/">原文链接</a>，原文日期：2015-08-15<br>译者：<a href="http://weibo.com/riven0951">riven</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/linusling">小铁匠Linus</a></p>
<p>本文写于 2015.8.15 适用于 Xcode 6 和 Swift 1.2</p>
</blockquote>
<p>列表解析可以让你用更简洁的方式来创建列表。尽管列表解析没有在 Swift 的语言指南中提及，但你也可以在 Swift 中实现类似列表解析的一些操作。</p>]]>
    
    </summary>
    
      <category term="Jameson Quave" scheme="http://swiftggteam.github.io/tags/Jameson-Quave/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于 Swift 的 5 个误区]]></title>
    <link href="http://swiftggteam.github.io/2015/10/28/five-myths-about-swift/"/>
    <id>http://swiftggteam.github.io/2015/10/28/five-myths-about-swift/</id>
    <published>2015-10-28T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/five-myths-about-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-19<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 虽然是一门比较新的技术语言，却已经有了很多关于 Swift 的误区。</p>
<a id="more"></a>
<h2 id="误区_1_：“Swift_是弱类型的语言”">误区 1 ：“Swift 是弱类型的语言”</h2><p>很多人认为 Swift 是一种弱类型的语言。他们这么说的原因主要是可以隐式声明一个值，而不管类型是什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这代码看上去好像<code>i</code>没有类型，其实并不是这样的。因为 5 是一个整型，所以编译器就会让<code>i</code>成为整型变量。之后，整型变量<code>i</code>不会再被改变，也就是说<code>i</code>永远是整型变量。</p>
<p>当然，我们也可以明确的指定变量的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>虽然这种方式不是必要的，但它可以提高代码的可读性。</p>
<h2 id="误区_2_：“Swift_和_Objective-C_协作性差”">误区 2 ：“Swift 和 Objective-C 协作性差”</h2><p>很多人不想开始尝试使用 Swift，因为他们认为 Swift 不能兼容现存的 Objective-C 代码和类库。其实并不是这样的。在同一个工程中，同时使用 Swift 和 Objective-C 也是可行的。并且，在 Swift 代码中也可以使用 Objective-C 的第三方库。</p>
<p>可以在所谓的桥接文件中声明 Objective-C 的头文件，然后，所有头文件的内容都会被翻译成 Swfit 的语法，这样在调用 Objective-C 的 API 的时候就不会感觉到什么区别了。甚至 Objective-C 错误处理也被转换成 Swift 的<code>do-try-catch</code>语法了。</p>
<p>苹果的框架仍然是用 Objective-C 写的，如果Swift 和 Objective-C 协作性差的话事情就会变得很糟。</p>
<h2 id="误区_3_：“必须在新的项目中使用_Swift”">误区 3 ：“必须在新的项目中使用 Swift”</h2><p>我觉得在新项目中使用 Swift 是个很好的想法，而且每个 iOS 开发者都应该学 Swift。</p>
<p>但是，你没必要一定要在新项目中开始使用 Swift。现在苹果官方还在支持 Objective-C，至少近几年不会改变。但是，我认为苹果未来对 Objective-C 的支持会越来越少。</p>
<p>可以去我发布的另一篇文章 <a href="http://www.thomashanning.com/should-you-use-objective-c-or-swift/" target="_blank" rel="external">Should You Use Objective-C or Swift?</a> 里看看关于本误区的其他详情。</p>
<h2 id="误区_4_：“只学_Swift_就够用了”">误区 4 ：“只学 Swift 就够用了”</h2><p>Swift 是门很棒的编程语言，它也可以用在生产环境，但是仅仅学 Swift 是不够的。原因大致如下：Swift 和 Objective-C 有很好的协作性，而且项目中也经常会有 Objective-C 的代码，同时，许多的示例代码和教程是用 Objective-C 写的。</p>
<p>因此，为了成为一个优秀的 iOS 开发者，最好能同时学会 Swift 和 Objective-C。</p>
<h2 id="误区_5_：“Swift_还不能用在生产环境”">误区 5 ：“Swift 还不能用在生产环境”</h2><p>很多人认为 Swift 还不能用在生产环境。其中一个原因就是，引进 Swift 到工程中时会有一些问题出现，尤其是 Xcode 会有一些 bug。如果知道一些变通方法的话，还是可以在生产环境使用 Swift 的。</p>
<p>Swift 1.2 和 Swift 2.0 的引进都有对语言的语法进行修改。因此，把现存的 Swift 代码迁移到新的语法上是必要的。当然，这也没什么可指责的，毕竟每个 iOS 版本都有代码在变更。而且，这也是 Swift 在尝试改善的重要标志，特别是在 Swift 发布不久的现阶段。</p>
<h2 id="接下来做什么">接下来做什么</h2><p>如果你想学习更多有关 Swift 的知识，学习<a href="https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11" target="_blank" rel="external">苹果的Swift文档</a>是一个非常好的开始。如果想了解其它的资源，可以关注一下我的博客<a href="http://www.thomashanning.com/how-to-stay-up-to-date-on-ios-development/" target="_blank" rel="external"> “How To Stay Up-To-Date On iOS Development”</a>。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/five-myths-about-swift/">原文链接</a>，原文日期：2015-10-19<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 虽然是一门比较新的技术语言，却已经有了很多关于 Swift 的误区。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解 Swift 模式匹配]]></title>
    <link href="http://swiftggteam.github.io/2015/10/27/swift-pattern-matching-in-detail/"/>
    <id>http://swiftggteam.github.io/2015/10/27/swift-pattern-matching-in-detail/</id>
    <published>2015-10-27T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-20<br>译者：<a href="http://blog.csdn.net/mmoaay" target="_blank" rel="external">mmoaay</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在众多 Swift 提供给 Objective-C 程序员使用的新特性中，有个特性把自己伪装成一个无聊的老头，但是却在如何优雅的解决“鞭尸金字塔“的问题上有着巨大的潜力。很显然我所说的这个特性就是 <code>switch</code> 语句， 对于很多 Objective-C 程序员来说，除了用在 <a href="http://en.wikipedia.org/wiki/Duff%27s_device" target="_blank" rel="external">Duff’s Device</a> 上比较有趣之外，<code>switch</code> 语句非常笨拙，与多个 <code>if</code> 语句相比，它几乎没有任何优势。</p>
<a id="more"></a>
<p>不过 Swift 中的 <code>switch</code> 语句能做的就多了。在接下来的教程里，我会更加详细的讲解这些新特性的各种用途。我会忽略那些与 Objective-C 和 C 中 <code>switch</code> 语句相比没有任何优势的解决方案。这篇文章基础的部分写于 2014 年 7 月，但是很多我写的模式都会导致编译器崩溃，所以我只好推迟这些内容的编写，直到编译器能提供更好的支持。</p>
<p>这篇博客还有如下语言的版本：</p>
<blockquote>
<p><a href="http://qiita.com/mono0926/items/f2875a9eacef53e88122" target="_blank" rel="external">日语</a> （感谢 <a href="https://twitter.com/_mono" target="_blank" rel="external">M Ono</a>！）</p>
</blockquote>
<h1 id="开始咯">开始咯</h1><p> <code>switch</code> 语句主要的特性当然是模式匹配咯，模式匹配可以对值进行解构，然后根据相应 <code>case</code> 的正确匹配值来进行匹配。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 历史上最坏的一个例子：二进制-&gt;十进制的转换</span></span><br><span class="line"><span class="keyword">let</span> bool1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> bool2 = <span class="number">0</span></span><br><span class="line"><span class="keyword">switch</span> (bool1, bool2) &#123;</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>): <span class="built_in">print</span>(<span class="string">"0"</span>)</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">0</span>, <span class="number">1</span>): <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">0</span>): <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">   <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">1</span>): <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模式匹配很早以前就在其他语言中存在了，这些语言包括 Haskell、Erlang、Scala 和 Prolog。这是一个福音，因为它允许我们观察那些语言如何利用模式匹配来解决问题。我们甚至可以通过观察它们的例子来找到最实用的那个。</p>
<h1 id="一个交易引擎">一个交易引擎</h1><p>假设华尔街找到你，他们需要一个新的运行在 iOS 设备上的交易平台。因为是交易平台，所以你需要给交易定义一个 <code>enum</code>。</p>
<h2 id="第一步">第一步</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trades</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时还会提供如下的 API 给你来进行交易处理。<strong>注意销售订单的金额是如何变成负数的</strong>，而且他们还说股票的价格不重要，他们的引擎会在内部选择一个价格。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> - 参数 stock: 股票的名字</span><br><span class="line"> - 参数 amount: 金额, 负数表示销售额, 正数表示购买额</span><br><span class="line">*/</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">process</span><span class="params">(stock: String, <span class="number">_</span> amount: Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"<span class="subst">\(amount)</span> of <span class="subst">\(stock)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步就是对交易进行处理。你会发现模式匹配在写这个业务时所具备的强大处理能力：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aTrade = <span class="type">Trades</span>.<span class="type">Buy</span>(stock: <span class="string">"APPL"</span>, amount: <span class="number">200</span>, stockPrice: <span class="number">115.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aTrade &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Buy</span>(<span class="keyword">let</span> stock, <span class="keyword">let</span> amount, <span class="number">_</span>):</span><br><span class="line">    process(stock, amount)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Sell</span>(<span class="keyword">let</span> stock, <span class="keyword">let</span> amount, <span class="number">_</span>):</span><br><span class="line">    process(stock, amount * -<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 "buy 200 of APPL"</span></span><br></pre></td></tr></table></figure>
<p>Swift 可以让我们非常方便的从 <code>enum</code> 中解构/提取出我们真正想要的信息。在这个例子中只有 <code>stock</code> 和 <code>amount</code> 被解构出来。</p>
<p>真棒，现在你可以去华尔街展示这个极好的交易平台了。然而，现实往往比美好的想象要残酷得多。你以为交易就是你以为的交易么？</p>
<ul>
<li>你必须根据不同的交易方式计算费用。</li>
<li>机构越小，费用越高</li>
<li>而且，机构越大，优先级越高。</li>
</ul>
<p>华尔街的人也意识到要处理这些问题你需要新的 API，所以他们给了你下面的两个：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processSlow</span><span class="params">(stock: String, <span class="number">_</span> amount: Int, <span class="number">_</span> fee: Float)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"slow"</span>) &#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFast</span><span class="params">(stock: String, <span class="number">_</span> amount: Int, <span class="number">_</span> fee: Float)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"fast"</span>) &#125;</span><br></pre></td></tr></table></figure>
<h2 id="交易类型">交易类型</h2><p>于是你回到绘图板重新增加了一个 <code>enum</code>。交易类型也是每个交易的一部分。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TraderType</span> </span>&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">SingleGuy</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Company</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trades</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>, type: <span class="type">TraderType</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>, stockPrice: <span class="type">Float</span>, type: <span class="type">TraderType</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，如何更好地实现这一新机制呢？你可以用一个 <code>if / else</code> 分支来实现购买和销售，但是这会导致代码嵌套以至于很快代码就变的不清晰了——而且谁知道那些华尔街人会不会给你找新的麻烦。所以你应该把它定义为模式匹配的一个新要求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aTrade = <span class="type">Trades</span>.<span class="type">Sell</span>(stock: <span class="string">"GOOG"</span>, amount: <span class="number">100</span>, stockPrice: <span class="number">666.0</span>, type: <span class="type">TraderType</span>.<span class="type">Company</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aTrade &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, -<span class="number">1</span> * amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, amount, <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, -<span class="number">1</span> * amount, <span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的优雅之处在于它非常简洁的描述了不同可能的组合。注意我们把 <code>.Buy(let stock, let amount)</code> 修改成 <code>let .Buy(stock, amount)</code> 来进行简化，这样就可以用更少的语句来像之前一样对 <code>enum</code> 进行解构。</p>
<h2 id="警卫！警卫！呼叫警卫！">警卫！警卫！呼叫警卫！</h2><p>于是你再次向你的华尔街用户展示你的开发成果，而他们又提出了新的问题（你真应该把项目的细节问得更清楚一点）。</p>
<ul>
<li>交易总额超过 1.000.000\$ 的销售订单通常需要更快进行处理，就算是个人客户也得这样。</li>
<li>交易总额小于 1.000\$ 的购买订单通常处理更慢。</li>
</ul>
<p>如果使用传统的 <code>if</code> 语句，这时代码就应该已经有点凌乱了，而 <code>switch</code> 就不会。Swift 为 <code>switch cases</code> 提供了保护机制，这种机制可以让你进一步的对可能匹配的 <code>case</code> 进行约束。</p>
<p>你只需要对 <code>switch</code> 语句稍作修改就可以满足新的变化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aTrade = <span class="type">Trades</span>.<span class="type">Buy</span>(stock: <span class="string">"GOOG"</span>, amount: <span class="number">1000</span>, stockPrice: <span class="number">666.0</span>, type: <span class="type">TraderType</span>.<span class="type">SingleGuy</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aTrade &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, price, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>)</span><br><span class="line">    <span class="keyword">where</span> price*<span class="type">Float</span>(amount) &gt; <span class="number">1000000</span>:</span><br><span class="line">    processFast(stock, -<span class="number">1</span> * amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">SingleGuy</span>):</span><br><span class="line">    processSlow(stock, -<span class="number">1</span> * amount, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, price, <span class="type">TraderType</span>.<span class="type">Company</span>)</span><br><span class="line">    <span class="keyword">where</span> price*<span class="type">Float</span>(amount) &lt; <span class="number">1000</span>:</span><br><span class="line">    processSlow(stock, amount, <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, amount, <span class="number">2.0</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount, <span class="number">_</span>, <span class="type">TraderType</span>.<span class="type">Company</span>):</span><br><span class="line">    processFast(stock, -<span class="number">1</span> * amount, <span class="number">2.0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码结构很清晰，阅读起来也相当简单，对复杂情况的封装也很好。</p>
<p>就是这样，我们已经成功的实现了我们的交易引擎。然而，这个解决方案还是有点繁琐；我们在想是否还有对其进行改进的模式匹配方案。所以，让我们继续深入研究一下模式匹配。</p>
<h1 id="模式匹配进阶">模式匹配进阶</h1><p>现在我们在实战中已经见过了几种模式。但其语法是什么？还能匹配什么？Swift 将这些模式分为 <strong>7</strong> 种。我们现在就来认识一下它们。</p>
<p>所有的这些模式不仅能用在 <code>switch</code> 关键词上，而且可以用在 <code>if</code>，<code>guard</code> 和 <code>for</code> 关键词上。如需了解详情，接着看下面的内容。</p>
<h2 id="1-_通配符模式">1. 通配符模式</h2><p>通配符模式会忽略需要匹配的值，这种 <code>case</code> 下任何值都是有可能的。这和 <code>let _ = fn()</code> 一样的模式，在这个模式下， <code>_</code>  表示你将不再使用这个值。有意思的是这个模式可以匹配包括 <code>nil</code> <a href="#1">1</a>在内的所有值 。如果增加一个 <code>?</code>，它甚至可以匹配可选值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p: <span class="type">String</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">switch</span> p &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">_</span>?: <span class="built_in">print</span> (<span class="string">"Has String"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>: <span class="built_in">print</span> (<span class="string">"No String"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像你在交易例子里面看到的一样，它也允许你忽略需要匹配的 <code>enum</code> 或者 <code>tuples</code> 中无用的数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">15</span>, <span class="string">"example"</span>, <span class="number">3.14</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, <span class="number">_</span>, <span class="keyword">let</span> pi): <span class="built_in">print</span> (<span class="string">"pi: <span class="subst">\(pi)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-_标示模式">2. 标示模式</h2><p>匹配一个具体的值。这个和 Objective-C 的 <code>switch</code> 实现是一样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">5</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">print</span>(<span class="string">"5"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-_值绑定模式">3. 值绑定模式</h2><p>这种模式和通过 <code>let</code> 或者 <code>var</code> 绑定值到变量一样，但是只能用在 <code>switch</code> 中。因为你之前已经见到过，所以我只给出一个非常简单的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="number">4</span>, <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> (x, y): <span class="built_in">print</span>(<span class="string">"<span class="subst">\(x)</span> <span class="subst">\(y)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-_元组模式">4. 元组模式</h2><p><a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="external">关于元组我已经写了一整篇博文</a>，这篇博文所提供的信息远远比这里多，但是我还是在这里给出一个简短的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">23</span></span><br><span class="line"><span class="keyword">let</span> job: <span class="type">String</span>? = <span class="string">"Operator"</span></span><br><span class="line"><span class="keyword">let</span> payload: <span class="type">AnyObject</span> = <span class="type">NSDictionary</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (age, job, payload) &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="keyword">let</span> age, <span class="number">_</span>?, <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSDictionary</span>):</span><br><span class="line">  <span class="built_in">print</span>(age)</span><br><span class="line">  <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们把 3 个值结合放到一个元组中（假想它们是通过调用不同的 API 得到的），然后一口气匹配它们，注意这个模式完成了三件事情：</p>
<ol>
<li>提取 <code>age</code></li>
<li>确保存在一个 <code>job</code>，就算我们不需要它</li>
<li>确保 <code>payload</code> 的类型是 <code>NSDictionary</code>，尽管我们同样不需要访问它的具体值。</li>
</ol>
<h2 id="5-_枚举_Case_模式（Enumeration_Case_Pattern）">5. 枚举 Case 模式（Enumeration Case Pattern）</h2><p>就如你在交易例子中所见，模式匹配对 Swift 的 <code>enum</code> 支持<strong>相当棒</strong>。这是因为 <code>enum cases</code> 就像密封、不可变且可解构的结构体。这非常像 <code>tuples</code>，你可以打开正好匹配上的某个单独 <code>case</code> 的内容然后只抽取出你需要的信息<a href="#2">2</a>。 </p>
<p>假想你正在用函数式的风格写一个游戏，然后你需要定义一些实体。你可以使用 <code>structs</code> 但是你的实体的状态很少，你觉得这样有点矫枉过正。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Soldier</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tank</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Player</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你需要实现绘图循环。这里我们只需要 X 和 Y 坐标：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> entities() &#123;</span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Soldier</span>(x, y):</span><br><span class="line">      drawImage(<span class="string">"soldier.png"</span>, x, y)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Tank</span>(x, y):</span><br><span class="line">      drawImage(<span class="string">"tank.png"</span>, x, y)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Player</span>(x, y):</span><br><span class="line">      drawImage(<span class="string">"player.png"</span>, x, y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-_类型转换模式">6. 类型转换模式</h2><p>就像名字所表示的一样，这种模式转换或者匹配类型。它有两种不同的关键词：</p>
<ul>
<li><code>is</code> <strong>类型</strong>：匹配右手边内容的运行时类型（或者类型的子类）。它会做类型转换但是不关注返回值。所以你的 <code>case</code> 块不知道所匹配的类型是什么。</li>
<li>模式 <code>as</code> <strong>类型</strong>：和 <code>is</code> 模式做同样的匹配操作，但是如果成功的话会把类型转换到左侧指定的模式中。</li>
</ul>
<p>下面是这两种关键词的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Any</span> = <span class="number">5</span> </span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line">  <span class="comment">// 这会失败因为它的类型仍然是 `Any`</span></span><br><span class="line">  <span class="comment">// 错误: binary operator '+' cannot be applied to operands of type 'Any' and 'Int'</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Int</span>: <span class="built_in">print</span> (a + <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 有效并返回 '6'</span></span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">let</span> n <span class="keyword">as</span> <span class="type">Int</span>: <span class="built_in">print</span> (n + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>is</code> 前没有 <code>pattern</code>。它直接和 <code>a</code> 做匹配。</p>
<h2 id="7-_表达模式">7. 表达模式</h2><p>表达模式非常强大。它可以把 <code>switch</code> 的值和实现了 <code>~=</code> 操作符的表达式进行匹配。而且对于这个操作符有默认的实现，比如对于范围匹配，你可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">5</span> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">0</span>..<span class="number">10</span>: <span class="built_in">print</span>(<span class="string">"In range 0-10"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更有趣的可能是自己重写操作符，然后使你的自定义类型可以匹配。我们假定你想重写之前写的士兵游戏，而且你无论如何都要使用结构体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hp: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你想轻松的匹配所有血量为 <strong>0</strong> 的实体。我们可以像下面一样实现 <code>~=</code> 操作符。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~= <span class="params">(pattern: Int, value: Soldier)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern == value.hp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就可以对一个实体做匹配了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> soldier = <span class="type">Soldier</span>(hp: <span class="number">99</span>, x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">switch</span> soldier &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">print</span>(<span class="string">"dead soldier"</span>)</span><br><span class="line">   <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不幸的是，对元组做全匹配似乎不好使。如果你编写下面的代码，就会出现类型检查错误。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> ~= <span class="params">(pattern: <span class="params">(hp: Int, x: Int, y: Int)</span></span></span>, value: <span class="type">Soldier</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> (hp, x, y) = pattern</span><br><span class="line">   <span class="keyword">return</span> hp == value.hp &amp;&amp; x == value.x &amp;&amp; y == value.y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个可能解决上述类似问题的方案是给你的 <code>struct</code> 增加一个 <code>unapply</code> 方法然后再进行匹配：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Soldier</span> </span>&#123;</span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">unapply</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">self</span>.hp, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> ~= <span class="params">(p: <span class="params">(Int, Int, Int)</span></span></span>, t: (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> p.<span class="number">0</span> == t.<span class="number">0</span> &amp;&amp; p.<span class="number">1</span> == t.<span class="number">1</span> &amp;&amp; p.<span class="number">2</span> == t.<span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> soldier = <span class="type">Soldier</span>(hp: <span class="number">99</span>, x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(soldier.unapply() ~= (<span class="number">99</span>, <span class="number">10</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>但是这相当繁琐而且没有利用好模式匹配背后的大量魔法般的效果。</p>
<p>在这篇博文之前的版本中我写过 <code>~=</code> 不适用于协议，但是我错了。我记得我在一个 <code>Playground</code> 中试过。而这个例子（<a href="https://www.reddit.com/r/swift/comments/3hq6id/match_me_if_you_can_swift_pattern_matching_in/cub187r" target="_blank" rel="external">由 reddit 上的 latrodectus 友情提供</a>）是完全可用的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tank</span>: <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.value = value &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Peasant</span>: <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> value: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.value = value &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> ~=<span class="params">(pattern: Entity, x: Entity)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pattern.value == x.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="type">Tank</span>(<span class="number">42</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Peasant</span>(<span class="number">42</span>): <span class="built_in">print</span>(<span class="string">"Matched"</span>) <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以利用 <code>Expression Patterns</code> 做很多事情。如果想要了解更多表达模式的细节，<a href="http://austinzheng.com/2014/12/17/custom-pattern-matching/" target="_blank" rel="external">看看这篇由 Austin Zheng 写的超棒博文</a>。</p>
<p>现在我们已经讲完了所有可能的 <code>switch</code> 模式。在我们继续讲解之前，还需要讨论最后一件事情。</p>
<h2 id="fallthrough，break_和标签">fallthrough，break 和标签</h2><p>下面的内容和模式匹配没有直接关系，仅仅是和 <code>switch</code> 关键词有关，所以我就简单说了。和 C/C++/Objective-C 不一样的是：<code>switch cases</code> 不会自动进入下一个 <code>case</code>，这也是为什么 Swift 不需要给每个 <code>case</code> 都写上 <code>break</code>。你可以选择使用 <code>fallthrough</code> 关键词来实现传统的自动进入下一个 <code>case</code> 的行为。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> <span class="number">5</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Is 5"</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Is a number"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会在命令行输出: "Is 5" "Is a number"</span></span><br></pre></td></tr></table></figure>
<p>另外，你可以使用 <code>break</code> 来提前跳出 <code>switch</code> 语句。既然不会默认进入下一个 <code>case</code>，为什么还需要这么做呢？比如你知道在一个 <code>case</code> 中有一个必须的要求是不满足的，这样你就不能继续执行这个 <code>case</code> 了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userType = <span class="string">"system"</span></span><br><span class="line"><span class="keyword">let</span> userID = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> (userType, userID)  &#123;</span><br><span class="line">   <span class="keyword">case</span> (<span class="string">"system"</span>, <span class="number">_</span>):</span><br><span class="line">     <span class="keyword">guard</span> <span class="keyword">let</span> userData = getSystemUser(userID) <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"user info: <span class="subst">\(userData)</span>"</span>)</span><br><span class="line">     insertIntoRemoteDB(userData)</span><br><span class="line">   <span class="keyword">default</span>: ()</span><br><span class="line">&#125;</span><br><span class="line">... 其他你需要执行的代码</span><br></pre></td></tr></table></figure>
<p>在这段代码中，当 <code>getSystemUser</code> 返回的结果是 <code>nil</code> 时你不想再继续调用 <code>insertIntoRemoteData</code>。当然，你可以在这里使用 <code>if let</code>，但是如果多个这样的情况结合到一起的时候，很快你就会得到一堆可怕丑陋的 <code>if lets</code> 嵌套代码。</p>
<p>但是如果你是在一个 <code>while</code> 循环中执行你的 <code>switch</code> 语句，然后你想跳出循环，而不是 <code>switch</code> 的时候，你需要怎么做呢？对与这种情况， Swift 允许你定义一个 <code>labels</code> ，然后 <code>break</code> 或者 <code>continue</code> 到这个 <code>labels</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">gameLoop: <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> state() &#123;</span><br><span class="line">     <span class="keyword">case</span> .<span class="type">Waiting</span>: <span class="keyword">continue</span> gameLoop</span><br><span class="line">     <span class="keyword">case</span> .<span class="type">Done</span>: calculateNextState()</span><br><span class="line">     <span class="keyword">case</span> .<span class="type">GameOver</span>: <span class="keyword">break</span> gameLoop</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经讨论过 <code>switch</code> 和模式匹配的语法和实现细节。现在，让我们来看一些（多少有点）有趣的真实案例。</p>
<h1 id="真实案例">真实案例</h1><h2 id="可选值">可选值</h2><p><a href="http://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="external">对可选值进行解包的方式有很多种</a>，模式匹配就是其中一种。可能到现在这种方法你已经用得非常频繁了，但还是给一个简短的例子吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">String</span>? = secretMethod()</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">None</span>:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"is nothing"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> a:</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(a)</span> is a value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 Swift 2.0 的话，这会更简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result: <span class="type">String</span>? = secretMethod()</span><br><span class="line"><span class="keyword">switch</span> result &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"is nothing"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> a?:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(a)</span> is a value"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所见，<code>result</code> 可以是一个字符串，但是它也可能是 <code>nil</code>，因为它是 <code>optional</code> 值。通过对 <code>result</code> 执行 <code>switch</code>。我们可以确定它是 <code>.None</code> 或者是一个确定的值。更进一步，如果他是一个确定的值，我们可以在 <code>a</code> 这种情况下马上把这个值绑定到一个变量。这段代码代码的优美之处在于：变量 <code>result</code> 可能存在的两种状态被非常明显的区分开来。</p>
<h2 id="类型匹配">类型匹配</h2><p>做为强类型语言，Swift 通常不会像 Objective-C 那样经常需要运行时类型检查。然而，当你需要与传统的 Objective-C 代码交互时（<a href="https://netguru.co/blog/objective-c-generics" target="_blank" rel="external">这还没有更新到简单泛型的反射一文中</a>），那你就经常会碰到需要做类型检查的代码。假想你得到了一个包含 <code>NSString</code> 和 <code>NSNumber</code> 元素的数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u = <span class="type">NSArray</span>(array: [<span class="type">NSString</span>(string: <span class="string">"String1"</span>), <span class="type">NSNumber</span>(int: <span class="number">20</span>), <span class="type">NSNumber</span>(int: <span class="number">40</span>)])</span><br></pre></td></tr></table></figure>
<p>当你遍历这个 <code>NSArray</code> 时，你永远不知道得到的是什么类型。然而， <code>switch</code> 语句可以让你很简单的检查这些类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> u &#123;</span><br><span class="line">    <span class="keyword">switch</span> x &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSString</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"string"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span> <span class="keyword">as</span> <span class="type">NSNumber</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"number"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Unknown types"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按范围做分级">按范围做分级</h2><p>现在你正在给你当地的高校写分级的 iOS 应用。老师想要输入一个 0 到 100 的数值，然后得到一个相应的等级字符（A-F）。模式匹配现在要来拯救你了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aGrade = <span class="number">84</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> aGrade &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">90</span>...<span class="number">100</span>: <span class="built_in">print</span>(<span class="string">"A"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>...<span class="number">90</span>: <span class="built_in">print</span>(<span class="string">"B"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">70</span>...<span class="number">80</span>: <span class="built_in">print</span>(<span class="string">"C"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>...<span class="number">70</span>: <span class="built_in">print</span>(<span class="string">"D"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>...<span class="number">60</span>: <span class="built_in">print</span>(<span class="string">"F"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Incorrect Grade"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字频率统计">字频率统计</h2><p>有一系列的数据对，每个数据对代表一个字和它在某段文字中出现的频率。我们的目标就是把那些低于或者高于某个固定阈值的数据对过滤掉，然后只返回剩下的不包含其频率的所有字。</p>
<p>这是我们的字集：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wordFreqs = [(<span class="string">"k"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">7</span>), (<span class="string">"b"</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>一个简单的解决方案是使用 <code>map</code> 和 <code>filter</code> 进行建模：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = wordFreqs.<span class="built_in">filter</span>(&#123; (e) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> e.<span class="number">1</span> &gt; <span class="number">3</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="built_in">map</span> &#123; $<span class="number">0.0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<p>然而，因为 <code>flatmap</code> 只能返回非空元素，所以这个解决方案还有很大的改进空间。首先，我们可以放弃使用 <code>e.1</code> 而利用元组来做适当的解构（你猜对了）。然后我们只需要调用一次 <code>flatmap</code>，这样可以减少先 <code>filter</code> 后 <code>map</code> 所带来的不必要的性能开销。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = wordFreqs.flatMap &#123; (e) -&gt; <span class="type">String</span>? <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> e &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (s, t) <span class="keyword">where</span> t &gt; <span class="number">3</span>: <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="遍历目录">遍历目录</h2><p>假想你需要遍历一个文件树然后查找以下内容：</p>
<ul>
<li>所有 customer1 和 customer2 创建的 “psd“文件</li>
<li>所有 customer2 创建的 “blend“文件</li>
<li>所有用户创建的 “jpeg“文件</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> enumerator = <span class="type">NSFileManager</span>.defaultManager().enumeratorAtPath(<span class="string">"/customers/2014/"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> enumerator &#123;</span><br><span class="line">    <span class="keyword">switch</span> (url.pathComponents, url.pathExtension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// customer1 和 customer2 创建的 “psd“文件</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">let</span> f, <span class="string">"psd"</span>) </span><br><span class="line">	    <span class="keyword">where</span> f.<span class="built_in">contains</span>(<span class="string">"customer1"</span>) </span><br><span class="line">	    || f.<span class="built_in">contains</span>(<span class="string">"customer2"</span>): <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// customer2 创建的 “blend“文件</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="keyword">let</span> f, <span class="string">"blend"</span>) <span class="keyword">where</span> f.<span class="built_in">contains</span>(<span class="string">"customer2"</span>): <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的 “jpeg“文件</span></span><br><span class="line">    <span class="keyword">case</span> (<span class="number">_</span>, <span class="string">"jpg"</span>): <span class="built_in">print</span>(url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 <code>contains</code> 在第一个匹配就结束然后就不用遍历完整的路径了。同样，模式匹配的代码非常简洁明了。</p>
<h2 id="Fibonacci">Fibonacci</h2><p>同样，来看一下使用模式匹配实现的 fibonacci 算法有多优美<a href="#3">3</a></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(i: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(i) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> n <span class="keyword">where</span> n &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>, <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> n: <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fibonacci(<span class="number">8</span>))</span><br></pre></td></tr></table></figure>
<p>当然，如果是大数的话，程序栈会爆掉。</p>
<h2 id="传统的_API_和值提取">传统的 API 和值提取</h2><p>通常情况下，当你从外部源取数据的时候，比如一个库，或者一个 API，它不仅是一种很好的做法，而且通常在解析数据之前需要检查数据的一致性。你需要确保所有的 <code>key</code> 都是存在的、或者数据的类型都正确、或者数组的长度满足要求。如果不这么做就会因为 bug（有的 <code>key</code> 不存在）而导致 app 崩溃（索引不存在的数组项）。而传统的做法通常是嵌套 <code>if</code> 语句。</p>
<p>假想有 API 返回一条用户信息。但是有两种类型的用户：系统用户——如管理员或者邮政局长——和本地用户——如 “John B”、“Bill Gates”等。因为系统的设计和增长，API 的使用者需要处理一些麻烦的事情：</p>
<ul>
<li><code>system</code> 和 <code>local</code> 用户来自同一个 API 调用。</li>
<li>因为早期版本的数据库没有 <code>department</code> 这个字段，所以这个 <code>key</code> 可能是不存在的，而且早期的雇员从来都不需要填写这个字段。</li>
<li>根据用户被创建的时间，<code>name</code> 数组可能包含 4 个元素（username，middlename，lastname 和 firstname）或者 2 个元素（full name，username）</li>
<li><code>age</code> 是代表用户年龄的整型数</li>
</ul>
<p>我们的系统需要给这个 API 返回的所有系统用户创建用户账号，账号信息只包含如下信息：username 和 department。我们只需要 1980 年以前出生的用户。如果没有指定 department，就指定为 “Corp”。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">legacyAPI</span><span class="params">(id: Int)</span></span> -&gt; [<span class="type">String</span>: <span class="type">AnyObject</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"type"</span>: <span class="string">"system"</span>, <span class="string">"department"</span>: <span class="string">"Dark Arts"</span>, <span class="string">"age"</span>: <span class="number">57</span>, </span><br><span class="line">	   <span class="string">"name"</span>: [<span class="string">"voldemort"</span>, <span class="string">"Tom"</span>, <span class="string">"Marvolo"</span>, <span class="string">"Riddle"</span>]] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们为给定的约束实现一个模式来进行匹配：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> item = legacyAPI(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">switch</span> (item[<span class="string">"type"</span>], item[<span class="string">"department"</span>], item[<span class="string">"age"</span>], item[<span class="string">"name"</span>]) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> (sys <span class="keyword">as</span> <span class="type">String</span>, dep <span class="keyword">as</span> <span class="type">String</span>, age <span class="keyword">as</span> <span class="type">Int</span>, name <span class="keyword">as</span> [<span class="type">String</span>]) <span class="keyword">where</span> </span><br><span class="line">      age &lt; <span class="number">1980</span> &amp;&amp;</span><br><span class="line">      sys == <span class="string">"system"</span>:</span><br><span class="line">     createSystemUser(name.<span class="built_in">count</span> == <span class="number">2</span> ? name.last! : name.first!, dep: dep ?? <span class="string">"Corp"</span>)</span><br><span class="line">  <span class="keyword">default</span>:()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 ("voldemort", "Dark Arts")</span></span><br></pre></td></tr></table></figure>
<p>注意这段代码做了一个很危险的假设：就是如果 <code>name</code> 数组元素的个数不是 2 个的话，那么它<strong>一定</strong>包含 4 个元素。如果这种假设不成立，我们获得了包含 0 个元素的数组，这段代码就会崩溃。</p>
<p>除了这一点，模式匹配向你展示了它是如何在只有一个 <code>case</code> 的情况下帮助你编写干净的代码和简化值的提取的。</p>
<p>同样来看看我们是怎么写紧跟在 <code>case</code> 之后 <code>let</code> 的，这样一来就不必在每一次赋值的时候都重复写它。</p>
<h1 id="模式和其他关键词">模式和其他关键词</h1><p>Swift 的文档指出不是所有的模式都可以在 <code>if</code>、<code>for</code> 或者 <code>guard</code> 语句中使用。然而，这个文档似乎不是最新的。所有 7 种模式对这三个关键词都有效。</p>
<p>我为那些感兴趣的人编了一个例子要点，为每个模式和每个关键词都写了一个例子。</p>
<p><a href="https://gist.github.com/terhechte/6eaeb90276bbfcd1ea41" target="_blank" rel="external">你可以在这里查看所有的样例模式</a></p>
<p>来看一个对三个关键词使用 <strong>值绑定</strong>、<strong>元组</strong>和<strong>类型转换</strong>模式的简短例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 到吗编译后只是一个关键词的集合。其本身没有任何意义</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">valueTupleType</span><span class="params">(a: <span class="params">(Int, Any)</span></span></span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// guard case 的例子</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> (x, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>) = a <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for case 的例子</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (a, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>) <span class="keyword">in</span> [a] &#123;</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if case 的例子</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> (x, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>) = a &#123;</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">"if"</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch case example</span></span><br><span class="line">    <span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (a, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>):</span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> u: <span class="type">Any</span> = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Any</span> = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(valueTupleType((<span class="number">5</span>, u)))</span><br><span class="line"><span class="built_in">print</span>(valueTupleType((<span class="number">5</span>, b)))</span><br><span class="line"><span class="comment">// 5, 5, "if 5", 5, true, false</span></span><br></pre></td></tr></table></figure>
<p>我们可以带着这个想法详细地看一看每一个关键词。</p>
<h1 id="使用_for_case"><strong>使用</strong> for case</h1><p>到了 Swift 2.0 后，模式匹配变得更加重要，因为它被扩展到不仅可以支持 <code>switch</code> ，还可以支持其他的关键词。比如，让我们写一个简单的只返回非空元素的数组函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">nonnil</span><span class="generics">&lt;T&gt;</span><span class="params">(array: [T?])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">   <span class="keyword">var</span> result: [<span class="type">T</span>] = []</span><br><span class="line">   <span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> x? <span class="keyword">in</span> array &#123;</span><br><span class="line">      result.append(x)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(nonnil([<span class="string">"a"</span>, <span class="literal">nil</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="literal">nil</span>]))</span><br></pre></td></tr></table></figure>
<p>关键词 <code>case</code> 可以被 <code>for</code> 循环使用，就像 <code>switch</code> 中的 <code>case</code> 一样。下面是另外一个例子。还记得我们之前说的游戏么？经过第一次重构之后，现在我们的实体系统看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">EntityType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Soldier</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Player</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Entry</span>(type: <span class="type">EntityType</span>, x: <span class="type">Int</span>, y: <span class="type">Int</span>, hp: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真棒！这可以让我们用更少的代码绘制出所有的项目：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Entity</span>.<span class="type">Entry</span>(t, x, y, <span class="number">_</span>) <span class="keyword">in</span> gameEntities()</span><br><span class="line"><span class="keyword">where</span> x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &#123;</span><br><span class="line">    drawEntity(t, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们用一行就解析出了所有必需的属性，然后确保我们不会在 0 一下的范围绘制，最后我们调用渲染方法（<code>drawEntity</code>）。</p>
<p>为了知道选手是否在游戏中胜出，我们想要知道是否有至少一个士兵的血量是大于 0 的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">gameOver</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">case</span> <span class="type">Entity</span>.<span class="type">Entry</span>(.<span class="type">Soldier</span>, <span class="number">_</span>, <span class="number">_</span>, <span class="keyword">let</span> hp) <span class="keyword">in</span> gameEntities() </span><br><span class="line">    <span class="keyword">where</span> hp &gt; <span class="number">0</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(gameOver())</span><br></pre></td></tr></table></figure>
<p>好的是 <code>Soldier</code> 的匹配是 <code>for</code> 查询的一部分。这感觉有点像 <code>SQL</code> 而不是命令循环编程。同时，这也可以让编译器更清晰的知道我们的意图，从而就有了打通调度增强这条路的可能性。另外一个很好的体验就是我们不需要完成的拼写出 <code>Entity.EntityType.Soldier</code>。就算我们像上面一样只写 <code>.Soldier</code>，Swift 也能明白我们的意图。</p>
<h1 id="使用_guard_case"><strong>使用</strong> guard case</h1><p>另外一个支持模式匹配的关键词就是新引入的 <code>guard</code> 关键词。它允许你像 <code>if let</code> 一样把 <code>optionals</code> 绑定到本地范围，而且不需要任何嵌套：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">example</span><span class="params">(a: String?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> a = a <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">example(<span class="string">"yes"</span>)</span><br></pre></td></tr></table></figure>
<p><code>guard let case</code> 允许你做一些类似模式匹配所介绍的事情。让我们再来看一下士兵的例子。在玩家的血量变满之前，我们需要计算需要增加的血量。士兵不能涨血，所以对于士兵实体而言，我们始终返回 0。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="type">MAX_HP</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">healthHP</span><span class="params">(entity: Entity)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Entity</span>.<span class="type">Entry</span>(.<span class="type">Player</span>, <span class="number">_</span>, <span class="number">_</span>, hp) = entity </span><br><span class="line">    <span class="keyword">where</span> hp &lt; <span class="type">MAX_HP</span> </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">MAX_HP</span> - hp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Soldier"</span>, healthHP(<span class="type">Entity</span>.<span class="type">Entry</span>(type: .<span class="type">Soldier</span>, x: <span class="number">10</span>, y: <span class="number">10</span>, hp: <span class="number">79</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Player"</span>, healthHP(<span class="type">Entity</span>.<span class="type">Entry</span>(type: .<span class="type">Player</span>, x: <span class="number">10</span>, y: <span class="number">10</span>, hp: <span class="number">57</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="string">"Soldier 0"</span></span><br><span class="line"><span class="string">"Player 43"</span></span><br></pre></td></tr></table></figure>
<p>这是把我们目前讨论的各种机制用到极致的一个例子。</p>
<ul>
<li>它非常清晰，没有牵扯到任何嵌套</li>
<li>状态的逻辑和初始化是在 <code>func</code> 之前处理的，这样可以提高代码的可读性</li>
<li>非常简洁</li>
</ul>
<p>这也是 <code>switch</code> 和 <code>for</code> 的完美结合，可以把复杂的逻辑结构封装成易读的格式。当然，它不会让逻辑变得更容易理解，但是至少会以更清晰的方式展现给你。特别是使用 <code>enums</code> 的时候。</p>
<h1 id="使用_if_case"><strong>使用</strong> if case</h1><p><code>if case</code> 的作用和 <code>guard case</code> 相反。它是一种非常棒的在分支中打开和匹配数据的方式。结合之前 <code>guard</code> 的例子。很显然，我们需要一个 <code>move</code> 函数，这个函数允许我们表示一个实体在朝一个方向移动。因为我们的实体是 <code>enums</code>，所以我们需要返回一个更新过的实体。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">move</span><span class="params">(entity: Entity, xd: Int, yd: Int)</span></span> -&gt; <span class="type">Entity</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">case</span> <span class="type">Entity</span>.<span class="type">Entry</span>(<span class="keyword">let</span> t, <span class="keyword">let</span> x, <span class="keyword">let</span> y, <span class="keyword">let</span> hp) = entity</span><br><span class="line">	<span class="keyword">where</span> (x + xd) &lt; <span class="number">1000</span> &amp;&amp;</span><br><span class="line">	    (y + yd) &lt; <span class="number">1000</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">Entity</span>.<span class="type">Entry</span>(type: t, x: (x + xd), y: (y + yd), hp: hp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> entity</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(move(<span class="type">Entity</span>.<span class="type">Entry</span>(type: .<span class="type">Soldier</span>, x: <span class="number">10</span>, y: <span class="number">10</span>, hp: <span class="number">79</span>), xd: <span class="number">30</span>, yd: <span class="number">500</span>))</span><br><span class="line"><span class="comment">// 输出: Entry(main.Entity.EntityType.Soldier, 40, 510, 79)</span></span><br></pre></td></tr></table></figure>
<h1 id="限制">限制</h1><p>一些限制已经在文章中说过，比如有关 <code>Expression Patterns</code> 的问题，看起来它似乎不能匹配 <code>tuples</code> （那样的话就真的很方便了）。在 Scala 和 Clojure 中，模式匹配在集合上同样可用，所以你可以匹配它的头部、尾部和部分等。<a href="#4">4</a>。这在 Swift 中是不支持的（<a href="http://austinzheng.com/2014/12/17/custom-pattern-matching/" target="_blank" rel="external">尽管 Austin Zheng 在我之前链接的博客里差不多实现了这一点</a>）</p>
<p>另外一种不可用的的情况是（这一点 Scala 同样做得很好）对类或者结构体进行解构。Swift 允许我们定义一个 <code>unapply</code> 方法，这个方法做的事情大体和 <code>init</code> 相反。实现这个方法，然后就可以让类型检查器对类进行匹配。而在 Swift 中，它看起来就像下面一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Imaginary</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">   <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">unapply</span><span class="params">()</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="comment">// 实现这个方法之后，理论上来说实现了解构变量所需的所有细节</span></span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后这个就会自动 unapply 然后再进行匹配</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Imaginary</span>(x, y) = anImaginaryObject <span class="keyword">else</span> &#123; <span class="keyword">break</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="更新">更新</h1><p><strong>08/21/2015</strong> 结合 <a href="https://www.reddit.com/r/swift/comments/3hq6id/match_me_if_you_can_swift_pattern_matching_in/" target="_blank" rel="external">Reddit 上 foBrowsing 的有用反馈</a></p>
<ul>
<li>增加 <code>guard case let</code></li>
<li>增加简化版的 let 语法（如：<code>let (x, y)</code> 替代 <code>(let x, let y)</code>）</li>
</ul>
<p><strong>08/22/2015</strong> <a href="https://www.reddit.com/r/swift/comments/3hq6id/match_me_if_you_can_swift_pattern_matching_in/" target="_blank" rel="external">似乎有一些东西我没测试好</a>。我列举的一些限制实际上是可用的，另外一个 Reddit 上的评论者（latrodectus）提出了一些非常有用的指正。</p>
<ul>
<li>将之前的修正为：所有的模式对三个关键词都适用，然后增加了一些要点案例</li>
<li>关于协议和表达式模式无效这个限制，其实没有的</li>
<li>增加 “模式可用性“章节</li>
</ul>
<p><strong>08/24/2015</strong> </p>
<ul>
<li>增加 <code>if case</code> 样例，重命名了一些章节。</li>
<li>修复了一些文本拼写错误。尤其我不小心写道：<code>_</code> 不能匹配 <code>nil</code>。那当然是不对的，<code>_</code> 可以匹配所有的东西。（感谢 <a href="https://github.com/obecker" target="_blank" rel="external">obecker</a>）</li>
</ul>
<p><strong>09/18/2015</strong></p>
<ul>
<li>添加了日语翻译的链接</li>
</ul>
<hr>
<p><a name="1">1.可以把它当做 <code>shell</code> 里面的 <code>*</code> 通配符</a></p>
<p><a name="2">2.我不清楚编译器是否在对这点进行了优化，但理论上来说，它应该能计算出所需数据的正确位置，然后忽略 <code>enum</code> 的其他情况并内联这个地址</a></p>
<p><a name="3">3.当然，不是 Haskell实现的对手：<br>fib 0 = 0<br>fib 1 = 1<br>fib n = fib (n-1) + fib (n-2)<br></a></p>
<p><a name="4">4.比如：switch [1, 2, 4, 3] {<br>case [<em>, 2, </em>, 3]:<br>}</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/">原文链接</a>，原文日期：2015-08-20<br>译者：<a href="http://blog.csdn.net/mmoaay">mmoaay</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在众多 Swift 提供给 Objective-C 程序员使用的新特性中，有个特性把自己伪装成一个无聊的老头，但是却在如何优雅的解决“鞭尸金字塔“的问题上有着巨大的潜力。很显然我所说的这个特性就是 <code>switch</code> 语句， 对于很多 Objective-C 程序员来说，除了用在 <a href="http://en.wikipedia.org/wiki/Duff%27s_device">Duff’s Device</a> 上比较有趣之外，<code>switch</code> 语句非常笨拙，与多个 <code>if</code> 语句相比，它几乎没有任何优势。</p>]]>
    
    </summary>
    
      <category term="APPVENTURE" scheme="http://swiftggteam.github.io/tags/APPVENTURE/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的范围和区间]]></title>
    <link href="http://swiftggteam.github.io/2015/10/26/swift-ranges-and-intervals/"/>
    <id>http://swiftggteam.github.io/2015/10/26/swift-ranges-and-intervals/</id>
    <published>2015-10-26T01:00:00.000Z</published>
    <updated>2015-11-20T03:44:34.798Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/09/swift-ranges-and-intervals/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-24<br>译者：<a href="http://www.dianqk.org/" target="_blank" rel="external">靛青K</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；定稿：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>本系列其它文章：</p>
<p>(1)<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/" target="_blank" rel="external">自定义模式匹配</a></p>
<p>(2)范围和区间(即本篇)</p>
<p>(3)<a href="http://oleb.net/blog/2015/09/more-pattern-matching-examples/" target="_blank" rel="external">更多有关模式匹配的例子</a></p>
<blockquote>
<p>下载本篇文章所需要的 <a href="http://oleb.net/media/swift-ranges-and-intervals.playground.zip" target="_blank" rel="external">playground</a> （Xcode7 运行环境）</p>
</blockquote>
<a id="more"></a>
<p>在前一篇<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/" target="_blank" rel="external">有关模式匹配</a>的文章中，我提及标准库中已经针对<strong>范围和区间</strong>使用<code>~=</code>模式匹配操作符进行了重载。</p>
<p>这两个数据类型是相关的，但也有一些重要的区别。对于如何在<code>switch</code>中进行不等式条件匹配的问题，它们不失为一个可选的解决方案，本文将对它们进行深入讨论。</p>
<h2 id="Ranges">Ranges</h2><p>范围是用<a href="http://swiftdoc.org/swift-2/type/Range/" target="_blank" rel="external">Range</a>类型表达的。一个范围就是一个<em>索引</em>集合。</p>
<blockquote>
<p>注意：一个范围就是一个索引集合。</p>
</blockquote>
<p><em>Range</em>在标准库中被频繁使用，特别是处在集合的上下文当中时。当我们查看<code>Range</code>定义时，范围和集合之间的紧密关系一目了然：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>&lt;<span class="title">Element</span> : <span class="title">ForwardIndexType</span>&gt; : <span class="title">CollectionType</span>, <span class="title">Indexable</span>, ... </span>&#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个范围中的元素必需遵守<code>ForwardIndexType</code>协议，同时<code>CollecitonType</code>协议中的大量功能也是基于它实现的。有一个特殊的类型用来表示集合索引的范围，对于获取一个集合的子集是相当有意义的。例如，我们可以使用范围获取一个数组的部分:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="comment">// 1..&lt;5 等价于 Range(start: 1, end: 5)</span></span><br><span class="line">numbers[<span class="number">1</span>..&lt;<span class="number">5</span>] <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>正如类型定义中所看到的，<em>Range</em>自身遵循<code>CollectionType</code>协议，所以几乎所有数组可以做的事情，范围也能够适用。比如用<code>for</code>循环遍历元素，或者使用<code>contains(_:)</code>检查一个值是否在这个范围内。</p>
<p>虽然范围主要适用于与其他集合配合使用，但谁也无法阻止你创建一个用于表示数字区间的<code>Range&lt;Int&gt;</code>。毕竟<a href="http://swiftdoc.org/swift-2/type/Int/" target="_blank" rel="external">Int</a>已经实现了<code>ForwardIndexType</code>协议。现在回到我们的模式匹配问题。</p>
<p>我们可以用一个范围<code>(Int.min..&lt;0).contains(x)</code>表示 x &lt; 0 的情况，这是完全等价的，不过执行速度巨慢。毕竟默认需要遍历整个集合，最糟糕的情况下，将执行<a href="https://en.wikipedia.org/wiki/9223372036854775807" target="_blank" rel="external">9,223,372,036,854,775,808次</a>，这相当耗费资源。我们可以为<code>Comparable</code>（比如<code>Int</code>）类型的索引提供一个更好实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Range</span> <span class="title">where</span> <span class="title">Element</span> : <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(element: Element)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> element &gt;= startIndex &amp;&amp; element &lt; endIndex</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">(<span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这是一个非常好的练习，不过在我们案例中可有可无，因为<code>~=</code>操作符为<code>Range</code>实现的匹配足够高效（就像我们的<code>contains(_:)</code>，<code>Comparable</code>只是在索引中工作）。所以我们可以这样的做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> ~= -<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> ~= <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> ~= <span class="number">1</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在这基础上，我们可以写一个<code>switch</code>语句，使用范围查询判断一个数字是否大于，小于还是等于 0，对吗？不幸地是，这并不适用。这段代码会崩溃：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="type">Int</span>.<span class="built_in">max</span>: <span class="comment">// EXC_BAD_INSTRUCTION</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会在<code>case 1...Int.max</code>这一行中得到一个<code>EXC_BAD_INSTRUCTION</code> 错误信息表明“fatal error: Range end index has no valid successor”。导致错误的原因在于:<code>range</code>中的<code>endIndex</code>总是指向范围中最后一个元素的后面。这对于半开区间（用 ..&lt; 操作符创建）和闭合区间（用 … 操作符创建）都是一样的，因为二者的内部实现是一样的，<code>a...b</code>事实上就是<code>a..&lt;b.successor()</code>。 </p>
<blockquote>
<p>注意：一个<code>Range&lt;Int&gt;</code>永远都不能有<code>Int.max</code></p>
</blockquote>
<p>这意味着<code>Int.max</code>永远都不会成为一个<code>Range&lt;Int&gt;</code>的成员，这同样适用于其他有最大值的类型。这个限制使范围不能满足我们所要的需求。所以接下来让我们来看看区间能不能满足我们的要求。</p>
<h2 id="区间">区间</h2><p>范围和区间是基本相同的概念构建的（一个连续元素的系列，有开始有结尾），但使用了不同的方法。范围基于索引，因此可以是个集合，他们的大多数功能都是基本这个特性的。区间<em>不是</em>集合，他们的实现是依赖<code>Comparable</code>协议的。我们只可以为服从<code>Comparable</code>协议的类型创建区间类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">IntervalType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Bound</span> : <span class="type">Comparable</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有别于范围的定义，区间使用<code>IntervalType</code>协议呈现，这个协议有两个具体的实现，<code>HalfOpenInterval</code>和<code>ClosedInterval</code>。两个范围操作符也为区间提供了重载：..&lt; 创建一个<code>HalfOpenInterval</code>和 … 创建一个<code>ClosedInterval</code>。由于默认是重载了<code>Range</code>，所以你必须明确变量为区间类型(IntervalType)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> int1: <span class="type">HalfOpenInterval</span> = <span class="number">1</span>..&lt;<span class="number">5</span></span><br><span class="line">int1.<span class="built_in">contains</span>(<span class="number">5</span>) <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> int2: <span class="type">ClosedInterval</span> = <span class="number">1</span>...<span class="number">5</span></span><br><span class="line">int2.<span class="built_in">contains</span>(<span class="number">5</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>另一件事情就是记得<code>ClosedInterval</code>不可以为空，x…x 总是会包含 x，而 x…(x-1) 会造成运行时错误。</p>
<p>然而闭合区间可以包含一个类型的最大值。这意味着我们现在可以写我们的<code>switch</code>语句了。重复一遍，一定要明确类型，告诉编译器我们想要的是区间而不是范围：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...<span class="type">Int</span>.<span class="built_in">max</span> <span class="keyword">as</span> <span class="type">ClosedInterval</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Int</span>.<span class="built_in">min</span>..&lt;<span class="number">0</span> <span class="keyword">as</span> <span class="type">HalfOpenInterval</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为开区间定制操作符">为开区间定制操作符</h2><p>非常好，但我想摆脱<code>Int.min</code>和<code>Int.max</code>。为了达到这个目的，我们需要为开区间和闭区间自定义前缀操作符和后缀操作符，用于表示所有小于一个上边界的值，或者大于一个下边界的值。这样不仅在语法上要更友善；理想情况下，这些操作符不仅适用于 <code>Int</code> 类型，也可以适合于其它拥有最小和最大值的类型。实现看起来应该是这个样子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...: <span class="comment">// an interval from 1 to Int.max (inclusive)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> ..&lt;<span class="number">0</span>: <span class="comment">// an interval from Int.min to 0 (exclusive)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要为 <code>..&lt;</code> 和 <code>...</code> 分别定义前缀和后缀的实现方式 。下面这段代码基本是基于 <a href="http://natecook.com/" target="_blank" rel="external">Nate Cook</a> 写的 <a href="https://gist.github.com/natecook1000/3b15b8bd974c8c08b3df" target="_blank" rel="external">gist片段</a> ，他已经在 2014 年 11 月使用范围和区间混合实现了它。我把使用区间的部分放在这里。</p>
<p>首先我们必须声明需要解释的操作符：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ..&lt; &#123; &#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ... &#123; &#125;</span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> ..&lt; &#123; &#125;</span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> ... &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>紧接着为<code>Int</code>实现第一个运算符的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Forms a half-open interval from `Int.min` to `upperBound`</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; (upperBound: Int) -&gt;</span> <span class="title">HalfOpenInterval</span><span class="generics">&lt;Int&gt;</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>.<span class="built_in">min</span>..&lt;upperBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以，但我们应该让它更通用。区间要求它的底层类型都遵循<code>Comparable</code>协议，所以使用相同的条件约束是一个很自然的选择。但在这里我们会碰到一个问题：我们需要知道 T 类型的最小值来创建区间，但这并没有一个通用的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; &lt;T : Comparable&gt;</span><span class="params">(upperBound: T)</span></span> -&gt; <span class="type">HalfOpenInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="built_in">min</span>..&lt;upperBound <span class="comment">// error: type 'T' has no member 'min'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至是在标准库中的其他协议都没有为数字（就比如<code>IntegerType</code>）提供这些–定义在数字类型中的<code>min</code>和<code>max</code>属性。</p>
<p>Nate 想出了一个很酷的解决方案：定义一个<code>MinMaxType</code>的自定义协议，这个协议定义了 <code>min</code> 和 <code>max</code> 两个属性。因为所有整数类型都有这两个属性，让他们遵守新的协议就不用额外写代码了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Conforming types provide static `max` and `min` constants.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MinMaxType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="built_in">min</span>: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="built_in">max</span>: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend relevant types</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int8</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int16</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int32</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int64</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt8</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt16</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt32</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt64</span> : <span class="title">MinMaxType</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个值得牢记的技巧。任何时候，当你有几个不相关的类型，但它们具有相同类型的一个或多个方法、属性，你都可以创建一个新的协议给他们提供一个通用接口。</p>
<blockquote>
<p>注意：任何时候，当你有几个不相关的类型，但它们具有相同类型的一个或多个方法、属性，你都可以创建一个新的协议给他们提供一个通用接口。</p>
</blockquote>
<p>告诉我们的通用类型 T 遵守<code>MinMaxType</code>协议以使这个实现可以正常运行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Forms a half-open interval from `T.min` to `upperBound`</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; &lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(upperBound: T)</span></span> -&gt; <span class="type">HalfOpenInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="built_in">min</span>..&lt;upperBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是其他三个操作符的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Forms a closed interval from `T.min` to `upperBound`</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="func"><span class="keyword">func</span> ... <span class="generics">&lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(upperBound: T)</span></span> -&gt; <span class="type">ClosedInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">T</span>.<span class="built_in">min</span>...upperBound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Forms a half-open interval from `lowerBound` to `T.max`</span></span><br><span class="line"><span class="keyword">postfix</span> <span class="func"><span class="keyword">func</span> ..<span class="generics">&lt; &lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(lowerBound: T)</span></span> -&gt; <span class="type">HalfOpenInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lowerBound..&lt;<span class="type">T</span>.<span class="built_in">max</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Forms a closed interval from `lowerBound` to `T.max`</span></span><br><span class="line"><span class="keyword">postfix</span> <span class="func"><span class="keyword">func</span> ... <span class="generics">&lt;T : Comparable where T : MinMaxType&gt;</span></span><br><span class="line">    <span class="params">(lowerBound: T)</span></span> -&gt; <span class="type">ClosedInterval</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lowerBound...<span class="type">T</span>.<span class="built_in">max</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加一些测试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">min</span>) <span class="comment">// true</span></span><br><span class="line">(..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">(..&lt;<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(...<span class="number">0</span>).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">min</span>) <span class="comment">// true</span></span><br><span class="line">(...<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">(...<span class="number">0</span>).<span class="built_in">contains</span>(<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">max</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="number">0</span>..&lt;).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">max</span> - <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>...).<span class="built_in">contains</span>(-<span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line">(<span class="number">0</span>...).<span class="built_in">contains</span>(<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line">(<span class="number">0</span>...).<span class="built_in">contains</span>(<span class="type">Int</span>.<span class="built_in">max</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>回到我们的<code>switch</code>语句，现在很好地工作了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>...:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"positive"</span>)</span><br><span class="line"><span class="keyword">case</span> ..&lt;<span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"negative"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"zero"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"Should be unreachable"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结论">结论</h2><p>Swift 中范围和区间都有相似的目的，但有着不同的实现和泛型约束。范围基于索引并且经常用于集合上下文中。这意味着范围不能包含一个类型最大值，这就不适合用在数字的区间上。区间兼容所有的<code>Comparable</code>类型，并且没有最大值的限制。</p>
<p>虽然我们应该对自定义操作符持谨慎的态度，但我认为在这个特定的例子中，他们可以明显地提高可读性而没有降低可理解性–这个前缀和后缀操作符非常接近他们原本的意思，甚至是不熟悉这段代码的读者在理解它的时候也不会有多大的困难。</p>
<p>即便如此，我还是认为在这个特定的例子中，使用自定义操作符来替代标准的 Swift 句法（case _ where x &gt; 0）所得到的好处是很小的，因此在实战代码中还是不值得使用。把这个方法暂时视为思考上的实践，而非推荐使用。</p>
<p>如果你喜欢这篇文章，你可能也会喜欢 Chris Eidhof 和 Airspeed Velocity 的即将出版的书，<a href="https://www.objc.io/books/advanced-swift/" target="_blank" rel="external">Swift 进阶</a>。他们对于相同的在区间下标上下文中的开闭区间主题讨论了很多其它的东西。我是这本书的技术审校，所以我的意见偏向的，但是如果你对 Swift 很感兴趣，我还是非常推荐这本书给你。这本书当前是 beta 状态，但是现在已经可以买到它的早期预览版了。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Ole Begemann，<a href="http://oleb.net/blog/2015/09/swift-ranges-and-intervals/">原文链接</a>，原文日期：2015-09-24<br>译者：<a href="http://www.dianqk.org/">靛青K</a>；校对：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；定稿：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a></p>
</blockquote>
<!--此处开始正文-->
<p>本系列其它文章：</p>
<p>(1)<a href="http://oleb.net/blog/2015/09/swift-pattern-matching/">自定义模式匹配</a></p>
<p>(2)范围和区间(即本篇)</p>
<p>(3)<a href="http://oleb.net/blog/2015/09/more-pattern-matching-examples/">更多有关模式匹配的例子</a></p>
<blockquote>
<p>下载本篇文章所需要的 <a href="http://oleb.net/media/swift-ranges-and-intervals.playground.zip">playground</a> （Xcode7 运行环境）</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Ole Begemann" scheme="http://swiftggteam.github.io/tags/Ole-Begemann/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
</feed>
