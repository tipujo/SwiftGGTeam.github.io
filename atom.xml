<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SwiftGG]]></title>
  <subtitle><![CDATA[走心的 Swift 翻译组]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://swiftggteam.github.io/"/>
  <updated>2016-01-12T01:05:23.234Z</updated>
  <id>http://swiftggteam.github.io/</id>
  
  <author>
    <name><![CDATA[SwiftGG]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[初识 iOS 9 中新的联系人框架]]></title>
    <link href="http://swiftggteam.github.io/2016/01/12/ios-contacts-framework/"/>
    <id>http://swiftggteam.github.io/2016/01/12/ios-contacts-framework/</id>
    <published>2016-01-11T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.234Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：gabriel theodoropoulos，<a href="http://www.appcoda.com/ios-contacts-framework/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-29<br>译者：<a href="undefined">BridgeQ、星夜暮晨</a>；校对：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<!--此处开始正文-->
<p>同每一代 iOS 系统版本的更新一样，最新发布的 iOS 9 为用户和开发者带来了许多新特性以及原有功能的改善。在这个版本中，我们不仅看到了很多首次推出的 API，还可以看到许多针对原有框架和类库的更新。此外，一些旧版本的 API 被标记为 <code>deprecated</code>（校对注：意为新版本已被弃用），而使用了更好的 API 来替代。iOS 9 中，新的 <em>Contacts framework</em> （联系人框架）是最好的例子了，它是来代替原有 <em><a href="http://www.appcoda.com/ios-programming-import-contact-address-book/" target="_blank" rel="external">AddressBook framework</a></em> 的。该框架更加符合技术潮流且简单易用。</p>
<a id="more"></a>
<p>过去使用过 <em>AddressBook</em> API 的开发者经常会抱怨这个旧有的联系人框架非常难用，大家普遍认为它不易理解而且很难管理，对开发者菜鸟来说更是如此。然而，这些都已成为历史，全新的联系人框架非常简单易用，通过它你可以很容易地查找、创建和更新联系人信息，开发时间被极大地减少，扩展更新也可以很快地实现。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/contacts-framework.jpg" alt=""></p>
<p>在接下来的部分中，我们将重点介绍 <em><code>Contacts framework</code></em> 中最主要的内容。如果需要更多的技术细节，你可以去苹果的官方文档中查找，或者观看 <a href="https://developer.apple.com/videos/play/wwdc2015-223/" target="_blank" rel="external">WWDC 2015 session 223 video</a> 来学习。</p>
<p>首先，我们来谈论一件非常重要的事情，那就是用户隐私。用户总是在被询问是否允许应用程序访问他们的联系人数据，如果被允许，应用就可以自由地同联系人数据库进行交互，而如果用户禁止访问，那么应用必须尊重用户的选择，即无法同联系人数据进行任何交互。稍后，我们会谈论用户隐私的更多细节，我们将看到如何通过程序的手段来处理所有可能的情况。此外，要记住用户总是有资格在手机设置的选项中更改应用的授权状态，所以在你想要执行与联系人数据相关的任务前，总应该检查你的应用是否允许访问联系人数据。</p>
<p>联系人数据的主要来源是设备内置的数据库。然而，新的联系人框架不仅可以检索这个数据库，实际上，它还可以对别的来源进行数据的检索，比如通过你的 iCloud 账户（当然是在你已经连接了 iCloud 账户的情况下），并且返回检索到的联系人结果。这是非常有用的，因为你不需要单独再进行某个来源的检索，你一次就能够检索所有数据，并且可以随意管理。</p>
<p>新的联系人框架包括了许多不同功能的类，所有类都非常重要，但其中使用最多的一个是 <em><code>CNContactStore</code></em>，它代表联系人数据库，并且提供了大量的操作方法，比如查询、保存、更新联系人记录、授权检查、授权请求等。 <em><code>CNContact</code></em> 表示一条联系人记录，并且它的内部属性都是不可变的，如果你想要创建或者更新一条已经存在的联系人记录，你应该使用它的可变版本 <em><code>CNMutableContact</code></em>。值得注意的是，当你使用联系人框架时，尤其是进行联系人查找时，你应该总是在后台执行。如果一条联系人记录的查找花费较长的时间并且在主线程执行的话，你的应用会无法响应，这会使应用的用户体验非常糟糕。</p>
<p>当导入联系人数据到应用中时，几乎不需要导入所有的联系人属性。在所有联系人框架允许的搜索范围中检索所有已存在的联系人数据，是一个非常费资源的操作，你应该尽量避免这样去做，除非你确定你真的需要使用所有的联系人数据。可喜的是，新联系人框架提供了仅检索部分结果的方式，即检索一个联系人的部分属性。比如说，你可以只查找联系人的姓、名、家庭邮件地址和家庭电话号码，而撇开所有那些你不需要的数据。</p>
<p>除了通过编程的方式来使用联系人框架，它还提供了一些默认的用户界面（UI），可以让你的应用以直观可视的方式访问联系人数据。默认提供的用户界面跟手机自带联系人应用几乎一样，也就是说同样有一个联系人选择控制器（<em>contact picker view controller</em>）用来选择联系人和联系人属性，一个联系人视图控制器用来展示联系人的详细信息并且处理某些操作（例如，拨打电话）。</p>
<p>上面所有这些方面我们都将在本教程的后续部分详细介绍。再次声明，你可以通过官方文档来学习所有这些方面的详细内容。接下来，我们先来看一下示例程序是什么样子，然后我们开始学习使用新的联系人框架中的各种类，你会发现新的联系人框架非常易用而且有趣。</p>
<h2 id="示例应用简介">示例应用简介</h2><p>我试图在本篇教程的示例应用中，尽可能给大家全面地展示这个新框架的功能。实际上，在以下部分我将会给大家展示：</p>
<ol>
<li>检查应用是否准许访问联系人，并且如何请求授权。</li>
<li>使用三种不同的方式检索联系人。其中一种方式将会涉及 Picker View Controller 的使用。</li>
<li>访问检索到的联系人属性，并调整为适当的显示格式。</li>
<li>使用默认的 <em>Contacts</em> UI 来实现选择、查看以及编辑联系人。</li>
<li>创建一个新的联系人。</li>
</ol>
<p>我将这个示例应用命名为 <em>Birthdays</em>，因为其目的就是展示所有联系人生日信息。同时，还会显示联系人的全名、头像（如果有的话）以及<em>家庭</em> email 地址。虽然在理想情况下，这个应用的主要功能应该是进行生日提醒，不过我们并不会处理诸如通知、发送短信之类的事情。</p>
<p>这个应用是基于导航栏设计的，包含了以下几个部分：</p>
<p><em>ViewController</em> 是应用启动时的默认展示界面。它将会展示我在上面所提及的所有信息，包括导入的联系人，提供检索联系人的选项（右边的导航栏按钮）、创建新的联系人（左边的导航栏按钮）以及通过单击单元格来查看联系人的具体信息：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_1_display_records.png" alt="默认展示界面"></p>
<p>联系人详情将会通过内置的联系人视图控制器进行展示。你会在后面看到，这个控制器既可以展示所有的联系人信息，也可以只显示你感兴趣的内容。</p>
<p>在接下来的内容中，检索联系人将会是一个非常有意思的部分。我会为大家展示三种进行检索的方法，我将使用三种不同的思路：</p>
<ol>
<li>第一种方法，我们将通过填写联系人姓名（或者姓名的一部分），点击键盘上的返回按钮，然后应用就会检索所有匹配该姓名的联系人。</li>
<li>在下面这个截图中您可以看到，屏幕中央有一个选择器视图。我们将会用它来寻找所有生日满足对应月份要求的联系人，月份可以在这个选择器中进行选择，通过点击右上角的 “Done” 导航栏按钮，还会显示检索进度。</li>
<li>我们将使用框架所提供的默认选择器视图控制器，来直接查看和检索联系人。值得注意的是，这个控制器可以自定义可用的联系人，此外其显示风格也可以自定义。大家会在后面部分看到如何操作。</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_2_fetch_contacts.png" alt=""></p>
<p>这个就是选择器视图控制器，其中只显示了有生日记录的联系人：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_3_picker_view_controller.png" alt=""></p>
<p>我们这个应用的最后一个部分就是创建新联系人了。这个任务相当简单，为了简单起见，我们使用下面的这个视图控制器来输入我们要创建的联系人姓名、家庭 email 地址以及生日（我们不处理头像，这玩意儿对于我们的示例来说并不重要）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_4_create_contact.png" alt=""></p>
<p>这个示例应用所使用的数据（作为例子的联系人信息）都是 iPhone 模拟器默认数据库中所包含的。这些联系人信息对我们来说就已经足够了。当然，您也可以使用自己设备中的联系人信息，或者给模拟器中添加新的联系人。默认情况下模拟器所提供的联系人是没有头像的，但是你可以从照片库中简单地为联系人添加头像。</p>
<p>一如往常，您可以<a href="https://www.dropbox.com/s/4cgjzsmvexyclv2/ContactFrameworkStarter.zip?dl=0" target="_blank" rel="external">下载这个起始项目</a>，因为我们接下来所做的工作将从它开始。一旦您下载完成，您可以打开这个项目然后浏览一下其中我添加的那些代码。当您觉得准备好的时候，就可以继续阅读下一个部分了。</p>
<h2 id="Contact_Store_类">Contact Store 类</h2><p>我们在处理联系人的时候，经常使用的一个基础类就是 <em><code>CNContactStore</code></em> 类。这个类实际上代表了设备中所拥有的联系人数据库，它负责管理应用和实际数据库之间的数据交互操作。具体而言，它负责处理诸如检索、保存、更新联系人以及组记录(group records)之类的工作。简而言之，在使用联系人信息的时候，这个类是绝大多数我们所能做的任务的起始点，并且我们将会在下面要写的代码中看到它。</p>
<p>此外，我在概述中也提及了，用户隐私是 iOS 中重要的组成部分，因此在使用的时候千万要小心。众所周知，用户可以准许或者禁止第三方应用访问他们的联系人信息，因此确保您的应用在任何时候都准许显示与任务有关的联系人信息就变得至关重要。使用 <em><code>CNContactStore</code></em> 类，您可以检查您应用<em>当前的认证状态</em>，然后根据实际情况进行相应的处理。要记住，每当用户在查看设置的时候，都很有可能禁止应用访问他们的联系人信息，即使他们在应用初次启动的时候同意了这个请求，因此<em>在执行任务前一定要确保您有权限执行</em>，然后根据实际情况进行相应的处理。如果不这样做的话，往往会导致极差的用户体验，这也是您应当极力避免的。在本教程的这部分里，我们会认真考虑示例应用的认证状态。我们接下来将要做的，就是让你能够在项目中随意使用它。</p>
<p>您将会发现，Contact Store 类很擅长处理下面的情形（和其他方式相比）：</p>
<ul>
<li>检索联系人</li>
<li>创建（保存）新联系人，以及更新联系人信息</li>
<li>使用 Contact Picker 视图控制器来选择联系人</li>
</ul>
<p>要时刻记住，在整个类中我们只需要初始化一个 <em><code>CNContactStore</code></em> 对象，并使用它即可。另一方面，虽然我们可以在需要的时候创建一个新的 <em><code>CNContactStore</code></em> 对象，但是由于这个类代表了代码中的联系人数据库，那么为什么还要创建多个数据库的实例呢？因此，让我们从打开 <em><code>AppDelegate.swift</code></em> 文件开始吧，声明并初始化一个 <em><code>CNContactStore</code></em> 属性。在类的顶部添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contactStore = <span class="type">CNContactStore</span>()</span><br></pre></td></tr></table></figure>
<p>当然，在类的顶部导入下面这个框架也是必要的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Contacts</span><br></pre></td></tr></table></figure>
<p>好的！现在，在我们处理应用认证状态以及所有相关操作之前，让我们先写两个简便的辅助方法。注意这两个方法并不是必须的，没有它们我们仍能够很好地工作。不过，实现这些有特定功能的方法将会带来极大的便利。</p>
<p>因此，第一个方法会让其他类访问应用委托 (AppDelegate) 变得更容易些。正常情况下，为了访问应用委托我们需要使用下面这条语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br></pre></td></tr></table></figure>
<p>然而，我个人觉得，每次获取应用委托的时候都要写上面这段代码，实在是太烦人了。我们为什么不写一个类方法呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">getAppDelegate</span>() -&gt; <span class="title">AppDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个方法，我们可以以一个非常简单的方式来访问应用委托中的所有属性和方法。例如，我们可以从项目中的任意一个类中使用下面这行代码访问 <code>contectStore</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">AppDelegate</span>.getAppDelegate().contactStore</span><br></pre></td></tr></table></figure>
<p>第二个加在 <code>AppDelegate.swift</code> 文件中的辅助方法将会显示一个带有消息的警告控制器（alert controller），我们每次使用它的时候只需要提供一个参数即可。实现起来并不复杂，但是我们在这里做了一点小小的特殊动作；警告控制器必须通过视图控制器来进行显示，然而应用委托中并没有视图控制器的存在。要解决这个问题，我们首先必须要找到当前显示在应用窗口上的<em>顶层视图控制器</em>，然后在这个视图控制器中显示警告控制器。我们可以这么做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">showMessage</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: <span class="string">"Birthdays"</span>, message: message, preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">Alert</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> dismissAction = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    alertController.addAction(dismissAction)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> pushedViewControllers = (<span class="keyword">self</span>.window?.rootViewController <span class="keyword">as</span>! <span class="type">UINavigationController</span>).viewControllers</span><br><span class="line">    <span class="keyword">let</span> presentedViewController = pushedViewControllers[pushedViewControllers.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    presentedViewController.presentViewController(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们要做的就是重点了，我们来处理应用的认证状态。该状态是通过 <em><code>CNAuthorizationStatus</code></em> 枚举来表示的，这个枚举属于 <em><code>CNContactStore</code></em> 类。它包含了下列四个枚举值：</p>
<ol>
<li><code>NotDetermined</code>：这个状态说明用户暂未决定是否允许访问联系人数据库。当应用第一次安装在设备上时将处于此状态。</li>
<li><code>Restricted</code>：这个状态说明应用不仅不能够访问联系人数据，并且用户也不能在设置中改变这个状态。这个状态是某些被激活的限制所导致的（比如说家长控制）。</li>
<li><code>Denied</code>：这个状态说明用户不允许应用访问联系人数据。这个状态只能够被用户改变。</li>
<li><code>Authorized</code>：这个状态是所有应用都希望拥有的，这表明应用能够自由访问联系人数据库，然后根据联系人数据来处理某些任务。</li>
</ol>
<p>有一点在这需要说明清楚：应用安装之后，当且仅当用户第一次尝试执行涉及联系人数据（比如说检索联系人）的操作时，iOS 才会显示一个预定义的警告控制器，询问用户是否给应用授权：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_5_ask_authorization_alert.png" alt=""></p>
<p>如果用户准许授权，那么万事大吉。然而，如果用户禁止授权的话，那么应用就不能够获取联系人数据了，自然也没法做任何操作了。在我们的示例应用中，对于这个特殊的情况，我们会展示一个自定义的警告消息（使用我们此前定义的函数），告知用户他必须在设置中准许我们的应用访问联系人数据。我们在一个新的函数中处理这个状况，接下来我们会对其进行实现。显然，在这个函数中我们会尽可能考虑到所有的认证状态。我们先来看看函数吧，然后对其进行简短的分析：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">requestForAccess</span><span class="params">(completionHandler: <span class="params">(accessGranted: Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> authorizationStatus = <span class="type">CNContactStore</span>.authorizationStatusForEntityType(<span class="type">CNEntityType</span>.<span class="type">Contacts</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> authorizationStatus &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Authorized</span>:</span><br><span class="line">        completionHandler(accessGranted: <span class="literal">true</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Denied</span>, .<span class="type">NotDetermined</span>:</span><br><span class="line">        <span class="keyword">self</span>.contactStore.requestAccessForEntityType(<span class="type">CNEntityType</span>.<span class="type">Contacts</span>, completionHandler: &#123; (access, accessError) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> access &#123;</span><br><span class="line">                completionHandler(accessGranted: access)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> authorizationStatus == <span class="type">CNAuthorizationStatus</span>.<span class="type">Denied</span> &#123;</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">let</span> message = <span class="string">"<span class="subst">\(accessError!.localizedDescription)</span>\n\nPlease allow the app to access your contacts through the Settings."</span></span><br><span class="line">                        <span class="keyword">self</span>.showMessage(message)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        completionHandler(accessGranted: <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上面这个函数，你会发现它包含了一个 <em>completionHandler</em> 闭包，当应用准许访问联系人的时候通过传递一个 true 值来调用，不可访问的时候传递一个 false 值。某些状况非常简单，比如说 <code>Authorized</code> 或者 <code>Restricted</code>，通过 completionHandler 中传递的值可以很清楚的知道其操作。然而，有趣的是，这里 <code>Denied</code> 和 <code>NotDetermined</code> 状态的处理竟然是相同的，它们都会调用 <code>requestAccessForEntityType:completionHandler</code>，因此应用会请求授权。我之前提到的自定义消息只会在 <code>Denied</code> 状态下显示。</p>
<p>值得注意的是，  <code>requestAccessForEntityType:completionHandler:</code> 以及 <code>authorizationStatusForEntityType:</code> 这两个方法都需要一个 <code>CNEntityType</code> 参数。这是一个枚举值，它其中只包含了一个名为 <code>Contacts</code> 的值。这个枚举实际上指定了我们需要请求访问的实体。</p>
<p>从下一节开始，上面这个函数将会被多次使用。每次我们执行涉及到联系人数据的操作时，我们都会使用这个函数，我们要确定联系人数据是否准许访问，当然还要处理每个可能的情况，以避免产生差的用户体验。我们暂时没有发现问题，因为我们准备了一些可重用的代码，能够让我们接下来的工作更为便利。</p>
<h2 id="使用断言（Predicates）来检索联系人">使用断言（Predicates）来检索联系人</h2><p>正如我在概览一节阐述过的，我们打算实现三种不同的方式来检索联系人数据。其中之一是通过在文本框中填写我们想要检索的联系人全名或部分名字（无论是姓还是名），然后向联系人框架请求结果。这就是我们即将开始的操作，实现此功能的核心函数是 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Contacts/Reference/CNContactStore_Class/index.html#//apple_ref/occ/instm/CNContactStore/unifiedContactsMatchingPredicate:keysToFetch:error:" target="_blank" rel="external"><code>unifiedContactsMatchingPredicate:keysToFetch:error:</code></a>。</p>
<p>这个函数作为 <code>CNContactStore</code> 类的一部分，接受两个重要的参数：</p>
<ol>
<li>Predicate：为了得到返回结果而用以检索的 <code>NSPredicate</code> 对象。需要特别注意的是，这里只接受从 <code>CNContact</code> 类中得到的断言，而不接受您自己创建的通用断言（<a href="https://developer.apple.com/library/prerelease/ios/documentation/Contacts/Reference/CNContact_Class/index.html#//apple_ref/doc/uid/TP40015273-CH1-DontLinkElementID_56" target="_blank" rel="external">看这里</a>）。在 <code>CNContact</code> 类中所有支持的断言函数中，有一个名为 <code>predicateForContactsMatchingName:</code> 的函数，我们将会使用它来生成断言。</li>
<li>keysToFetch：通过设定此参数，您可以指定您想要检索的<em>部分联系人数据</em>。这是一个描述需要检索的联系人（<code>CNContact</code> 对象）属性的字符串数组。框架提供了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Contacts/Reference/CNContact_Class/index.html#//apple_ref/doc/constant_group/Metadata_Keys" target="_blank" rel="external">预定义的常量字符串值</a>，可以用作关键词来使用。</li>
</ol>
<p>值得注意的是，这个方法可能会抛出<em>异常</em>，因此它必须要在 <code>do-catch</code> 声明中使用 <code>try</code> 关键字来进行修饰。然后在语句的 <code>catch</code> 模块中对错误情况进行处理。</p>
<p><code>unifiedContactsMatchingPredicate:keysToFetch:error:</code> 函数的结果包含了匹配给定断言的 <code>CNContact</code> 对象的一个数组，或者当错误发生的时候返回 nil。</p>
<p>将上面的内容牢记在心，现在就可以开始实现代码了。现在打开 <code>AddContactViewController.swift</code> 文件，然后直接来到打开的类上方。在这里也要导入联系人框架，如果没有它，我们就没法做事了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Contacts</span><br></pre></td></tr></table></figure>
<p>我们现在前往 <code>textFieldShouldReturn:</code> 委托方法中。一开始我们会用上之前在应用委托中创建的最后一个函数，并且检查应用是否有权限读取联系人，以便继续：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在准许访问的情况下，为了匹配联系人，我们要准备好将进行检索的断言和关键词。除此之外，我们还将声明两个变量：一个用于存储结果的数组（如果有结果的话），以及如果没有检索到匹配联系人或者检索请求失败的时候，用以存储自定义消息的字符串变量。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">            <span class="keyword">let</span> predicate = <span class="type">CNContact</span>.predicateForContactsMatchingName(<span class="keyword">self</span>.txtLastName.text!)</span><br><span class="line">            <span class="keyword">let</span> keys = [<span class="type">CNContactGivenNameKey</span>, <span class="type">CNContactFamilyNameKey</span>, <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>]</span><br><span class="line">            <span class="keyword">var</span> contacts = [<span class="type">CNContact</span>]()</span><br><span class="line">            <span class="keyword">var</span> message: <span class="type">String</span>!</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察我们是如何声明断言和关键词组的，随后我们继续。在下一步中，我们使用 <em>try</em> 关键字来检索联系人数据，如果该操作成功的话，那么查询结果就会写入到我们此前初始化的 <em>contacts</em> 数组当中。如果没有找到联系人或者检索失败的话，我们就会设定一个即将用来展示的自定义消息；通过这几个操作我们对这个函数的实现操作就即将完成了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">            <span class="keyword">let</span> predicate = <span class="type">CNContact</span>.predicateForContactsMatchingName(<span class="keyword">self</span>.txtLastName.text!)</span><br><span class="line">            <span class="keyword">let</span> keys = [<span class="type">CNContactGivenNameKey</span>, <span class="type">CNContactFamilyNameKey</span>, <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br><span class="line">            <span class="keyword">var</span> contacts = [<span class="type">CNContact</span>]()</span><br><span class="line">            <span class="keyword">var</span> message: <span class="type">String</span>!</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">let</span> contactsStore = <span class="type">AppDelegate</span>.getAppDelegate().contactStore</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                contacts = <span class="keyword">try</span> contactsStore.unifiedContactsMatchingPredicate(predicate, keysToFetch: keys)</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> contacts.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    message = <span class="string">"No contacts were found matching the given name."</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123;</span><br><span class="line">                message = <span class="string">"Unable to fetch contacts."</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> message != <span class="literal">nil</span> &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="type">AppDelegate</span>.getAppDelegate().showMessage(message)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，我们现在遗留了一个 <code>else</code> 语句暂未处理，我们之后会回来补全这个遗漏的代码的。这里最重要的是观察我们是如何根据给定名字匹配联系人数据的，并且是如何处理非预期状况的。</p>
<h2 id="展示检索到的联系人">展示检索到的联系人</h2><p>最好的情况就是，我们的检索请求成功地返回了匹配到的联系人信息，接着将他们显示在 <code>ViewController</code> 类的表视图（tableview）中，这就很有必要了。然而，我们的第一步还是要让 <code>ViewController</code> 类也得到检索到的联系人信息，因为我们的所有检索操作都是在 <code>AddContactViewController</code> 中发生的。最好也是最简单的方法就是，使用众所周知的协议委托模式（Delegation pattern）。那么，让我们朝着这个方向进行吧，继续给我们的示例应用添砖加瓦。</p>
<p>在 <em>AddContactViewController.swift</em> 文件的类上方，创建如下所示的协议，这个协议只有一个委托方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AddContactViewControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">didFetchContacts</span><span class="params">(contacts: [CNContact])</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用上面这个委托方法，我们不仅可以让 <em>ViewController</em> 类知晓检索到的联系人信息，还可以把它传递给新检索到的联系人。</p>
<p>接着，在 <code>AddContactViewController</code> 类中添加下面这个委托声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">AddContactViewControllerDelegate</span>!</span><br></pre></td></tr></table></figure>
<p>还记得吗，我们在上一节中的 <code>textFieldShouldReturn:</code> 方法中遗留了一个 <code>else</code> 没有实现，现在是时候添加缺失的东西了。实际上，缺失的代码只有两行而已：第一行是调用上面声明的委托方法，第二行则是通过导航控制器栈来推出视图控制器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textFieldShouldReturn</span><span class="params">(textField: UITextField)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">            ...</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> message != <span class="literal">nil</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.delegate.didFetchContacts(contacts)</span><br><span class="line">                    <span class="keyword">self</span>.navigationController?.popViewControllerAnimated(<span class="literal">true</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，当我们处理 UI 的时候一直都使用主线程。这是一个非常重要的细节，您应当牢记于心，否则的话 UI 就很有可能不会及时进行更新，应用也有可能出现一些无法预料的奇怪行为。</p>
<p>这时候我们就可以前往 <em>ViewController.swift</em> 文件来处理检索到的结果了。一开始，我们也需要在这个类中导入 Contacts 框架：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Contacts</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要实现我们新的自定义协议，因此我们需要在类的头部添加这个协议名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span>, <span class="title">AddContactViewControllerDelegate</span></span></span><br></pre></td></tr></table></figure>
<p>现在，是时候来声明一个 <code>CNContact</code> 对象的数组了。这个数组将会存储所有从检索请求返回的联系人数据，它甚至还是表视图的数据源。因此，在 <code>ViewController</code> 类的顶端添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> contacts = [<span class="type">CNContact</span>]()</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还需要更新接下来将要进行展示的表视图的行数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> contacts.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们实现我们先前声明的委托方法之前，我们需要让 <em>ViewController</em> 类成为 <code>AddContactViewControllerDelegate</code> 协议的委托。这会在 <code>prepareForSegue:</code> 函数中实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> identifier = segue.identifier &#123;</span><br><span class="line">        <span class="keyword">if</span> identifier == <span class="string">"idSegueAddContact"</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> addContactViewController = segue.destinationViewController <span class="keyword">as</span>! <span class="type">AddContactViewController</span></span><br><span class="line">            addContactViewController.delegate = <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们必须要实现我们自定义的委托方法。在委托方法中，我们将依次获取所有返回的联系人数据，然后将它们添加到 <code>contacts</code> 数组中即可。当然，我们会重新加载表视图，以便让其显示新的联系人。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">didFetchContacts</span><span class="params">(contacts: [CNContact])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> contact <span class="keyword">in</span> contacts &#123;</span><br><span class="line">        <span class="keyword">self</span>.contacts.append(contact)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    tblContacts.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们来显示这些联系人信息吧！对于每个单元格（cell）来说，我们都要显示联系人的姓和名，如果存在的话则还要显示联系人的生日、头像以及家庭 email。具体的实现你会在下面的代码中看到，我们将会修改很多东西，不过这足够让你理解联系人属性是如何被访问的了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"idCellContactBirthday"</span>) <span class="keyword">as</span>! <span class="type">ContactBirthdayCell</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> currentContact = contacts[indexPath.row]</span><br><span class="line"> </span><br><span class="line">    cell.lblFullname.text = <span class="string">"<span class="subst">\(currentContact.givenName)</span> <span class="subst">\(currentContact.familyName)</span>"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置生日信息</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> birthday = currentContact.birthday &#123;</span><br><span class="line">        cell.lblBirthday.text = <span class="string">"<span class="subst">\(birthday.year)</span>-<span class="subst">\(birthday.month)</span>-<span class="subst">\(birthday.day)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cell.lblBirthday.text = <span class="string">"Not available birthday data"</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置联系人头像</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> imageData = currentContact.imageData &#123;</span><br><span class="line">        cell.imgContactImage.image = <span class="type">UIImage</span>(data: imageData)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置联系人的家庭 email 地址</span></span><br><span class="line">    <span class="keyword">var</span> homeEmailAddress: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">for</span> emailAddress <span class="keyword">in</span> currentContact.emailAddresses &#123;</span><br><span class="line">        <span class="keyword">if</span> emailAddress.label == <span class="type">CNLabelHome</span> &#123;</span><br><span class="line">            homeEmailAddress = emailAddress.value <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> homeEmailAddress != <span class="literal">nil</span> &#123;</span><br><span class="line">        cell.lblEmail.text = homeEmailAddress</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cell.lblEmail.text = <span class="string">"Not available home email"</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来通览一遍上面的实现。首先，我们将姓和名连接起来，将其赋给了 “lblFullname” 标签。接下来，我还会为你展示另一种实现方式，不过现在我们就这么做。接着，我们设置生日信息。如果生日数据存在的话，我们就通过最简单的方式将其展示出来。注意到这只是一个临时方法 (temporary approach)，之后我们会用正确的方式来处理这个出生日期。同样，你必须知道生日数据并不是一个 <code>NSDate</code> 对象，其实，它是一个 <code>NSDateComponents</code> 对象，它可以转换为 <code>NSDate</code> 后再转换为 <code>String</code>。</p>
<p>接下来我们要设置的是图片数据。如果不存在的话，你唯一能在这看到的就只是 <code>imgContactImage</code> 图片视图的背景颜色了，这个颜色是我在自定义的单元格 xib 文件中设定好的。</p>
<p>最后，我们要设置的就是家庭 email 地址了。你可以注意到的是，我们使用循环来遍历了所有的 email 地址，直到我们找到所需要的那个为止。这是因为联系人所拥有的 <code>emailAddresses</code> 属性包含了<em>被标记为值 (CNLabeledValue) 对象所拥有的全部 email 地址</em>。最后，如果家庭 email 地址找到的话，我们就将其分别赋值给对应的标签，否则的话我们就将其设置为上面你所看到的消息。</p>
<p>如果你现在运行这个应用的话，输入您想要选择的联系人名称，上面的实现或许可用，也可能不起作用。再次尝试的话应用会崩溃掉，但是你不必担心。我们之后会修复这个问题。我故意没有给你上面方法的完整实现，因为上面的方法更容易展示应用是如何工作的。</p>
<h2 id="重新检索联系人">重新检索联系人</h2><p>这个应用可能会崩溃的原因在于，当你请求联系人数据的时候，它可能并没有检索到所有的值。为此，<code>CNContact</code> 类包含了一个名为 <code>isKeyAvailable:</code> 的方法，必须要在访问任何联系人属性之前使用。比如说，在我们视图显示生日、头像以及 email 地址之前，我们应该添加如下检查：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> currentContact.isKeyAvailable(<span class="type">CNContactBirthdayKey</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> currentContact.isKeyAvailable(<span class="type">CNContactImageDataKey</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> currentContact.isKeyAvailable(<span class="type">CNContactEmailAddressesKey</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有对应的关键词的话，那么必须要采取合适的操作来<em>重新检索</em>联系人数据，然后尝试再次显示。这就是我们在这所要做的，明确来说我们要在 <em>ViewController</em> 类中创建一个新的函数。然而，在此之前，我们需要通过添加 <code>isKeyAvailable:</code>  方法来修复联系人详情的显示问题。实际上，我们创建一个条件来检查所有的不可用关键词即可，而不是为上面所提到的属性使用三个不同的条件语句，并且如果有关键词缺失的话，我们就调用下面将要实现的这个函数，以便让其重新检索联系人数据。我故意没有包含进联系人名字的关键词，因此我们可以在下一个部分看到更多内容。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"idCellContactBirthday"</span>) <span class="keyword">as</span>! <span class="type">ContactBirthdayCell</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> currentContact = contacts[indexPath.row]</span><br><span class="line"> </span><br><span class="line">    cell.lblFullname.text = <span class="string">"<span class="subst">\(currentContact.givenName)</span> <span class="subst">\(currentContact.familyName)</span>"</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> !currentContact.isKeyAvailable(<span class="type">CNContactBirthdayKey</span>) || !currentContact.isKeyAvailable(<span class="type">CNContactImageDataKey</span>) ||  !currentContact.isKeyAvailable(<span class="type">CNContactEmailAddressesKey</span>) &#123;</span><br><span class="line">        refetchContact(contact: currentContact, atIndexPath: indexPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Set the birthday info.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> birthday = currentContact.birthday &#123;</span><br><span class="line">            cell.lblBirthday.text = <span class="string">"<span class="subst">\(birthday.year)</span>-<span class="subst">\(birthday.month)</span>-<span class="subst">\(birthday.day)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cell.lblBirthday.text = <span class="string">"Not available birthday data"</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Set the contact image.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> imageData = currentContact.imageData &#123;</span><br><span class="line">            cell.imgContactImage.image = <span class="type">UIImage</span>(data: imageData)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Set the contact's work email address.</span></span><br><span class="line">        <span class="keyword">var</span> homeEmailAddress: <span class="type">String</span>!</span><br><span class="line">        <span class="keyword">for</span> emailAddress <span class="keyword">in</span> currentContact.emailAddresses &#123;</span><br><span class="line">            <span class="keyword">if</span> emailAddress.label == <span class="type">CNLabelHome</span> &#123;</span><br><span class="line">                homeEmailAddress = emailAddress.value <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> homeEmailAddress != <span class="literal">nil</span> &#123;</span><br><span class="line">            cell.lblEmail.text = homeEmailAddress</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cell.lblEmail.text = <span class="string">"Not available home email"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面调用的 <code>refetchContact:atIndexPath:</code> 函数是我们现在要实现的。此外，我觉得我们添加的那行条件语句非常明确，因此你能轻易理解其逻辑。注意到做完这个改动之后，应用就不再会发生崩溃了，即使返回的结果中出现了不可用的关键词。</p>
<p>现在，让我们看看这个新函数吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refetchContact</span><span class="params">(contact contact: CNContact, atIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">            <span class="keyword">let</span> keys = [<span class="type">CNContactGivenNameKey</span>, <span class="type">CNContactFamilyNameKey</span>, <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> contactRefetched = <span class="keyword">try</span> <span class="type">AppDelegate</span>.getAppDelegate().contactStore.unifiedContactWithIdentifier(contact.identifier, keysToFetch: keys)</span><br><span class="line">                <span class="keyword">self</span>.contacts[indexPath.row] = contactRefetched</span><br><span class="line"> </span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.tblContacts.reloadRowsAtIndexPaths([indexPath], withRowAnimation: <span class="type">UITableViewRowAnimation</span>.<span class="type">Automatic</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Unable to refetch the contact: <span class="subst">\(contact)</span>"</span>, separator: <span class="string">""</span>, terminator: <span class="string">"\n"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们会检查应用是否有权限访问联系人数据库。接着，我们会指定想要检索的特定结果关键词，接着我们尝试为给定的联系人重新进行数据检索。注意到这个时候我们使用了一个新的方法来执行检索操作，也就是 <code>unifiedContactWithIdentifier:keysToFetch:</code>。这个方法的功能是重新检索一个通过标识符参数值所指定的联系人数据。一旦结果得到返回，我们将会将位于 <em>contacts</em> 数组中的旧联系人对象替换为新的。最后，我们就重新加载表视图的特定行即可。</p>
<p>这时候你可以自己重新运行一遍应用。重新检索联系人数据是一项您最好经常执行的任务，以防止某些数据发生丢失，这样你就可以确保应用不会为用户带来出乎意料的“惊喜”。</p>
<h2 id="输出格式化">输出格式化</h2><p>目前为止，在单元格上显示每个联系人的生日信息之前，我们并没有对其进行正确的格式化操作。我们只是简单的连接并展示这些生日属性而已，但是现在我们已经完成了前面的事情，是时候来处理它了。</p>
<p>我们通过在 <em>ViewController</em> 类中创建新的自定义函数来解决这个问题。在其中，我们会使用 <code>NSDateFormatter</code> 对象将日期转换为一个本地化的字符串，但首先，我们需要将日期组件 (date components，日期的每个部分) 转换为 <code>NSDate</code> 对象。让我们来看看这个新函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getDateStringFromComponents</span><span class="params">(dateComponents: NSDateComponents)</span></span> -&gt; <span class="type">String</span>! &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> date = <span class="type">NSCalendar</span>.currentCalendar().dateFromComponents(dateComponents) &#123;</span><br><span class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">NSDateFormatter</span>()</span><br><span class="line">        dateFormatter.locale = <span class="type">NSLocale</span>.currentLocale()</span><br><span class="line">        dateFormatter.dateStyle = <span class="type">NSDateFormatterStyle</span>.<span class="type">MediumStyle</span></span><br><span class="line">        <span class="keyword">let</span> dateString = dateFormatter.stringFromDate(date)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> dateString</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法的参数是一个被 <code>NSDateComponents</code> 对象（在我们的例子中是出生日期）所表示的日期。返回值自然是一个字符串。为了将 <code>dateComponents</code> 对象转换为 <code>NSDate</code> 对象，只需要添加一行代码即可。我们使用 <code>NSCalendar</code> 来进行转换，以及使用将会初始化的日期格式化器 (date formatter) 对日期对象进行处理。将这个日期格式化器的区域设置为当前设备的区域，这是一个非常有必要的操作，只有这样才能够取得本地化的日期描述信息。最后，我们要设置日期的样式（不要太长，也不要太短），再执行最后的转换即可。最终，转换过的值将返回给调用者。</p>
<p>现在，让我们来完善出生日期的显示吧。其实，只需要调用上面这个方法即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> !currentContact.isKeyAvailable(<span class="type">CNContactBirthdayKey</span>) || !currentContact.isKeyAvailable(<span class="type">CNContactImageDataKey</span>) ||  !currentContact.isKeyAvailable(<span class="type">CNContactEmailAddressesKey</span>) &#123;</span><br><span class="line">        refetchContact(contact: currentContact, atIndexPath: indexPath)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置生日信息</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> birthday = currentContact.birthday &#123;</span><br><span class="line">            cell.lblBirthday.text = getDateStringFromComponents(birthday)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常好，现在出生日期的显示就更加高大上了。</p>
<p>现在让我们来看看一些关于姓名显示的有趣东西吧。<code>CNContact</code> 类提供了一个内置的格式化器，用以帮助我们轻松格式化两类数据：联系人的全名 (<a href="https://developer.apple.com/library/prerelease/ios/documentation/Contacts/Reference/CNContactFormatter_Class/index.html#//apple_ref/occ/cl/CNContactFormatter" target="_blank" rel="external">CNContactFormatter</a>) 以及地址 (<a href="https://developer.apple.com/library/prerelease/ios/documentation/Contacts/Reference/CNPostalAddressFormatter_Class/index.html#//apple_ref/occ/cl/CNPostalAddressFormatter" target="_blank" rel="external">CNPostalAddressFormatter</a>)。这里我们将使用第一种，因此，联系人的全名会被 Contacts 框架自动格式化。</p>
<p>首先，我们先回到最后一次修改联系人的方法，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"idCellContactBirthday"</span>) <span class="keyword">as</span>! <span class="type">ContactBirthdayCell</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> currentContact = contacts[indexPath.row]</span><br><span class="line"> </span><br><span class="line">    cell.lblFullname.text = <span class="type">CNContactFormatter</span>.stringFromContact(currentContact, style: .<span class="type">FullName</span>)</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，<code>cell.lblFullname.text = “(currentContact.givenName) (currentContact.familyName)”</code> 这行语句被下面这行替代了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">cell.lblFullname.text = <span class="type">CNContactFormatter</span>.stringFromContact(currentContact, style: .<span class="type">FullName</span>)</span><br></pre></td></tr></table></figure>
<p>显然，我们不再需要将联系人的姓与名连接起来而作为全名。<code>CNContactFormatter</code> 已经替我们完成了这项工作，同时它还提供了一个本地化字符串（取决于设备的本地化设置，通过合适的次序来设置名字部分）。</p>
<p>然而，上面这行代码还是会导致一些问题，因为联系人格式化器需要访问所有与联系人名字相关联的关键词，即使这些关键词我们并没有在检索的关键词数组中。不过，我们也没有必要一个一个地将它们全部写出来。所有相关的关键词都可以通过<em>关键词描述符 (key descriptor)</em> 所指定，这个描述符被用来替代关键词数组中的单一关键词。</p>
<p>为了说明得更具体一些，前往 <em>AddContactViewController</em> 文件的 <code>textFieldShouldReturn:</code> 方法。在那里，将这行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = [<span class="type">CNContactGivenNameKey</span>, <span class="type">CNContactFamilyNameKey</span>, <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br></pre></td></tr></table></figure>
<p>替换为下面这行使用关键词描述符的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> keys = [<span class="type">CNContactFormatter</span>.descriptorForRequiredKeysForStyle(<span class="type">CNContactFormatterStyle</span>.<span class="type">FullName</span>), <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br></pre></td></tr></table></figure>
<p>正如上面所示，描述符格式化的方式是非常明确的。除此之外，其他的关键词都保持不变。</p>
<p>上面的变化也必须在 <code>refetchContact:</code> 方法（在 <code>ViewController</code> 类中）进行。你所需要做的就是将 <code>keys</code> 数组定义替换为上面的那行代码，所以放手向前吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refetchContact</span><span class="params">(contact contact: CNContact, atIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">            <span class="keyword">let</span> keys = [<span class="type">CNContactFormatter</span>.descriptorForRequiredKeysForStyle(<span class="type">CNContactFormatterStyle</span>.<span class="type">FullName</span>), <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br><span class="line"> </span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经给代码做完了所有与格式化相关的修改了。当然，你仍然可以使用单个关键词来检索单个名字，不过这得取决于你的具体需求了。</p>
<h2 id="使用自定义过滤器检索联系人">使用自定义过滤器检索联系人</h2><p>我在此教程中提到的首要事情之一就是，如何使用断言来检索联系人。我们使用 Contacts 框架中的断言来匹配给定名字的联系人，但是你是否记得，通常情况下这个方法有一个缺点。我们必须使用框架内置的断言，而我们无法对其进行自定义。那么问题来了，我们如何实现自定义的过滤器来检索联系人呢？</p>
<p>对我们的示例应用来说，问题可以变得更为具体一些，比如，如何才能基于联系人的生日来检索呢？在 <code>AddContactViewController</code> 类中有一个用于展示所有月份的选择器视图，因此现在我们所想做的是，选择一个月份，然后单击“完成”按钮，最后就可以获得所有出生月份和所选月份相同的记录了。</p>
<p>好吧，正如你所猜想的，的确是有一个办法可以“应用”自定义的过滤器，但是会使整个过程比使用断言还麻烦。通常情况下，我们所看到的方法是基于 <code>CNContectStore</code> 类中的 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Contacts/Reference/CNContactStore_Class/index.html#//apple_ref/occ/instm/CNContactStore/enumerateContactsWithFetchRequest:error:usingBlock:" target="_blank" rel="external">enumerateContactsWithFetchRequest(_:usingBlock)</a> 方法，这也是苹果针对这种情况而建议使用的。这个方法将会检索所有的联系人，因此自定义的查询标准 (criteria) 能够在代码块 (闭包) 中设置，比如说比较属性值或者使用其他自定义的逻辑，并在最后获得你所需要的联系人信息。</p>
<p>在我们的例子中，我们将要检查两个东西：首先，我们必须要确保每个联系人的生日都已被设定，这样可以避免任何可能出现的崩溃。其次，我们只要比较生日月份和在选择器视图中所选月份即可，如果有匹配的，就将这个联系人放到数组当中。这个做法十分简单，因为生日是 <code>NSDateComponents</code> 对象，因此我们能够直接访问其月份。此外，剩下的操作也十分简单。我们将看到的所有操作已经在之前的部分展示过了，并且我也进行了介绍。接下来，我们会在 <code>AddContactViewController</code> 类的 <code>performDoneItemTap</code> 自定义方法中写下这些新代码，这样就可以在视图控制器中的“完成”按钮被按下的时候就基于所选月份来检索联系人了。</p>
<p>代码在此：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performDoneItemTap</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess &#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">            <span class="keyword">var</span> contacts = [<span class="type">CNContact</span>]()</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">let</span> keys = [<span class="type">CNContactFormatter</span>.descriptorForRequiredKeysForStyle(<span class="type">CNContactFormatterStyle</span>.<span class="type">FullName</span>), <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> contactStore = <span class="type">AppDelegate</span>.getAppDelegate().contactStore</span><br><span class="line">                <span class="keyword">try</span> contactStore.enumerateContactsWithFetchRequest(<span class="type">CNContactFetchRequest</span>(keysToFetch: keys)) &#123; (contact, pointer) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> contact.birthday != <span class="literal">nil</span> &amp;&amp; contact.birthday!.month == <span class="keyword">self</span>.currentlySelectedMonthIndex &#123;</span><br><span class="line">                        contacts.append(contact)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.delegate.didFetchContacts(contacts)</span><br><span class="line">                    <span class="keyword">self</span>.navigationController?.popViewControllerAnimated(<span class="literal">true</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(error.description, separator: <span class="string">""</span>, terminator: <span class="string">"\n"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，检索完成后我们调用了委托，这样 <code>ViewController</code> 类中的表视图就会根据新的联系人数据进行更新了，接下来我们推出这个视图控制器。上面这些代码对你来说在很多方面都十分有用，因为你所需要做的，就是只改变一下位于上述代码块中的过滤器规则条件即可。</p>
<h2 id="联系人选择器视图控制器（Contact_Picker_View_Controller）">联系人选择器视图控制器（Contact Picker View Controller）</h2><p>目前，我们所完成的所有联系人管理操作都完全是基于代码的，然而我们的故事还没有结束。Contacts 框架直接提供了视图控制器 (UI)，可以以可视化的方式来访问联系人，并立即与它们进行交互。所提供的视图控制器和“通讯录”应用中的控制器十分相像，因此你可以借此得到用于选择一个或多个联系人的选择器控制器，一个用于查看联系人详情的视图控制器，以及一个可以编辑信息的表单。在选择联系人的时候，重写默认的控制器行为也是允许的，此外还有委托方法可以让你处理结果。</p>
<p>在这一部分，我们将设置这个选择器视图控制器，并在应用的选择器视图控制器中选择和导入联系人。我们无需准备太多其他的东西，不过定制程度将取决于每个应用的需求。Contacts 框架允许设置三个可选的断言，从而让你自定义所显示的联系人信息：</p>
<ol>
<li><code>predicateForEnablingContact</code>：这可能是你最常用的断言了。通过它，你可以指定在选择器控制器中可用的联系人。比如说，你可以通过它来完成联系人的过滤，因此只有那些拥有可用生日的联系人才能够在选择器中显示出来。</li>
<li><code>predicateForSelectionOfContact</code>：通过它，你可以决定选择器视图控制器在被选择的时候，应该在何种情况下返回所选的联系人；以及何时应该为显示详情视图控制器而添额外的选择。</li>
<li><code>predicateForSelectionOfProperty</code>：通过它，你可以指定某个属性的默认行为是否可以被执行（比如说当点击电话号码时会执行电话呼叫操作），或者所按下的属性是否应该被返回。</li>
</ol>
<p>这里我们所打算使用的只是第一个断言，打开选择器视图控制器，只允许显示有生日信息的联系人信息。另外两个断言的使用也不难，但是我们这里暂时用不着它们；如果需要参考的话，我建议您分别查看断言的<a href="https://developer.apple.com/library/prerelease/ios/documentation/ContactsUI/Reference/ContactsUI_Framework/index.html#//apple_ref/doc/uid/TP40016207" target="_blank" rel="external">文档</a>。</p>
<p>再次回到我们的应用中，打开 <em>AddContactViewController.swift</em> 文件。首先，到文件的顶端，导入 <code>ContactsUI</code> 框架。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ContactsUI</span><br></pre></td></tr></table></figure>
<p>接着，实现 <code>CNContactPickerDelegate</code> 协议，因此我们可以处理返回的联系人：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddContactViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITextFieldDelegate</span>, <span class="title">UIPickerViewDelegate</span>, <span class="title">CNContactPickerDelegate</span></span></span><br></pre></td></tr></table></figure>
<p>从现在开始，我们的工作都将在 <code>showContacts:</code> 这个 IBAction 方法中进行。这个方法会启用位于 <code>AddContactViewController</code> 底端的按钮。让我们来看看具体的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">showContacts</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> contactPickerViewController = <span class="type">CNContactPickerViewController</span>()</span><br><span class="line"> </span><br><span class="line">    contactPickerViewController.predicateForEnablingContact = <span class="type">NSPredicate</span>(format: <span class="string">"birthday != nil"</span>)</span><br><span class="line"> </span><br><span class="line">    contactPickerViewController.delegate = <span class="keyword">self</span></span><br><span class="line"> </span><br><span class="line">    presentViewController(contactPickerViewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是非常简单！在这个示例应用中我们不需要在单击联系人时显示详情页面。不过如果需要的话，很容易使用这些属性来展示详情。你所需要做的就是将一个包含所需关键词的数组赋值给一个名为 <code>displayedPropertyKeys</code> 属性。比如说，如果我们打算在应用中展示详情信息的话，我们就会在显示选择器视图控制器之前增加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">contactPickerViewController.displayedPropertyKeys = [<span class="type">CNContactGivenNameKey</span>, <span class="type">CNContactFamilyNameKey</span>, <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br></pre></td></tr></table></figure>
<p>几分钟前，我们实现了 <code>CNContactPickerDelegate</code> 协议，现在是时候来实现一个必须实现（required）的委托方法了。在方法中，我们会获取所选择联系人，然后通过我们自己的代理方法将其发回给 <code>ViewController</code> 类当中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">contactPicker</span><span class="params">(picker: CNContactPickerViewController, didSelectContact contact: CNContact)</span></span> &#123;</span><br><span class="line">    delegate.didFetchContacts([contact])</span><br><span class="line">    navigationController?.popViewControllerAnimated(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设你显示了联系人的详情信息，然后你想处理返回的属性，你需要使用 <code>contactPicker:didSelectContactProperty:</code> 委托方法。我们在这里不对其进行实现，因为我们不需要它。你可以在<a href="https://developer.apple.com/library/prerelease/ios/documentation/ContactsUI/Reference/CNContactPickerDelegate_Protocol/index.html#//apple_ref/occ/intfm/CNContactPickerDelegate/contactPicker:didSelectContactProperty:" target="_blank" rel="external">这里</a>找到所有委托方法的集合。</p>
<p>应用现在可以继续测试了。这时候按下 “Open contacts to select” 按钮来显示选择器视图控制器。你会注意到没有可用生日的联系人是不会显示出来的。选择其中一个联系人，然后你就会看到它出现在了 <code>ViewController</code> 的表视图当中。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_3_picker_view_controller.png" alt=""></p>
<h2 id="联系人视图控制器">联系人视图控制器</h2><p>到目前为止，我们已经实现了三种不同的方法以允许我们检索联系人并将其添加到应用中来。然而，只在表视图中显示联系人信息并不是一个很好的主意。我们想要更丰富的展现形式，那就是在一个新的视图控制器中显示所选联系人的详情信息。实际上，我们不需要创建一个自定义的控制器，我们会使用由 Contacts 框架所提供的联系人视图控制器。通过它我们不仅能查看联系人数据，还能够对其进行编辑。当然，通过 <a href="https://developer.apple.com/library/prerelease/ios/documentation/ContactsUI/Reference/CNContactViewController_Class/index.html" target="_blank" rel="external">CNContactViewController</a> 类我们可以轻易获得它。</p>
<p>让我们回到 <em>ViewController.swift</em> 文件中来，然后处理一下用户单击联系人时所发生的情况。然而，在我们显示 <code>CNContactViewController</code> 实例之前，我们需要确保所选联系人的详情信息中所有关键词都可用。即便我们在展示每个单元格的时候检查了所有可用的关键词，即便我们在需要的时候重新检索了联系人，但是当用户单击此行单元格的速度比重新检索操作的速度更快的时候，一切就都不好说了。因此，我们必须要处理点东西。</p>
<p>之前，我们使用 <code>CNContact</code> 类中的 <code>isKeyAvailable:</code> 方法来检查某个检索到的联系人中关键词的可用性。除了这个方法外，<code>CNContact</code> 还提供了另一种名为 <code>areKeysAvailable:</code> 的方法，我们可以用其来确保联系人视图控制器所需要的所有关键词都已存在。这个方法只接收一个参数，也就是一个包含关键词或者关键词描述符的数组 (和我们用来检索联系人时多次使用的关键词数组类似)。就 <code>CNContactViewController</code> 而言，虽然我们必须要设置 <code>CNContactViewController.descriptorForRequiredKeys()</code>的特定值作为参数数组的唯一元素。假设关键词都可用的话，我们将会显示联系人视图控制器。如果不可用的话，我们就用之前的方法，使用 <code>descriptorForRequiredKeys()</code> 来重新检索联系人，从而指定所需要检索的关键词。</p>
<p>此外，我们在整个示例应用中用来检索联系人数据的 <code>keys</code> 数组就会再次变得简单易用。不仅可以如我刚刚所述的那样检查可用性，还可以指定<em>在联系人视图控制器中应该显示何种属性</em>。你可以在下面的实现中看到它是如何使用的。注意，要记住如果你省略了这个属性，那么所有既有的联系人属性 (并不只是我们想显示的) 都将在联系人视图控制器中显示出来。</p>
<p>上面说了这么多，我们现在还是来看看这些代码吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> selectedContact = contacts[indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> keys = [<span class="type">CNContactFormatter</span>.descriptorForRequiredKeysForStyle(<span class="type">CNContactFormatterStyle</span>.<span class="type">FullName</span>), <span class="type">CNContactEmailAddressesKey</span>, <span class="type">CNContactBirthdayKey</span>, <span class="type">CNContactImageDataKey</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> selectedContact.areKeysAvailable([<span class="type">CNContactViewController</span>.descriptorForRequiredKeys()]) &#123;</span><br><span class="line">        <span class="keyword">let</span> contactViewController = <span class="type">CNContactViewController</span>(forContact: selectedContact)</span><br><span class="line">        contactViewController.contactStore = <span class="type">AppDelegate</span>.getAppDelegate().contactStore</span><br><span class="line">        contactViewController.displayedPropertyKeys = keys</span><br><span class="line">        navigationController?.pushViewController(contactViewController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">AppDelegate</span>.getAppDelegate().requestForAccess(&#123; (accessGranted) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> accessGranted &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> contactRefetched = <span class="keyword">try</span> <span class="type">AppDelegate</span>.getAppDelegate().contactStore.unifiedContactWithIdentifier(selectedContact.identifier, keysToFetch: [<span class="type">CNContactViewController</span>.descriptorForRequiredKeys()])</span><br><span class="line"> </span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">let</span> contactViewController = <span class="type">CNContactViewController</span>(forContact: contactRefetched)</span><br><span class="line">                        contactViewController.contactStore = <span class="type">AppDelegate</span>.getAppDelegate().contactStore</span><br><span class="line">                        contactViewController.displayedPropertyKeys = keys</span><br><span class="line">                        <span class="keyword">self</span>.navigationController?.pushViewController(contactViewController, animated: <span class="literal">true</span>)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"Unable to refetch the selected contact."</span>, separator: <span class="string">""</span>, terminator: <span class="string">"\n"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，你可以看到我们通过使用联系人视图控制器实例的 <code>displayedPropertyKeys</code> 属性，指定了我们想要展示的属性。另一个值得提及的细节就是，我们通过 <code>contactStore</code> 属性给联系人视图控制器提供了我们的<em>联系人存储</em>实例。如果应用中没有 <code>CNContactStore</code> 实例的话这个设置就不是必要的，因为 <code>CNContactsViewController</code> 会自行创建一个新的存储器。剩余的部分我们之前已经讨论过了。作为最后一步，不要忘记在文件头部导入下面这个框架：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ContactsUI</span><br></pre></td></tr></table></figure>
<h2 id="新建并保存一个新联系人">新建并保存一个新联系人</h2><p>到目前为止，我们已经见识了许多关于 Contacts 框架中的新东西了。然而，仍然有一个我们没有讨论的部分，那就是如何通过代码创建一个新的联系人并将其保存到数据库中。因此，正如你所理解的，本教程的最后一个部分我们将要谈论这个话题。我不会详细说明如何更新一个既有记录，因为这个操作和我们在这里将要看到的十分相似，因此我将这个操作完全留给你，你可以自己找一下这两个操作之间的差异。</p>
<p>除了代表单个联系人及其所有属性的 <code>CNContact</code> 类之外，Contacts 框架还提供了一个名为 <code>CNMutableContact</code> 的类。如它的名字所言，这个类和 <code>CNContact</code> 十分相似，它允许我们为联系人的属性赋予新值，因此就可以通过它来创建一个新的联系人或者更新一个既有的联系人。实际的保存 (以及更新) 操作将在我们所周知的联系人存储类 (<code>CNContactStore</code>) 中处理，但是这是创建新联系人的最后一步。你可以在下面看到额外的具体信息。</p>
<p>通常情况下，使用 <code>CNMutableContact</code> 类来设置某个联系人的属性值包含了一系列与获取它们时完全相反的操作。进一步来说，对于简单的属性而言，直接分配一个单独的值即可 (比如说名)，特殊的属性需要特殊对待。例如：</p>
<ul>
<li>当设置某个联系人的出生日期的时候，必须创建一个 <code>NSDateComponents</code> 对象并将其赋给对应的属性</li>
<li>当设置联系人头像的时候，必须要赋给一个 <code>NSData</code> 对象</li>
<li>当设置 email 地址的时候，必须给每个单独的 email 地址创建一个 <code>CNLabeledValue</code> 对象，然后所有的地址对象都应该放到一个数组中赋值给 <code>emailAddresses</code> 属性。</li>
</ul>
<p>上面的仅仅只是一些例子。当然还有很多联系人属性需要谨慎对待，不过无论如何，接下来你会看到这些操作并不是很困难。</p>
<p>回到我们的示例应用中来，这时候我们要切换到 <em>CreateContactViewController.swift</em> 文件。在这个文件中，你会找到一个空的名为 <code>createContact()</code> 的自定义函数，这是我们所有工作将要进行的地方。简单而言，我们将创建一个 <code>CNMutableContact</code> 类的实例，然后设置我们感兴趣的所有属性值，最后我们将这个新纪录存储到数据库中。让我们来看一看实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createContact</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newContact = <span class="type">CNMutableContact</span>()</span><br><span class="line"> </span><br><span class="line">    newContact.givenName = txtFirstname.text!</span><br><span class="line">    newContact.familyName = txtLastname.text!</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> homeEmail = <span class="type">CNLabeledValue</span>(label: <span class="type">CNLabelHome</span>, value: txtHomeEmail.text!)</span><br><span class="line">    newContact.emailAddresses = [homeEmail]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> birthdayComponents = <span class="type">NSCalendar</span>.currentCalendar().components([<span class="type">NSCalendarUnit</span>.<span class="type">Year</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Month</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Day</span>], fromDate: datePicker.date)</span><br><span class="line">    newContact.birthday = birthdayComponents</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> saveRequest = <span class="type">CNSaveRequest</span>()</span><br><span class="line">        saveRequest.addContact(newContact, toContainerWithIdentifier: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">try</span> <span class="type">AppDelegate</span>.getAppDelegate().contactStore.executeSaveRequest(saveRequest)</span><br><span class="line"> </span><br><span class="line">        navigationController?.popViewControllerAnimated(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="type">AppDelegate</span>.getAppDelegate().showMessage(<span class="string">"Unable to save the new contact."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从头来看这些操作，第一步是初始化一个 <code>CNMutableContact</code> 对象，这个对象将在后面一直使用。很明显设置姓、名属性是一个非常简单的操作。接下来的家庭 email 地址必须创建为一个 <code>CNLabeledValue</code> 对象，这也是上面代码所展示的。一旦新的 email 地址创建之后，就会作为 email 地址数组的一部分添加到 <code>emailAddresses</code> 属性当中。在我们的这个例子中，我们没有其他的地址。最后，我们基于用户所挑选的日期，为这个新联系人制定了出生日期。如上面的代码所示，使用 <code>NSCalendar</code> 类并从 <code>NSDate</code> 对象创建一个 <code>NSDateComponents</code> 对象是非常容易的。注意到日历对象 (年、月、日) 是如何合并的，借此它们产生了我们最终所想要的值。</p>
<p>这个代码片段中最有趣的部分就是保存新联系人的方式了。你可以注意到，首先是创建一个 <code>CNSaveRequest</code> 对象，接着向其中添加新的联系人对象。到这里并没有任何实际的存储操作被执行。这个操作而是发生在下一行代码中，也就是调用联系人存储实例中的 <code>executeSaveRequest:</code> 方法的时候。</p>
<p>假设新联系人无法保存的话，那么就会给用户弹出一个带有消息的警示框。</p>
<p>现在运行这个应用，使用 <em>ViewController</em> 左上角的按钮来创建一个新的联系人。保存你的记录，然后前去使用我们在之前部分实现的检索方法将其检索出来。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t43_4_create_contact.png" alt=""></p>
<p><strong>重要提示：</strong>我在写这篇教程的时候注意到一个问题，在我的测试中，也就是创建一个新的记录并将其保存到联系人数据库的时候，通过应用访问联系人详情信息（通过点击联系人所在的行单元格）并不可用。而且会在控制台出现以下信息：</p>
<p><em>CNUI ERROR] error calling service – Couldn’t communicate with a helper application.</em></p>
<p>在网上我并不能找到任何可用的帮助，我只好就此罢休，将其作为 BUG 报告给了苹果。要牢牢记住，在测试应用的时候，要避免创建一个新的联系人。</p>
<h2 id="总结">总结</h2><p>在本教程的结尾，我希望我已经讲清楚新的 Contacts 框架的易用性了。如果你过去曾经使用过 AddressBook API，那么你会发现在使用 Contacts 联系人的时候一切都发生了巨大的变化。你可以尽情地把玩这个示例应用，对其进行修改，以及按照你的意愿对其进行扩展。这个应用仍有提升的空间，但是千万不要忘记了用户隐私协议，并且你必须要尊重用户关于是否准许应用访问联系人的选择。不要错过了官方文档，你会在那里发现更有意思的东西。我希望你能够享受本篇教程，并能发现其中有用的知识。下次我们再见，希望你拥有美好、积极的一天！</p>
<p>作为参考，你可以<a href="https://www.dropbox.com/s/3pxzqd5u712ntkc/ContactsFrameworkFinal.zip?dl=0" target="_blank" rel="external">在这里下载完整的 Xcode 项目</a>。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：gabriel theodoropoulos，<a href="http://www.appcoda.com/ios-contacts-framework/">原文链接</a>，原文日期：2015-09-29<br>译者：<a href="undefined">BridgeQ、星夜暮晨</a>；校对：<a href="http://weibo.com/linusling">小铁匠Linus</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<!--此处开始正文-->
<p>同每一代 iOS 系统版本的更新一样，最新发布的 iOS 9 为用户和开发者带来了许多新特性以及原有功能的改善。在这个版本中，我们不仅看到了很多首次推出的 API，还可以看到许多针对原有框架和类库的更新。此外，一些旧版本的 API 被标记为 <code>deprecated</code>（校对注：意为新版本已被弃用），而使用了更好的 API 来替代。iOS 9 中，新的 <em>Contacts framework</em> （联系人框架）是最好的例子了，它是来代替原有 <em><a href="http://www.appcoda.com/ios-programming-import-contact-address-book/">AddressBook framework</a></em> 的。该框架更加符合技术潮流且简单易用。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift：带有私有设置方法的公有属性]]></title>
    <link href="http://swiftggteam.github.io/2016/01/11/public-properties-with-private-setters/"/>
    <id>http://swiftggteam.github.io/2016/01/11/public-properties-with-private-setters/</id>
    <published>2016-01-10T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.234Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/public-properties-with-private-setters/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-24<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="http://weibo.com/lfbWb" target="_blank" rel="external">lfb_CD</a>；定稿：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 可以很方便地创建带有私有设置方法的公有属性。这可以让你的代码更加安全和简洁。</p>
<a id="more"></a>
<h3 id="封装">封装</h3><p>封装从根本上意味着类的信息和状态应该对外部类隐藏，只有类自身可以操作。因此，所有的 bug 和 逻辑错误更加不可能发生了。</p>
<p>通常你会使用 <code>setter</code> 以及 <code>getter</code> 来达到封装的目的。然而，有时候你根本不想对外提供类中的设置方法。对于这样的情况，你可以使用带有私有设置方法的属性。</p>
<h3 id="例子">例子</h3><p>假设我们想要创建一个代表圆的类，那么圆的半径应该是可以改变的。而且，该圆的面积和直径应该可以从圆的实例中获取，而这两个属性不应该被类本身以外所更改。出于性能考虑，面积和直径也应该只计算一次。</p>
<p>所以这个圆类应该是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            calculateFigures()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">        calculateFigures()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        area = <span class="type">M_PI</span> * radius * radius</span><br><span class="line">        diameter = <span class="number">2</span> * <span class="type">M_PI</span> * radius</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getArea</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> area</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getDiameter</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diameter</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在所有的需求都满足啦。然而，Swift 提供了一种更好的方式，可以使得这段代码更加简洁。</p>
<h3 id="带有私有设置方法的属性">带有私有设置方法的属性</h3><p>通过在属性前面使用 <code>private(set)</code> ，属性就被设置为默认访问等级的 <code>getter</code> 方法，但是 <code>setter</code> 方法是私有的。所以我们可以去掉两个 <code>getter</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            calculateFigures()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">        calculateFigures()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        area = <span class="type">M_PI</span> * radius * radius</span><br><span class="line">        diameter = <span class="number">2</span> * <span class="type">M_PI</span> * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以为属性设置公有的 <code>getter</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> area: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> diameter: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            calculateFigures()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(radius:<span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.radius = radius</span><br><span class="line">        calculateFigures()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">calculateFigures</span><span class="params">()</span></span> &#123;</span><br><span class="line">        area = <span class="type">M_PI</span> * radius * radius</span><br><span class="line">        diameter = <span class="number">2</span> * <span class="type">M_PI</span> * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象">对象</h2><p>在这个例子中，属性只是 <code>Double</code> 值。然而，如果是一个对象，可以通过使用对象的某个方法来操作！使用私有设置方法只允许设置一个全新的对象，在使用过程中应铭记这一点。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/public-properties-with-private-setters/">原文链接</a>，原文日期：2015-12-24<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="http://weibo.com/lfbWb">lfb_CD</a>；定稿：<a href="https://github.com/Cee">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 可以很方便地创建带有私有设置方法的公有属性。这可以让你的代码更加安全和简洁。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 并发：从 NSOperation 和 Dispatch Queues 开始]]></title>
    <link href="http://swiftggteam.github.io/2016/01/08/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/"/>
    <id>http://swiftggteam.github.io/2016/01/08/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/</id>
    <published>2016-01-07T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.234Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：hossam ghareeb，<a href="http://www.appcoda.com/ios-concurrency/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-09<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="undefined">Channe</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>并发（Concurrency）在 iOS 开发中总是被看作是洪水猛兽一般。人们以为它是一个很危险的领域，很多开发者都尽量避免与其接触。更有传闻说你一定要竭尽所能的避免写任何关于多线程的代码。假如你对并发不是很了解却还去使用它的话，那么我同意：并发是很危险的。只是它的危险是因为你不了解它。试想一下常人一生中体验过的危险运动和行为有多少，很多对吧？但是当掌握了之后，就会统统变成小菜一碟。并发是把双刃剑，你应该掌握并学会如何去使用它。它能帮你写出效率高、执行快、反应灵敏的 App，而与此同时，对它的滥用会无情的毁掉你的 App。这就是为什么在开始写任何关于并发的代码之前，先要想一想你为什么要用到并发、需要用到哪个（与并发有关的）API 来解决这个问题。iOS 中我们有很多能用到的 API。在此教程里我会讲到最常用的两个：<code>NSOperation</code> 和 <code>Dispatch Queues</code>（派发队列）。</p>
<a id="more"></a>
<p><img src="/img/articles/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/12401452214820.2549465" alt=""></p>
<h2 id="我们为什么要用并发？">我们为什么要用并发？</h2><p>我知道你是一个有 iOS 背景的出色开发者。然而无论你要做一个什么样的 App，你都需要了解并发，让你的 App 更快，更灵敏。我总结了一下学习和使用并发所带来的优点：</p>
<ul>
<li><strong>能更有效的利用 iOS 设备的硬件：</strong>现在所有的 iOS 设备都有一个多核处理器，可以让开发者并行执行多个任务。你应该好好利用这个特性，让硬件优势发挥出来。</li>
<li><strong>更好的用户体验：</strong>你可能写过一些呼叫网络服务、处理 IO，或者是其他任何执行繁重任务的代码。你也知道在 UI 所在的线程中做这些操作会把你的 App 冻结住，使它没任何反应。当用户遇到这种情况时，他/她会毫不犹豫的直接杀掉或是关闭你的 App。而用并发的话，这些繁重的任务就会被安排到后台去执行，不会占满主线程、干扰你用户的操作。他们依旧能够点击按钮，来回拖动屏幕并在你的 App 中的每个页面之间跳转，与此同时在后台还处理着繁重的装载任务。</li>
<li><strong>NSOperation 和 Dispatch Queues 这样的 API 让使用并发变得容易：</strong>创建并管理线程并不是简单的事情。这也是为什么很多的开发者一听到并发，还有多线程代码这样的术语时会感到害怕的原因。在 iOS 中我们有强大而易用的并发 API，让你的生活变得更来福。你无需再为创建线程或管理底层的东西操心，API 会为你搞定。这些 API 的另一个优点是它们能轻松帮你实现同步（synchronization），避免了竞态条件（race condition）的产生，而竞态条件产生在当多个线程试图访问相同的资源的时候，这会引起无法预计的后果。有了同步，你就保护了资源不会被多个线程同时访问。</li>
</ul>
<h2 id="关于并发你都需要知道些什么？">关于并发你都需要知道些什么？</h2><p>在本篇教程中，我会解释为理解并发你所需要了解的一切，消除你对它的所有恐惧心理。首先我推荐你去看一下 blocks（即 Swift 中的 closures），它们在并发中会被大量使用。之后我们会聊一下 <code>Dispatch Queues</code> 和 <code>NSOperationQueues</code>。我会带你了解每个并发中的概念，概念之间的不同，以及如何使用它们。</p>
<h2 id="第一部分：GCD（Grand_Central_Dispatch）">第一部分：GCD（Grand Central Dispatch）</h2><p>GCD 是在系统的Unix层级中用于管理并发代码并异步执行操作时最常用的 API。GCD 提供并且管理任务的队列（queues of tasks）。先来看看什么是队列。</p>
<h3 id="什么是队列">什么是队列</h3><p>队列是按照先进先出（FIFO）顺序管理对象的数据结构。队列类似于电影院的售票窗口前的长队。电影票是按先到先得的顺序卖出。长队前面的人先买到票，晚来的人后买到票。计算机科学中的队列概念和这个很像，因为第一个被加到队列中的对象也是第一个要从队列中被移除的。<br><img src="/img/articles/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/12401452214821.022044" alt="Photo credit: FreeImages.com/Sigurd Decroos"></p>
<h3 id="Dispatch_Queues">Dispatch Queues</h3><p><code>Dispatch Queues</code> 是一种能够轻松执行异步和并发任务的方式。它们是队列，其中的任务是由你的 App 以 blocks（代码块）的形式提交。<code>Dispatch Queues</code> 有两种：(1)串行队列（serial queues），和(2)并发队列（concurrent queues）。在讲述两者的不同之前，你需要知道派给这两种队列的任务是在另外的线程中被执行，而不是在创建它们的那个线程中被执行。换句话说，你是在主线程中创建block并将其提交到 <code>Dispatch Queues</code> 中去。但所有这些任务（block）会在其他的线程中运行，并非主线程。</p>
<h3 id="串行队列">串行队列</h3><p>当你选择创建一个串行队列时，该队列在某一时刻只能执行一个任务。该队列中的所有任务都会彼此尊重，按序执行。然而你无需担心其他队列中的任务，意思是你依然可以通过使用多个串行队列来以并发的形式执行任务。例如你可以创建两个串行队列，每一个队列某一时刻只能执行一个任务，但是还是有最多两个任务被并发执行。</p>
<p>用串行队列来管理一个共享资源（shared resource）再合适不过。它提供的对共享资源的访问确保是串行化的，从而防止竞态条件的发生。想象一下有个售票小摊，还有一大堆人想买电影票，那小摊的售票员就是一个共享资源。如果这个售票员必须同时为这堆人服务时就会特别混乱。为避免这个情况，买票的人会被要求去排队（串行队列），这样售票员同一时刻就可以只对一人服务。</p>
<p>再说一遍，这里没有说电影院每时刻只能为一个顾客服务。如果电影院再开两个售票点，就可以同时服务三位客户了。这也是为什么我说过即使你使用串行队列还依然能并行执行多个任务的原因。</p>
<p>使用串行队列的优点：</p>
<ol>
<li>能确保对一个共享资源进行串行化的访问，避免了竞态条件；</li>
<li>任务的执行顺序是可预知的；你向一个串行队列提交任务时，它们被执行的顺序与它们被提交的顺序相同；</li>
<li>你可以创建任意数量的串行队列；</li>
</ol>
<h3 id="并发队列">并发队列</h3><p>正如其名，并发队列可以让你并行的执行多个任务。任务（block）按照它们被加入到队列中的顺序依次开始，但是它们都是并发的被执行，并不需要彼此等待才开始。并发队列能保证任务按同一顺序开始，但你不能知道执行的顺序、执行的时间以及在某一时刻正在被执行任务的数量。</p>
<p>比如你向一个并发队列提交了三个任务（任务#1，#2和#3）。任务被并发执行，按照加入队列的顺序依次开始。然而任务的执行时间和结束时间都不相同。即使任务#2和#3可能会迟一些开始，它们可能都会先于任务#1结束。对任务的执行是由系统本身决定。</p>
<h3 id="使用队列">使用队列</h3><p>已经解释了串行队列和并发队列，现在来看看如何使用它们。系统会缺省为每个应用提供一个串行队列和四个并发队列。其中 main dispatch queue（主派发队列）是全局可用的串行队列，在应用的主线程中执行任务。这个队列被用来更新 App 的 UI，执行所有与更新 UIViews 相关的任务。该队列中同一时刻只执行一个任务，这就是为什么当你在主队列中运行一个繁重的任务时UI会被阻塞的原因。</p>
<p>除主队列之外，系统还提供了4个并发队列。我们管它们叫 Global Dispatch queues（全局派发队列）。这些队列对整个应用来说是全局可用的，彼此只有优先级高低的区别。要使用其中一个全局并发队列的话，你得使用 <strong>dispatch_get_global_queue</strong> 函数获得一个你想要的队列的引用，该函数的第一个参数取如下值：</p>
<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
</ul>
<p>这些队列类型代表着执行优先级。带有 HIGH 的队列有最高优先级，BACKGROUND 则是最低的优先级。这样你就能基于任务的优先级来决定要用哪一个队列。还要注意这些队列也被 Apple 的 API 所使用，所以这些队列中并不只有你自己的任务。</p>
<p>最后，你可以创建任何数量的串行或并发队列。使用并发队列的情况下，即使你可以自己创建，我还是强烈建议你使用上面那四个全局队列。</p>
<h2 id="GCD_小抄">GCD 小抄</h2><p>现在你应该有了一个对 <code>Dispatch Queues</code> 的基本了解。我会给你一个简单的小抄做参考。里面很简单，包含了对 GCD 你需要了解的所有信息。</p>
<p><img src="/img/articles/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/12401452214821.2764683" alt=""></p>
<p>还不错吧？现在我们来研究一个简单的示范，看看如何使用 <code>Dispatch Queues</code>。我会告诉你如何使用 <code>Dispatch Queues</code> 来优化 App 的性能，让它有更快的响应速度。</p>
<h2 id="示例项目">示例项目</h2><p>我们的初始项目很简单，它展示4个 image views，每个 image view 显示一张来自远端站点的图片。图片的请求是在主线程中完成。为了给你展示这么做对UI响应会有何影响，我还在图片下面加了一个简单的 slider。<a href="https://www.dropbox.com/s/lkiasutevec5vx0/ConcurrencyDemoStarter.zip?dl=0" target="_blank" rel="external">下载并运行这个初始项目</a>。点击 <strong>Start</strong> 按钮开始图片的下载，然后在图片下载的过程中拖动 slider，你会发现根本就拖不动。</p>
<p><img src="/img/articles/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/12401452214821.4513347" alt=""><br>你点了 Start 按钮之后，图片就会在主线程中开始下载。显然这种方式糟糕至极，让 UI 无法响应。不幸的是时至今日还有很对的 App 依旧在主线程中执行繁重的装载任务。现在我们使用 <code>Dispatch Queues</code> 来解决这个问题。</p>
<p>首先我们使用并发队列的解决方案，随后再使用串行队列的解决方案。</p>
<h3 id="使用_Concurrent_Dispatch_Queues">使用 Concurrent Dispatch Queues</h3><p>现在回到 Xcode 项目的 ViewController.swift 文件中。如果你细看一下代码，就会看到点击事件的方法 <strong>didClickOnStart</strong>。这个方法负责处理图片的下载。我们现在是这样来完成该任务的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnStart</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> img1 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">self</span>.imageView1.image = img1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> img2 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">self</span>.imageView2.image = img2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> img3 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">self</span>.imageView3.image = img3</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> img4 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">self</span>.imageView4.image = img4</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个 downloader 都被看作是一个任务，而所有的任务都在主队列中被执行。现在我们来获得一个全局并发队列的引用，该队列是默认优先级的那个。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        dispatch_async(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> img1 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">0</span>])</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">self</span>.imageView1.image = img1</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>先用 <em>dispatch_get_global_queue</em> 获得到默认并发队列的引用，然后在 block 中提交一个任务，下载第一张图片。当图片下载完成后，我们再向主队列提交另外一个任务，这个任务用拿下载好了的图片去更新 image view。换句话说，我们就是将图片下载任务放到了后台线程中执行，而 UI 相关的任务则是在主线程中执行。</p>
<p>对剩下的图片做同样改动，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnStart</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">    dispatch_async(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img1 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">0</span>])</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView1.image = img1</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img2 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView2.image = img2</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img3 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView3.image = img3</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img4 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">3</span>])</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView4.image = img4</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你向默认队列以并发任务的形式提交了四个图片的下载任务。现在创建项目然后运行 App ，运行起来应该更快了（如果你收到任何错误告警，在把你的代码和上面的比较一下）。注意到下载图片的过程中你应该可以拖动那个 slider，没有任何延迟。</p>
<h3 id="使用_Serial_Dispatch_Queues">使用 Serial Dispatch Queues</h3><p>另一种解决延迟问题的方法是使用串行队列。现在还是回到 ViewController.swift 中的 didClickOnStart() 方法。这回我们用一个串行队列来下载图片。使用串行队列时你一定要留意你所引用的到底是哪一个串行队列。每一个 App 都有一个默认的串行队列，实际上它也是UI任务相关的主队列。所以切记用串行队列的时候，你一定要创建一个新的，否则就会在 App 尝试执行更新UI相关任务的同时又执行你的任务。这就会产生错误，引起延时，毁掉用户体验。你可以使用 dispatch_queue_create 函数创建一个新的队列，然后将所有任务按相同方式提交给它，和我们之前做的一样。更改之后，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnStart</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.appcoda.imagesQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    dispatch_async(serialQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img1 = <span class="type">Downloader</span> .downloadImageWithURL(imageURLs[<span class="number">0</span>])</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView1.image = img1</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(serialQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img2 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView2.image = img2</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(serialQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img3 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView3.image = img3</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_async(serialQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img4 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">3</span>])</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.imageView4.image = img4</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，与并行队列解决方案唯一的不同就是需要创建一个串行队列。再次点击 build 然后运行 App ，你又会看见图片在后台进行下载，所以可以和UI进行交互。</p>
<p>但是你会注意到两点：</p>
<ol>
<li>与使用并发队列的情况相比，下载图片的时间有些长。原因是我们在同一时刻只下载一张图片。每个任务必须等到前一个任务执行完成后才会被执行。</li>
<li>图片的下载是按照 image1，image2，image3，和 image4 的顺序。因为使用的是每次只能执行一个任务的串行队列。</li>
</ol>
<h2 id="第二部分：Operation_Queues">第二部分：Operation Queues</h2><p>GCD 是一个底层的 C API，能让开发者并行执行任务。与之相对比，Operation queues 是对队列模型的高层级抽象，而且是基于GCD创建的。这意味着你可以像GCD那样执行并发任务，只不过是以一种面性对象的风格。简而言之，Operation Queues 让开发者的“来福”更进一步。</p>
<p>与 GCD 不同的是，Operation Queues 不遵循先进先出的顺序。以下是 Operation Queues 和 <code>Dispatch Queues</code> 的不同：</p>
<ol>
<li>不遵循 FIFO（先进先出）：在 Operation Queues 中，你可以设置 operation（操作）的执行优先级，并且可以在 operation 之间添加依赖，这意味着你可以定义某些 operation，使得它们可以在另外一些 operation 执行完毕之后再被执行。这就是为什么它们不遵循先进先出的顺序。</li>
<li>默认情况下 Operation Queues 是并发执行：虽然你不能将其改成串行队列，但还是有一种方法，通过在 operation 之间添加相依性来让 Operation Queues 中的任务按序执行。</li>
<li>Operation Queues 是 <em>NSOperationQueue</em> 类的实例，任务被封装在 <em>NSOperation</em> 的实例中。</li>
</ol>
<h3 id="NSOperation">NSOperation</h3><p>任务是以 <em>NSOperation</em> 实例的形式被提交到 Operation Queues 中去的。之前说过 GCD 中任务是以 block 的形式被提交。在这里也是类似，只不过是需要被绑到 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="external">NSOperation</a> 实例中。你可以简单的将 <code>NSOperation</code> 看作是一套工作任务的整体。</p>
<p><code>NSOperation</code> 是一个抽象的类，不可以被直接拿来用，所以你只能使用 <code>NSOperation</code> 的子类。在 iOS 的 SDK 中有两个 <code>NSOperation</code> 的具体子类。这两个类可以直接用，但是你也可以用 <code>NSOperation</code> 的子类，创建你自己的类来完成特定 operation。这两个可以直接使用的类是：</p>
<ol>
<li><strong>NSBlockOperation</strong> - 用这个类来初始化包含一个或多个 blocks 的 operation。该 operation 本身可包含的 block 超过一个，当所有的block 执行完毕后这个 operation 就被视为已完成。</li>
<li><strong>NSInvocationOperation</strong>  - 用这个类来初始化一个 operation，能用来调用某指定对象的选择器（selector）。</li>
</ol>
<p>那么 <code>NSOperation</code> 的优势在哪里？</p>
<ol>
<li>首先它可以通过 <code>NSOperation</code> 类的 addDependency（op: NSOperation）方法获得对相依性的支持。如果你有这样的需求：即某 operation 的启动需取决于另一个 operation 的执行，那么就得用 <code>NSOperation</code>。<br><img src="/img/articles/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/12401452214821.6419117" alt=""></li>
<li>其次，你可将 <em>queuePriority</em> 属性设为以下值来改变执行优先级：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">NSOperationQueuePriority</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">VeryLow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Low</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Normal</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">High</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">VeryHigh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拥有最高优先级的 operation 会被第一个执行。</p>
<ol>
<li><p>你可以取消掉某特定队列中的某个 operation，或者是取消队列中所有的 operation。<br>通过调用 <code>NSOperation</code> 类的 cancel() 方法来实现对 operation 的取消。你取消任何 operation 的时候，会是下面三种场景之一：</p>
<ul>
<li>你的 operation 已经完成了，这种情况下 cancel 方法没有任何效果。</li>
<li>你的 operation 正在被执行的过程中，这种情况下系统不会强制停止你的 operation 代码，而是将 cancelled 属性置为 true。</li>
<li>你的 operation 还在队列中等待被执行，这种情况下你的 operation 就不会被执行。</li>
</ul>
</li>
<li><p><code>NSOperation</code> 有3个有用的布尔型属性：<code>finished</code>，<code>cancelled</code> 和 <code>ready</code>。<code>finished</code> 在 operation 执行完毕后被置为 true。<code>cancelled</code> 在 operation 被取消后被置为 true。<code>ready</code> 在 operation 即将被执行时被置为 true。</p>
</li>
<li><p>所有的 <code>NSOperation</code> 在任务被完成后都可以选择去设置一段 completion block。<code>NSOperation</code> 的 <code>finished</code> 属性变为 true 后这段 block 就会被执行。</p>
</li>
</ol>
<p>现在来重写一下我们的示例项目，这次使用 NSOperationQueues。首先在 ViewController 类中声明如下变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = <span class="type">NSOperationQueue</span>()</span><br></pre></td></tr></table></figure>
<p>然后将 didClickOnStart 方法中的代码替换成下面的，再看看在 NSOperationQueue 中怎样去执行 operation：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnStart</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    queue = <span class="type">NSOperationQueue</span>()</span><br><span class="line"> </span><br><span class="line">    queue.addOperationWithBlock &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> img1 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">0</span>])</span><br><span class="line"> </span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView1.image = img1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue.addOperationWithBlock &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> img2 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView2.image = img2</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue.addOperationWithBlock &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> img3 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">2</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView3.image = img3</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue.addOperationWithBlock &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> img4 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">3</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView4.image = img4</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所见，你使用了 <em>addOperationWithBlock</em> 方法来创建一个新的、带有某给定 block（或者它在 Swift 中的名字：闭包）的 operation。很简单，对吧？为在主队列中完成某个任务，与使用 GCD 时调用 dispatch_async() 不同，我们用 NSOperationQueue（NSOperationQueue.mainQueue()）也可以达到相同结果，将你想要在主队列中执行的 operation 提交过去。</p>
<p>可以运行一下这个 App 做个快速测试。如果代码输入正确的话， App 应该能够在后台下载图片，不会阻塞UI。</p>
<p>之前的例子中我们使用了 addOperationWithBlock 方法把 operation 添加到队列中。再让我们来看看如何使用 NSBlockOperation：在达到相同的效果的同时，还会给我们提供更多的功能和选项，比如设置 completion handler。改后的 didClickOnStart 方法如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnStart</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    queue = <span class="type">NSOperationQueue</span>()</span><br><span class="line">    <span class="keyword">let</span> operation1 = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        <span class="keyword">let</span> img1 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">0</span>])</span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView1.image = img1</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    operation1.completionBlock = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Operation 1 completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.addOperation(operation1)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> operation2 = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        <span class="keyword">let</span> img2 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">1</span>])</span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView2.image = img2</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    operation2.completionBlock = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Operation 2 completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.addOperation(operation2)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> operation3 = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        <span class="keyword">let</span> img3 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">2</span>])</span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView3.image = img3</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    operation3.completionBlock = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Operation 3 completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.addOperation(operation3)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> operation4 = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        <span class="keyword">let</span> img4 = <span class="type">Downloader</span>.downloadImageWithURL(imageURLs[<span class="number">3</span>])</span><br><span class="line">        <span class="type">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView4.image = img4</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    operation4.completionBlock = &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Operation 4 completed"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    queue.addOperation(operation4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对每个 operation，我们都为其创建了一个新的 NSBlockOperation 实例并将任务封装在一个 block 中。而使用了 NSBlockOperation，你还可以设置 completion handler。当 operation 完成后，completion handler 就会被调用。将示例运行一下，就会在控制台看见这样的输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Operation</span> <span class="number">1</span> completed</span><br><span class="line"><span class="type">Operation</span> <span class="number">3</span> completed</span><br><span class="line"><span class="type">Operation</span> <span class="number">2</span> completed</span><br><span class="line"><span class="type">Operation</span> <span class="number">4</span> completed</span><br></pre></td></tr></table></figure>
<h3 id="取消_operation">取消 operation</h3><p>之前提过，NSBlockOperation 能够让你管理 operation。那么现在来看看如何取消一个 operation。首先给 navigation bar 加一个 bar button item，将其命名为 Cancel。为展示取消 operation，我们在 Operation #2 和 Operation #1 之间添加一个相依性，Operation #3 和 Operation #2 之间添加另一个相依性。也就是说 Operation #2 会在 Operation #1 完成后开始执行，而 Operation #3 会在 Operation #2 完成后执行。Operation #4 并没有相依性，它会被并发执行。要取消 operation 的话，你只需调用 NSOperationQueue 的 cancelAllOperations() 方法。在ViewController 类中插入下面的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnCancel</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.queue.cancelAllOperations()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住需要把你在 navigation bar 上添加的 Cancel 按钮与 didClickOnCancel 方法关联起来。你可以这么做：返回 Main.storyboard 文件，打开Connections Inspector，这里你会在Received Actions区域中看见unlink didSelectCancel()。点击 + 并将其从空圆圈拖拽到 Cancel bar button 上。然后在 didClickOnStart 方法中添加相依性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation2.addDependency(operation1)</span><br><span class="line">operation3.addDependency(operation2)</span><br></pre></td></tr></table></figure>
<p>接下来把 operation #1 的 completion block 改一下，让它在控制台打印出 cancel 的状态：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operation1.completionBlock = &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Operation 1 completed, cancelled:<span class="subst">\(operation1.cancelled)</span> "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以自己改一下 operation #2，#3 和 #4 的打印语句，这样可以更好的理解这一过程。然后创建并运行项目。你点击了 Start 按钮之后，再按 Cancel 按钮，这就会在 operation #1 执行完毕后取消所有的 operation。下面告诉了我们都发生了些什么：</p>
<ul>
<li>由于 operation #1 已经开始执行，取消对它没有任何效果。这就是为什么 <code>cancelled</code> 会被记录成 false，并且 App 还是会显示第一张图片。</li>
<li>如果你点击 Cancel 按钮足够快的话，operation #2 会被取消。对 cancelAllOperations() 的调用会停止对该 operation 的执行，所以第二张图片没有被下载。</li>
<li>operation #3 已经排在队列中，等待 operation #2 的完成。因为 operation #3 是否开始取决于 operation #2 的完成与否，而 operation #2 已经被取消，operation #3 就不会被执行，从队列中被立即踢出了。</li>
<li>没有对 operation #4 做任何相依性的设置，所以它被并发的执行了，下载了第四张图片。</li>
</ul>
<p><img src="/img/articles/ios-concurrency-getting-started-with-nsoperation-and-dispatch-queues/12401452214821.7265584" alt=""></p>
<h2 id="接下来看什么？">接下来看什么？</h2><p>本篇教程中我为你讲解了 iOS 中并发的概念，以及你在 iOS 中该如何去使用它。我给了你一个还不错的并发入门简介，解释了 GCD，并示范了怎样去创建串行和并发队列。除此之外，我们还看了一下 NSOperationQueues。你现在应该对 GCD 和 NSOperationQueues 之间的不同有所了解了。</p>
<p>如果想进一步了解 iOS 的并发，建议你去看一下 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">Apple 的并发指南</a>。</p>
<p>你可以从 <a href="https://github.com/appcoda/NSOperation-Demo" target="_blank" rel="external">iOS Concurrency repository on Github</a> 这里找到此教程提到的全套源代码以作参考。</p>
<p>随便问任何问题，我真心喜欢你的评论。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：hossam ghareeb，<a href="http://www.appcoda.com/ios-concurrency/">原文链接</a>，原文日期：2015-12-09<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="undefined">Channe</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>并发（Concurrency）在 iOS 开发中总是被看作是洪水猛兽一般。人们以为它是一个很危险的领域，很多开发者都尽量避免与其接触。更有传闻说你一定要竭尽所能的避免写任何关于多线程的代码。假如你对并发不是很了解却还去使用它的话，那么我同意：并发是很危险的。只是它的危险是因为你不了解它。试想一下常人一生中体验过的危险运动和行为有多少，很多对吧？但是当掌握了之后，就会统统变成小菜一碟。并发是把双刃剑，你应该掌握并学会如何去使用它。它能帮你写出效率高、执行快、反应灵敏的 App，而与此同时，对它的滥用会无情的毁掉你的 App。这就是为什么在开始写任何关于并发的代码之前，先要想一想你为什么要用到并发、需要用到哪个（与并发有关的）API 来解决这个问题。iOS 中我们有很多能用到的 API。在此教程里我会讲到最常用的两个：<code>NSOperation</code> 和 <code>Dispatch Queues</code>（派发队列）。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 iOS 9 App 瘦身功能]]></title>
    <link href="http://swiftggteam.github.io/2016/01/07/app-thinning-appcoda/"/>
    <id>http://swiftggteam.github.io/2016/01/07/app-thinning-appcoda/</id>
    <published>2016-01-07T01:20:00.000Z</published>
    <updated>2016-01-12T01:05:23.234Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：gregg mojica，<a href="http://www.appcoda.com/app-thinning/" target="_blank" rel="external">原文链接</a>，原文日期：2015/10/11<br>译者：<a href="http://ijack.pw/" target="_blank" rel="external">JackAlan</a>；校对：<a href="http://weibo.com/lfbWb" target="_blank" rel="external">lfb_CD</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><strong>更新</strong>: iOS 9 有个 bug 影响 APP 瘦身功能，这个 bug 在 iOS 9.0.2 被修复。从 AppStore 下载 App 时请留意。</p>
<p>iOS 9 已经变成了一个大<a href="http://techcrunch.com/2015/09/21/apple-announces-50-ios-9-adoption-and-iphone-6s-launch-day-specifics/" target="_blank" rel="external">热门</a>。发布几周后，这个新的操作系统在 iOS 设备上的安装量就超过了一半。它的普及率打破了 iOS 7 在 2013 年的记录。</p>
<p>在写完上一篇文章之后 <a href="http://www.appcoda.com/search-api-sfsafariviewcontroller/" target="_blank" rel="external">Search APIs and SFSafariViewController in iOS 9</a>，我们继续学习如何使用 App 瘦身这个 iOS 9 中令人兴奋的特性。在此教程中，我们将探索为什么要使用 App 瘦身以及如何在自己的 App 中使用这个令人兴奋的新特性。</p>
<a id="more"></a>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/app-thinning-1024x682.png" alt=""></p>
<p>在本次 WWDC 中公布的 App 瘦身是一个令人兴奋的新技术，这会改变整个下载的过程。由于蜂窝流量消费大、iOS 设备内存限制以及网络提速，App 瘦身是一个值得学习的至关重要的特性。进一步来说，因为 App 瘦身被推迟(稍后详述)，这也是一个绝好的时机去了解这个令人兴奋的技术。</p>
<h2 id="预备知识">预备知识</h2><p>在这篇教程中，我假设你知道如何使用 Xcode 和 IDE。如果这对你来说很陌生，或者你根本不知道 IDE 是什么，你应该先看一下<a href="http://www.appcoda.com/ios-programming-course/" target="_blank" rel="external">excellent free course</a>.</p>
<p>我还假设你已经知道如何在 AppStore 上或者 TestFlight (苹果 beta 版 App 测试服务)上发布 App。我不会具体到讲述如何用 TestFlight，所以如果你对 TestFlight 很陌生或者对 App 发布流程很陌生，我建议你先读阅读<a href="http://www.appcoda.com/testflight-beta-testing/" target="_blank" rel="external">AppCoda article</a>。这些就足够了，不需要其他预备知识，只要用心学习就好！</p>
<p>有了这样的想法，那就让我们开始吧。</p>
<h2 id="App_瘦身简介">App 瘦身简介</h2><p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/apple_app_slicing_illustration-516x300.jpg" alt=""></p>
<p>当前市场上存在大量的 iOS 设备，因此有多种屏幕尺寸和分辨率，要想保证一个 App 在多种屏幕下的展示效果需要大量的资源(比如 png、jpeg 以及二进制的 PDF)。不幸的是，这导致用户需要下载一个巨大的程序包(之前的 iOS 版本强制用户下载全部 App 文件，包括他们在用 iPhone 时永远也不会用到的 iPad 适配图片)。16G 的 iPhone 仍然有不少人在用(并且可能短时间内不会消失)，所以你要缩小 App 体积从而可以快速下载并且保证用户有足够的空间。App 瘦身特性让这一切成为可能。</p>
<p>除了代码和图片，现在的 App 还包括可执行代码以及32位、64位版本(针对各种架构进行优化，比如 arm64、arm7S 和 arm7)、3D 图形技术(例如 OpenGL、Metal 等)、声音和其他文件。总之，现在的 App 已经复杂到令人难以置信。这就是 App 瘦身需要解决的问题。</p>
<p>App 瘦身会自动检测用户设备类型(比如型号名称)，并为特定的设备下载相关内容。换句话来说，如果你使用 iPad Mini 1(没有视网膜屏，只有 1X 的分辨率)，那么只有 1X 的文件会被下载。更强大更清晰的资源(比如 iPad Mini 3 或 4)将不会下载。因为用户只需要下载他/她需要用到的内容，这加速了下载过程，并节省了设备上的空间。</p>
<p>虽然这起初可能听起来很复杂，我们将深入到具体的细节。幸运的是，Xcode 和 AppStore 会完成这项工作的绝大部分，开发者会轻松很多。因此，在本教程中不会有太多的代码，而是重点关注理解 App 瘦身的过程和它用到的技术。</p>
<p>App 瘦身有三个主要方面，应用程序切片(<code>App Slicing</code>)、中间代码(<code>Bitcode</code>)和按需加载资源(<code>On Demand Resources</code>)。在本教程中，我们将一一介绍。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/13196-7761-150609-Developer-2-l-545x300.jpg" alt=""></p>
<h2 id="应用程序切片(App_Slicing)">应用程序切片(App Slicing)</h2><p>App瘦身第一个我们要讨论的就是切片(slicing)。根据苹果的文档，</p>
<blockquote>
<p>切片是创建和提供不同的目标设备的应用程序包的变体(<code>variant</code>)的过程。</p>
</blockquote>
<p>一个变体(<code>variant</code>)只包含可执行架构和目标设备所需要的资源。换句话来说，应用程序切片只提供给与每个设备相关的资源(取决于屏幕分辨率和架构等等)。实际上，应用程序切片完成了 App 瘦身的大部分工作。</p>
<p>假设你已准备好提交 App，和之前一样，你会上传 .IPA 或者 .App 文件到 iTunes Connect(但是必须使用 Xcode7，因为它包含支持 App 瘦身的 iOS 9 SDK)。然后 AppStore 会对 App 进行切片，创建特定的变体(<code>variant</code>)，这些变体将根据功能(<code>capabilities</code>)分发给每个设备，。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/slicing.png" alt=""></p>
<h2 id="按需加载资源(On_Demand_Resources)">按需加载资源(On Demand Resources)</h2><p>为了完全理解 App 瘦身，你需要了解什么是按需加载资源(<code>ODR</code>)。 按需加载的资源就是在 App 初次安装后需要下载的文件。例如，游戏的特定关卡(以及和这些关卡相关的内容)只有在玩家解锁时才可以下载。此外，超过设置时间之后，玩家不需要的早期关卡可以被移除，以节省设备的存储空间。</p>
<p>在 Xcode 的设置中(在 Build Setting 里)，开启按需加载资源需要把”Enable On Demand Resources”改为”YES”.</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-3.53.20-PM.png" alt=""></p>
<h2 id="中间代码(Bitcode)">中间代码(Bitcode)</h2><p>App 瘦身的最后一个内容是中间代码。中间代码有点抽象，但在本质上，它是在 App 被下载前，苹果优化它的新途径。中间代码使得 App 可以在任何设备上尽可能快速和高效执行。中间代码可以为最近使用的编译器自动编译 App，并且对特定的架构做优化(例如 arm64 64 位处理器，如 iPhone6s 和 iPad Air 2)。</p>
<p>中间代码会和上文提到的其他瘦身技巧一起使用，去除针对其他架构的优化内容，只下载需要的优化内容，从而减少下载文件的大小。</p>
<p>在 iOS 中，中间代码是一种新特性，并且在新的工程中需要手动开启。这个过程可以在 Build Setting 下把 Enable bitcode 修改为 YES。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-3.50.06-PM.png" alt=""></p>
<h2 id="在你的项目中使用_App_瘦身">在你的项目中使用 App 瘦身</h2><p>尽管 Xcode 和 App Store 处理了 App 瘦身的绝大多数流程，你仍然需要采取一定的预防措施以确保你的 App 真的使用了这种新的技术。首要的，你必须使用资源目录(<code>asset catalogs</code>).在这一点上，大多数的 App 默认使用资源目录(<code>asset catalogs</code>)。如果你还没有用采用资源目录(<code>asset catalogs</code>)，你现有的大部分内容可以被转移到一个目录下，只需要在 Xcode的项目设置中点击”Use Asset Catalog”按钮，如下所示。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-7.59.13-PM1.png" alt=""></p>
<p>Xcode 的新特性之一就是<code>Sprite Atlases</code>。Sprite Atlases 基本上结合使用资源目录和 SpriteKit(Xcode 中开发 2D 游戏用到的技术)。同样的，如果你是用 SpriteKit，App 瘦身是必须的。</p>
<h2 id="测试_App_瘦身">测试 App 瘦身</h2><p>如你所见，Xcode 和苹果的 AppStore 已经处理了绝大多数 App 瘦身的过程，这样在你自己的 App 中使用这个技术会容易很多。但是如何测试你的 App 并且确保它已经应用了 App 瘦身？幸运的是苹果的 TestFlight 提供了完美的解决方案。除 AppStore 的应用瘦身技术外，TestFlight 的用户也可以体验这个特性。</p>
<p>在本篇教程的第二部分，我们会介绍如何在 TestFlight 中使用 App 瘦身。</p>
<p>首先，下载这个<a href="https://github.com/AlanMelody/AppThinning" target="_blank" rel="external">基本空白的项目</a>，解压，并且在 Xcode 中运行，你将会注意到这个项目基本没有什么除了在资源目录(<code>asset catalogs</code>)中的一系列的图片(以及少量的代码)。这个资源目录(<code>asset catalogs</code>) 也包含 1x、2x和3x 版本的 App 图标。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-9.00.47-PM-1024x239.png" alt=""></p>
<p>首先，在模拟器或者真机上运行这个 App。打开设置应用，点击<code>存储和 iCloud 使用</code>这一项(如果不是 iOS 9 设备，点<code>存储</code>) 并选择管理存储空间。向下滑动到我们刚刚编译好的 App 并点击它。你会注意到它大概有 17.0 MB(当上传至 iTunes Connect 时这个大小可能略有不同)。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/IMG_0106-2.png" alt=""></p>
<p>当你使用 Xcode 构建并运行一个 App 时，Xcode 不会自动处理 App 变体(<code>variant</code>)并对 App 瘦身，因此整个 App 文件都在你的设备上。</p>
<p>下一步，在 Xcode 中单击<code>Product</code>标签，选择<code>Archive</code>.</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Screen-Shot-2015-09-28-at-8.36.26-PM-1024x345.png" alt=""></p>
<blockquote>
<p>注意，你可能首先需要修改这个 App 的<code>Bundle Identifier</code>以匹配一个你自己创建的标识符。否则，这个 App 将不会被上传到 iTunes Connect.</p>
</blockquote>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/appthinnning-1024x390.png" alt=""></p>
<p>确保你在点击”Submit”前，选择了”Include bitcode”。如果一切顺利的话，你将会看到一个绿色对号通知你这次构建已经被上传。</p>
<p>现在登录到<a href="https://itunesconnect.apple.com" target="_blank" rel="external">iTunes Connect</a>，创建一个新的 App(包含合适的 bundle ID、App 名字等等)。如果你不确定如何做这项工作，请参阅<a href="http://www.appcoda.com/testflight-beta-testing/" target="_blank" rel="external">AppCoda TestFlight tutorial</a>.</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/iTunes-Connect-App-Thinning-1024x483.png" alt=""></p>
<p>把你自己添加为内部测试人员。注意，一次构建保持“正在处理中”这个状态几小时是很寻常的。一旦这个 App 处理完成，选择它并且按下开始测试按钮。</p>
<p>一封电子邮件将会被发送到你的地址。确保你正在使用想要测试的 iOS 设备，打开这封电子邮件。你将会进入 TestFlight 应用。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/Untitled.png" alt=""></p>
<p>安装此次构建，一旦完成安装，就回到设置应用中，找到存储，像此前一样找到这个 App。注意，这个 App 现在接近 5.4 MB。这就是 App 瘦身的意义。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/IMG_0108.png" alt=""></p>
<p>哇哦！你刚刚从你的 App 中剔除掉了 12.4 MB - 并且这只是一个非常简单的 App。那些包含多种不同的资源(<code>asset</code>)的 App 效果更好。</p>
<h2 id="总结">总结</h2><p>在本篇教程，我们看到了 App 瘦身的强大。我们讨论了 App 瘦身的三个主要的方面：应用程序切片(<code>App Slicing</code>)、中间代码(<code>Bitcode</code>)和按需加载资源(<code>On Demand Resources</code>).</p>
<p>不幸的是，2015 年 9 月 24 日，苹果在它的开发者门户宣布 App 瘦身已经被延迟，并且不会包含在 iOS 9(或者 9.0.1)公开发行版中：</p>
<blockquote>
<p>应用程序切片目前不可用于 iOS 9 应用，因为 iCloud 创建 iOS 9 备份有问题，AppStore 中的一些 App 只能还原到相同型号的 iOS 设备。</p>
<p>当用户下载你的 iOS 9 应用时，他们会获取通用版本，而不是针对他们的设备类型的特定变体(<code>vatiant</code>)。TestFlight 将会给内部测试用户继续分发变体(<code>vatiant</code>). 应用程序切片将会在未来的软件更新中可以使用。现在你什么都不用做。</p>
</blockquote>
<p>然而，就像我在文章的一开始中提到的，App 瘦身已经被修复并且已经为所有运行 iOS 9.0.2 的设备准备就绪。App 瘦身是一个简直不可思议的工具，它将会持续加速 App 下载。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：gregg mojica，<a href="http://www.appcoda.com/app-thinning/">原文链接</a>，原文日期：2015/10/11<br>译者：<a href="http://ijack.pw/">JackAlan</a>；校对：<a href="http://weibo.com/lfbWb">lfb_CD</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><strong>更新</strong>: iOS 9 有个 bug 影响 APP 瘦身功能，这个 bug 在 iOS 9.0.2 被修复。从 AppStore 下载 App 时请留意。</p>
<p>iOS 9 已经变成了一个大<a href="http://techcrunch.com/2015/09/21/apple-announces-50-ios-9-adoption-and-iphone-6s-launch-day-specifics/">热门</a>。发布几周后，这个新的操作系统在 iOS 设备上的安装量就超过了一半。它的普及率打破了 iOS 7 在 2013 年的记录。</p>
<p>在写完上一篇文章之后 <a href="http://www.appcoda.com/search-api-sfsafariviewcontroller/">Search APIs and SFSafariViewController in iOS 9</a>，我们继续学习如何使用 App 瘦身这个 iOS 9 中令人兴奋的特性。在此教程中，我们将探索为什么要使用 App 瘦身以及如何在自己的 App 中使用这个令人兴奋的新特性。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[每周 Swift 社区问答 2016-01-06]]></title>
    <link href="http://swiftggteam.github.io/2016/01/06/swift-qa-2016-01-06/"/>
    <id>http://swiftggteam.github.io/2016/01/06/swift-qa-2016-01-06/</id>
    <published>2016-01-06T15:00:00.000Z</published>
    <updated>2016-01-06T04:50:14.927Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a> &amp; <a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a></p>
<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Question on extracting a substring from a url</a></li>
<li><a href="#Q2">All func pointers need a protocol now</a></li>
<li><a href="#Q3">Property for Double and CGFloat</a></li>
<li><a href="#Q4">Question on dismissing model ViewController</a></li>
<li><a href="#Q5">count numbers in array and order them by count in swift</a></li>
<li><a href="#Q6">Cannot invoke [Method] with argument list of type ( , )</a></li>
<li><a href="#Q7">Swift programming style</a></li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20160106/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420160106.playground" target="_blank" rel="external">点击下载</a></p>
<a id="more"></a>
<p><a name="Q1"></a></p>
<h2 id="Question1:_Question_on_extracting_a_substring_from_a_url">Question1: Question on extracting a substring from a url</h2><p><a href="https://forums.developer.apple.com/thread/29374" target="_blank" rel="external">Q1链接地址</a></p>
<h3 id="问题描述">问题描述</h3><p>这个问题在实战中经常被提及，譬如现在有一个字符串URL：<a href="https://api.github.com/gists/public?page=2" target="_blank" rel="external">https://api.github.com/gists/public?page=2</a> ，我需要从中提取出“?page=2”以及“<a href="https://api.github.com/gists/public”，将这两个部分存储到两个变量中，如下：" target="_blank" rel="external">https://api.github.com/gists/public”，将这两个部分存储到两个变量中，如下：</a></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strBase = <span class="string">"https://api.github.com/gists/public"</span></span><br><span class="line"><span class="keyword">var</span> strPage = <span class="string">"?page=2"</span></span><br></pre></td></tr></table></figure>
<p>问题解答前了解下小知识：</p>
<ul>
<li>HTTP GET请求中，url 与请求参数之间用<strong>?</strong>分隔，参数与参数之间是<strong>&amp;</strong>分隔。</li>
</ul>
<h3 id="问题解答">问题解答</h3><p>思路：显而易见，关注点应该放在<strong>?</strong>上，解决方式也五花八门，现提供以下几种方式：</p>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlStr = <span class="string">"https://api.github.com/gists/public?page=2"</span></span><br><span class="line"><span class="keyword">var</span> strBase:<span class="type">String</span>		<span class="comment">// 请求地址</span></span><br><span class="line"><span class="keyword">var</span> strPage:<span class="type">String</span>		<span class="comment">// 请求参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> qIndex = urlStr.characters.indexOf(<span class="string">"?"</span>) &#123;  <span class="comment">//35</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">strBase = urlStr.substringToIndex(qIndex)</span><br><span class="line">strPage = urlStr.substringFromIndex(qIndex)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">strBase = urlStr</span><br><span class="line">strPage = <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先定位到 <strong>?</strong> 的 index 索引值。</li>
<li>请求地址中存在参数（即存在?），那么通过<code>substringToIndex</code> 和 <code>substringFromIndex</code> 获取到两个部分</li>
<li>请求地址中不存在参数，那么直接传入的地址就是<code>strBase</code>。</li>
</ol>
<p>这里的<code>qIndex</code>是一个索引值，类型是<code>String.CharacterView.Index</code>，修改该值并非是用 <code>+、-</code> 操作，而是调用<code>qIndex.successor()</code> 取到下一位索引值，使用<code>qIndex.predecessor()</code>取到前一位索引值。</p>
<p>对于<code>substringToIndex(qIndex)</code>方法，从 urlStr 的 <code>startIndex(这里是0)</code> 开始截取直到 <code>qIndex</code>；对于<code>substringFromIndex(qIndex)</code> 方法，即从 <code>qIndex</code> 索引开始直到<code>endIndex</code>前面一个索引，为什么这么说？举个例子，“Hello”字符的 startIndex 毫无疑问是等于0，但 endIndex 不是等于4！！而是5！！最后一个字符的后一位！希望大家记住。</p>
<ul>
<li>方法二</li>
</ul>
<p>这里是使用了<code>componentsSeparatedByString</code>方法，通过<strong>?</strong>字符将字符串分隔符将原字符串分割成多个部分到数组中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parts = urlStr.componentsSeparatedByString(<span class="string">"?"</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">strBase = parts[<span class="number">0</span>]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">strPage = parts.<span class="built_in">count</span> &gt;= <span class="number">2</span> ? <span class="string">"?"</span> + parts[<span class="number">1</span>] : <span class="string">""</span></span><br></pre></td></tr></table></figure>
<ol>
<li>显然这里只有一个 ? 字符，将原字符串分割成两个部分，第一个部分当然是 strBase 喽</li>
<li>通过数组的count 来判断是否存在请求参数。</li>
</ol>
<ul>
<li>方法三<br>这里使用了 NSURLComponents 方法：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> urlCompo = <span class="type">NSURLComponents</span>(string: urlStr) &#123;</span><br><span class="line">strPage = urlCompo.query != <span class="literal">nil</span> ? <span class="string">"?"</span> + urlCompo.query! : <span class="string">""</span></span><br><span class="line">urlCompo.query = <span class="literal">nil</span></span><br><span class="line">strBase = urlCompo.string!</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fatalError</span>(<span class="string">"invalid URL"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举一反三，如果我还想获得请求参数中的各个参数，那应该怎么做呢？我先抛砖引玉下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> urlStr1 = <span class="string">"https://api.github.com/gists/public?page=2&amp;name=machao&amp;pwd=222"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parts1 = urlStr1.componentsSeparatedByString(<span class="string">"?"</span>)</span><br><span class="line">strBase = parts1[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> strPara = parts1.<span class="built_in">count</span> &gt;= <span class="number">2</span> ? <span class="string">"?"</span> + parts[<span class="number">1</span>] : <span class="string">""</span></span><br><span class="line"></span><br><span class="line">strPara.removeAtIndex(strPara.startIndex)</span><br><span class="line"><span class="keyword">let</span> <span class="type">Paras1</span> = strPara.componentsSeparatedByString(<span class="string">"&amp;"</span>)<span class="comment">//就是这个！</span></span><br></pre></td></tr></table></figure>
<p><a name="Q2"></a></p>
<h2 id="Question2:_All_func_pointers_need_a_protocol_now?">Question2: All func pointers need a protocol now?</h2><p><a href="https://forums.developer.apple.com/thread/29580" target="_blank" rel="external">Q2链接地址</a></p>
<h3 id="问题描述-1">问题描述</h3><p>Gargoyle 想实现一个对象之间的回调，但是却未使用 protocol + delegate 的设计模式，而是使用了如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> onSomeAction: ((<span class="type">String</span>) -&gt; <span class="type">Void</span>)!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> myView = <span class="type">MyView</span>(frame: <span class="type">CGRectZero</span>)</span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">myView.onSomeAction = someFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">someFunc</span><span class="params">(str: String)</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到 <code>myViewController</code> 实例与 <code>myView</code> 实例会形成一个 retain cycle ，倘若你想为 <code>var onSomeAction</code> 使用 <code>weak</code> 关键字，抱歉！报错“weak cannot be applied to non-class type xxxx” ，显然对于非 class 对象你无法使用 weak 关键字。</p>
<h3 id="问题解答-1">问题解答</h3><p>Jessy 提供了一种解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> onSomeAction_get: () -&gt; (<span class="type">String</span> -&gt; <span class="type">Void</span>)! = &#123;<span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line">myView.onSomeAction_get = &#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="keyword">self</span>.someFunc&#125;</span><br></pre></td></tr></table></figure>
<p>首先对闭包类型进行了修改，从<code>(String) -&gt; Void</code> 变为 <code>() -&gt; (String -&gt; Void)</code> ；其次为 <code>myView</code> 的 <code>onSomeAction_get</code> 赋值是用闭包方式，其中使用了[unowned self] 保证不会形成retain cycle，这也是问题解决的关键所在。</p>
<p><a name="Q3"></a></p>
<h2 id="Question3:_Property_for_Double_and_CGFloat">Question3: Property for Double and CGFloat</h2><p><a href="https://forums.developer.apple.com/thread/29710" target="_blank" rel="external">Q3链接地址</a></p>
<h3 id="问题描述-2">问题描述</h3><p>Albinus 希望判断是一个随意给定的 number 是否是整型，譬如给定一个 number 是 Double 类型，他现在是通过extension 来实现的，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isInteger: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Double</span>(<span class="keyword">self</span>) == <span class="type">Double</span>(<span class="type">Int</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到通过 extension 扩展了一个computed property <code>isInteger</code> ， 布尔类型，判断方式也很简单，是通过类型转换先 Int 去除小数部分（如果有的话），然后再转成 Double 类型，这样做很繁琐，但是 Swift 作为一门强类型语言，类型安全放在首位，任何时候都要先保证类型统一。</p>
<p>再来说说其他数字类型，譬如 CGFloat 、 Float 等等，我们都可以通过 extension 依葫芦画瓢来实现，不过有木有更简单，直观的方式呢？</p>
<h3 id="问题解答-2">问题解答</h3><p>OOPer 给出了自己解答：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">protocol IntegerCheckableFloatType: FloatLiteralConvertible, Equatable &#123;</span><br><span class="line">    func % (lhs: Self, rhs: Self) -&gt; Self   // % 可是取余运算符哦</span><br><span class="line">    var isInteger: Bool &#123;get&#125;</span><br><span class="line">    &#125;</span><br><span class="line">extension IntegerCheckableFloatType &#123;</span><br><span class="line">    var isInteger: Bool &#123;</span><br><span class="line">        return self % 1.0 == 0.0 as Self</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension Double: IntegerCheckableFloatType &#123;&#125;</span><br><span class="line">extension CGFloat: IntegerCheckableFloatType &#123;&#125;</span><br><span class="line">extension Float: IntegerCheckableFloatType &#123;&#125;</span><br><span class="line">(123.4).isInteger //-&gt;false</span><br><span class="line">(123.0).isInteger //-&gt;true</span><br></pre></td></tr></table></figure>
<p>首先定义 <code>IntegerCheckableFloatType</code> 协议，它遵循（实现）了 <code>FloatLiteralConvertible</code> 和 <code>Equatable</code> 协议，当然协议本身还要求一个 method 以及 read-only property，分别是 <code>func % (lhs: Self, rhs: Self) -&gt; Self</code> 和 <code>isInteger</code>。</p>
<p>对于 <code>FloatLiteralConvertible</code> 协议内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">FloatLiteralType</span></span><br><span class="line"><span class="comment">/// Create an instance initialized to `value`.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(floatLiteral value: <span class="type">Self</span>.<span class="type">FloatLiteralType</span>)</span><br></pre></td></tr></table></figure>
<p><code>FloatLiteralType</code> 又是什么鬼？其实是<code>public typealias FloatLiteralType = Double</code> 正如你所看到其实就是 Double。 只要实现了这个协议的类型就能使用浮点类型<strong>字面量</strong>进行初识化。</p>
<p><code>Equatable</code> 更简单，协议内容如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> ==<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>从名称就知道这个协议用于 <code>==</code> 进行两个数之间的判断了，返回一个布尔类型值来标示是否相等。</p>
<p>现在巧妙的是我们使用了 Protocol 中的 <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="external">extension 特性</a>，为协议增加了默认行为，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">IntegerCheckableFloatType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isInteger: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> % <span class="number">1.0</span> == <span class="number">0.0</span> <span class="keyword">as</span> <span class="type">Self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据协议的知识，一个类型遵循了某个协议，那么必须实现该协议中的所有“要求”。但是！倘若你使用了 extension 特性为协议增加了一个默认行为，那么类型遵循了该协议，本身却不实现，则会调用默认行为。就拿上文例子说吧，如果类型遵循了<code>IntegerCheckableFloatType</code> 协议却没有实现 <code>var isInteger:Bool</code> 这个只读属性，就会调用默认行为<code>self % 1.0 == 0.0 as Self</code> ，不过一旦你自己实现了 <code>var isInteger:Bool</code>这个协议内容，就会覆盖原有的默认行为。</p>
<p>再来看看后面部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span>: <span class="title">IntegerCheckableFloatType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGFloat</span>: <span class="title">IntegerCheckableFloatType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Float</span>: <span class="title">IntegerCheckableFloatType</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们令 <code>Double、CGFloat和Float</code> 遵循自定义协议<code>IntegerCheckableFloatType</code>，你可能会问怎么不实现协议内容呢？原因是这些类型本身就已经是实现了<code>FloatLiteralConvertible</code> 以及 <code>Equatable</code> 协议，另外<code>func % (lhs: Self, rhs: Self) -&gt; Self</code> 也是实现的。所以你只需要贴心地用extension对已有类型进行扩展，告知它们是遵循<code>IntegerCheckableFloatType</code>即可，想要判断是否是整型，只需要获取<code>isInteger</code>属性即可。</p>
<p><a name="Q4"></a></p>
<h2 id="Question4:_Question_on_dismissing_model_ViewController">Question4: Question on dismissing model ViewController</h2><h3 id="问题链接">问题链接</h3><p><a href="https://forums.developer.apple.com/thread/29701" target="_blank" rel="external">Q4链接地址</a></p>
<h3 id="问题描述-3">问题描述</h3><p>VolmDev 问了一个自己在实际开发中遇到的问题：应用需要登录操作，为此当主界面出现之后，跳转到登陆界面，输入账号密码，点击 Login 按钮，关闭登陆界面，回到主界面，一切就应该结束，不是吗？ 可问题偏偏出现了！当关闭登陆界面后居然又跳出了登陆界面！再关闭又打开？ VolmDev 抓狂了，这尼玛什么情况！他附上了完整的代码，如下：</p>
<p>这是ViewController.swift 文件源代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewController.swift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> SafariServices</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">LoginViewDelegate</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> safariViewController: <span class="type">SFSafariViewController</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">	<span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">	showPopUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">showPopUp</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="type">NSBundle</span>.mainBundle())</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> loginVC = storyboard.instantiateViewControllerWithIdentifier(</span><br><span class="line"><span class="string">"LoginViewController"</span>) <span class="keyword">as</span>? <span class="type">LoginViewController</span> &#123;</span><br><span class="line">	loginVC.delegate = <span class="keyword">self</span></span><br><span class="line">	<span class="keyword">self</span>.presentViewController(loginVC, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate function.</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">didTapLoginButton</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">false</span>, completion: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//        if let authURL = GitHubAPIManager.sharedInstance.URLToStartOAuth2Login() &#123;</span></span><br><span class="line"><span class="comment">//            safariViewController = SFSafariViewController(URL: authURL)</span></span><br><span class="line"><span class="comment">//            safariViewController?.delegate = self</span></span><br><span class="line"><span class="comment">//            if let webViewController = safariViewController &#123;</span></span><br><span class="line"><span class="comment">//                self.presentViewController(webViewController, animated: true, completion: nil)</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 LoginViewController.swift 文件源代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  LoginViewController.swift</span></span><br><span class="line"><span class="comment">//  TestingPopUps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a delegate function that can be used</span></span><br><span class="line"><span class="comment">// to call a funct+-*`*ion outside this class to do</span></span><br><span class="line"><span class="comment">// something on behafe of this class.</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LoginViewDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">didTapLoginButton</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">LoginViewDelegate</span>?</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">btnDismiss</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line"><span class="comment">// Note: I tried dismissing here too with failure</span></span><br><span class="line"><span class="comment">//self.dismissViewControllerAnimated(false, completion: nil)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> delegate = <span class="keyword">self</span>.delegate &#123;</span><br><span class="line">	delegate.didTapLoginButton()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">	<span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">	<span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，storyboard 还有些不关紧要的东西，倘若有兴趣，你可以自己来补充。</p>
<p>倘若不想看源代码思考下，请直接跳转到问题解答。</p>
<h3 id="问题解答-3">问题解答</h3><p>该例出现的问题其实很简单，但也是新手经常犯的错误。贴出逻辑错误的部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidAppear(animated)</span><br><span class="line">    showPopUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 viewController 的主视图出现之后，调用showPopUp方法弹出登陆界面，貌似没什么错误。此时登陆界面位于主视图之上，输入账号密码之后点击按钮，通过 protocol+delegate 方法告知 viewController 视图控制器用户点击了登陆按钮，此时事件处理只是简单的关闭登陆视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">didTapLoginButton</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">false</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭视图之后，意味着 viewController 的视图又出现了！那么就会调用<code>viewDidAppear</code> 方法，再次调用了<code>showPopUp</code>方法！问题就是这么来的。</p>
<h3 id="思考">思考</h3><p>今天的问题很基础，但是同样有我们值得学习的地方，我简单归纳下：</p>
<ol>
<li>你需要了解 ViewController 中几个方法的调用顺序，譬如：viewDidLoad() viewDidAppear() LoadView()等等</li>
<li>Protocol + Delegate 的用法。</li>
<li>从 StoryBoard 中加载视图控制器。也就是 <code>storyboard.instantiateViewControllerWithIdentifier()</code>。</li>
</ol>
<p><a name="Q5"></a></p>
<h2 id="Question5:_count_numbers_in_array_and_order_them_by_count_in_swift">Question5: count numbers in array and order them by count in swift</h2><h3 id="问题链接-1">问题链接</h3><p><a href="http://stackoverflow.com/questions/34614782/count-numbers-in-array-and-order-them-by-count-in-swift" target="_blank" rel="external">Q5链接地址</a></p>
<h3 id="问题描述-4">问题描述</h3><p>楼主提了一个算法问题：<br>1、已知一个数组，按照单个元素在数组中出现的次数作为重新排序的依据，个数多的排在前面<br>2、相同个数时候，元素值大的排前面</p>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>经过计算得到的结果是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-4">问题解答</h3><p>问题解答思路也比较简单，首先是要计算每个元素在数组中出现的次数，然后再做排序。<br>跟帖提供了 2 中解法，都是这样的思路。不过实现方式略有不同：</p>
<p>解法1：<br>扩展 SequenceType，因为数组的遍历是基于 SequenceType 协议的，所以自然会拥有扩展的方法 frequencies，用来计算元素在数组出现的次数。然后通过 sort 方法输出比较的结果。注意结果数组元素是元组形式。如果想变成与输入相同的结构，要做一下遍历输出。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">extension SequenceType <span class="keyword">where</span> Generator.Element : Hashable &#123;</span><br><span class="line">    func frequencies() -&gt; [Generator.Element:Int] &#123;</span><br><span class="line">        var results : [Generator.Element:Int] = [:]</span><br><span class="line">        for element in self &#123;</span><br><span class="line">            results[element] = (results[element] ?? <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        return results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alpha = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> beta = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sorted = alpha.frequencies().sort &#123;</span><br><span class="line">    if <span class="variable">$0</span>.<span class="number">1</span> &gt; <span class="variable">$1</span>.<span class="number">1</span> &#123; // if the frequency is higher, return true</span><br><span class="line">        return true</span><br><span class="line">    &#125; else if <span class="variable">$0</span>.<span class="number">1</span> == <span class="variable">$1</span>.<span class="number">1</span> &#123; // if the frequency is equal</span><br><span class="line">        return <span class="variable">$0</span>.<span class="number">0</span> &gt; <span class="variable">$1</span>.<span class="number">0</span> // return value is higher</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false // else return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解答2：<br>定义一个字典数组，专门来存储每个元素在数组出现的次数，然后用 sort 方法来输出结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counting = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill counting dictionary</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> arr1 &#123;</span><br><span class="line">    <span class="keyword">if</span> counting[num] != <span class="literal">nil</span> &#123;</span><br><span class="line">        counting[num]!++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        counting[num] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [6: 3, 2: 3, 8: 2, 1: 1]</span></span><br><span class="line"><span class="built_in">print</span>(counting)</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">order</span><span class="params">(i1: Int, i2: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> count1 = counting[i1]</span><br><span class="line">    <span class="keyword">let</span> count2 = counting[i2]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if counting is the same: compare which number is greater</span></span><br><span class="line">    <span class="keyword">if</span> count1 == count2 &#123;</span><br><span class="line">        <span class="keyword">return</span> i1 &gt; i2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count1 &gt; count2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [6, 6, 6, 2, 2, 2, 8, 8, 1]</span></span><br><span class="line"><span class="built_in">print</span>(arr1.<span class="built_in">sort</span>(order))</span><br><span class="line"><span class="built_in">print</span>(arr2)</span><br></pre></td></tr></table></figure>
<p><a name="Q6"></a></p>
<h2 id="Question6:_Cannot_invoke_[Method]_with_argument_list_of_type_(_,_)">Question6: Cannot invoke [Method] with argument list of type ( , )</h2><h3 id="问题链接-2">问题链接</h3><p><a href="http://stackoverflow.com/questions/34610440/cannot-invoke-method-with-argument-list-of-type" target="_blank" rel="external">Q6链接地址</a></p>
<h3 id="问题描述-5">问题描述</h3><p>楼主的问题是：<br>已知协议 A，B 其中协议 B 遵从 协议 A。类 Utility 定义了一个泛型方法 add，T 遵从 A 协议。<br>在另外一个 Test 类的方法 addItem 中，调用了这个 add 方法，但是传入的 data 类型是 B，但调用时候出错，见下面代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utility</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">add</span><span class="generics">&lt;T:A&gt;</span><span class="params">(t:T.<span class="keyword">Type</span>,param:T)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> util: <span class="type">Utility</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        util = <span class="type">Utility</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">addItem</span><span class="params">(data:B)</span></span>&#123;</span><br><span class="line">        <span class="comment">//util.add(B.self,param: data) //这里报错：expected an argument list of type '(T.Type, param: T)'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-5">问题解答</h3><p>楼主把 data 的类型定义为协议 B，这不是正确的用法，应该定义一个泛型类型 T，T 遵从 B 协议，见以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> util: <span class="type">Utility</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        util = <span class="type">Utility</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">addItem</span><span class="generics">&lt;T: B&gt;</span><span class="params">(data: T)</span></span> &#123;</span><br><span class="line">        util.add(<span class="type">T</span>.<span class="keyword">self</span>, param: data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Q7"></a></p>
<h2 id="Question7:_Swift_programming_style">Question7: Swift programming style</h2><h3 id="问题链接-3">问题链接</h3><p><a href="http://stackoverflow.com/questions/34607320/swift-programming-style" target="_blank" rel="external">Q7链接地址</a></p>
<h3 id="问题描述-6">问题描述</h3><p>楼主的问题是：extension 存在的意义是啥，为什么不直接写到一个定义里面，比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">yyy</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//: 可以合并成以下代码：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx1</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">yyy</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-6">问题解答</h3><p>此问题其实很容易解答，extension 存在的意义，是去扩展已有的类型，而不是新建了类型，而去用 extension 扩展新的逻辑。<br>比如，对 Int，Double 新增功能，就需要用到 extension。<br>跟帖中也建议楼主好好读读官方文档，理解一下extension存在的价值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://codebuild.me">shanks</a> &amp; <a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a></p>
<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Question on extracting a substring from a url</a></li>
<li><a href="#Q2">All func pointers need a protocol now</a></li>
<li><a href="#Q3">Property for Double and CGFloat</a></li>
<li><a href="#Q4">Question on dismissing model ViewController</a></li>
<li><a href="#Q5">count numbers in array and order them by count in swift</a></li>
<li><a href="#Q6">Cannot invoke [Method] with argument list of type ( , )</a></li>
<li><a href="#Q7">Swift programming style</a></li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20160106/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420160106.playground">点击下载</a></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/tags/Swift/"/>
    
      <category term="社区问答" scheme="http://swiftggteam.github.io/tags/%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%94/"/>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/categories/Swift/"/>
    
      <category term="iOS开发" scheme="http://swiftggteam.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聚焦 Swift #2]]></title>
    <link href="http://swiftggteam.github.io/2016/01/06/open-source-swift-weekly-2/"/>
    <id>http://swiftggteam.github.io/2016/01/06/open-source-swift-weekly-2/</id>
    <published>2016-01-06T04:30:00.000Z</published>
    <updated>2016-01-12T01:05:23.234Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/open-source-swift-weekly-2/" target="_blank" rel="external">原文链接</a>，原文日期：2015.12.17<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>本周 Swift.org 又有哪些新鲜事呢？ <strong>2015.12.17</strong></p>
</blockquote>
<p>Swift.org 社区已经度过其源码开发的第二个星期。倘若你期望过个安静的周末，最好打消这个念头。要知道项目中仍旧还有一大堆事情需要处理，压根就没有减缓的迹象。Swift 团队继续以公开的方式<a href="https://twitter.com/uint_min/status/675022507527684096" target="_blank" rel="external">运作</a>，鼓励开发者们加入到贡献的行列中。本周主要修复了一些 crashs 以及更多的 Swift 变革提案。闲话少说，开始本周简讯！</p>
<a id="more"></a>
<h3 id="社区">社区</h3><p>Craig Federighi 在 John Gruber 的<a href="http://daringfireball.net/thetalkshow/2015/12/07/ep-139" target="_blank" rel="external">脱口秀节目</a>中回顾了 Swift 的第一周开源情况。我真的非常喜欢这一期节目，继续被苹果的开源所深深折服！采访仅仅只持续了 30 分钟左右。Daring Fireball 还提供了完整的<a href="http://daringfireball.net/thetalkshow/139/federighi-gruber-transcript" target="_blank" rel="external">采访对话记录</a>。</p>
<p><a href="https://github.com/zhuowei" target="_blank" rel="external">@zhuowei</a> 看起来已经在为 <a href="https://github.com/SwiftAndroid" target="_blank" rel="external">Android</a> 提供 Swift 支持了。我真心希望这个项目能火起来。用 Swift 开发 Andriud 应用对于移动开发者来说无疑是一个巨大的胜利！</p>
<p>这里需要澄清上星期的一个纰漏 —— 柯里化函数将不会被完全移除，仅仅只是<a href="https://github.com/apple/swift-evolution/pull/43#issuecomment-163849233" target="_blank" rel="external">语法</a>而已。</p>
<h3 id="Commits_和_pull_requests">Commits 和 pull requests</h3><ul>
<li><a href="https://github.com/slavapestov" target="_blank" rel="external">Slava Pestov</a> 推送了一个 <a href="https://github.com/apple/swift/commit/c258f991f64a431da57fc79b66e879e5062fba3b" target="_blank" rel="external">commit</a> 修复了编译器中 91% 的报错。😲（pmst注：本来编译时有783个错误，现在只有74个了！）</li>
<li><a href="https://github.com/nubbel" target="_blank" rel="external">Dominique d’Argent</a> 在他自己实现的 <code>NSAffineTransform</code> 中首次介绍了 <a href="https://github.com/apple/swift-corelibs-foundation/pull/93#discussion_r47160608" target="_blank" rel="external">unicode 变量名称</a>。这也是迄今为止我所看到的唯一一个。谁要是能把使用 💩 的 pull request 合并到项目中，我非常乐意请他喝杯☕或🍺。</li>
<li><a href="https://github.com/apple/swift/pull/413" target="_blank" rel="external">Bill Abt</a> 和 <a href="https://github.com/apple/swift-corelibs-libdispatch/pull/15" target="_blank" rel="external">David Grove</a> 这两位来自 IBM 的大神为 Swift 和核心标准库（core libraries）做出了巨大的贡献！正如 Federighi 在脱口秀所说， IBM 非常乐意将 Swift 应用到服务器端。</li>
<li>Chris Lattner 修复了少量的 <a href="https://github.com/apple/swift/commit/0bfacde2420937bfb6e0e1be6567b0e90ee2fb67" target="_blank" rel="external">radars</a> 问题。</li>
<li><a href="https://github.com/dduan" target="_blank" rel="external">Daninel Duan</a> 提交了一个 <a href="https://github.com/apple/swift/pull/419" target="_blank" rel="external">pull request</a> 用于优化 <code>Set</code> 集合类型。这将提升大约 42% 的执行效率。咳！<a href="https://twitter.com/practicalswift" target="_blank" rel="external">@PracticalSwift</a> 还修正了<a href="https://github.com/apple/swift/pull/561" target="_blank" rel="external">一堆</a><a href="https://github.com/apple/swift/pull/526" target="_blank" rel="external">错别字</a>。😂</li>
<li>William Dillon 开始为 ARMv7 主机提供<a href="https://github.com/apple/swift/pull/439" target="_blank" rel="external">支持</a>，譬如 Raspberry Pi,，BeagleBone 以及 Nvidia Tegras.</li>
<li>Brian Gesiak 一如既往地从事<a href="https://github.com/apple/swift-corelibs-xctest/pull/14" target="_blank" rel="external">测试 XCTest 框架的工作</a>，他在 corelibs-xctest 项目的提交数量贡献榜中位居<a href="https://github.com/apple/swift-corelibs-xctest/graphs/contributors" target="_blank" rel="external">第三</a>。👏</li>
</ul>
<h3 id="提案">提案</h3><p>第一个独立的 Swift 语言的变革提案已经被<a href="https://twitter.com/clattner_llvm/status/676472122437271552" target="_blank" rel="external">采纳</a>啦！你必须感谢下 <a href="https://twitter.com/ericasadun" target="_blank" rel="external">Erica Sadun</a> ，是她让你告别了 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md" target="_blank" rel="external">C 语言风格的 for 循环</a>。从 Swift2.2 开始，如果使用 C 语言风格的 for-loop ，你将收到警告信息，直至 Swift3.0 正式发布版本中将被彻底移除。“在大多数情况下，我们一致认同在 Swift 代码中极少会使用 C 语言风格的 for-loop ”，大多数情况下会选择使用<code>for-in</code>语句。同时注意到<a href="https://lists.swift.org/pipermail/swift-evolution-announce/2015-December/000001.html" target="_blank" rel="external">通知</a>中描述了改变将可能导致的两个潜在问题。 </p>
<p><a href="https://github.com/ddunbar" target="_blank" rel="external">Max Howell</a>，<a href="https://github.com/ddunbar" target="_blank" rel="external">Daniel Dunbar</a>，和 <a href="https://github.com/mattt" target="_blank" rel="external">Mattt Thompson</a> 已经准备提交一份<a href="https://github.com/apple/swift-evolution/pull/51" target="_blank" rel="external">提案</a>，为 <a href="https://github.com/apple/swift-package-manager" target="_blank" rel="external">Swift 包管理器</a>（Swift package manager）增加测试支持！“测试是现代软件开发中的一个重要组成部分。紧密耦合的测试集成到 Swift 包管理器中有助于确保一个稳定可靠的打包机制。我们建议扩展我们的常规包目录布局以适应测试模块。”🎉</p>
<p>Max Moiseev 建议给 <code>AnySequence.init</code> 增添约束条件，应该会在本周审核。我想不出任何理由为什么这个建议不被采纳。“事实上，这些约束应该被应用到 <code>SequenceType</code> 协议自身上（尽管就目前来看是不太可能了），同我们预期的那样每个 <code>SequenceType</code> 实现都已经满足自身。”</p>
<p>Divid Hart <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0009-require-self-for-accessing-instance-members.md" target="_blank" rel="external">建议</a>：要求使用 <code>self</code> 来访问实例成员，目前正在审核当中。如果你现在还未遵守的话，<code>self</code> 关键字总是必须的，即使它可以进行隐式地推断。譬如， <code>self.view</code> 与简化的 <code>view</code>。 有关这个的讨论非常多，你可以前往<a href="http://www.jessesquires.com/open-source-swift-weekly-2/(https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002407.html" target="_blank" rel="external">邮件列表</a>)和 <a href="https://twitter.com/ashfurrow/status/676881928168017921" target="_blank" rel="external">twitter</a> 看看。我并不是这个建议的拥护者，但是这样有助于我理解一些参数。</p>
<p>Erica Sadun 同时发表了一篇精彩的文章细述了最近的一些提议。</p>
<h3 id="Mailing_lists">Mailing lists</h3><p>这里有个非常有意思的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001948.html" target="_blank" rel="external">话题</a>，有关动态方法与静态方法的调度。Chris Lattner 亲述：“简而言之：我真正所要表达的意思是旧的静态与动态比喻至少只是故事的一半。你真正需要的是将编译模型包含进来，从而由此产生的程序设计模式加入到故事中，要知道程序设计模式才是真正所要关心的。”</p>
<p>Fabian Ehrentraud 发起了一个<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001054.html" target="_blank" rel="external">话题</a>，讨论了当导入无 <code>nullability</code> 属性的 Objective-C 代码时如何改善崩溃安全性（crash-safety）。目前，出自 Objective-C 的成员采用隐式可选类型桥接到 Swift 上（例如 view!）。这个提议中建议在导入这些成员时用显示可选类型替换（view?），这样可以促使开发者安全地处理可能的 <code>nil</code> 值。对我来说，这听起来很不错。老实讲，我不太理解为什么一开始会有隐式解包可选（implicitly unwrapped optionals）存在，这看起来和 Swift 的安全宗旨相悖嘛。</p>
<p>Colin Cornaby <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/002324.html" target="_blank" rel="external">建议</a>将分号（;）完全从 Swift 中移除来顺应摒弃所有 C-style 语言特性的大势。正如邮件列表中有人提到，分号在语法上通常可以忽略，但是它们能将类似的语句组合到一行代码中，提高代码可读性。我觉得两者都有道理，不过目前来看这个讨论还没有引起足够的重视，短期不太可能修改。<br>送大家一句话：</p>
<blockquote>
<p>Stare long enough into the language design, and the language design stares back into you.<br>—— <a href="https://twitter.com/jckarter/status/676939142790569986" target="_blank" rel="external">Joe Groff</a></p>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/open-source-swift-weekly-2/">原文链接</a>，原文日期：2015.12.17<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>本周 Swift.org 又有哪些新鲜事呢？ <strong>2015.12.17</strong></p>
</blockquote>
<p>Swift.org 社区已经度过其源码开发的第二个星期。倘若你期望过个安静的周末，最好打消这个念头。要知道项目中仍旧还有一大堆事情需要处理，压根就没有减缓的迹象。Swift 团队继续以公开的方式<a href="https://twitter.com/uint_min/status/675022507527684096">运作</a>，鼓励开发者们加入到贡献的行列中。本周主要修复了一些 crashs 以及更多的 Swift 变革提案。闲话少说，开始本周简讯！</p>]]>
    
    </summary>
    
      <category term="Open Source Swift" scheme="http://swiftggteam.github.io/tags/Open-Source-Swift/"/>
    
      <category term="Swift 开源信息" scheme="http://swiftggteam.github.io/categories/Swift-%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聚焦 Swift #1]]></title>
    <link href="http://swiftggteam.github.io/2016/01/06/open-source-swift-weekly-1/"/>
    <id>http://swiftggteam.github.io/2016/01/06/open-source-swift-weekly-1/</id>
    <published>2016-01-06T04:20:00.000Z</published>
    <updated>2016-01-12T01:05:23.234Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/open-source-swift-weekly-1/" target="_blank" rel="external">原文链接</a>，原文日期：2015.12.10<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><a href="http://www.jessesquires.com/swift-open-source/" target="_blank" rel="external">上一篇文章</a>中我阐述了自己的想法以及时刻关注 <a href="https://swift.org/" target="_blank" rel="external">Swift open source</a> 项目的动向，看起来深得社区中许多开发者的喜欢。因此，我将竭尽所能维护该周刊——每周三更新哦，要知道 Swift 开源项目通告就在这一天发布。每周我都会提供高质量的汇总，细述本周发生的变动，更新一些有意思的统计信息，以及提供感兴趣的内容链接。如果你有任何建议，请告诉<a href="https://twitter.com/jesse_squires" target="_blank" rel="external">我</a>!。OK！是时候开始安利本周内容了！</p>
<a id="more"></a>
<h3 id="This_week_on_Swift-org">This week on Swift.org</h3><ul>
<li><a href="https://twitter.com/ManavGabhawala" target="_blank" rel="external">Manav Gabhawala</a> 提交了一个非常有趣的<a href="https://github.com/apple/swift-evolution/pull/37" target="_blank" rel="external">建议</a>：为 Swift 增加隐式构造方法（ implicit initializers）。特别指出这将解决数字类型（number types）转换时候冗长的问题。不管怎样，<a href="https://lists.swift.org/pipermail/swift-evolution/2015-December/000352.html" target="_blank" rel="external">邮件列表</a>中指出了相关安全和清晰的观点。</li>
<li><a href="https://twitter.com/1101_debian" target="_blank" rel="external">Alex Denisov</a> 提交了一个 <a href="https://github.com/apple/swift/pull/295" target="_blank" rel="external">pull request</a> 竟然修复了 323 个 crashes 。😲</li>
<li><a href="https://github.com/apple/swift-evolution/pull/39" target="_blank" rel="external">使用 git </a>火候不够？别担心！许多<a href="https://github.com/apple/swift-evolution/pull/34#issuecomment-162693826" target="_blank" rel="external">牛人</a>同样不擅长那玩样。我想指出：别因为这个而成为你为 Swift 做贡献的绊脚石！</li>
<li>昨天晚上 Chris Lattner 修复了 <a href="https://github.com/apple/swift/commit/5dded3f3523e9bd6ea45d0b6ffe5068a59d03a3f" target="_blank" rel="external">radars</a> 问题。</li>
<li>倘若你注意到这条消息，柯里化函数将<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="external">从 Swift3.0 中被移除</a>了。（什么是<a href="https://robots.thoughtbot.com/introduction-to-function-currying-in-swift" target="_blank" rel="external">柯里化</a>?）ps：下一篇文章中作者已经纠正，暂不透剧。^.^</li>
<li><a href="https://twitter.com/owensd" target="_blank" rel="external">David Owens</a> 提交了一份<a href="https://github.com/apple/swift-evolution/pull/26" target="_blank" rel="external">提案</a>为 <code>throws</code> 关键字增添类型注释。当 Swift 的错误处理模型首次调用时，缺乏明确的错误类型受到开发者普遍的批评。邮件列表中对此进行了良好的<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001117.html" target="_blank" rel="external">讨论</a>。这里给出了原始版本的 <a href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst" target="_blank" rel="external">Error Handling</a> 以及 <a href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst" target="_blank" rel="external">Rationale 和 Proposal</a> 供你参考。</li>
<li>Swift 目前已经拥有将近 200 的贡献者以及超过 230 的 pull request 被合并进来。</li>
<li>上星期我提到了 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="external">Foundation</a> 还遗留大量<a href="https://github.com/apple/swift-corelibs-foundation/search?utf8=✓&amp;q=NSUnimplemented" target="_blank" rel="external">未实现的内容</a>。同时还存在一些令人惊讶的 <a href="https://github.com/apple/swift-corelibs-foundation/pull/89/files" target="_blank" rel="external">bugs</a> 等待处理。</li>
<li><a href="https://github.com/argon" target="_blank" rel="external">Andrew Naylor</a> 雄心勃勃地实现了 <a href="https://github.com/apple/swift-corelibs-foundation/pull/54" target="_blank" rel="external">NSJSONSerialization</a>。👏</li>
<li><a href="https://twitter.com/jtbandes" target="_blank" rel="external">Jacob Bandes-Storch</a>提交了一份<a href="https://github.com/apple/swift-evolution/pull/44" target="_blank" rel="external">提案</a>致力于提高与 C API 的桥接。</li>
<li>邮件中列表中还讨论了一个很有意思的问题，默认为 class 以及 methods 标记为 <code>final</code> 。其实任何阻止或防止子类化（subclassing）对我来说都是没问题的（不妨看看作者的<a href="https://twitter.com/jesse_squires/status/664588682997964800" target="_blank" rel="external">观点</a>）。😊</li>
<li>Swift Programming Language iBook(ePub) 官方文档目前可以直接从 Swift.org 官网上下载下来（不再局限于 iBook Store），此外目前书籍是基于<a href="https://swift.org/documentation/" target="_blank" rel="external">知识共享署名4.0国际(CC by 4.0)许可证</a>下开源的！对于翻译来说这是相当棒的！ps：原因请点<a href="https://twitter.com/clattner_llvm/status/674454905449373696" target="_blank" rel="external">这里</a>。</li>
<li>对于 Chris Lattner 来说，编程不过是“夜晚和周末”的爱好罢了。😂</li>
</ul>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/open-source-swift-weekly-1/">原文链接</a>，原文日期：2015.12.10<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p><a href="http://www.jessesquires.com/swift-open-source/">上一篇文章</a>中我阐述了自己的想法以及时刻关注 <a href="https://swift.org/">Swift open source</a> 项目的动向，看起来深得社区中许多开发者的喜欢。因此，我将竭尽所能维护该周刊——每周三更新哦，要知道 Swift 开源项目通告就在这一天发布。每周我都会提供高质量的汇总，细述本周发生的变动，更新一些有意思的统计信息，以及提供感兴趣的内容链接。如果你有任何建议，请告诉<a href="https://twitter.com/jesse_squires">我</a>!。OK！是时候开始安利本周内容了！</p>]]>
    
    </summary>
    
      <category term="Open Source Swift" scheme="http://swiftggteam.github.io/tags/Open-Source-Swift/"/>
    
      <category term="Swift 开源信息" scheme="http://swiftggteam.github.io/categories/Swift-%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聚焦 Swift #3]]></title>
    <link href="http://swiftggteam.github.io/2016/01/06/open-source-swift-weekly-3/"/>
    <id>http://swiftggteam.github.io/2016/01/06/open-source-swift-weekly-3/</id>
    <published>2016-01-06T04:20:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/open-source-swift-weekly-3/" target="_blank" rel="external">原文链接</a>，原文日期：2015.12.24<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p>正如预期的一样，在圣诞放假期间 Swift.org 的<a href="https://lists.swift.org/pipermail/swift-corelibs-dev/Week-of-Mon-20151214/000179.html" target="_blank" rel="external">步伐</a><a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151221/000540.html" target="_blank" rel="external">慢了下来</a>。我也在放假期间出去玩耍了一番，所以这篇文章会比较平常的来得短。如果你还没准备好，我强烈建议你从代码中抽身出去享受一下假期，<a href="https://twitter.com/chriseidhof/status/679213894343200768" target="_blank" rel="external">防止过劳</a>（译者注：然而我们并没有放假）。😄现在，让我们开始本周简讯！</p>
<a id="more"></a>
<h2 id="Commits_以及_Pull_requests">Commits 以及 Pull requests</h2><p><a href="https://github.com/tienex" target="_blank" rel="external">@tienex</a> 针对 Linux/armv7 支持提交了一个<a href="https://github.com/apple/swift/pull/608" target="_blank" rel="external">pull request</a>。</p>
<p><a href="https://github.com/practicalswift" target="_blank" rel="external">@practicalswift</a> 增加了大量的 <a href="https://github.com/apple/swift/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+author%3Apracticalswift+is%3Aclosed+test+case" target="_blank" rel="external">测试用例</a>。在写本篇文章的时候，这些改变应该还需要一段时间才会被合并。</p>
<p><a href="https://github.com/masters3d" target="_blank" rel="external">@masters3d</a> 合并了一个 <a href="https://github.com/apple/swift-evolution/pull/72/files" target="_blank" rel="external">pull request</a>，这个 PR 将一些对于 Swift 的常见改变文档化了。这是一个很棒的主意，可以减少重复的建议。在为邮件列表提交建议时，记得要先<a href="https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md" target="_blank" rel="external">核对这个列表</a> 。</p>
<p>Doug Gregor <a href="https://github.com/apple/swift/commit/c8dd8d066132683aa32c2a5740b291d057937367" target="_blank" rel="external">实现了 SE-0001</a>，“允许（基本上）所有的关键字作为参数标签”。这是一个很大的改变。当 Swift 首次发布的时候，我的一个 Objective-C 库使用了 <code>extension:</code> 作为一个<a href="https://github.com/jessesquires/JSQSystemSoundPlayer/issues/8" target="_blank" rel="external">参数名称</a>(作为一个文件的扩展名)并且桥接到了 Swift 当中，这导致了很多的问题，所以我只能将它重命名为 <code>fileExtension:</code>。我十分期待在 Swift 2.2 当中看到这个改变！注意 <code>var</code>，<code>let</code> 和 <code>inout</code> 关键字被排除在外。</p>
<h2 id="建议">建议</h2><p>Oisin Kidney 的<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0008-lazy-flatmap-for-optionals.md" target="_blank" rel="external">建议 (SE-0008)</a>，<em>为可选类型序列增加一个 Lazy flatMap</em>，已经被 Swift 2.2 <a href="https://lists.swift.org/pipermail/swift-evolution-announce/2015-December/000006.html" target="_blank" rel="external">接受</a>！🎉</p>
<p>Kevin Ballard 的<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md" target="_blank" rel="external">建议 (SE-0015)</a>，Tuple 比较运算符已经<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004423.html" target="_blank" rel="external">被接受</a>！在写作本篇文章的时候，这个建议的状态还未返回在 GitHub 上。因为这个建议不会影响到现在代码，我猜它应该会加入到 Swift 2.2 当中。🎉</p>
<p>Joe Groff 提交了<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151214/003148.html" target="_blank" rel="external">一个建议</a>，为 Swift 的属性增加属性行为。你可以在 GitHub 上找到<a href="https://gist.github.com/jckarter/f3d392cf183c6b2b2ac3" target="_blank" rel="external">原型</a>。如果你更喜欢在 twitter 中获取这些信息，<a href="https://twitter.com/jckarter/status/677554831003791360" target="_blank" rel="external">它在这里</a>。😄 简单来讲，这个建议提出了一个大纲，可以使用一个扩展的框架为属性增加不同的属性行为，类似 Objective-C 当中的 <code>atomic</code> 与 <code>copy</code>。目前，Swift 有些硬编码的针对特定用途的属性行为，比如 <code>lazy</code>，<code>@NSCopying</code>，和 <code>willSet</code> / <code>didSet</code>。这个建议主要目的是将这些概念规范和统一起来，使它们跟底层的框架实现方式一致，以使它们可以更方便地进行扩展。开发者甚至可以实现它们自己的属性行为。这听起来实在很酷。一些示例的属性行为包含：lazy, 记忆化(memoization), 延迟初始化(delayed initialization)。</p>
<h2 id="邮件列表">邮件列表</h2><p>Andyy Hope 开启了<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/003819.html" target="_blank" rel="external">一个讨论</a>，建议为枚举增加一个 <code>.allValues</code> 属性，通过这个属性可以将枚举中的所有 case 以数组的方式返回。看起来到目前为止有很多人支持这个观点。<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001233.html" target="_blank" rel="external">Jacob Bandes-Storch</a> 在几周之前也提出过这个想法。我也是这个想法的拥簇者，在之前我就好几次试图写过几次这样的代码了。👍 </p>
<p>Kevin Ballard <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151221/004223.html" target="_blank" rel="external">建议</a> 为“一周Swift”建立一个更正式的 newsletter. 😁 也许我应该创建一个 swiftweekly.org?</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/open-source-swift-weekly-3/">原文链接</a>，原文日期：2015.12.24<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p>正如预期的一样，在圣诞放假期间 Swift.org 的<a href="https://lists.swift.org/pipermail/swift-corelibs-dev/Week-of-Mon-20151214/000179.html">步伐</a><a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151221/000540.html">慢了下来</a>。我也在放假期间出去玩耍了一番，所以这篇文章会比较平常的来得短。如果你还没准备好，我强烈建议你从代码中抽身出去享受一下假期，<a href="https://twitter.com/chriseidhof/status/679213894343200768">防止过劳</a>（译者注：然而我们并没有放假）。😄现在，让我们开始本周简讯！</p>]]>
    
    </summary>
    
      <category term="Open Source Swift" scheme="http://swiftggteam.github.io/tags/Open-Source-Swift/"/>
    
      <category term="Swift 开源信息" scheme="http://swiftggteam.github.io/categories/Swift-%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 Target-Action 中使用响应链]]></title>
    <link href="http://swiftggteam.github.io/2016/01/06/utilize-the-responder-chain-for-target-action/"/>
    <id>http://swiftggteam.github.io/2016/01/06/utilize-the-responder-chain-for-target-action/</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/utilize-the-responder-chain-for-target-action/" target="_blank" rel="external">原文链接</a>，原文日期：2016/1/1<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="http://www.brighttj.com" target="_blank" rel="external">saitjr</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>本文会介绍 iOS 的响应链以及如何在 Target-Action 中使用它。</p>
<h2 id="响应链（The_Responder_Chain）">响应链（The Responder Chain）</h2><p>在 iOS 中，事件（比如，触摸事件（touch event））都使用响应链来传递。响应链由响应者对象（Responder Objects，<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1" target="_blank" rel="external">苹果官方术语</a>）构成。如果你看过官方文档，可能会注意到 <code>UIView</code> 和 <code>UIViewController</code> 都是响应者对象。这就意味着， <code>UIView</code> 和 <code>UIViewController</code> 都继承自 <code>UIResponder</code> ，如下图：</p>
<p><img src="/img/articles/utilize-the-responder-chain-for-target-action/UIViewDocumentation.png1452047417.154566" alt=""></p>
<a id="more"></a>
<p>当用户点击了视图层级（view hierarchy）中的一个 view 时，iOS 会通过点击测试（hit test）来判定哪个响应者对象优先响应触摸事件。这个过程从最底层的 window 开始，沿着视图层级向上寻找并检查这个 touch 是不是发生在当前 view 边界内。该过程中被点击的最后一个 view 会先收到触摸事件。如果该 view 没有对触摸事件做出反应，触摸事件就会沿着响应链传递到下一个响应者。苹果的官方<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4" target="_blank" rel="external">示例</a>很好的解释了这个过程。如果 view 告诉 iOS 它没有被点击，那它的子视图就不会被检查。</p>
<p>这就会产生一个有趣的事情。当一个正常显示（父视图的 <code>clipsToBounds</code> 被设置为 <code>false</code> 时）的按钮位于父视图边界外时，该按钮不会接收到任何的触摸事件。因此，当一个按钮不能响应事件时，记得检查一下该按钮是否有在父视图的边界内。</p>
<h2 id="Target-Action">Target-Action</h2><p>Target-Action 机制通过设置 <code>target</code> 为 <code>nil</code>来使用响应链。事件触发时，iOS 会询问第一响应者是否要处理传递过来的 action。如果不处理的话，第一响应者就会把该 action 传递给下一个响应者（<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIResponder_Class/index.html#//apple_ref/occ/instm/UIResponder/nextResponder" target="_blank" rel="external">苹果官方文档 <code>nextResponder</code> </a>）。</p>
<h2 id="举个例子">举个例子</h2><p>让我们来举个例子吧。我们的 view controller 中有一个 view ，里面有一个 button 和一个 label 。我们可以在 <code>viewDidLoad</code> 中把 view controller 设置为 <code>target</code> 来相应按钮的点击事件，像这样 <code>subview.button.addTarget(self, action: &quot;onButtonTap:&quot;, forControlEvents: .TouchUpInside)</code> 。但是，我们也可以把 <code>target</code> 设置为 <code>nil</code>，然后就可以使用响应链了。以下是初始化并添加 button 和 label 的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewWithButtonAndLabel</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> button: <span class="type">UIButton</span></span><br><span class="line">    <span class="keyword">let</span> label: <span class="type">UILabel</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        label = <span class="type">UILabel</span>()</span><br><span class="line">        label.textAlignment = .<span class="type">Center</span></span><br><span class="line">        label.text = <span class="string">"Touch the button"</span></span><br><span class="line"></span><br><span class="line">        button = <span class="type">UIButton</span>(type: .<span class="type">System</span>)</span><br><span class="line">        button.setTitle(<span class="string">"The Button"</span>, forState: .<span class="type">Normal</span>)</span><br><span class="line">        button.addTarget(<span class="literal">nil</span>, action: <span class="string">"onButtonTap:"</span>, forControlEvents: .<span class="type">TouchUpInside</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> stackView = <span class="type">UIStackView</span>(arrangedSubviews: [label, button])</span><br><span class="line">        stackView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        stackView.axis = .<span class="type">Vertical</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line"></span><br><span class="line">        backgroundColor = .yellowColor()</span><br><span class="line"></span><br><span class="line">        addSubview(stackView)</span><br><span class="line"></span><br><span class="line">        stackView.centerXAnchor.constraintEqualToAnchor(centerXAnchor).active = <span class="literal">true</span></span><br><span class="line">        stackView.centerYAnchor.constraintEqualToAnchor(centerYAnchor).active = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init(coder:) has not been implemented"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>button.addTarget(nil, action: &quot;onButtonTap:&quot;, forControlEvents: .TouchUpInside)</code> 这行代码中，将按钮的 <code>target</code> 设置为 <code>nil</code> 。如之前描述的那样，这就意味着 action 会沿着响应链向下传递，直到一个响应者对象处理该 action 为止。</p>
<p>以下是 view controller 的部分代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> viewWithButtonAndLabel = <span class="type">ViewWithButtonAndLabel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        view.backgroundColor = .whiteColor()</span><br><span class="line"></span><br><span class="line">        view.addSubview(viewWithButtonAndLabel)</span><br><span class="line"></span><br><span class="line">        viewWithButtonAndLabel.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> views = [<span class="string">"subView"</span>: viewWithButtonAndLabel]</span><br><span class="line">        <span class="keyword">var</span> layoutConstraints = [<span class="type">NSLayoutConstraint</span>]()</span><br><span class="line">        layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"|-20-[subView]-20-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">        layoutConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:|-20-[subView]-20-|"</span>, options: [], metrics: <span class="literal">nil</span>, views: views)</span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activateConstraints(layoutConstraints)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">onButtonTap</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">        viewWithButtonAndLabel.label.text = viewWithButtonAndLabel.label.text == <span class="string">"Yeah!"</span> ? <span class="string">"Touch the button"</span> : <span class="string">"Yeah!"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使我们没有明确的设置 <code>target</code> ，当点击按钮的时候，view controller 里的 <code>onButtonTap(_:)</code> 也会被调用，因为它是第一响应者，且实现了相应的处理。</p>
<p>你可以去 GitHub 上查看本文的<a href="https://github.com/dasdom/ResponderChainDemo" target="_blank" rel="external">示例代码</a>。</p>
<h2 id="结论">结论</h2><p>响应链是你的好朋友，试着去了解它。还要多读文档，学习如何使用响应链，让你的代码更牛。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/utilize-the-responder-chain-for-target-action/">原文链接</a>，原文日期：2016/1/1<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="http://www.brighttj.com">saitjr</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>本文会介绍 iOS 的响应链以及如何在 Target-Action 中使用它。</p>
<h2 id="响应链（The_Responder_Chain）">响应链（The Responder Chain）</h2><p>在 iOS 中，事件（比如，触摸事件（touch event））都使用响应链来传递。响应链由响应者对象（Responder Objects，<a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW1">苹果官方术语</a>）构成。如果你看过官方文档，可能会注意到 <code>UIView</code> 和 <code>UIViewController</code> 都是响应者对象。这就意味着， <code>UIView</code> 和 <code>UIViewController</code> 都继承自 <code>UIResponder</code> ，如下图：</p>
<p><img src="/img/articles/utilize-the-responder-chain-for-target-action/UIViewDocumentation.png1452047417.154566" alt=""></p>]]>
    
    </summary>
    
      <category term="Swift and Painless" scheme="http://swiftggteam.github.io/tags/Swift-and-Painless/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 unwind segue 而不是 delegate 模式传递回调数据]]></title>
    <link href="http://swiftggteam.github.io/2016/01/05/ios-passing-data-back-using-unwind-segue-instead-of-delegate-pattern/"/>
    <id>http://swiftggteam.github.io/2016/01/05/ios-passing-data-back-using-unwind-segue-instead-of-delegate-pattern/</id>
    <published>2016-01-04T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-passing-data-back-using-unwind-segue-instead-of-delegate-pattern/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-6<br>译者：<a href="http://www.dianqk.org/" target="_blank" rel="external">靛青K</a>；校对：<a href="undefined">Channe</a>；定稿：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>这是一个不使用 delegate 模式传递回调数据的好方法。</p>
</blockquote>
<p>我今天注意到这个小技巧，值得和你分享一下。</p>
<a id="more"></a>
<p>通常当我们创建一个视图控制器作为 picker 时，它会从屏幕的底部出现，覆盖在当前页面上，并且仅只占屏幕的一部分。当选择一个值后，就通过 delegate 模式返回回来。代码大概就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">AnimalPickerViewControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">prepareForSegue</span><span class="params">(segue: UIStoryboardSegue, sender: AnyObject?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> segue.identifier == <span class="string">"ShowAnimalPicker"</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickerVC = segue.destinationViewController <span class="keyword">as</span>! <span class="type">AnimalPickerViewController</span></span><br><span class="line">            pickerVC.delegate = <span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">animalPicker</span><span class="params">(picker: AnimalPickerViewController, didSelectAnimal animal: String)</span></span> &#123;</span><br><span class="line">        label.text = animal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AnimalPickerViewControllerDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">animalPicker</span><span class="params">(picker: AnimalPickerViewController, didSelectAnimal animal: String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalPickerViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">AnimalPickerViewControllerDelegate</span>?</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">dogButtonPressed</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        selectAnimal(<span class="string">"Dog"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">catButtonPressed</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        selectAnimal(<span class="string">"Cat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">snakeButtonPressed</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        selectAnimal(<span class="string">"Snake"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">selectAnimal</span><span class="params">(animal: String)</span></span> &#123;</span><br><span class="line">        delegate?.animalPicker(<span class="keyword">self</span>, didSelectAnimal: animal)</span><br><span class="line">        dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是就像你看到的，我使用了 segue 去弹出这个 picker 视图控制器，但我使用了 delegate 模式获取返回的数据值。</p>
<p>今天我认识到在这种情况下，使用 unwind segue 更合适。我没有必要使用 delegate 模式。并且代码是这个样子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> label: <span class="type">UILabel</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">performUnwindSegue</span><span class="params">(segue: UIStoryboardSegue)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> segue.identifier == <span class="type">AnimalPickerViewController</span>.<span class="type">UnwindSegue</span> &#123;</span><br><span class="line">            label.text = (segue.sourceViewController <span class="keyword">as</span>! <span class="type">AnimalPickerViewController</span>).selectedAnimal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalPickerViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">UnwindSegue</span> = <span class="string">"UnwindAnimalPicker"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> selectedAnimal: <span class="type">String</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">dogButtonPressed</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        selectAnimal(<span class="string">"Dog"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">catButtonPressed</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        selectAnimal(<span class="string">"Cat"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">snakeButtonPressed</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        selectAnimal(<span class="string">"Snake"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">selectAnimal</span><span class="params">(animal: String)</span></span> &#123;</span><br><span class="line">        selectedAnimal = animal</span><br><span class="line">        performSegueWithIdentifier(<span class="type">AnimalPickerViewController</span>.<span class="type">UnwindSegue</span>, sender: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是不是更好一些？对于我来说，在这种特别的情况时，的确更好。希望对你有一些帮助！</p>
<p>（译者注：关于 Unwind Segue 的使用，需要注意的几点。我们最好先将下面的代码写上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">performUnwindSegue</span><span class="params">(segue: UIStoryboardSegue)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> segue.identifier == <span class="type">AnimalPickerViewController</span>.<span class="type">UnwindSegue</span> &#123;</span><br><span class="line">        label.text = (segue.sourceViewController <span class="keyword">as</span>! <span class="type">AnimalPickerViewController</span>).selectedAnimal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们再从 button 等控件拉向 exit 时才会有效果。至于 identifier 是设置在刚刚拉向 exit 的 segue（unwind segue）。我补写了本文的 <a href="http://github.com/DianQK/StudyUnwindSegue" target="_blank" rel="external">demo</a>，如果你还有什么困惑可以直接看这个 demo。）</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-passing-data-back-using-unwind-segue-instead-of-delegate-pattern/">原文链接</a>，原文日期：2015-12-6<br>译者：<a href="http://www.dianqk.org/">靛青K</a>；校对：<a href="undefined">Channe</a>；定稿：<a href="https://github.com/Cee">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>这是一个不使用 delegate 模式传递回调数据的好方法。</p>
</blockquote>
<p>我今天注意到这个小技巧，值得和你分享一下。</p>]]>
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="http://swiftggteam.github.io/tags/Tomasz-Szulc/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Alert Controller 中实现可编辑文本字输入框教程]]></title>
    <link href="http://swiftggteam.github.io/2016/01/04/editable-text-field-alert-controller-tutorial/"/>
    <id>http://swiftggteam.github.io/2016/01/04/editable-text-field-alert-controller-tutorial/</id>
    <published>2016-01-03T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="http://www.ioscreator.com/tutorials/editable-text-field-alert-controller-tutorial" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-21<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>UIAlertController 类不仅用于呈现警告弹窗，还能够提供 Text Fields 来获取文本信息输入。本教程演示了从用户处获取账号和密码，并打印到终端中。此教程开发环境为 Xcode 7.2 以及 iOS 9。</p>
<p>打开X code，创建一个 Single View Application。输入项目名称：<strong>IOS9TextFieldAlertControllerTutorial</strong>，接着填写你独有的 Organization Name 以及 Organization Identifier。选择语言为 Swift 并确保设备为 iPhone 。<br><a id="more"></a></p>
<p><img src="/img/articles/editable-text-field-alert-controller-tutorial/format=1500w1451868017.9978042" alt=""></p>
<p>前往 Storyboard。从 Object Library（译者注：快捷键 Command + Option + Control + 3） 中拖拽一个按钮（UIButton）到主视图中。双击按钮设置 title 名为 「Log in」。此刻保持按钮为选中状态，按下 Ctrl 键，使用鼠标左键拖拽一条线到主视图上方，弹出黑色信息框，使用 Shift 键选中「Vertical Spacing to Top Layout Guide」和「Center Horizontally in Container」两个选项。</p>
<p><img src="/img/articles/editable-text-field-alert-controller-tutorial/1451868018.5434368" alt=""></p>
<p>Storyboard 应该是这个样子的。</p>
<p><img src="/img/articles/editable-text-field-alert-controller-tutorial/format=1500w1451868018.9260972" alt=""></p>
<p>（译者注：也许你的界面呈现了黄色约束警告，你需要使用 Command + Option + = 快捷键来更新下。）</p>
<p>选中 Assistant Editor ，确保 <strong>ViewControllers.swift</strong> 可见。选中按钮使用 Ctrl + 左键拖拽方式创建如下 Action。</p>
<p><img src="/img/articles/editable-text-field-alert-controller-tutorial/format=750w1451868019.366837" alt=""></p>
<p>在 <strong>ViewController</strong> 类中实现 <strong>login</strong> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">login</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">var</span> usernameTextField: <span class="type">UITextField</span>?</span><br><span class="line">    <span class="keyword">var</span> passwordTextField: <span class="type">UITextField</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.  </span></span><br><span class="line">    <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(</span><br><span class="line">      title: <span class="string">"Log in"</span>,</span><br><span class="line">      message: <span class="string">"Please enter your credentials"</span>,</span><br><span class="line">      preferredStyle: <span class="type">UIAlertControllerStyle</span>.<span class="type">Alert</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.  </span></span><br><span class="line">    <span class="keyword">let</span> loginAction = <span class="type">UIAlertAction</span>(</span><br><span class="line">      title: <span class="string">"Log in"</span>, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>) &#123;</span><br><span class="line">        (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> username = usernameTextField?.text &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">" Username = <span class="subst">\(username)</span>"</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No Username entered"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> password = passwordTextField?.text &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Password = <span class="subst">\(password)</span>"</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No password entered"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.</span></span><br><span class="line">    alertController.addTextFieldWithConfigurationHandler &#123;</span><br><span class="line">      (txtUsername) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        usernameTextField = txtUsername</span><br><span class="line">        usernameTextField!.placeholder = <span class="string">"&lt;Your username here&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    alertController.addTextFieldWithConfigurationHandler &#123;</span><br><span class="line">      (txtPassword) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        passwordTextField = txtPassword</span><br><span class="line">        passwordTextField!.secureTextEntry = <span class="literal">true</span></span><br><span class="line">        passwordTextField!.placeholder = <span class="string">"&lt;Your password here&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.</span></span><br><span class="line">    alertController.addAction(loginAction)</span><br><span class="line">    <span class="keyword">self</span>.presentViewController(alertController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建两个可选类型的 UITextField 变量用于警告弹窗。</li>
<li>创建一个 Alert 样式的 AlertController。</li>
<li>创建一个 Alert Action，闭包体中执行如下行为：将 textField 输入的信息打印到终端中。</li>
<li>addTextFieldWithConfigurationHandler 方法用于添加文本输入框（text input fields），闭包接收 Text Filed 作为参数变量。</li>
<li>将登录动作添加到 AlertController 中，同时呈现该控制器。</li>
</ol>
<p><strong>构建并运行</strong>该工程，点击 Login 按钮，填充 AlertController 中的 username 和 password 字段。输入内容随之打印到终端中。</p>
<p><img src="/img/articles/editable-text-field-alert-controller-tutorial/format=1500w1451868019.8416817" alt=""></p>
<p>你可以前往 ioscreator 的 GitHub 仓库下载 <a href="https://github.com/ioscreator/ioscreator" target="_blank" rel="external">IOS9TextFieldAlertControllerTutorial</a> 源代码。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Arthur Knopper，<a href="http://www.ioscreator.com/tutorials/editable-text-field-alert-controller-tutorial">原文链接</a>，原文日期：2015-12-21<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>UIAlertController 类不仅用于呈现警告弹窗，还能够提供 Text Fields 来获取文本信息输入。本教程演示了从用户处获取账号和密码，并打印到终端中。此教程开发环境为 Xcode 7.2 以及 iOS 9。</p>
<p>打开X code，创建一个 Single View Application。输入项目名称：<strong>IOS9TextFieldAlertControllerTutorial</strong>，接着填写你独有的 Organization Name 以及 Organization Identifier。选择语言为 Swift 并确保设备为 iPhone 。<br>]]>
    
    </summary>
    
      <category term="IOSCREATOR" scheme="http://swiftggteam.github.io/tags/IOSCREATOR/"/>
    
      <category term="iOS开发" scheme="http://swiftggteam.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在团队开发中使用 CocoaPods 的小技巧]]></title>
    <link href="http://swiftggteam.github.io/2015/12/31/cocoapods-on-a-team/"/>
    <id>http://swiftggteam.github.io/2015/12/31/cocoapods-on-a-team/</id>
    <published>2015-12-30T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/cocoapods-on-a-team/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-18<br>译者：<a href="http://ijack.pw/" target="_blank" rel="external">JackAlan</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在我工作的一个团队中，我们有很多关于安装 CocoaPods 的问题。团队成员拥有不同的 <code>cocoapods gem</code> 的安装版本，并且当有人运行 <code>pod install</code> 时，会将事情搞得一团糟。</p>
<p>我们最终不得不委托一人安装 CocoaPods，并且把工程推到 GitHub 上以供我们使用。这显然是不够灵活的，并且对于我们团队或者是委托人来说都不是一个很满意的解决方式。</p>
<a id="more"></a>
<p>我跟 <a href="https://twitter.com/NeoNacho" target="_blank" rel="external">@NeoNacho</a> 提到了这个问题，他是 CocoaPods 的核心贡献者，并且他提供了我们急需的那个解决方案。使用 <code>Gemfile</code>！</p>
<p>你可以在 <code>Gemfile</code> 中指定 <code>cocoapods gem</code> 的使用版本。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'https://rubygems.org'</span></span><br><span class="line"></span><br><span class="line">gem <span class="string">'cocoapods'</span>, <span class="string">'0.39.0'</span></span><br></pre></td></tr></table></figure>
<p>（译者注：在大天朝还是换成 <code>source &#39;https://ruby.taobao.org&#39;</code> 这个吧。）</p>
<p>当你更新了 Gemfile 文件并且自动安装了正确版本的 gem 后，确保团队的每个成员都运行一次 <code>bundle install</code> 这条命令。</p>
<p>此后，只需要运行 <code>bundle exec pod install</code> 这条命令来安装新的 CocoaPods——这将会确保通过你在的 Gemfile 中指定 <code>cocoapods gem</code> 的版本后，<code>pods</code> 仍可以被正确的安装。</p>
<p>感谢 <a href="https://twitter.com/NeoNacho" target="_blank" rel="external">@NeoNacho</a> 提供的小技巧。</p>
<p><strong>更新</strong>：获取更多如何在项目中使用 <code>Gemfile</code> 的信息，请参阅 <a href="https://guides.cocoapods.org/using/a-gemfile.html" target="_blank" rel="external">Cocoapods Guide on Using a Gemfile</a>。感谢 <a href="https://twitter.com/orta/status/677972879988932608" target="_blank" rel="external">@orta</a>！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/cocoapods-on-a-team/">原文链接</a>，原文日期：2015-12-18<br>译者：<a href="http://ijack.pw/">JackAlan</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>在我工作的一个团队中，我们有很多关于安装 CocoaPods 的问题。团队成员拥有不同的 <code>cocoapods gem</code> 的安装版本，并且当有人运行 <code>pod install</code> 时，会将事情搞得一团糟。</p>
<p>我们最终不得不委托一人安装 CocoaPods，并且把工程推到 GitHub 上以供我们使用。这显然是不够灵活的，并且对于我们团队或者是委托人来说都不是一个很满意的解决方式。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="iOS开发" scheme="http://swiftggteam.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[每周 Swift 社区问答 2015-12-30]]></title>
    <link href="http://swiftggteam.github.io/2015/12/30/swift-qa-2015-12-30/"/>
    <id>http://swiftggteam.github.io/2015/12/30/swift-qa-2015-12-30/</id>
    <published>2015-12-29T16:00:00.000Z</published>
    <updated>2015-12-30T13:25:13.618Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Swift regular expressions</a></li>
<li><a href="#Q2">Storing a reference to array in swift</a></li>
<li><a href="#Q3">What’s the difference between [String!] and [String]!</a></li>
<li><a href="#Q4">How can I filter dictionary [[String:String]]</a></li>
<li><a href="#Q5">Why ‘self.self’ compiles and run in swift?</a></li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20151230/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420151230.playground" target="_blank" rel="external">点击下载</a></p>
<a id="more"></a>
<p><a name="Q1"></a></p>
<h2 id="Question1:_Swift_regular_expressions">Question1: Swift regular expressions</h2><p><a href="http://stackoverflow.com/questions/34459701/swift-regular-expressions" target="_blank" rel="external">Q1链接地址</a></p>
<h3 id="问题描述">问题描述</h3><p>楼主直接就问：如何在 swift 中使用<code>[a-zA-Z]+@[a-zA-Z]+.[a-zA-Z]</code>这样的正则表达式?</p>
<h3 id="问题解答">问题解答</h3><p>目前在 Swift 中使用正则表达式，还是直接调用 oc 里面的 NSRegularExpression 来完成的。<br>喵神有一个 tips 专门介绍了这个知识点：<br><a href="http://swifter.tips/regex/" target="_blank" rel="external">http://swifter.tips/regex/</a></p>
<p>下面是跟帖的代码，解决了问题：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">test</span> = <span class="string">"someone@somewhere.com"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    let regex = try NSRegularExpression(pattern: <span class="string">"[a-zA-z]+@[a-zA-Z]+.[a-zA-Z]"</span>, options: [])</span><br><span class="line">    <span class="keyword">if</span> regex.firstMatchInString(<span class="keyword">test</span>, options: [], <span class="keyword">range</span>: NSMakeRange(0, <span class="keyword">test</span>.characters.<span class="keyword">count</span>)) != nil &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"matched"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"not matched"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch let <span class="keyword">error</span> <span class="keyword">as</span> NSError &#123;</span><br><span class="line">    <span class="keyword">print</span>(<span class="keyword">error</span>.localizedDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Q2"></a></p>
<h2 id="Question2:_Storing_a_reference_to_array_in_swift">Question2: Storing a reference to array in swift</h2><p><a href="http://stackoverflow.com/questions/34486043/storing-a-reference-to-array-in-swift" target="_blank" rel="external">Q2链接地址</a></p>
<h3 id="问题描述-1">问题描述</h3><p>Swift 类中定义的方法，传入参数默认是值拷贝，也就是说，即使方法内部改变参数值，传入的参数原始值是不会改变的。</p>
<p>楼主纠结如何实现引用拷贝，也就是，赋值给类中的属性以后，改变了属性的值，传入的参数也会跟着改变，见代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo : <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(foo: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.foo = foo</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">modify</span><span class="params">()</span></span> &#123;</span><br><span class="line">        foo.append(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> bar = <span class="type">Foo</span>(foo: a)</span><br><span class="line">bar.modify()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">// My goal is that it will print 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
<h3 id="问题解答-1">问题解答</h3><p>实际上，使用inout，也不能解决问题，inout 只是应用在方法内部直接改变传入值的时候有用，而上例中，是先赋值给了类的一个属性，改变了属性的值，而没有改变传入参数值。因为 Array<int> 是值类型，赋值默认为值拷贝：</int></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo : <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(foo: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;) &#123;</span><br><span class="line">        <span class="keyword">self</span>.foo = foo</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">modify</span><span class="params">()</span></span> &#123;</span><br><span class="line">        foo.append(<span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar1 = <span class="type">Foo1</span>(foo: a)</span><br><span class="line">bar.modify()</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">// 还是没有改变 a</span></span><br></pre></td></tr></table></figure>
<p>以下代码是跟帖中提供的解决方案，使用 UnsafeMutablePointer<int>，也就是 c 语言中的 int * 指针来达成指向内存的一致。从而在修改时候，能够保持一致。但是强烈不推荐此种做法，因为 Swift 强调的类型安全丢失了。</int></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo : [<span class="type">Int</span>]</span><br><span class="line">    <span class="keyword">var</span> pInner: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(foo: [<span class="type">Int</span>]) &#123;</span><br><span class="line">        pInner = <span class="type">UnsafeMutablePointer</span>(foo)</span><br><span class="line">        <span class="keyword">self</span>.foo = <span class="type">Array</span>(<span class="type">UnsafeBufferPointer</span>(start: pInner, <span class="built_in">count</span>: foo.<span class="built_in">count</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(<span class="keyword">inout</span> pOuter: UnsafeMutablePointer&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">        foo.append(<span class="number">5</span>) <span class="comment">// &lt;-- foo gets new memory adress</span></span><br><span class="line">        pInner = <span class="type">UnsafeMutablePointer</span>(foo)</span><br><span class="line">        pOuter = pInner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pOuter: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt; = <span class="type">UnsafeMutablePointer</span>(a)</span><br><span class="line"><span class="keyword">var</span> bar2 = <span class="type">Foo2</span>(foo: a) <span class="comment">// 'bar.foo' now at same address as 'a'</span></span><br><span class="line"><span class="built_in">print</span>(bar2.foo) <span class="comment">// [1,2,3,4]</span></span><br><span class="line">bar2.modify(&amp;pOuter) <span class="comment">// -&gt; [1,2,3,4,5]</span></span><br><span class="line">a = <span class="type">Array</span>(<span class="type">UnsafeBufferPointer</span>(start: pOuter, <span class="built_in">count</span>: bar.foo.<span class="built_in">count</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Same pointer adress, OK! */</span></span><br><span class="line"><span class="built_in">print</span>(bar2.pInner)</span><br><span class="line"><span class="built_in">print</span>(pOuter)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Naturally same value (same address in memory) */</span></span><br><span class="line"><span class="built_in">print</span>(bar.foo)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>此问题其实在实际编码中，应该尽量避免，一个类，去改变外部的值，违背了类的封装性。</p>
<p><a name="Q3"></a></p>
<h2 id="Question3:_What’s_the_difference_between_[String!]_and_[String]!">Question3: What’s the difference between [String!] and [String]!</h2><p><a href="http://stackoverflow.com/questions/34485421/whats-the-difference-between-string-and-string-swift" target="_blank" rel="external">Q3链接地址</a></p>
<h3 id="问题描述-2">问题描述</h3><p>楼主是新手，新手最多的几个问题之一就是对 Optional 的理解。楼主的问题是：<br>[String!] and [String]! 的区别是什么？</p>
<h3 id="问题解答-2">问题解答</h3><ul>
<li><p>[String!] 是一个包含隐式解包 Optional String 的数组，数组的值可以为 nil。</p>
</li>
<li><p>[String]! 是一个隐式解包 Optional 的数组，数组类型是 String，可以直接对这个数组赋值为nil，但是因为数组元素类型是 String，所以数组元素不能为nil</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list0: [<span class="built_in">String</span>!] = [<span class="string">"Hello"</span>, nil, <span class="string">"world"</span>, nil]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list1: [<span class="built_in">String</span>]! = nil</span><br><span class="line"><span class="keyword">let</span> list2: [<span class="built_in">String</span>]! = [<span class="string">"Hello"</span>, <span class="string">"world"</span>]</span><br></pre></td></tr></table></figure>
<p><a name="Q4"></a></p>
<h2 id="Question4:_How_can_I_filter_dictionary_[[String:String]]">Question4: How can I filter dictionary [[String:String]]</h2><h3 id="问题链接">问题链接</h3><p><a href="http://stackoverflow.com/questions/34483418/how-can-i-filter-dictionary-stringstring" target="_blank" rel="external">Q4链接地址</a></p>
<h3 id="问题描述-3">问题描述</h3><p>楼主有一个二维数组，想通过数组中的 type 字段，进行过滤。于是他写出了如下报错的代码：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">var data = [[<span class="string">"type"</span>:<span class="string">"Sport"</span>, <span class="string">"model"</span>:<span class="string">"R6"</span>],[<span class="string">"type"</span>:<span class="string">"Enduro"</span>, <span class="string">"model"</span>:<span class="string">"Tenerre"</span>],[<span class="string">"type"</span>:<span class="string">"Chopper"</span>, <span class="string">"model"</span>:<span class="string">"Intruder"</span>]]</span><br><span class="line">//data.filter(&#123; (<span class="keyword">type</span>: <span class="built_in">String</span>) -&gt; <span class="built_in">Bool</span> <span class="keyword">in</span></span><br><span class="line">//    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">//&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-3">问题解答</h3><p>数组 filter 方法的定义：</p>
<p>filter(includeElement: (T) -&gt; Bool) -&gt; T[]</p>
<p>在这个例子中，数组是二维的，所以 T = [String:String]，也是一个数组。所以正确答案应该是：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filteredData = data.filter &#123; (dict:[<span class="built_in">String</span>:<span class="built_in">String</span>]) -&gt; <span class="built_in">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> dict[<span class="string">"type"</span>] == <span class="string">"Sport"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Q5"></a></p>
<h2 id="Question5:_Why_‘self-self’_compiles_and_run_in_swift?">Question5: Why ‘self.self’ compiles and run in swift?</h2><h3 id="问题链接-1">问题链接</h3><p><a href="http://stackoverflow.com/questions/34499890/why-self-self-compiles-and-run-in-swift" target="_blank" rel="external">Q5链接地址</a></p>
<h3 id="问题描述-4">问题描述</h3><p>楼主的问题是：为什么 self.self 这样的写法在其他语言会报错，而 Swift 中，不会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someProperty = <span class="string">""</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">self</span>.<span class="keyword">self</span>.someProperty)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-4">问题解答</h3><p>实际上，无论支持还是不支持这种语法，一个 self，应该就足够了。<br>跟帖也在质疑这种用法的实用性在那？例如如下的形式，这样写与只带一个 self，没什么区别：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"Hello"</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span><span class="built_in">.</span><span class="built_in">self</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">"Hello"</span><span class="built_in">.</span><span class="built_in">self</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://codebuild.me">shanks</a></p>
<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Swift regular expressions</a></li>
<li><a href="#Q2">Storing a reference to array in swift</a></li>
<li><a href="#Q3">What’s the difference between [String!] and [String]!</a></li>
<li><a href="#Q4">How can I filter dictionary [[String:String]]</a></li>
<li><a href="#Q5">Why ‘self.self’ compiles and run in swift?</a></li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20151230/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420151230.playground">点击下载</a></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/tags/Swift/"/>
    
      <category term="社区问答" scheme="http://swiftggteam.github.io/tags/%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%94/"/>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/categories/Swift/"/>
    
      <category term="iOS开发" scheme="http://swiftggteam.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[教你如何在 Auto Layout 下设置两个视图之间的最小间距]]></title>
    <link href="http://swiftggteam.github.io/2015/12/30/minimal-distance-to-two-views-in-auto-layout/"/>
    <id>http://swiftggteam.github.io/2015/12/30/minimal-distance-to-two-views-in-auto-layout/</id>
    <published>2015-12-29T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/minimal-distance-to-two-views-in-auto-layout/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-08<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="http://www.jianshu.com/users/ef1058d2d851" target="_blank" rel="external">星夜暮晨</a>；定稿：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<p>假设现在要在某个视图（view）中放置三个子视图（subviews）。其中两个子视图放置在上方，第三个视图紧挨着它们放到下方。不过上方的两个视图高度不定，并且你不知道哪个更高一些。现在要求我们使用自动布局（Auto Layout）来控制下方视图和上方视图之间间距至少 10 单位像素。</p>
<a id="more"></a>
<p>我们该如何实现呢？实现技巧是使用不等式约束条件 (inequality) 以及设置约束优先级 (priority)。相关约束如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意约束使用不等式 &gt;=，以及设置优先级</span></span><br><span class="line">leftViewConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:[red(50)]-(&gt;=10)-[green]"</span>, options: [], metrics: <span class="literal">nil</span>, views: leftViews)</span><br><span class="line">leftViewConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:[blue(100)]-(&gt;=10)-[green]"</span>, options: [], metrics: <span class="literal">nil</span>, views: leftViews)</span><br><span class="line">leftViewConstraints += <span class="type">NSLayoutConstraint</span>.constraintsWithVisualFormat(<span class="string">"V:[blue(100)]-(&lt;=10@999)-[green]"</span>, options: [], metrics: <span class="literal">nil</span>, views: leftViews)</span><br></pre></td></tr></table></figure>
<p>上方两个视图与底部视图的最小间距不能小于 10（译者注：这里约束优先级默认是 1000）。此外蓝色视图与底部视图的最大间距不得大于 10 ，其优先级为 999。</p>
<p>就是这样！你可以看到如下方截图所示的结果。左侧图片中，蓝色视图的高度为 100 单位像素，红色视图高度为 50 单位像素。 右侧图片则刚刚相反。</p>
<p><img src="/img/articles/minimal-distance-to-two-views-in-auto-layout/Screen-Shot-2015-12-08-at-21.52.25-300x155.png1451437944.9187686" alt=""></p>
<p>这里向你提供完整代码的 <a href="http://swift.eltanin.uberspace.de/wp-content/uploads/2015/12/MinimalDistanceAutoLayoutPlayground.playground.zip" target="_blank" rel="external">playground</a> 下载。</p>
<blockquote>
<p>译者注：你可以在下载的 playground 下方键入 view 属性，然后在右侧栏点击 Quick Look，也就是那个眼睛，就能看到如上所示的截图了！</p>
</blockquote>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/minimal-distance-to-two-views-in-auto-layout/">原文链接</a>，原文日期：2015-12-08<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="http://www.jianshu.com/users/ef1058d2d851">星夜暮晨</a>；定稿：<a href="https://github.com/Cee">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<p>假设现在要在某个视图（view）中放置三个子视图（subviews）。其中两个子视图放置在上方，第三个视图紧挨着它们放到下方。不过上方的两个视图高度不定，并且你不知道哪个更高一些。现在要求我们使用自动布局（Auto Layout）来控制下方视图和上方视图之间间距至少 10 单位像素。</p>]]>
    
    </summary>
    
      <category term="Swift and Painless" scheme="http://swiftggteam.github.io/tags/Swift-and-Painless/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聚焦 Swift #0]]></title>
    <link href="http://swiftggteam.github.io/2015/12/29/swift-open-source/"/>
    <id>http://swiftggteam.github.io/2015/12/29/swift-open-source/</id>
    <published>2015-12-28T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/swift-open-source/" target="_blank" rel="external">原文链接</a>，原文日期：2015/12/06<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
<p>译者注：这个系列的关注重点是 Swift 开源项目本身的发展，作者会截取每周发生的大事（比如合并了一个大改动）并进行分析，还会写一些有趣的小发现，很有意思。我们已经拿到翻译授权，会每周进行更新，欢迎关注。</p>
</blockquote>
<p>革命起源：<strong>2015.12.06</strong></p>
<p>Apple 宣告 “<a href="https://developer.apple.com/swift/blog/?id=34" target="_blank" rel="external">Swift即将开源</a>” 的随后几天里，项目的活跃度让人瞠目结舌。回想今年早些时候的 <a href="https://developer.apple.com/wwdc/" target="_blank" rel="external">WWDC</a> 大会上 Apple 提及 Swift 不久会被开源，我可不认为任何人会像这样期待该发布版本。</p>
<p><img src="/img/articles/swift-open-source/swift-logo.png1451394012.0965536" alt=""></p>
<a id="more"></a>
<h3 id="Expectations（期望）">Expectations（期望）</h3><p>没人真正知道接下来会发生什么。譬如 Swift 项目将会被投放到 <a href="http://www.opensource.apple.com/" target="_blank" rel="external">opensource.apple.com</a> 上，变得和其他开源项目一样毫无新意？还是说它会像 <a href="https://github.com/ResearchKit" target="_blank" rel="external">ResearchKit</a> 一样放置到 GitHub 上？最终，Swift 不仅发布到 <a href="https://github.com/apple/" target="_blank" rel="external">GitHub</a> 上，而且 Swift 团队将会以一种彻底透明化的方式工作。Apple 为该发布版所做的工作是令人瞩目的。我们不但可以获得所有的源代码，同时还能浏览每个项目<a href="https://github.com/apple/swift/commits/master" target="_blank" rel="external">完整的提交历史</a>，提供非常详细的视图展示 Swift 团队的开发流程，以及 Swift 的<a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">演变史</a>。 任何你想要获悉的东西都可以在 <a href="http://swift.org/" target="_blank" rel="external">Swift.org</a>上找到。</p>
<h3 id="Swift_in_the_open">Swift in the open</h3><p>过去的几天里我浏览了 <a href="https://github.com/apple/" target="_blank" rel="external">GitHub</a> 的源码仓以及 Swift 的<a href="https://swift.org/community/#mailing-lists" target="_blank" rel="external">邮件列表</a>。真是太有意思了！很好奇 Swift 开发在之后的发展中会变成什么样子？下面分享到目前为止我觉得很有意思的一些东西。</p>
<ul>
<li>Chris Lattner 于 2010.7.17 提交了首个 <a href="https://github.com/apple/swift/commit/18844bc65229786b96b89a9fc7739c0fc897905e" target="_blank" rel="external">commit</a>。</li>
<li>Swift 源代码发布到 GitHub 上的短短24小时里，<a href="https://github.com/apple/swift" target="_blank" rel="external">Swift repo</a> 星星数以超过 10,000 之多。到目前为止已经拥有 19,000 星星数 和超过 2,000次 fork。在写这篇文章时候，它依旧占据 GitHub 热门榜单第一位。（pmst注：翻译时 <strong>24,724</strong> stars，<strong>3043</strong> fork，遗憾的是不在热门榜单中。）</li>
<li>所有 repos 的 pull requests 加起来超过 400 之多。许多都已经被接收并合并了。</li>
<li><a href="https://developer.apple.com/videos/play/wwdc2014-402/" target="_blank" rel="external">WWDC 2014</a> 宣告发布 Swift 语言之后，我想 Swift 团队在 twitter 上的活跃度是有目共睹的：一边答疑解惑；一边是 <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">Chris Lattner</a>，<a href="https://twitter.com/jckarter" target="_blank" rel="external">Joe Groff</a> 以及 <a href="https://twitter.com/UINT_MIN" target="_blank" rel="external">Jordan Rose</a> 大神时不时地举例说明。正是因为这些推文加速了 bug 的修复！😄</li>
<li>还记得 <a href="https://www.apple.com/pr/library/2014/07/15Apple-and-IBM-Forge-Global-Partnership-to-Transform-Enterprise-Mobility.html" target="_blank" rel="external">Apple 和 IBM</a> 的<a href="http://www.apple.com/business/mobile-enterprise-apps/" target="_blank" rel="external">合作关系</a>吗？因此 IBM 对服务器端 Swift 开发的<a href="https://developer.ibm.com/swift/2015/12/03/introducing-the-ibm-swift-sandbox/" target="_blank" rel="external">投入</a>也就没什么令人吃惊的。就目前来看，Swift 应用到服务器端的趋势尤为明显。</li>
<li>Chris Lattner 于星期六下午10点合并了 <a href="https://github.com/apple/swift/pull/166" target="_blank" rel="external">pull requests</a>。😆</li>
<li>我们已经确切获悉了 Swift3.0 即将做出的改变。没有啥让人惊喜的东东拉。</li>
<li>Swift3.0 中 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md" target="_blank" rel="external">++ 和 – 运算符将被移除</a>。感谢 <a href="https://twitter.com/ericasadun" target="_blank" rel="external">Erica Sadun</a>，以及 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md" target="_blank" rel="external">C 风格的 for 循环</a>。她同一天中提交了2个建议！👏</li>
<li>Chris lattner <a href="https://github.com/apple/swift/commit/22c3aa0588d2df1a207dcbad85946bab7976894c" target="_blank" rel="external">提交</a>了“Pull some ancient history off an internal wiki page for possible historical interest.” 什么？是的，没错！奇客们注意了。</li>
<li>自从2014年9月开始 <a href="https://twitter.com/practicalswift" target="_blank" rel="external">@practicalswift</a> 这个专门收集 <a href="https://github.com/practicalswift/swift-compiler-crashes" target="_blank" rel="external">swift 编译崩溃信息的系列</a>已经作为<a href="https://github.com/apple/swift/commit/e5ca8be1a090335d401cd1d7dfcf9b2104674d5b" target="_blank" rel="external">仓库内容</a>的一部分了。</li>
<li>使用 <code>associated</code> 类型声明取代 <code>typealias</code> 声明方式看起来是一个不错的<a href="https://github.com/apple/swift-evolution/pull/33/files" target="_blank" rel="external">机会</a>。</li>
<li><a href="https://twitter.com/jtbandes" target="_blank" rel="external">Jacob Bandes-Storch</a> 提交了两个 <a href="https://github.com/apple/swift/pull/272" target="_blank" rel="external">pull request</a> 修复了将近 400 个 crash 。😲</li>
<li>Swift 团队似乎很热衷于让社区参与进来。无所谓贡献大小！</li>
<li><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="external">swift-corelibs-foundation</a> 框架大部分都还<a href="https://github.com/apple/swift-corelibs-foundation/search?utf8=✓&amp;q=NSUnimplemented" target="_blank" rel="external">未实现</a>。看起来还有很多低挂的“果实”能让你来采摘。我很好奇这是否是 Apple 故意而为之，鼓励开发者参与贡献，还是说真的是因为时间紧迫导致的？</li>
<li>自2010起的<a href="https://github.com/apple/swift/commit/afc81c1855bf711315b8e5de02db138d3d487eeb" target="_blank" rel="external">initial checkin</a> 实际上是版本4，从内部 SVN 仓库中导入的。“Swift SVN r4”。 你将注意到下面头文件中的注释说到：“该源文件是 Swift.org 开源项目中的一部分。Copyright(c)2014-2015 Apple Inc.” 我的看法有三点：<br>  1 在将项目发布到 GitHub 之前，提交历史已经被重新编辑以及整理过了。<br>  2 2010年时，Swift 团队指定的截止日期就是“2014-2015”，无关其他。这本就是 Apple 的一贯做法，反正 Swift 跌跌撞撞地已经到来。<br>  3 Chris Lattner 是个“巫师”。</li>
</ul>
<p>我想我们已经有了一个良好的开端。社区实在强大且狂热，仅仅<strong>三天</strong>,Swift 就有了极大地改进。正如 Lattner 所说，革命是属于 Swift 的！</p>
<p>以上就是我所获知的所有东西了。如果你喜欢该文章，<a href="https://twitter.com/jesse_squires" target="_blank" rel="external">请让我知道</a>。或许我会坚持下去，分享我的发现。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/swift-open-source/">原文链接</a>，原文日期：2015/12/06<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
<p>译者注：这个系列的关注重点是 Swift 开源项目本身的发展，作者会截取每周发生的大事（比如合并了一个大改动）并进行分析，还会写一些有趣的小发现，很有意思。我们已经拿到翻译授权，会每周进行更新，欢迎关注。</p>
</blockquote>
<p>革命起源：<strong>2015.12.06</strong></p>
<p>Apple 宣告 “<a href="https://developer.apple.com/swift/blog/?id=34">Swift即将开源</a>” 的随后几天里，项目的活跃度让人瞠目结舌。回想今年早些时候的 <a href="https://developer.apple.com/wwdc/">WWDC</a> 大会上 Apple 提及 Swift 不久会被开源，我可不认为任何人会像这样期待该发布版本。</p>
<p><img src="/img/articles/swift-open-source/swift-logo.png1451394012.0965536" alt=""></p>]]>
    
    </summary>
    
      <category term="Open Source Swift" scheme="http://swiftggteam.github.io/tags/Open-Source-Swift/"/>
    
      <category term="Swift 开源信息" scheme="http://swiftggteam.github.io/categories/Swift-%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 Swift、Foursquare API 及 Realm 构建一款 Coffee Shop 应用]]></title>
    <link href="http://swiftggteam.github.io/2015/12/29/foursquare-realm-swift/"/>
    <id>http://swiftggteam.github.io/2015/12/29/foursquare-realm-swift/</id>
    <published>2015-12-28T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：reinder de vries，<a href="http://www.appcoda.com/foursquare-realm-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/23<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="http://www.brighttj.com" target="_blank" rel="external">saitjr</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>我们经常说，程序员喝进去的是咖啡，吐出来的是代码。让我们换一个角度去思考，来做一个显示附近咖啡店的 App。</p>
<p>这篇文章中，用到了以下技能：</p>
<ul>
<li>Swift，Xcode 和 Interface Builder（Auto Layout, Constraints 和 Storyboards）</li>
<li>Realm，一种本地存储方案，轻量级的 Core Data</li>
<li>使用 Foursquare 和 Das Quadrat 库访问 REST API</li>
<li>CocoaPods 和 Geolocation</li>
</ul>
<p>这个 App 可以检测当前用户的 500 平方米的范围，并从 Foursquare 拿到附近咖啡店的地理信息。我们将使用 map view（<code>MKMapView</code>）和一个 table view（<code>UITableView</code>）来展示数据。当然，还要使用 Realm 来过滤数据，并使用闭包来对数据进行排序。</p>
<a id="more"></a>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/foursquare-api.jpg" alt=""></p>
<p>你可以从 GitHub <a href="https://github.com/reinderdevries/CoffeeGuide" target="_blank" rel="external">reinderdevries/CoffeeGuide</a> 上下载所有源代码和 Xcode 项目。</p>
<p>让我们开始码代码吧！</p>
<h2 id="设置_Xcode">设置 Xcode</h2><p>第一步，创建工程。打开 Xcode，选择 File -&gt; New -&gt; Project…</p>
<p>在分类中，选择 iOS -&gt; Application -&gt; Single View Application，然后填写一下信息：</p>
<ul>
<li>Product Name：Coffee</li>
<li>Organisation Name：随便写一个</li>
<li>Organisation Identifier：也随便写一个，使用的格式如：com.mycompanyname</li>
<li>Language：Swift（当然是 Swift 了）</li>
<li>Devices：iPhone</li>
<li>取消 Core Data，勾选 Unit Tests 和 UI Tests</li>
</ul>
<p>选择工程的存储路径，不用勾选 create a local Git repository。</p>
<p>接着创建 Podfile。在项目名称上（工程目录选项卡）点击右键，选择 New File … 如下图所示，选择 iOS -&gt; Other -&gt; Empty。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_2.png" alt=""></p>
<p>文件命名为 Podfile（不要文件扩展名）并<strong>确保</strong>它和 .xcodeproj 文件在同一级目录下！还要勾选 Target 栏里的 Coffee 选框。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_3.png" alt=""></p>
<p>然后复制下面的代码到 Podfile里：（译者注：以下是原文的代码，但是有个地方错了：<code>useframeworks!</code> 要改为 <code>use_frameworks!</code> ）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line">useframeworks!</span><br><span class="line"></span><br><span class="line">pod <span class="string">'QuadratTouch'</span>, <span class="string">'&gt;= 1.0'</span></span><br><span class="line">pod <span class="string">'RealmSwift'</span></span><br></pre></td></tr></table></figure>
<p>项目集成了两个第三方类库：Realm 和 Das Quadrat（一个  Foursquare REST API 的 Swift 库）。</p>
<p>然后，退出工程并关闭 Xcode（最好完全关闭）。打开 OS X 终端，cd 到你的工程目录下。详细步骤如下：</p>
<ol>
<li>打开终端</li>
<li>键入<code>cd</code>（c-d-空格）</li>
<li>打开文件夹</li>
<li>定位到你工程目录的那个文件夹，但是不要点进去</li>
<li>把文件夹拖到终端里</li>
<li>这样，工程的绝对路径会显示在 <code>cd</code>的后面</li>
<li>回车</li>
<li>这样，就进入正确的工程目录了</li>
</ol>
<p>现在，在终端里输入：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>稍等一会，会出现几行信息，这表示 Cocoapods 已按照之前设置的要求把需要的第三方库装进 Xcode 了，同时，我们的工程已经变成 workspace （编辑模式）了。</p>
<p>这步完成后，找到新生成的 .xcworkspace 文件并将其打开。以后都用它打开工程。</p>
<p>注意：如果打开 workspace 以后发现工程目录里面是空的，那就重新用 .xcodeproj 文件打开工程。然后关闭它，也关闭 workspace，然后再重新用 .xcworkspace 打开工程。这样应该就没什么问题了。</p>
<p>好了，这就是 Xcode 所需的全部设置。如果每个步骤都设置正确，那么现在工程目录中会有两个 Project。Pods 的 project 中包含 Realm 和 Das Quadrat 的库文件。</p>
<h2 id="在_Storyboards_中构建_UI_元素">在 Storyboards 中构建 UI 元素</h2><p>这个 App 的 UI 极其简单，一共就两个 UI 控件：map view 和 table view 。</p>
<p>Xcode 已经为你完成了大部分工作， Single View Application 模板包含了一个 <code>Main.storyboard</code>，它是程序入口。</p>
<p>接下来，配置 map view ，步骤如下：</p>
<ol>
<li>打开 <code>Main.storyboard</code> </li>
<li>在 Xcode 右下部分的 Object Library 里，找到 Map Kit View （<code>MKMapKitView</code>）</li>
<li>把它拖到 View Controller 里面，左上角顶格，宽度和 View Controller 一样，高度是 View Controller 的一半。（译者注：其实是 View Controller 的 View ，大家能理解就好）</li>
<li>接着，再从 Object Library 里找到 Table View （<code>UITableView</code>），并把它拖到 View Controller 里面，宽度与 View Controller 一样，高度填满屏幕的剩余部分。</li>
</ol>
<p>然后，给两个 View 设置右边距约束。首先，选中 map view ，点击 Pin 按钮（编辑区右下角的倒数第二个按钮，看起来像星球大战里面的战机…（译者注：感觉作者也被自己的比喻无语到了…））</p>
<p>点击以后，会有一个弹出框，操作步骤如下：</p>
<ol>
<li>取消 Constrain to margins 的选中状态</li>
<li>选中左、上、右的线，选中后会变成红色的高亮状态</li>
<li>每条线旁边都有一个输入框，确保输入框中的值都是 0</li>
<li>最后，点击 Add 3 constraints 按钮</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_5.png" alt=""></p>
<p>接着，也给 table view 添加约束。步骤和之前一样，但是 table view 添加的是 左、下、右三个约束。同样需要注意 Constrain to margins 是未选中状态，然后点击 Add 3 constraints 按钮。</p>
<p>现在已经给两个 View 添加了以下这些约束：各自上下边距的约束，宽度和父容器相同。还差最后一个步骤，需要确保两个 View 的高度各占父容器的一半。</p>
<p>你可以通过给约束设置一个倍数来达到效果，但是以下是一个更简单的方法：</p>
<ol>
<li>同时选中 table view 和 map view（按住 Command 键并选中两者）</li>
<li>点击 Pin 按钮</li>
<li>选中 Equal Heights 选框</li>
<li>点击 Add 1 constraint 按钮</li>
</ol>
<p>OK，这个时候 Xcode 可能会有报错，别担心，照下面的步骤来解决：</p>
<ol>
<li>选中 map view，点击 Pin 按钮</li>
<li>取消 Constrain to margins，选中下边距约束，并在输入框中键入0</li>
<li>点击 Add 1 constraint</li>
</ol>
<p>现在，红色的线（报错）消失了，但是有可能会出现黄色的线（警告）。意思是说，展示的 frame 可能和添加的约束不一致。其实这个时候所有的约束都加了，只是 Interface Builder 没有正确显示更新而已。</p>
<p>解决方式：在 Document Outline 中，点击有小箭头的黄色按钮。</p>
<p>点击黄色的小箭头以后，会跳到一个新的界面。然后，在新的界面中点击黄色的三角形 -&gt; Update frames -&gt; Fix misplacement 。如果还有黄色三角，重复上一个步骤。有可能，更新后的 frame 不是你想要的，所以添加约束的时候就一定要注意，一定要添加对。（译者注：作者这里解决警告的方式太麻烦了，其实可以在 Document Outline 中选中 View ，点击 Pin 按钮右边的 Resolve Auto Layout Issues 按钮，然后选择下面的那个 Update frames 就行了）。</p>
<p>在添加约束的过程中很容易出错，最简单的解决方式是，在 Document Outline 中删除所有约束，重新来一遍。（译者注：同样，选中要删除约束的 View ，点击 Resolve Auto Layout Issues ，点击 Clear Constraints 就行。植入硬广一则：@saitjr 的<a href="http://www.saitjr.com/ios/ios-autolayout-demo.html" target="_blank" rel="external">Autolayout 案例讲解</a>）</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_7.png" alt=""></p>
<h2 id="构建_App_并解决错误">构建 App 并解决错误</h2><p>在开发过程中，应该时不时跑一下程序，这样可以及时发现错误并解决。</p>
<p>在有了一定的开发经验以后，写一点代码就运行程序的现象会越来越少。但如果你是新手，那就尽量将开发步骤细分，每改动一点，就跑起来看看效果。这样就可以将代码错误定位到最小范围。</p>
<p>运行程序有两个快捷键：Command + B 或者 Command + R。前者是编译，后者是编译并运行。在 Xcode 的左上角可以选择 iPhone 型号和版本。这里也可以选择使用真机测试，那需要加入苹果开发者计划。</p>
<p>刚好我们的程序有个错误，来看一下怎么解决。运行程序，先找到控制台（在 Xcode 底部窗口的右栏）。如图：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_8.png" alt=""></p>
<p>如果没找到底栏，可以在 Xcode 右上角打开底栏，然后点击底栏右边的按钮，打开右栏。（译者注：一图胜千言，如上图）</p>
<p>然后控制台上可以看到如下错误：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span><span class="symbol">:</span><span class="number">37</span><span class="symbol">:</span><span class="number">56.353</span> <span class="constant">Coffee</span>[<span class="number">85299</span><span class="symbol">:</span><span class="number">6341066</span>] *** <span class="constant">Terminating</span> app due to uncaught exception <span class="string">'NSInvalidUnarchiveOperationException'</span>, <span class="symbol">reason:</span> <span class="string">'Could not instantiate class named MKMapView'</span></span><br><span class="line">    *** <span class="constant">First</span> throw call <span class="symbol">stack:</span></span><br><span class="line">    (</span><br><span class="line">        <span class="number">0</span>   <span class="constant">CoreFoundation</span>                      <span class="number">0x0000000109fdff65</span> exceptionPreprocess + <span class="number">165</span></span><br></pre></td></tr></table></figure>
<p>苦逼的是，控制台显示的错误信息太复杂，而且，有些时候甚至连错误信息都没有显示。大多数运行时错误由以下三种组成：异常信息、崩溃原因和堆栈信息。</p>
<p>以上三个信息可以帮助你定位错误。举个例子，你可以通过异常信息找到抛出异常的代码段。堆栈信息显示的是报错前程序调用的类与方法。这个过程一般被称为回溯，可追溯到报错的代码。</p>
<p>现在来看看错误信息，其实很好理解：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="constant">Could</span> <span class="keyword">not</span> instantiate <span class="class"><span class="keyword">class</span> <span class="title">named</span> <span class="title">MKMapView</span></span></span><br></pre></td></tr></table></figure>
<p>咦，<code>MKMapView</code> 看起来很眼熟吧。对，刚刚才在 Interface Builder 里面见过，拖到界面上半部分的那个 View 就是。报错中出现的 “instantiate” 是实例化的意思，这是一个术语。错误含义是：编译器（Xcode 中，把代码转成二进制目标文件的工具）不能创建一个 <code>MKMapView</code> 给你。简单点理解就是：创建 map view 失败了。</p>
<p>其实，99%的错误信息都不告诉你怎么去解决问题，它们只是告诉你这里出错，却连错误原因都没写。</p>
<p>你能做的就两点：</p>
<ol>
<li>甩手不做了，剧终；</li>
<li>去 Google （度娘就算了，对英文支持太差）</li>
</ol>
<p>把错误信息复制下来，去 Google 吧，搜索结果一般是这样的：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/google-search.png" alt=""></p>
<p>点击第一个链接就行，这是个 Stack Overflow 的链接（一个专为程序员设计的问答网站）。这网站上的问题几乎涵盖了所有的编程语言，而且都解决得相当完美。</p>
<p>在 StackOverFlow 上解求问题的答案，你应该按照以下步骤：</p>
<ol>
<li>查看问题是否有答案，如果没有，就到 Google 里继续找。如果有些问题还没有答案，你也可以去回答。</li>
<li>回到我们的问题上来，撇开标题不看，答案通常隐藏在下面的评论当中。</li>
<li>找到被采纳的回答（回答下面有绿色的对勾），然后看看下面的评论（评论通常比回答有效）。左边的数字，是这个回答收到的赞。有时候被采用的回答不是最好的，所以也要留意评论和其他回答。</li>
<li>找到解决方案以后，不要盲目的照着做，要知其所以然。初学时，这可能会耗费大量时间，但是这些都是知识储备，以后肯定能派上用场。几乎每个程序员都有他们的知识缺口，这会削弱他们的技能。假如你能做到既知道错误出现原因，又能有效避免，那么你就是世上前 1% 的程序员了。</li>
</ol>
<p>那这个问题的原因到底是什么呢？其实是 <code>MapKit.framework</code> 没有导入到工程里面。看框架名字就知道， <code>MKMapView</code> 是被包含在这个外部框架里的。即使我们还没有直接显式的去调用 map view ，但也必须要导入框架到我们的工程里。</p>
<p>如果你通读了 StackOverflow 的解决方案，你会发现报错这种错的原因有很多。</p>
<p>根据以下步骤来解决我们的问题：</p>
<ol>
<li>在 Xcode 左导航栏上点击项目配置（左栏顶部蓝色的那一栏）</li>
<li>选择 Build Phases 选项卡</li>
<li>点击 Link Binary With Libraries ，展开列表</li>
<li>点击下面的 +- 按钮，会出来一个弹出框（这里选 + ）</li>
<li>搜索 mapkit </li>
<li>最后，双击 <code>MapKit.framework</code></li>
</ol>
<p>这样就把一个库导入到了工程中。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_10.png" alt=""></p>
<h2 id="处理地理位置">处理地理位置</h2><p>现在的工程没有报错了，接下来来看看下一个需求：地理位置。我们需要将用户的位置标记在 map view 上。</p>
<p>首先，需要将 Storyboard 中的 map view 和代码关联。在创建工程的时候，Xcode 就自动生成了 <code>ViewController.swift</code> 文件。这也是 Storyboard 中的 view controller 所关联的文件。</p>
<p>下面来做一个小测试，看看文件是否成功关联：</p>
<ol>
<li>打开 <code>ViewController.swift</code> 文件，看到 <code>class</code> 开头的那一行。这是在类的定义。包含的信息有：类名、父类、遵循的协议。在这个类中，类名是 <code>ViewController</code>。</li>
<li>打开 <code>Main.storyboard</code> 文件，在 Document Outline 中，找到顶上的一栏，这里应该标注的是 <code>View Controller Scene</code>。</li>
<li>在右上角点击 Identity Inpector （左起第三个按钮）</li>
<li>检查 Class 那一栏写得什么</li>
</ol>
<p>这样，就完成了 <code>ViewController</code> 与 Storyboard 的关联检查，如果你今后在 Storyboard 中创建了其他 view controller ，也可以在 Storyboard 中设置类名来进行关联。</p>
<h2 id="建立_Map_View_Outlet">建立 Map View Outlet</h2><p>现在，你已经知道 Storyboard 和代码是有关联的了，让我们为 Map View 添加 Outlet 吧。在你用自己的代码扩展 Map View 之前，需要将 Map View 的实例连接起来。</p>
<p>打开 <code>ViewController.swift</code> ，在第一个 <code>{</code> 下面添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> mapView:<span class="type">MKMapView</span>?</span><br></pre></td></tr></table></figure>
<p>这行代码含义如下：</p>
<ul>
<li>在 Swift 中，使用变量前需要先定义。在变量定义的同时，也可以进行初始化。在上面的代码中，并没有进行初始化，默认是 <code>nil</code> （空）。</li>
<li>上面代码给 <code>ViewController</code> 类的对象声明了一个实例属性，并且该属性在该类的每个实例对象中，都是唯一的。与实例属性相对的是类属性，类属性在每个实例对象中都是相同的。</li>
<li>属性名称为 <code>mapView</code> ，类型为 <code>MKMapView</code> 。<code>MKMapView</code> 是 <code>MapKit</code> 框架里的一个类。</li>
<li><code>@IBOutlet</code> 告诉 Xcode 这个属性将会作为 outlet 。outlet 会与 Storyboard (或 xib) 中的 UI 元素相关联。</li>
<li><code>var</code> 表示这个属性是可变的，与之相对的是 <code>let</code> ，表示常量，不可变。（译者注：可参照 <code>NSMutableArray</code> 与 <code>NSArray</code>）</li>
<li>关于 <code>?</code> 标识，是表明变量是个可选类型。这是 Swift 的一大特点，表示对象可以是 <code>nil</code> （空），与之相对的是 non-nil 。 可选类型提高了程序的安全性和可读性，之后也会用到很多可选类型。</li>
<li>为什么这行代码要放在这（class 的大括号内的顶部）呢？这表示变量的作用域是当前类。还有一种作用域是方法作用域，即在方法中定义的变量，只在当前方法中可用，当然，如果是全局作用域（全局变量），那就是在全局都可用了。</li>
</ul>
<p>是不是觉得变量、属性有点搞不清楚？变量就是用来存储数据的；而属性，它其实也是一个变量，但是他属于一个类。同时，属性分为两种：实例属性和类属性。</p>
<p>是不是觉得类、实例、类型有点搞不清楚？类就是具有同种属性的对象，它可以创建该对象的很多副本。类创建后的一个个副本就是实例。这里所说的“类型”其实是有歧义的，你可以想象成和“类”差不多的东西。</p>
<p>是不是觉得定义（声明）、初始化、实例有点搞不清楚？OK，首先，定义（声明）：即告诉编译器，要用的变量的名称与类型。初始化：给变量一个初始值。初始值可以写在声明之后，如果没有赋值，那默认为 <code>nil</code> 。实例：表示这个变量是一个实例（类的“副本”）。严格意义上来讲，应该解释为该变量是一个实例化对象。</p>
<p>好了，现在回到项目中来。这时，Xcode 应该会在当前行报错，错误信息是：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="constant">Use</span> of undeclared type <span class="constant">MKMapView</span></span><br></pre></td></tr></table></figure>
<p>这是因为 <code>MapKit</code> 还没有导入到当前文件。因此，在类定义的上面，引入 <code>UIKit</code> 代码的下面，添加这句话：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MapKit</span><br></pre></td></tr></table></figure>
<p>现在，来关联一下 outlet：</p>
<ol>
<li>打开 <code>Main.Storyboard</code> 。</li>
<li>显示 Document Outline，点击 View Controller Scene 。</li>
<li>打开左边栏的 Connections Inspector 。</li>
<li>在列表中找到 <code>mapView</code> 属性。（译者注：如果没找到，也可以通过 Show the Assistant editor 直接在代码中关联）</li>
<li>然后，把这个属性右边的小圆点拖拽到编辑器上的 map view 中。</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_11.png" alt=""></p>
<h2 id="添加第一个方法">添加第一个方法</h2><p>OK，现在来做下 map view 的相关实现。在 <code>ViewController</code> 类中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mapView = <span class="keyword">self</span>.mapView</span><br><span class="line">    &#123;</span><br><span class="line">        mapView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你是不是在问添加到哪里？你想放哪放哪，只要在类的大括号结束前就行，就是这么任性。</p>
<p>所有方法都必须在类作用域之内。类作用域即类定义之后的 <code>{</code> 到与之匹配的 <code>}</code> 之间。</p>
<p>你可以说这是平衡之美，每个 <code>{</code> 都有与之对应的 <code>}</code> 。同时，程序员也会使用缩进来突出作用域层级。一般来说，使用的是 1 个 tab 或 4 个空格来进行缩进。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_12.png" alt=""></p>
<p>下面来解释下刚才写的方法：</p>
<ul>
<li>方法，是类中的一块代码整体。这些代码相对独立，并实现某些特定的功能。方法能在当前类中调用，也可以在当前工程的其他地方被调用。</li>
<li>这个方法叫 <code>viewWillAppear</code>，带一个参数。这个参数是一个变量，在方法被调用的时候会传进来的。参数作用域在整个方法范围内。在父类调用的 <code>viewWillAppear</code> 方法中，参数名为 <code>animated</code> ，类型为 <code>Bool</code> （布尔值，真或假）。</li>
<li>所有方法都以 <code>func</code> 关键字开头，这是 <code>function</code> 的缩写。在这个例子中，<code>viewWillAppear</code> 是重写的父类方法，所以要加上 <code>override</code> 关键字。将父类的同名方法实现并替换成当前类的实现。父类与重写概念都属于面向对象编程范式范畴（ Object Oriented Programming ）。这个概念在本文中不做讲解。</li>
<li>该方法的主体：先将可选绑定的 <code>self.mapView</code> 赋值给了常量 <code>mapView</code> 。使用可选绑定可以验证可选变量是否为 <code>nil</code> 。如果有值，<code>if</code> 中的代码才会执行。同时，常量 <code>mapView</code> 只在 <code>if</code> 作用域内有效。</li>
<li>在 <code>if</code> 条件语句中，将 <code>mapView</code> 的 <code>delegate</code> 属性设置给当前类 <code>self</code> 。换句话说，当 <code>self.mapView</code> 不为 <code>nil</code> 的时候，<code>mapView</code> 的 <code>delegate</code> 就是 <code>self</code> 。再简单点说：如果当前类实例不为空，那就是 <code>mapView</code> 的 <code>delegate</code> （译者注：这里作者解释了N多遍，代码胜千言…）。之后还会用到其他 <code>delegate</code>。</li>
</ul>
<p>完成 <code>delegate</code> 的设置之后，Xcode 又报错了。告诉我们，<code>self</code> 不能作为 <code>delegate</code>，因为当前类 <code>ViewController</code> 没有遵循  <code>MKMapViewDelegate</code> 。现在进行修正：</p>
<p>改一下类定义的那行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MKMapViewDelegate</span></span></span><br></pre></td></tr></table></figure>
<h2 id="获取用户地理位置">获取用户地理位置</h2><p>现在 map view 已经配置好了，你可以将注意力集中在获取地理位置上了。</p>
<p>在 <code>ViewController</code> 类中，添加以下两个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locationManager:<span class="type">CLLocationManager</span>?</span><br><span class="line"><span class="keyword">let</span> distanceSpan:<span class="type">Double</span> = <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>第一个属性 <code>locationManager</code> 是类型为 <code>CLLocationManager</code> 的变量。这是一个可选类型，所以它的值可以是 <code>nil</code> 。第二个属性是个类型为 <code>Double</code> 的常量，值为 500 。<code>Double</code> 即双精度浮点数类型（有效位长度是 <code>Float</code> 的两倍）。</p>
<p>现在，给当前类添加下面这个方法。可以将代码插入到 <code>viewWillAppear</code> 的下面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> locationManager == <span class="literal">nil</span> &#123;</span><br><span class="line">        locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"></span><br><span class="line">        locationManager!.delegate = <span class="keyword">self</span></span><br><span class="line">        locationManager!.desiredAccuracy = kCLLocationAccuracyBestForNavigation</span><br><span class="line">        locationManager!.requestAlwaysAuthorization()</span><br><span class="line">        locationManager!.distanceFilter = <span class="number">50</span> <span class="comment">// Don't send location updates with a distance smaller than 50 meters between them</span></span><br><span class="line">        locationManager!.startUpdatingLocation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoah，这段代码是啥意思？</p>
<ol>
<li>首先，用 <code>if</code> 条件语句判断 <code>locationManager</code> 变量的值是否为空。</li>
<li>然后，实例化 <code>CLLocationManager</code> ，并赋值给 <code>locationManager</code>。换句话说：<code>locationManager</code> 变量指向的就是 <code>CLLocationManager</code> 的实例对象。 location manager 对象能用来获取用户地址。</li>
<li>接着，我们给 <code>locationManager</code> 设置了一些属性。将 delegate 设为当前类，并设置了 GPS 精度。还调用了 <code>requestAlwaysAuthorization()</code> 方法，这个方法在 app 中弹出提示框，提示用户 app 会用到 GPS ，并征得用户授权。</li>
<li>最后，调用 <code>startUpdatingLocation</code> 方法，location manager 就会开始轮询 GPS 坐标，并将最新的坐标通过代理方法传回。如果实现了代理方法，我们就能拿到用户的地理位置信息了。</li>
</ol>
<p>你是否注意到 <code>locationManager</code> 代码后面的感叹号？这是因为 <code>locationManager</code> 是可选值，所以有可能是 <code>nil</code> 。当我们要访问这个变量时，就需要先解包，确保非空。根据这个访问约定，解包有两种方式：</p>
<ul>
<li><strong>可选绑定</strong>。使用 <code>if let definitiveValue = optionalValue { …</code> 这样的结构（译者注：关于 <code>if let</code> 的使用，可以参考 SwiftGG 翻译组的另一篇文章：<a href="http://swift.gg/2015/11/06/if-let-assignment/" target="_blank" rel="external">if-let赋值运算符</a>）</li>
<li><strong>强制解包</strong>。使用感叹号，如 <code>optionalValue!</code>。</li>
</ul>
<p>在写第一个方法的时候，我们用的就是可选绑定的方式。当可选变量不为 <code>nil</code> 时，使用 <code>if let</code> 来定义一个新的变量。</p>
<p>强制解包不是一个很好的方案。要在需要解包的变量后面加上感叹号，那么它就会从可选状态 “强制转换” 为不可选状态。不幸的是，当你强制解包一个值为 <code>nil</code> 的可选变量时，程序会直接崩溃。 </p>
<p>所以不能对值为 <code>nil</code> 的可选变量强制解包。在上面的代码中，强制解包就不存在这个问题。为什么呢？因为在强制解包之前，我们先将 <code>CLLocationManager</code> 的实例变量赋给了 <code>locationManager</code> ，所以可以保证 <code>locationManager</code> 不是 <code>nil</code>。</p>
<p>OK，回到代码部分。当我们添加了上面方法以后，Xcode 又报错了…让我们继续来解决问题吧！</p>
<p>错误之处：我们想让 <code>self</code> 作为 <code>locationManager</code> 的委托（ <code>delegate</code> ），但是并没有遵循相应的协议。在类定义的地方，添加以下代码来遵循协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MKMapViewDelegate</span>, <span class="title">CLLocationManagerDelegate</span></span></span><br></pre></td></tr></table></figure>
<p>OK，给 <code>ViewController</code> 类添加以下代理方法。放在上一个方法的后面就行。（译者注：添加的这个方法已经被弃用了。取而代之的是 <code>func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation])</code> 方法。）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">locationManager</span><span class="params">(manager: CLLocationManager, didUpdateToLocation newLocation: CLLocation, fromLocation oldLocation: CLLocation)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mapView = <span class="keyword">self</span>.mapView &#123;</span><br><span class="line">        <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(newLocation.coordinate, distanceSpan, distanceSpan)</span><br><span class="line">        mapView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又在做什么呢？</p>
<ul>
<li>首先，方法名是 <code>locationManager:didUpdateToLocation:fromLocation</code> 。这个方法使用了命名参数，说明他的方法名会随着参数名的不同而不同（变量在方法内部）。简言之，这个方法有三个参数：调用该方法的 location manager，最新的 GPS 坐标，上一次的 GPS 坐标。</li>
<li>在方法内部，先使用可选绑定对 <code>self.mapView</code> 解包。当 <code>self.mapView</code> 不为 <code>nil</code> 时，<code>mapView</code> 变量就是它解包以后的值，然后执行 <code>if</code> 条件中的对应语句。</li>
<li>在 <code>if</code> 语句中，根据新的 GPS 坐标与之前定义的 <code>distanceSpan</code> 两个值，计算得到 <code>region</code> 值。这句代码创建了一个以 <code>newLocation</code> 为中心，500 * 500 的一个矩形区域（500 就是 <code>distanceSpan</code> 的值）。</li>
<li>最后，调用 map view 的 <code>setRegion</code> 方法。<code>animation</code> 参数设为 <code>true</code> ，这样 <code>region</code> 改变就会有动画。换句话说：地图可能会有平移或缩放操作，所以要保证他每次都能显示 500 * 500 的区域。</li>
</ul>
<p>最后一件事，为了让用户同意地理位置授权，你需要在 Xcode 中设置一个特别的授权请求。这个请求要用一句话涵盖为什么要获取用户地理位置。iPhone 会在申请授权时，弹框显示这句话（即在调用 <code>requestAlwaysAuthorization()</code> 方法时）。</p>
<p>配置请求的步骤如下：</p>
<ol>
<li>在工程目录中打开 <code>info.plist</code> 文件。</li>
<li>右键点击列表，选择 Add Row。</li>
<li>在 key 列，填入 <code>NSLocationAlwaysUsageDescription</code> 。</li>
<li>在 type 列，将类型改为 <code>String</code>。</li>
<li>在 value 列，填入 <code>We need to get your location!</code> （译者注：这个 value 就是申请授权并弹框时，显示给用户的文本）</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/info-plist.png" alt=""></p>
<h2 id="运行程序">运行程序</h2><p>现在，让我们运行一下程序。确保你选择了相应的 iPhone Simulator，运行快捷键 Command - R 。第一次运行 App ，会弹出是否允许获取地理位置的授权框，选择 Allow，如下图。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_14.png" alt=""></p>
<p>当我们点击了 Allow 以后，map view 好像并没有更新位置。这是因为模拟器没有 GPS ，所以…我们需要模拟一下：</p>
<p>当 app 在模拟器上跑起来以后，在以下两种方式中，选择一种进行配置：</p>
<ul>
<li>iPhone Simulator: Debug -&gt; Location -&gt; Apple.</li>
<li>Xcode: Debug -&gt; Simulate Location -&gt; [随便选一个]</li>
</ul>
<p>当你选择了一个地理位置后，map view 就会定位到对应位置，并缩放到合适的大小。（译者注：可能定位这一步会有点慢，map 半天没有更新或没有图像出来，等等就好了）</p>
<p>搞定了吗？完美！</p>
<h2 id="从_Foursquare_上读取地理信息">从 Foursquare 上读取地理信息</h2><p>你以为到这一步就完了吗？其实并没有，还会有更有趣的事情！我们还需要使用 Das Quadrat 来读取 Foursquare 上的数据，然后用 Realm 将数据存入本地。</p>
<p>在使用 Foursquare 的 API 之前，首先需要到开发者中心注册这个 app 。这个步骤很简单。（译者注：如果只是练习，没必要去注册，直接使用作者提供的 Client ID 和 Client Secret 即可）</p>
<ul>
<li>首先，确保你有一个 Foursquare 账号，没有可以去注册一个：<a href="https://foursquare.com/" target="_blank" rel="external">foursquare.com</a>。</li>
<li>然后，进入 <a href="https://developer.foursquare.com/" target="_blank" rel="external">developer.foursquare.com</a>，点击顶部蓝色菜单栏中的 My Apps 。</li>
<li>接着，点击右边绿色的 new app 按钮。</li>
<li>接着，填写以下信息：<ul>
<li>App Name： Coffee</li>
<li>Download / Welcome page URL: <a href="http://example.com" target="_blank" rel="external">http://example.com</a></li>
</ul>
</li>
<li>最后，点击保存</li>
</ul>
<p>保存以后，网页自动跳转到了你创建的 app 页面。记录下 Client ID 和 Client Secret ，之后会用到。（译者注：作者提供的 Client ID 和 Client Secret 在后面的代码里有提供）</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_15.png" alt=""></p>
<h2 id="构建_Foursquare_API_连接">构建 Foursquare API 连接</h2><p>OK，下面开始连接 Foursquare API 。这里我们会用到单例模式。我们要做的部分用单例模式简直是完美。</p>
<p>单例是一个类的实例，它在整个 app 生命周期中，只允许有一份拷贝。所以你不能去创建第二个实例。为什么要使用单例呢？虽然单例的使用饱受争议，但是它有一个明显的优势：可以避免对外部资源发起并发连接。</p>
<p>设想一下。如果对网站同时发起两个请求，并且他们会写入同一个特定的文件，会发送什么呢？这样就很有可能读到脏数据，除非网站知道这两个请求发起的先后顺序。</p>
<p>而单例就能确保只有 app 的一部分能访问外部资源。在单例中，有很多种实现方式能保证没有请求冲突存在。将请求加入队列并添加依赖就是其中一种解决方案。这又是一个很大的主题，本文不进行讲解。</p>
<p>不扯了，继续实现：</p>
<ul>
<li>在工程目录中，右键点击 Coffee 文件夹。</li>
<li>选择 New File。</li>
<li>选择 iOS -&gt; Source 中的 Swift File ，点击继续。</li>
<li>文件命名为 <code>CoffeeAPI.swift</code> ，确认 target 中的 Coffee 是选中状态，选择和其他 swift 文件统计目录，点击 Create ，保存文件。</li>
</ul>
<p>Whoah，新文件里面空空如也！让我们来加点料吧。在 import 代码的后面，添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QuadratTouch</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"><span class="keyword">import</span> RealmSwift</span><br></pre></td></tr></table></figure>
<p>然后，添加：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">API</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifications</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> venuesUpdated = <span class="string">"venues updated"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简洁对吧。首先，你正确地引入了一些需要的库（Quadrat, MapKit, Realm），然后使用 <code>struct</code> 创建了一个名为 <code>venuesUpdated</code> 的静态常量。之后，通过以下方式访问该变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">API</span>.notifications.venuesUpdated</span><br></pre></td></tr></table></figure>
<p>接着，键入：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeAPI</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">CoffeeAPI</span>()</span><br><span class="line">    <span class="keyword">var</span> session:<span class="type">Session</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的作用：</p>
<ul>
<li>告诉 Xcode 编译器，当前类名为 <code>CoffeeAPI</code> 。这是一个单独的 Swift 类，没有继承 <code>NSObject</code>。</li>
<li>声明一个静态常量 <code>sharedInstance</code> ，类型为 <code>CoffeeAPI</code> 。这个 <code>sharedInstance</code> 只有 <code>CoffeeAPI</code> 类才能访问，并且在 app 启动的时候就已经被初始化了。</li>
<li>声明一个类型为 <code>Session?</code> 的可选变量 <code>session</code> （该类型包含在 <code>Das Quadrat</code> 中）。</li>
</ul>
<p>之后，我们访问 Coffee API 单例的方式都将是 <code>CoffeeAPI.sharedInstance</code> 。你可以在任何地方，通过这种方式访问单例，并且，访问的都是同一个对象，这也正是单例的一大特点。</p>
<p>接着，需要写一个构造器。给当前类添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Initialize the Foursquare client</span></span><br><span class="line">    <span class="keyword">let</span> client = <span class="type">Client</span>(clientID: <span class="string">"..."</span>, clientSecret: <span class="string">"..."</span>, redirectURL: <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> configuration = <span class="type">Configuration</span>(client:client)</span><br><span class="line">    <span class="type">Session</span>.setupSharedSessionWithConfiguration(configuration)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session = <span class="type">Session</span>.sharedSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器是一个会在类实例化的时候调用的方法。这也是实例化时，系统自动调用的第一个方法。</p>
<p>还记得之前在 Foursquare 开发者网站上复制的  Client ID 和 Client Secret 吗？粘贴到下面代码中。可以先不填 <code>redirectURL</code> 参数。向下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> client = <span class="type">Client</span>(clientID: <span class="string">"X4I3CFADAN4MEB2TEVYUZSQ4SHSTXSZL34VNP4CJHSJGLKPV"</span>, clientSecret: <span class="string">"EDOLJK3AGCOQDRKVT2GK5E4GECU42UJUCGGWLTUFNEF1ZXHB"</span>, redirectURL: <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>OK，继续。复制下面的代码，粘贴在 <code>CoffeeAPI</code> 类外面（即最后的大括弧的后面）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CLLocation</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">parameters</span><span class="params">()</span></span> -&gt; <span class="type">Parameters</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ll      = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.coordinate.latitude)</span>,<span class="subst">\(<span class="keyword">self</span>.coordinate.longitude)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> llAcc   = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.horizontalAccuracy)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> alt     = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.altitude)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> altAcc  = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.verticalAccuracy)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> parameters = [</span><br><span class="line">            <span class="type">Parameter</span>.ll:ll,</span><br><span class="line">            <span class="type">Parameter</span>.llAcc:llAcc,</span><br><span class="line">            <span class="type">Parameter</span>.alt:alt,</span><br><span class="line">            <span class="type">Parameter</span>.altAcc:altAcc</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> parameters</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这又是什么呢？这是一个 <code>extension</code> ，可以给当前类扩展其他的方法（译者注：关于 <code>extension</code> 的知识点，可以查看 SwiftGG 翻译组的其他文章：<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/21_Extensions.html" target="_blank" rel="external">扩展基础知识</a>。延伸到程序结构设计方面，还有进阶的 <a href="http://swift.gg/2015/12/15/mixins-over-inheritance/" target="_blank" rel="external">Mixins 比继承更好</a>）。无需创建新的类，就可以给 <code>CLLocation</code> 类扩展一个名为 <code>parameters()</code> 的方法。每次使用 <code>CLLocation</code> 的实例时，这个 <code>extension</code> 就会被加载，你可以通过实例来调用 <code>parameters</code> 方法，即使这个方法没包含在原生的 <code>MapKit</code> 中。</p>
<p>注意：不要混淆 Swift 中 <code>extension</code> 和编程术语 <code>extend</code> 。前者是给基类添加新的方法，后者意思是父类与子类间的继承关系。</p>
<p><code>parameter</code> 方法返回一个 <code>Parameters</code> 的实例对象。<code>Parameters</code> 是一个字典，里面包含了一些参数信息（ GPS 坐标和精度）。（译者注：<code>Parameters</code> 是在 <code>Session.swift</code> 中定义的 <code>typealias</code>，完整定义为：<code>public typealias Parameters = [String:String]</code> ）。</p>
<h2 id="给_Foursquare_发送请求">给 Foursquare 发送请求</h2><p>接下来，让我们从 Foursquare 获取数据吧。Foursquare 内部有一个 HTTP REST API 可以返回 JSON 数据。幸运的是，我们不需要知道这些，因为 Das Quadrat 库已经帮我们搞定了一切。</p>
<p>从 Foursquare 请求数据就和调用 <code>session</code> 里的属性一样简单，同时请求数据使用的是该属性里很多方法中的一个。这个方法返回一个 <code>Task</code> 的实例对象，即异步后台任务的引用。我们可以用闭包的形式实现，代码大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> searchTask = session.venues.search(parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        (result) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do something with "result"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>session</code> 里的地理属性包含了与 Foursquare API 通讯的所有 venues 信息。你提供的这个 search 方法是带有参数（上段代码中的 parameters ）的，还有第二个闭包作为参数，该闭包会在 search 方法完成后执行。同时，该方法会返回一个耗时的后台 <code>Task</code> 引用。你可以在任务完成之前用它来停止，或着在你代码的其他地方用它检查进度。</p>
<p>OK，现在来看看下面这个方法。复制并粘贴到你的代码里，即放在初始构造函数的后面，但在 CoffeeAPI 这个类的右括号前面。接下来，我们会看到这个方法的用途。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getCoffeeShopsWithLocation</span><span class="params">(location:CLLocation)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> session = <span class="keyword">self</span>.session</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> parameters = location.parameters()</span><br><span class="line">        parameters += [<span class="type">Parameter</span>.categoryId: <span class="string">"4bf58dd8d48988d1e0931735"</span>]</span><br><span class="line">        parameters += [<span class="type">Parameter</span>.radius: <span class="string">"2000"</span>]</span><br><span class="line">        parameters += [<span class="type">Parameter</span>.limit: <span class="string">"50"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start a "search", i.e. an async call to Foursquare that should return venue data</span></span><br><span class="line">        <span class="keyword">let</span> searchTask = session.venues.search(parameters)</span><br><span class="line">            &#123;</span><br><span class="line">                (result) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> response = result.response</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> venues = response[<span class="string">"venues"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">AnyObject</span>]]</span><br><span class="line">                    &#123;</span><br><span class="line">                        autoreleasepool</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">                                realm.beginWrite()</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">for</span> venue:[<span class="type">String</span>: <span class="type">AnyObject</span>] <span class="keyword">in</span> venues</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">let</span> venueObject:<span class="type">Venue</span> = <span class="type">Venue</span>()</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> id = venue[<span class="string">"id"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        venueObject.id = id</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> name = venue[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        venueObject.name = name</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>  <span class="keyword">let</span> location = venue[<span class="string">"location"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>]</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> longitude = location[<span class="string">"lng"</span>] <span class="keyword">as</span>? <span class="type">Float</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            venueObject.longitude = longitude</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> latitude = location[<span class="string">"lat"</span>] <span class="keyword">as</span>? <span class="type">Float</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            venueObject.latitude = latitude</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> formattedAddress = location[<span class="string">"formattedAddress"</span>] <span class="keyword">as</span>? [<span class="type">String</span>]</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            venueObject.address = formattedAddress.joinWithSeparator(<span class="string">" "</span>)</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    realm.add(venueObject, update: <span class="literal">true</span>)</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                    <span class="keyword">try</span> realm.commitWrite()</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"Committing write..."</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">catch</span> (<span class="keyword">let</span> e)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"Y U NO REALM ? <span class="subst">\(e)</span>"</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">API</span>.notifications.venuesUpdated, object: <span class="literal">nil</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        searchTask.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么多代码，你能从里面分辨出它完成的 5 个主要的任务吗？</p>
<ol>
<li>配置并启动 API 请求。</li>
<li>使用闭包实现请求的 Completion handler。</li>
<li>解析请求返回的数据，并开启 Realm 事务来处理。</li>
<li>使用 for-in 循环遍历所有的地理数据。</li>
<li>在 Completion handler 的最后发送通知。</li>
</ol>
<p>接下来，让我们一行行的来解释一下：</p>
<h3 id="设置请求的准备动作">设置请求的准备动作</h3><p>首先，使用可选绑定检查 <code>self.session</code> 是否为空。如果非空的话，常量 <code>session</code> 会被赋值解包后的值。</p>
<p>接着，<code>location</code> 的 <code>parameters()</code> 方法被调用。你问这个 <code>location</code> 是从哪里来的？你可以看下 <code>getCoffeeShopsWithLocation</code> 方法后面的那个参数。每次你调用这个方法，你也必须传入一个 <code>location</code> 参数，并检查传入的参数是不是你之前写的。</p>
<p>最后，我们添加了一个新的数据项到 <code>parameters</code> 字典。该数据项使用 <code>Parameter.categoryId</code> 作为 key ，字符串 <code>4bf58dd8d48988d1e0931735</code> 作为 value 。这个字符串就是之前 Foursquare 上 <code>Coffeeshops</code> 目录的编号，因此，没什么特殊的。</p>
<h3 id="配置请求">配置请求</h3><p>接着，让我们来配置真正的请求。获取 <code>session</code> 的 <code>venues</code> ，并开始搜寻这个 <code>venues</code> 。该方法有两个参数：你刚才创建的 <code>parameters</code> 字典和闭包。现在使用的闭包的形式叫尾随闭包（ trailing closure ）。它作为该方法的最后一个参数，没有采用圆括号括起来的形式，而是将它写在方法外部并用大括号括起来。这是个很耗时的方法，因此，我们并没有让它自动开始执行，而是在本方法的末尾再执行。</p>
<h3 id="书写闭包">书写闭包</h3><p>接着，我们进到闭包里去看看。值得注意的一点是，尽管这些代码看上去连续的，但是它们不会一个一个按你看到的顺序执行。该闭包会在搜寻任务完成后执行。当数据从 HTTP API 返回到应用中时，代码会从 <code>let searchTask …</code> 这行执行到 <code>searchTask.start()</code> 这行，接着会跳到 <code>if let response = …</code> 这行。</p>
<p>闭包的格式是这样的：<code>(result) -&gt; Void in</code> 。 <code>result</code> 作为闭包里的参数是可以拿到值的，并且该闭包没有返回值（ <code>Void</code> ）。这一点和普通的方法有点相似。</p>
<h3 id="解析数据">解析数据</h3><p>接着，我们使用了 <code>if</code> 可选绑定：</p>
<ul>
<li>如果 <code>result.response</code> 非空，就将其赋值给常量 <code>response</code> ，并继续执行 <code>if</code> 条件内的语句。</li>
<li>如果 <code>response[“venues”]</code> 非空，并且可以转换成 <code>[[String: AnyObject]]</code> 类型。</li>
</ul>
<p>这个类型转换可以确保我们拿到的是正确的类型。如果转换失败，即可选绑定失败，就不会执行 <code>if</code> 条件内的语句。这个方法有一石二鸟的效果：检查对应的值是否为空，同时尝试将数据转换成合适的类型。</p>
<p>你能说一下 <code>venues</code> 的类型是什么吗？首先它是一个数组，每个元素是字典类型，每个字典是以 <code>String</code> 类型为 key ， <code>AnyObject</code> 类型为 value 。</p>
<h3 id="自动释放内存">自动释放内存</h3><p>接着，我们开启了一个自动释放池。自动释放池本身就是一个很大的话题。你知道 iPhone 是如果进行内存管理的吗？</p>
<p>本质上来说，内存里的对象在没有被使用时，会在某个时间点从内存里被移除。有点类似垃圾回收，但还是有点区别的。当自动释放池里的一个变量被释放时，这个变量就和这个自动释放池紧紧联系在一起了。当这个自动释放池自己要被释放时，在内的所有变量的内存也会一起被释放。这个有点像，对内存释放的批处理。</p>
<p>为什么要这么做呢？因为，可以通过创建自己的自动释放池，来帮助 iPhone 系统管理内存。我们在处理数以百计的地理对象时，如果没有放在自己的自动释放池里，内存就会被未释放的内存拥塞了。而，能释放这些内存的时间点是在该方法结束的时候。因此，你在冒着用光内存的风险操作（自动释放的机理导致不会立马释放无用的内存）。使用自己创建的自动释放池，你就可以影响内存释放的时间点并能避免被内存不足困扰。（译者注：ARC 下，在方法内创建的临时变量，系统都会自动加上 <code>__strong</code> 修饰符，并在出该变量作用域时，进行 <code>release</code> 。所以，一般在处理有大量的临时变量的方法时，会自己加上 <code>autoreleasepool</code> ，提前释放已经不用的临时变量，及时释放内存。）</p>
<h3 id="开启_Realm">开启 Realm</h3><p>接着，你用 <code>let realm = try! Realm()</code> 这样一行代码初始化了一个 Realm 对象。你在从 Realm 获取数据之前肯定需要有一个 Realm 对象。 <code>try!</code> 关键字是 Swift 的一种错误处理。用了这个关键字，我们其实声明了：当前不会处理来自 Realm 的错误。虽然这样的做法对生产环境来说并不推荐，但是可以让我们的代码变得相当简单。</p>
<h3 id="开启事务处理">开启事务处理</h3><p>接下来，调用 Realm 实例方法 <code>beginWrite</code> 。其实这代码开启了一个事务。让我们先来谈谈效率的问题。以下哪种方式更高效：</p>
<ul>
<li>创建一个文件指针，打开文件，写入 1x 数据到文件里，关闭文件，再重复之前的步骤直到写入 50x 数据。</li>
<li>创建一个文件指针，打开文件，写入 50x 数据到文件里，关闭文件。</li>
</ul>
<p>确切地说，当然是后者更高效。和其他数据库系统一样， Realm 也是把数据存储在文本文件里的。文件处理就意味着：操作系统（ operation system ， OS ）需要打开着文件，赋予程序写入权限，并让程序可以一个字节一个字节的向文件里写入数据。</p>
<p>你需要使用打开一次文件，一次写入 50 个 Realm 对象的方式，而不是一次次的写入文件。因为，每个对象之间非常相似，它们可以被连续地写入。这种方式更快一点，其实这就是事务。</p>
<p>为了完整性，如果事务中的一次写入失败了，那么所有的写入都会失败。这种机制其实来源于银行和账户：如果你写入了 50 个事务到一个分类账簿，而其中的一个（比如，账上没有钱）被证明是错误的，但是你又不能找出来。你必须阻止这种“污染”整个账簿的行为。这时候使用事务就再好不过了，成功都写入，失败都回滚，这样的方式也能减少数据出错的风险。</p>
<h3 id="遍历地理数据">遍历地理数据</h3><p>OK，现在来看看 for-in 循环。你已经可选绑定上面创建了 <code>venues</code> 变量。在 for-in 循环遍历整个数组时，每次循环里都是数组中的一个元素：<code>venue</code>。</p>
<p>首先，创建了一个 <code>Venue</code> 类型的 <code>venueObject</code> 变量。这行代码暂时会报错，因为现在还没有一个类叫 <code>Venue</code> 。你等会就会添加这个类的，因此先放一边吧。</p>
<p>接着，一系列的可选绑定来了。每个可选绑定都尝试去访问 <code>venue</code> 的键值对（ key-value pair ），同时尝试将其转换成合适的类型。举个例子，当 <code>venue</code> 包含一个键 <code>id</code> ，并尝试转换成 <code>String</code> 类型，假如成功的话，会将 <code>venueObject</code> 的 <code>id</code> 属性赋值给它。</p>
<p><code>location</code> 的可选绑定看上去复杂一点，但是其实一点也不复杂。仔细看，你会发现 <code>lat</code> 、 <code>lng</code> 、 <code>formattedAddress</code> 这些都是<code>location</code> 的一部分 key （并不是 <code>venue</code> 的）。它们其实在数据结构中是属于同一层的。</p>
<p>接下来，是 for-in 循环最后一行代码：<code>realm.add(venueObject, update: true)</code> 。这行代码会把 <code>venueObject</code> 添加到 Realm，并写入到数据库（仍然是以事务的形式写入）。方法中的第二个参数 <code>update</code> 表示：当对应传入的对象已经存在，就用新数据覆盖掉之前写入的数据。之后，你会发现每个 <code>Venue</code> 对象都有一个唯一的编号，所以 Realm 可以根据编号知道对象已经存在。</p>
<h3 id="错误处理">错误处理</h3><p>OK，现在 Realm 已经将事务中所有要写入的数据保存起来了，接下来将尝试写入到 Realm 数据库。这一步当然也有可能出错了。庆幸的是，这里可以使用 Swift 的错误处理机制。步骤如下：</p>
<ol>
<li>尝试执行可能出错的操作。</li>
<li>如果出错，就抛出错误。</li>
<li>操作的调用者抓住对应错误。</li>
<li>进行错误处理。</li>
</ol>
<p>在大多数语言里，这种机制以 try-catch 闻名，但是 Swift 称它为 do-catch （同时，也将 do-while 重命名为 repeat-while ）。你的代码大概是这样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> realm.commitWrite()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Committing write..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">let</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Y U NO REALM ? <span class="subst">\(e)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realm.commitWrite()</code> 这行代码就是在尝试执行可能出错的操作。同时，这行代码前面写了 <code>try</code> 。回到你之前写 <code>try!</code> 的地方，<code>try!</code> 会摒弃错误。（译者注：<code>try!</code> 表示禁用错误传递，如果抛出错误，那么程序崩溃。一般用于，你知道这个步骤不会出错的情况。关于错误处理，可以看 SwiftGG 翻译组翻译的 Swift 官方文档：<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/18_Error_Handling.html" target="_blank" rel="external">错误处理</a>）。</p>
<p>当在 <code>do { }</code> 代码块里产生错误的时候， <code>catch</code> 代码块就会执行。它只有一个参数，<code>let e</code>，它会包含异常的具体信息。在后面的代码块里，我们将具体的错误信息打印出来。当程序运行过程中出现错误了，打印的信息就会告诉我们错误到底是由什么异常引起的。</p>
<p>这里的这个错误处理是很基础的。设想一下，一个错误处理很完善的系统，不仅仅需要抓住出错信息，还要对错误信息进行一下处理。举个例子，当你写数据到文件，而磁盘满了的时候，你就需要弹窗让用户知道磁盘已经满了。在较早版本的 Swift 中，处理错误比现在更艰难，而且如果你不处理得当，程序就崩溃了。</p>
<p>Swift 的错误处理或多或少还是加强了。你要不处理错误，要不摒弃掉错误，但是不管怎么样也不能忽视错误。处理错误可以让你的代码更健壮，因此，养成多使用 do-catch 处理错误的习惯，而不是使用 <code>try!</code> 来摒弃错误。</p>
<p>OK，该方法中还有最后两行代码，第一行如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">API</span>.notifications.venuesUpdated, object: <span class="literal">nil</span>, userInfo: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码会给整个应用中监听它的地方发送一个通知。这实际上是应用中的通知机制，可以高效的将事件传递到应用中的不同位置。考虑到你刚从 Foursquare 获取到新数据，你可能要去更新显示数据的 table view ，也可能要更新代码的其他部分。通知是完成这个操作最好的方式了。</p>
<p>请牢记，通知会一直保留在发送它的那个线程上。如果你在主线程外（比如，发送通知的线程）更新你的 UI ，你的应用就会崩溃并抛出错误。</p>
<p>注意到这行代码里的硬编码 <code>API.notifications.venuesUpdated</code> 了吗？本来我们可以写成 <code>&quot;venuesUpdated&quot;</code> 的字符串， 而不是 <code>API.notifications.venuesUpdated</code>。使用硬编码的编译时常量能让你的代码更安全。如果你出错，编译器会报错。但是，如果你使用字符串的方式，拼写错 <code>&quot;venuesUpdated&quot;</code> ，编译器就不会报错了。</p>
<p>最后，闭包外的这行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">searchTask.start()</span><br></pre></td></tr></table></figure>
<p>再次注意，这行代码会在 <code>let searchTask …</code> 后执行，且和上面一大段闭包是独立的。这行代码到底是干什么的呢？现在，我们已经设置好请求，配置好所有需要的参数，这行代码就是让这个搜寻任务启动起来。</p>
<p>Das Quadrat 发送一条消息到 Foursquare ，等待数据的返回，然后就执行了处理数据的闭包。懂了吧？</p>
<p>暂时把这些代码放一边，因为接下来我们要写 <code>Venue</code> 对象了。</p>
<h2 id="编写_Realm_Venue_对象">编写 Realm Venue 对象</h2><p>你知道 Realm 酷在什么地方吗？它整个代码结构是很简短的。本质上来说，你只需要一个类文件就可以写 Realm 了。你创建了一系列的实例对象，把它们写到 Realm 文件中，然后 BAM！你已经完成了你自己的本地数据库。</p>
<p>Realm 有一系列很赞的特性，比如排序、过滤以及支持 Swift 数据类型。你再也不需要在 table view 里使用 Core Data 的 <code>NSFetchedResultsController</code> 来加载成千上万的对象。Realm 也有它自己的数据浏览器。</p>
<p>OK，接下来该写 Realm Venue 对象了。步骤如下：</p>
<ul>
<li>右击 Xcode 中 Project Navigator 的 Coffee 这个文件夹。</li>
<li>点击 <code>New File …</code> ，从 iOS -&gt; Source 目录选择 Swift 文件，并点击 <code>Next</code> 。</li>
<li>将新建的文件命名为 <code>Venue.swift</code> ，并确保选中了 Coffee 这个 target 。</li>
<li>最后，点击 <code>Create</code> 完成创建。</li>
</ul>
<p>好吧，又是一个无内容的文件。这个文件将会包含 Realm 的 Venue 对象的代码。</p>
<p>首先导入正确的库。在 Foundation 的导入代码添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RealmSwift</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br></pre></td></tr></table></figure>
<p>接着，键入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Venue</span>: <span class="title">Object</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就为 Venue 新建了一个类。其中，这个冒号表示当前类继承自 <code>Object</code> 类。这其实是面向对象编程（ Object Oriented Programming ）中父类和子类之间的继承关系。此处代码就是将 <code>Venue</code> 类继承自 <code>Object</code> 类。</p>
<p>简单来说，作为一个子类会自动将父类的所有方法和属性拷贝到自己的类中。值得注意的是，这和我们之前使用的 <code>extension</code> 是不一样的，它是为现有的类添加新的方法，而没有创建一个独立的新类。</p>
<p>接着，将以下代码拷贝到该类中，记得要添加在大括号的范围内：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> id:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> latitude:<span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> longitude:<span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> address:<span class="type">String</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>这些句子是什么意思呢？就是为这个类添加了 5 个属性。你可以像使用 <code>CoffeeAPI</code> 的代码那样，使用这些属性为类实例添加数据。</p>
<p>属性中的 <code>dynamic</code> 关键字可以确保该属性能被 Objective-C 运行时访问。这本身是另外一个主题，但是我们先假设 Swift 的代码和 Objective-C 代码在各自的 “沙盒” 里运行。在 Swift 2.0 之前，所有的 Swift 代码都是运行在 Objective-C 运行时里，但是现在 Swift 已经有自己的运行时了。我们用 <code>dynamic</code> 关键字修饰属性，就可以让 Objective-C 运行时访问到这个属性，因为 Realm 需要在内部用到该属性。</p>
<p>每个属性都是 <code>String</code> 或  <code>Float</code> 类型。 Realm 本身支持一些变量类型，包括 <code>NSData</code> 、<code>NSDate</code> 、<code>Int</code> 、<code>Float</code> 、<code>String</code> 等等。</p>
<p>接下来，在 <code>address</code> 属性下面添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> coordinate:<span class="type">CLLocation</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CLLocation</span>(latitude: <span class="type">Double</span>(latitude), longitude: <span class="type">Double</span>(longitude));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性的值要计算后才会有。它不能保存到 Realm 里，因为它的类型没有包含在 Realm 本身支持的类型中。这个属性保存的是表达式的结果值。它就像一个方法，但是接着它就可以用属性来访问了。以上属性返回的是一个 <code>CLLocation</code> 实例对象，它有 <code>latitude</code> 和 <code>longitude</code> 两个属性。</p>
<p>这种使用方法很便利，因为我们只需要访问 <code>venueObject.coordinate</code> 就能获得对应类型的实例，而不用我们自己创建。</p>
<p>OK，接下来，粘贴以下代码到最后的代码块下面：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">primaryKey</span><span class="params">()</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"id"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个新出现的方法，它重写了父类 <code>Object</code> 的方法。这个自定义方法可以返回一个 Realm 的主键（ primary key ）。主键就是唯一标识。每个 Realm 数据库中的对象有且仅有一个唯一的值作为主键，就像一个村庄里的房子必须有且仅有一个唯一的地址一样。</p>
<p>Realm 会用主键去区分一个个不同的对象，并确定当前这个对象是否唯一。</p>
<p>该方法的返回值类型为 String，因此我们就可以返回主键对应的属性名或者返回 <code>nil</code>（不使用主键的情况）。</p>
<p>Realm 对象的属性（比如，<code>id</code> 和 <code>name</code>）类似于电子表格里的列。方法返回的主键返回值即是每一列的名字，其实就是 <code>id</code> 。</p>
<p>现在，我们需要按 Command-B 来编译当前应用，并确保没有报错。我们没必要运行当前的应用，因为我们没有改变前端的展示代码。取而代之的是，我们只要检查编译应用时候是否有报错。如果你这时候去查看 <code>CoffeeAPI.swift</code> 文件，之前关于 <code>venueObject</code> 的错误已经不存在了。</p>
<h2 id="在_Map_View_中展示地理数据">在 Map View 中展示地理数据</h2><p>OK，现在让我们来处理下载下来的数据吧。你将要把它们放入之前创建的 map view 里以注释（annotation）的形式展示。</p>
<p>首先，切换到 <code>ViewController.swift</code> 文件。检查用来在 map view 上显示用户位置的代码。</p>
<p>接着，在文件的最上部，添加如下的导入语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RealmSwift</span><br></pre></td></tr></table></figure>
<p>接着，在类的最上部，添加以下这些属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastLocation:<span class="type">CLLocation</span>?</span><br><span class="line"><span class="keyword">var</span> venues:<span class="type">Results</span>?</span><br></pre></td></tr></table></figure>
<p>你需要 RealmSwift 库来支持你使用 Realm，并且你需要这两个属性分别处理位置和地理数据。</p>
<p>接下来，定位到文件中的 <code>locationManager:didUpdateToLocation:fromLocation</code> 方法。在该方法的右大括号后面，粘贴以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refreshVenues</span><span class="params">(location: CLLocation?, getDataFromFoursquare:Bool = <span class="literal">false</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> location != <span class="literal">nil</span></span><br><span class="line">    &#123;</span><br><span class="line">        lastLocation = location</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> location = lastLocation</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> getDataFromFoursquare == <span class="literal">true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">CoffeeAPI</span>.sharedInstance.getCoffeeShopsWithLocation(location)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"></span><br><span class="line">        venues = realm.objects(<span class="type">Venue</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> venue <span class="keyword">in</span> venues!</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> annotation = <span class="type">CoffeeAnnotation</span>(title: venue.name, subtitle: venue.address, coordinate: <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="type">Double</span>(venue.latitude), longitude: <span class="type">Double</span>(venue.longitude)))</span><br><span class="line"></span><br><span class="line">            mapView?.addAnnotation(annotation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoah，好长的方法，它是怎么执行的呢？</p>
<p>让我们从 <code>location</code> 的两行判断语句说起吧。第一行检查了 <code>location</code> 是否非空，第二行使用可选绑定检查了 <code>lastLocation</code> 属性是否非空。</p>
<p>虽然这两行代码看上去很相似，但是其实干的事情是不同的。让我们退一步想想。检查以下陈述是否是真实的：</p>
<ul>
<li>应用中的所有位置数据都来源于 <code>locationManager:didUpdateToLocation:fromLocation</code> 方法。即，该方法是唯一一个能获取到 <code>CLLocation</code> 实例（数据来自 GPS 硬件数据）的地方。</li>
<li><code>refreshVenues</code> 方法需要一个位置作为参数，该参数可能为空。</li>
<li><code>refreshVenues</code> 方法可能会在没有可用的位置时被调用。比如，在代码里，一个与位置数据方法没有联系的地方就调用 <code>refreshVenues</code> 方法。</li>
</ul>
<p>最后一句陈述很重要。其实也很简单：因为我们不一定要在获取到最新地理位置（<code>locationManager:didUpdateToLocation:fromLocation</code> ）时，才进行位置保存，所以，我们需要将保存位置的功能单独封装出来（封装为 <code>refreshVenues</code> 方法）。</p>
<p>因此，每次调用 <code>refreshVenues</code> 方法时，如果 <code>lastLocation</code> 属性非空的话，我们会将 <code>location</code> 参数保存起来。然后，我们会用可选绑定检查 <code>lastLocation</code> 是否为空。<code>if</code> 语句只会在有值的时候执行，因此我们可以 100% 确定 <code>if</code> 语句里的代码块肯定会包含一个有效的 GPS 位置信息！</p>
<p>当然，前提是 <code>refreshVenues</code> 方法确实获取到了位置数据。你肯定要确保它是非空的。如果你还是不太理解的话，可以重新读一下上一段内容。这样的代码非常优雅，而且这样的编码还可以确保你的应用数据是安全的且仍然是解耦的。</p>
<p>OK，<code>refreshVenues</code> 方法里的下一行代码讲了什么呢？该代码块里使用了 <code>CoffeeAPI</code> 单例来从 <code>Foursquare</code> 请求数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> getDataFromFoursquare == <span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">CoffeeAPI</span>.sharedInstance.getCoffeeShopsWithLocation(location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只会在 <code>getDataFromFoursquare</code> 这个变量为 <code>true</code> 的时候执行。这是一种简单的使用 CoffeeAPI 请求数据方式。你要事先监听 CoffeeAPI 里的通知，才能在获取数据完成的时候，得到状态的更新。我们会在稍后实现该功能。</p>
<p>在请求数据之后，是以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">venues = realm.objects(<span class="type">Venue</span>)</span><br></pre></td></tr></table></figure>
<p>这些代码看上去是不重要的，但是代码的主体却是在这几句上。首先，实例化 <code>Realm</code> 。然后，所有从 <code>Realm</code> 获取来的 <code>Venue</code> 类的对象都保存到 <code>venues</code> 这个属性里。该属性的类型是 <code>Results?</code>，该类型是以 <code>Venue</code> 实例为元素的数组。</p>
<p>最后，for-in 循环遍历 <code>venues</code>，并将每个元素以注释（annotation）的样式添加到 map view 里。这段代码很可能会报出错误，但我们将会解决掉它的。</p>
<h2 id="创建注释（Annotation）类">创建注释（Annotation）类</h2><p>创建注释类，需要以下步骤：</p>
<ol>
<li>右击 Coffee 文件夹，选择 <code>New File …</code> 。</li>
<li>从 iOS -&gt; Source 目录里选择 Swift 文件并点击 <code>Next</code> 。</li>
<li>将该 Swift 文件命名为 <code>CoffeeAnnotation</code>，并点击 <code>Create</code> 。</li>
</ol>
<p>然后，将以下代码粘贴到该文件里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeAnnotation</span>: <span class="title">NSObject</span>, <span class="title">MKAnnotation</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> title:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> subtitle:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> coordinate: <span class="type">CLLocationCoordinate2D</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>?, subtitle:<span class="type">String</span>?, coordinate: <span class="type">CLLocationCoordinate2D</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.subtitle = subtitle</span><br><span class="line">        <span class="keyword">self</span>.coordinate = coordinate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码很简单：</p>
<ul>
<li>你新建了一个名叫 <code>CoffeeAnnotation</code> 的类，它继承自 <code>NSObject</code> 且遵循 <code>MKAnnotation</code> 协议。最后遵循协议的这个部分很重要，要想使用注释，必须要遵循这个 <code>MKAnnotation</code> 协议。</li>
<li>接着，创建了一大串属性。这些属性是由协议决定的，是类的一部分。</li>
<li>最后，还创建了构造器方法。该方法初始化了类的属性。</li>
</ul>
<p>切换回 <code>ViewController.swift</code> 文件，是不是发现原来 <code>CoffeeAnnotation</code> 那里的错误已经消失了？</p>
<p>接下来，添加以下的方法到 <code>ViewController</code> 这个类中。这个方法可以确保添加到地图的注释能被显示出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">mapView</span><span class="params">(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation)</span></span> -&gt; <span class="type">MKAnnotationView</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> annotation.isKindOfClass(<span class="type">MKUserLocation</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> view = mapView.dequeueReusableAnnotationViewWithIdentifier(<span class="string">"annotationIdentifier"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view == <span class="literal">nil</span></span><br><span class="line">    &#123;</span><br><span class="line">       view = <span class="type">MKPinAnnotationView</span>(annotation: annotation, reuseIdentifier: <span class="string">"annotationIdentifier"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    view?.canShowCallout = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 table view，map view 也用可重用的实例来让地图上的 <code>pin</code> 显示更平滑。以上代码大概是以以下的步骤展开：</p>
<ul>
<li>首先，检查 <code>annotation</code> 是不是用户的当前位置。</li>
<li>接着，在重用队列中取出 <code>pin</code> （并赋值给 <code>view</code> 变量）。</li>
<li>然后，如果没有 <code>pin</code> 在重用队列中，就创建一个新的。</li>
<li>接着，设置 <code>pin</code> 允许显示 callout（一块小小的用来显示信息的简介）。</li>
<li>最后，返回 <code>view</code> 。</li>
</ul>
<p>值得注意的是，这方法是代理模式的一部分。你之前设置了 <code>map view</code> 的代理为 <code>self</code>。因此，当 <code>map view</code> 准备显示 <code>pin</code> 时，都会调用代理中的 <code>mapView:viewForAnnotation:</code> 方法，应用才能执行到你刚定义的代码。</p>
<p>代理是一种很不错的自定义代码的方式，它不用重载整个类。</p>
<h2 id="回应地理数据的通知">回应地理数据的通知</h2><p>好的，现在让我们把这一切都整理一下。在之前，我们在 <code>ViewController.swift</code> 的 <code>viewDidLoad</code> 方法里添加了以下这行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"onVenuesUpdated:"</span>), name: <span class="type">API</span>.notifications.venuesUpdated, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码会告诉通知中心（ notification center ），<code>self</code>（当前类）正在监听名为 <code>API.notifications.venuesUpdated</code> 的通知。当发出通知的时候，<code>ViewController</code> 类的 <code>onVenuesUpdated:</code> 方法就会被调用。</p>
<p>添加以下方法到 <code>ViewController</code> 类里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">onVenuesUpdated</span><span class="params">(notification:NSNotification)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    refreshVenues(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这里到底发生了什么吧：</p>
<ul>
<li>当从 Foursquare 接收到返回的位置数据时，<code>refreshVenues</code> 方法就会被调用。</li>
<li>该方法没有包含位置数据，也没有提供 <code>getDataFromFoursquare</code> 参数。如果没有传入参数，就默认是 <code>false</code>，因此没有向 <code>Foursquare</code> 请求数据。如果传入参数，那么就会再次发起请求，请求结束又会调用该方法，这样就会导致死循环。</li>
<li>本质上来说，从 <code>Foursquare</code> 返回的数据会触发相应方法，从而将注释画到 map view 上去。</li>
</ul>
<p>关于代码，还有一个很重要的部分。添加如下代码到 <code>locationManager:didUpdateToLocation:fromLocation:</code> 方法里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">refreshVenues(newLocation, getDataFromFoursquare: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>这行添加后大概是这样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> mapView = <span class="keyword">self</span>.mapView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(newLocation.coordinate, distanceSpan, distanceSpan)</span><br><span class="line">    mapView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    refreshVenues(newLocation, getDataFromFoursquare: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码是怎么回事呢？简单来说：调用 <code>refreshVenues</code> 方法获取用户的 GPS 位置。同时，也用 API 向 Foursquare 请求数据。本质上来说，用户每次移动到新的位置都会向 Foursquare 请求数据。由于设置了间隔 50m 就更新，并且注册了通知，所以地图能正常更新。</p>
<p>运行应用并验证一下。是不是很酷？</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_16.png" alt=""></p>
<h2 id="在_Table_View_里显示地理数据">在 Table View 里显示地理数据</h2><p>现在，map view 已经能正常显示了。接着我们将会把同样的地理数据显示到 table view 中。实现起来也是很简单直接的。</p>
<p>首先，添加实例属性和 outlet 到 <code>ViewController</code>。在 <code>mapView</code> 属性下面添加如下的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> tableView:<span class="type">UITableView</span>?</span><br></pre></td></tr></table></figure>
<p>接着，切换到 <code>Main.storyboard</code> ，选中 View Controller Scene。将 table view 与 IBOutlet 关联。</p>
<p>与以 <code>self.mapView</code> 可选绑定相同的方法，添加如下的代码到 <code>ViewController.swift</code> 的  <code>viewWillAppear:</code> 方法里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tableView = <span class="keyword">self</span>.tableView</span><br><span class="line">&#123;</span><br><span class="line">    tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将当前的类遵循以下的协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UITableViewDataSource</span>, <span class="type">UITableViewDelegate</span></span><br></pre></td></tr></table></figure>
<p>接着，再添加两个代理中的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> venues?.<span class="built_in">count</span> ?? <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法是 table view delegate 协议中方法的一部分。第一个方法确定了 table view 有多少个 cell，而第二个方法确定了 table view 有多少个 section。注意到代码中的 <code>??</code> 了吗？它是空和运算符（nil-coalescing operator）（译者注：如果对空和运算符有什么不理解的话，可以查看<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/02_Basic_Operators.html#nil_coalescing_operator" target="_blank" rel="external">中文版官方文档</a>的说明）。即，如果 <code>venues</code> 是空的话，使用 0 作为默认值。</p>
<p>接着，添加以下方法到 <code>ViewController</code> 类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"cellIdentifier"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cell == <span class="literal">nil</span></span><br><span class="line">    &#123;</span><br><span class="line">        cell = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCellStyle</span>.<span class="type">Subtitle</span>, reuseIdentifier: <span class="string">"cellIdentifier"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> venue = venues?[indexPath.row]</span><br><span class="line">    &#123;</span><br><span class="line">        cell!.textLabel?.text = venue.name</span><br><span class="line">        cell!.detailTextLabel?.text = venue.address</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分都是易懂的代码。大致步骤如下：</p>
<ul>
<li>从重用队列中取出一个 cell。</li>
<li>如果没有 cell 存在，就以 <code>Subtitle</code> 的样式创建一个新的 cell 。</li>
<li>如果 <code>venues</code> 数组的第 <code>indexPath.row</code> 个元素存在，就赋值给常量 <code>venue</code> 。使用该数据去填充 cell 的 <code>textLabel</code> 和 <code>detailTextLabel</code> 。</li>
<li>返回 cell 。</li>
</ul>
<p>和 map view 的类似， 当 table view 需要一个 table cell 的时候，就会调用 <code>tableView:cellForRowAtIndexPath:</code> 方法。你可以使用该方法来自定义你的 table view cell。这比写个子类简单多了。</p>
<p>接下来，是 table view 的最后一个方法。把一些方法添加到 <code>ViewController</code> 类中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> venue = venues?[indexPath.row]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(<span class="type">CLLocationCoordinate2D</span>(latitude: <span class="type">Double</span>(venue.latitude), longitude: <span class="type">Double</span>(venue.longitude)), distanceSpan, distanceSpan)</span><br><span class="line">            mapView?.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户点击 cell 时，就会调用这个代理方法。代码的内容是比较简单的：当 <code>venues</code> 数组的第 <code>indexPath.row</code> 个元素存在时，使用它去填充该数据项所在区域的 map view。换句话说，把点击的项显示到 map view 的中心。</p>
<p>现在唯一剩下的事情就是，当通知事件发生时，及时地刷新 table view 数据。当数据更新时，你就想要把它们显示出来。</p>
<p>在第二个 <code>if</code> 条件判断的末尾，添加以下这行代码到 <code>refreshVenues:</code> 方法。定位到 <code>if let location = lastLocation</code> 这行代码，在该语句的有括号后面，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView?.reloadData()</span><br></pre></td></tr></table></figure>
<p>OK，现在检查一下应用能否运行。使用 Command-R 编译并运行后验证结果。如果所有的设置都正确的话，地理数据会在 table view 中显示出来。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_17.png" alt=""></p>
<h2 id="基于位置过滤地理数据">基于位置过滤地理数据</h2><p>OK，现在有个奇怪的现象，即 table view 显示了所有的数据。如果你在应用中点击过日本，然后点了旧金山，仍然会将日本的咖啡店显示在 table view 里。</p>
<p>我们当然不想要这样。因此，让我们使用一些 Realm 的小魔法只让准确的数据显示。</p>
<p>首先，把 <code>ViewController</code> 类中的 <code>venues</code> 属性改变一下。不再使用 <code>Results?</code>，而是设置为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> venues:[<span class="type">Venue</span>]?</span><br></pre></td></tr></table></figure>
<p>两者之间的区别，只是类型不同而已。之前那种是包含 <code>Venue</code> 对象的 <code>Results</code> 实例。它是 Realm 的一部分。而第二种新的类型是 <code>Venue</code> 实例的数组。</p>
<p>最大的区别是懒加载。Realm 在加载需要使用的数据时很高效，比如你的代码访问 Realm 数据。不幸的是，Realm 并不支持对属性计算后排序的特性。因此，我们需要加载所有从 Realm 获取的数据，并执行自己定义的过滤操作。通常你会使用 Realm 来处理数据检索（使用延迟加载），并给它一个过滤器。这次暂不考虑使用这种方法。</p>
<p>OK，还记得这两行代码吗？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">venues = realm.objects(<span class="type">Venue</span>)</span><br></pre></td></tr></table></figure>
<p>用以下的代码段来代替以上两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (start, stop) = calculateCoordinatesWithRegion(location)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>(format: <span class="string">"latitude &lt; %f AND latitude &gt; %f AND longitude &gt; %f AND longitude &lt; %f"</span>, start.latitude, stop.latitude, start.longitude, stop.longitude)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"></span><br><span class="line">venues = realm.objects(<span class="type">Venue</span>).<span class="built_in">filter</span>(predicate).<span class="built_in">sort</span> &#123;</span><br><span class="line">     location.distanceFromLocation($<span class="number">0</span>.coordinate) &lt;; location.distanceFromLocation($<span class="number">1</span>.coordinate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，在 <code>ViewController</code> 类里添加一下方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">calculateCoordinatesWithRegion</span><span class="params">(location:CLLocation)</span></span> -&gt; (<span class="type">CLLocationCoordinate2D</span>, <span class="type">CLLocationCoordinate2D</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(location.coordinate, distanceSpan, distanceSpan)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> start:<span class="type">CLLocationCoordinate2D</span> = <span class="type">CLLocationCoordinate2D</span>()</span><br><span class="line">    <span class="keyword">var</span> stop:<span class="type">CLLocationCoordinate2D</span> = <span class="type">CLLocationCoordinate2D</span>()</span><br><span class="line"></span><br><span class="line">    start.latitude  = region.center.latitude  + (region.span.latitudeDelta  / <span class="number">2.0</span>)</span><br><span class="line">    start.longitude = region.center.longitude - (region.span.longitudeDelta / <span class="number">2.0</span>)</span><br><span class="line">    stop.latitude   = region.center.latitude  - (region.span.latitudeDelta  / <span class="number">2.0</span>)</span><br><span class="line">    stop.longitude  = region.center.longitude + (region.span.longitudeDelta / <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (start, stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，这方法也没什么特别的。只是一些基本的数学计算，把 <code>CLLocation</code> 实例基于区域的距离转换成左上和右下两个坐标。</p>
<p>第一行代码创建了基于位置和距离的区域。接着，设置好位置和它们的经纬度。这些值是根据中心的坐标计算出来的。最后，该方法返回一个元组：两个有序的变量。</p>
<p>可以把任意顺序的类型组合成元组（译者注：如果对元组有什么不理解的话，可以查看<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html#tuples" target="_blank" rel="external">中文版官方文档</a>的相应说明）。圆括号里的变量有特定的顺序，且是不可变的数组。</p>
<p>OK，回到我们的过滤器代码（译者注：位于上上段代码）。让我们一行一行来解读。</p>
<ul>
<li>首先，创建了两个常量，<code>start</code> 和 <code>stop</code>。它们是 <code>calculateCoordinatesWithRegion:</code> 方法的返回结果。该方法返回的是一个元组，由 <code>start</code> 和 <code>stop</code> 组成。<code>calculateCoordinatesWithRegion:</code> 方法的功能就是返回当前用户的地理位置。</li>
<li>接着，创建了一个 <code>predicate</code> 变量。<code>NSPredicate</code> 是一个过滤器，它可以适用于数组，序列（译者注：也可以理解为元组）等等。<code>predicate</code> 变量定义了一个范围，<code>venues</code>数组里的 GPS 坐标必须落在该范围内。它主要是用于过滤 Realm 的数据（下一行代码会过滤）。值得注意的是，该 <code>predicate</code> 变量假设 GPS 数据是平面的，虽然地球明显是球体的。现在暂时这样假设是没事的，但是当你在南极点或北极点附近使用本应用去寻找咖啡店时就会出问题。</li>
<li>接下来，让我们来剖析一下 <code>realm</code> 对象获取数据的那部分内容。所有方法都是有关联的，也就意味着每次方法调用都用到了前一个方法调用的结果。<ul>
<li>首先，创建了一个 <code>realm</code> 变量来保存 Realm 的引用对象。</li>
<li>接着，<code>Venue</code> 的所有对象都被懒加载：<code>objects(Venue)</code>。</li>
<li>接着，过滤器（ <code>predicate</code> ）来过滤这些对象。Realm 可以快速的处理过滤，而且它并不是所有的对象都过滤，而只是过滤能访问到的对象。</li>
<li>接着，调用 Swift 本地的排序算法。这里的 <code>sort</code> 并不是 Realm 的那部分，Realm 的排序算法叫<code>sorted</code>。换句话说，这部分没用上 Realm。该排序算法会访问所有的 Realm 对象，也就意味着它们都会被加载进内存，这里也没用上 Realm 的懒加载特性。该排序算法只有一个参数：一个确定两个无序对象顺序的闭包。通过返回 <code>true</code> 或 <code>false</code>，来标识闭包里两个对象比较后的关系。在上面那段代码里，前后顺序是基于离用户位置的距离的。这也是坐标属性派上用场的地方。其中，<code>$0</code> 和 <code>$1</code> 是两个无序对象的缩写。从根本上来说，该方法将地理数据以用户位置距离远近进行排序（距离越近，排在越前面）。</li>
</ul>
</li>
</ul>
<p>就说到这里吧。以上是的代码量比较大，但是效率很高。 Realm 优化的特性，方法链（method chaining）以及 Swift 本地的排序算法可以让一大票地理数据按特定的顺序保存。而且，还有一个很炫酷的事情：随着你的移动，它会随时更新。</p>
<p>就这样了！用 Command-R 来看看应用的效果吧。干的漂亮！</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_18.png" alt=""></p>
<p>注意：不幸的是，当你在 Xcode 里模拟 GPS 坐标时，从 Foursquare 获取的数据可能会少的可怜。假如你想要获得更多数据的话，你可以去除 CoffeeAPI 中硬编码的部分，或者把地点模拟到有更多咖啡店的位置。</p>
<p>你对本教程有什么想法呢？留下你的留言和想法吧。</p>
<p>最后再安利一波。你可以从 GitHub <a href="https://github.com/reinderdevries/CoffeeGuide" target="_blank" rel="external">reinderdevries/CoffeeGuide</a> 上下载所有源代码和 Xcode 项目。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：reinder de vries，<a href="http://www.appcoda.com/foursquare-realm-swift/">原文链接</a>，原文日期：2015/11/23<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="http://www.brighttj.com">saitjr</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>我们经常说，程序员喝进去的是咖啡，吐出来的是代码。让我们换一个角度去思考，来做一个显示附近咖啡店的 App。</p>
<p>这篇文章中，用到了以下技能：</p>
<ul>
<li>Swift，Xcode 和 Interface Builder（Auto Layout, Constraints 和 Storyboards）</li>
<li>Realm，一种本地存储方案，轻量级的 Core Data</li>
<li>使用 Foursquare 和 Das Quadrat 库访问 REST API</li>
<li>CocoaPods 和 Geolocation</li>
</ul>
<p>这个 App 可以检测当前用户的 500 平方米的范围，并从 Foursquare 拿到附近咖啡店的地理信息。我们将使用 map view（<code>MKMapView</code>）和一个 table view（<code>UITableView</code>）来展示数据。当然，还要使用 Realm 来过滤数据，并使用闭包来对数据进行排序。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Friday Q&A 2015-12-11：Swift 中的弱引用]]></title>
    <link href="http://swiftggteam.github.io/2015/12/28/friday-qa-2015-12-11-swift-weak-references/"/>
    <id>http://swiftggteam.github.io/2015/12/28/friday-qa-2015-12-11-swift-weak-references/</id>
    <published>2015-12-27T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-11<br>译者：<a href="http://weibo.com/riven0951" target="_blank" rel="external">riven</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即便你已经在火星的一个洞穴里，紧闭着你的双眼并且捂住你的耳朵，<a href="https://swift.org/" target="_blank" rel="external">也避免不了 Swift 已经开源的事实</a>。正因为开源，我们能够更加方便地去探索 Swift 中的很多有趣的特性，其中之一便是 Swift 中弱引用是如何工作的问题。</p>
<a id="more"></a>
<h3 id="弱引用">弱引用</h3><p>在采用垃圾回收器或者引用计数进行内存管理的语言中，强引用可以使得特定的对象一直存活，但弱引用就无法保证。当一个对象被强引用时，它是不能够被销毁的；但是如果它是个弱引用，就可以。</p>
<p>当我们所提到「弱引用」时，通常的意思是指一个<em>归零</em>弱引用（Zeroing Weak Reference）。也就是说，当弱引用的目标对象被销毁时，弱引用就会变成 <code>nil</code>（校者注：<a href="https://www.mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.html" target="_blank" rel="external">看这篇文章了解更多</a>）。非归零弱引用也是存在的，它会导致一些陷阱（Trap）、崩溃（Crash）或者未定义行为的调用。比如你在 Objective-C 中使用 unsafe_unretained，或者在 Swift 中使用 unowned（Objective-C 未定义行为处理方式，而 Swift 却很可靠地处理这些崩溃）。</p>
<p>归零弱引用很方便使用，在基于引用计数进行内存管理的语言中他们是非常有用的。它们允许循环引用存在却不会产生死循环，并且不需要手动打破逆向引用。他们非常的有用，在苹果引入 ARC 和让弱引用在垃圾收集代码之外的语言层面上可用之前，<a href="https://www.mikeash.com/pyblog/introducing-mazeroingweakref.html" target="_blank" rel="external">我就已经实现了我自己的弱引用版本</a>。</p>
<h3 id="它是如何工作的呢？">它是如何工作的呢？</h3><p>归零弱引用比较典型的实现方式是保持一个对每个对象的所有弱引用列表。当对一个对象创建了弱引用，这个引用就会被添加到这个列表中。当这个引用被重新赋值或者超出了其作用域，它就会从列表中被移除。当一个对象被销毁，这个列表中的所有引用都会被归零。在多线程的情况下，其实现必须是同步获取一个弱引用并销毁一个对象，以避免竞态条件的出现：比如当一个线程释放某个对象的最后一个强引用而同时另一个线程却试图加载一个它的一个弱引用。</p>
<p>在我的实现中，每一个弱引用都是一个完整的对象。弱引用列表是一个弱引用对象的集合。虽然由于额外的转换和内存使用让效率变低了，但这种方式可以很方便的让这些引用变成完整的对象。</p>
<p>苹果公司的 Objective-C 的实现是这样的，每一个弱引用是一个指向目标对象的普通指针。编译器并不直接读写指针，而是使用一些帮助函数。当存储一个弱指针时，存储函数会将指针的位置注册为目标对象的一个弱引用。由于读取函数被集成进了引用计数系统，这就确保了在读取一个弱指针时，不会返回一个已经被释放了的对象的指针。</p>
<h3 id="归零操作">归零操作</h3><p>让我们创建一些代码来研究一下它们究竟是怎么运行的。</p>
<p>我们希望写一个函数能够 dump 一个对象的内存内容。这个函数接受一块内存区域，将其按指针大小进行分块，并且将最终的结果转换成一个易于查看的十六进制字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">contents</span><span class="params">(ptr: UnsafePointer&lt;Void&gt;, <span class="number">_</span> length: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wordPtr = <span class="type">UnsafePointer</span>&lt;<span class="type">UInt</span>&gt;(ptr)</span><br><span class="line">    <span class="keyword">let</span> words = length / <span class="built_in">sizeof</span>(<span class="type">UInt</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> wordChars = <span class="built_in">sizeof</span>(<span class="type">UInt</span>.<span class="keyword">self</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> buffer = <span class="type">UnsafeBufferPointer</span>&lt;<span class="type">UInt</span>&gt;(start: wordPtr, <span class="built_in">count</span>: words)</span><br><span class="line">    <span class="keyword">let</span> wordStrings = buffer.<span class="built_in">map</span>(&#123; word -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> wordString = <span class="type">String</span>(word, radix: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">while</span> wordString.characters.<span class="built_in">count</span> &lt; wordChars &#123;</span><br><span class="line">            wordString = <span class="string">"0"</span> + wordString</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordString</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> wordStrings.joinWithSeparator(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数会为一个对象创建一个 dump 函数。调用时传入一个对象，它会返回一个 dump 这个对象内容的函数。在函数内部，我们给对象保存了一个 <code>UnsafePointer</code>，而不是普通的引用。这样可以确保它不会和语言的引用计数系统发生交互。它允许我们可以在这个对象被销毁之后 dump 出它的内存，后面我们会介绍。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dumperFunc</span><span class="params">(obj: AnyObject)</span></span> -&gt; (<span class="type">Void</span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="type">String</span>(obj)</span><br><span class="line">    <span class="keyword">let</span> ptr = <span class="built_in">unsafeBitCast</span>(obj, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> length = class_getInstanceSize(obj.<span class="keyword">dynamicType</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bytes = contents(ptr, length)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(objString)</span> <span class="subst">\(ptr)</span>: <span class="subst">\(bytes)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个包含弱引用变量的类，后面我会观察这个弱引用。我在弱引用变量的前后分别添加了一个 dummy 变量，以便于我们区分弱引用在 dump 出来的内存结构中的位置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakReferer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dummy1 = <span class="number">0x1234321012343210</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">WeakTarget</span>?</span><br><span class="line">    <span class="keyword">var</span> dummy2: <span class="type">UInt</span> = <span class="number">0xabcdefabcdefabcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们试一下! 我们先创建一个引用，然后 dump 它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007f8</span>a<span class="number">3861b920</span>: <span class="number">0000000107</span>ab<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>我们看到 <code>isa</code> 指针位于最开始的位置，紧随其后的是其它一些内部字段。<code>dummy1</code> 变量占据了第四块，<code>dummy2</code> 变量占据了第六块。正如我们所期望的那样，在他们之间的弱引用正好是零。</p>
<p>现在我们让这个弱引用指向一个目标对象，看看会变成什么样。我将这段代码放入一个 <code>do</code>语句中，以便于当目标对象超出作用域和被销毁时我们可以进行控制：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">NSObject</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(target)</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">&lt;NSObject: 0x7fda<span class="number">6a21c6a0</span>&gt;</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fda6a000ad0: <span class="number">00000001050</span>a<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fda<span class="number">6a21c6a0</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>正如我们期望的那样，目标对象的指针直接存储在弱引用中。在目标对象被销毁之后，我们在 <code>do</code> 代码块之后再次调用 dump 函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"></span><br><span class="line"><span class="type">WeakReferer</span> <span class="number">0x00007ffe32300060</span>: 000000010cfb44a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>它被归零了。点个赞!</p>
<p>仅仅为了好玩，我们用一个纯 Swift 对象作为对象来重复这个实验。不必要时，我并不是很想使用 Objective-C 中的东西。下面是一个纯 Swift 对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>让我们试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br></pre></td></tr></table></figure>
<p>目标对象像我们期望的那样被归零了，然后被重新赋值：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fbe95121ce0 abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>然后当目标对象被销毁，引用应该被归零：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fbe95121ce0 abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>不幸的是它并没有被归零。可能是目标对象没有被销毁。一定是有某些东西让它继续活着！让我们再检查一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码，结果如下：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fd<span class="number">29a42a920</span> abcdefabcdefabcd</span><br><span class="line">WeakTarget deinit</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fd<span class="number">29a42a920</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>它消失了，但是弱引用并没有归零。怎么回事呢，我们发现了 Swift 的一个 bug！很神奇，这个 bug 一直没有被解决。你会想之前肯定已经有人已经注意到了这个问题。接下来，我们通过访问弱引用来产生一个崩溃，然后我们可以用这个 Swift 工程提交这个 bug ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">        <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(referer.target)</span><br></pre></td></tr></table></figure>
<p>下面就是崩溃信息：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>ff7aa2157f0 abcdefabcdefabcd</span><br><span class="line">WeakTarget deinit</span><br><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>ff7aa2157f0 abcdefabcdefabcd</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>哦，我的天呐！大爆炸在哪呢？应该有一个惊天动地的大爆炸呀！输出的内容表明一切工作正常，但我们可以清楚地从 dump 内容看到它并没有正常工作。</p>
<p>让我们再仔细检查一下。下面是一个经过修改的 <code>WeakTarget</code> 类，我们添加了一个 dummy 变量以便于区分 dump 的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dummy = <span class="number">0x0123456789abcdef</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Weak target deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一段新的代码，运行的程序和之前的基本相同，只不过每次 dump 都会输出两个对象（校者注：Target 和 Referer）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">let</span> targetDump: <span class="type">Void</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    targetDump = dumperFunc(target)</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line"></span><br><span class="line">    referer.target = target</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br><span class="line"><span class="built_in">print</span>(referer.target)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br></pre></td></tr></table></figure>
<p>让我们检查一下输出内容。referer 对象的生命周期和之前一样，它的 <code>target</code> 字段被顺利的归零了：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p><code>target</code> 首先作为一个普通对象，在各种头字段之后紧跟着我们的 <code>dummy</code> 字段：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>在给 <code>target</code> 字段赋值后，我们可以看到被填充的指针的值：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fe<span class="number">17341d270</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p><code>target</code> 对象还是和之前一样，但是它其中一个头字段增加了 2：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>目标对象像我们期望的那样被销毁了：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">Weak <span class="keyword">target</span> deinit</span><br></pre></td></tr></table></figure>
<p>我们看到引用对象一直都有一个指针指向目标对象：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fe<span class="number">17341d270</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>并且目标对象本身一直存活着。和上次我们看到的相比，它的头字段减少了 2：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000002</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>访问 <code>target</code> 字段会产生 <code>nil</code> ，即便它没有被归零：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>再次 dump referer 对象的内容，从中我们看出仅仅访问 <code>target</code> 字段的行为已经改变了它。现在它被归零了：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>目标对象现在被完全抹掉了：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: 200007fe<span class="number">17342a04 30</span>0007fe<span class="number">17342811</span> ffffffffffff0002</span><br></pre></td></tr></table></figure>
<p>现在变的越来越有趣了。我们看到头字段会一会儿增加，一会儿减少；让我们看看是否能有重现出更多的信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line"><span class="keyword">let</span> targetDump = dumperFunc(target)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> a = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> b = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> <span class="built_in">c</span> = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> d = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> e = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> g = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> h = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> i = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> j = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> k = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00600000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00800000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00a00000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000008</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c0000000</span>c <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000010</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000014</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000018</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c0000001</span>c <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>我们看到每一个新的弱引用会让头字段中的第一个数增加 2。每一个新的强引用会让头字段中的第二个数增加 4。</p>
<p>回顾一下，下面这些就是目前我们所发现的：</p>
<ul>
<li>在内存中弱指针和普通指针是一样的.</li>
<li>当一个弱目标对象（WeakTarget）的 <code>deinit</code> 方法调用时，目标对象是<em>不会</em>被释放的，并且弱指针也<em>不会</em>被归零。</li>
<li>当目标对象的 <code>deinit</code> 方法执行之后，访问弱指针，它就会被归零并且弱目标对象也会被释放。</li>
<li>弱目标对象包含一个弱引用的引用计数，与强引用计数分离开。</li>
</ul>
<h3 id="Swift_代码">Swift 代码</h3><p>既然 Swift 已经开源，我们可以通过查看源代码来继续我们的观察。</p>
<p>在 Swift 标准库中用 <code>HeapObject</code> 类型来表示一个分配在堆上的对象，其实现可参考 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/SwiftShims/HeapObject.h#L33" target="_blank" rel="external">stdlib/public/SwiftShims/HeapObject.h</a>。看起来是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">struct HeapObject &#123;</span><br><span class="line">/// 这始终是一个有效的元数据对象的指针。</span><br><span class="line">struct HeapMetadata const *metadata;</span><br><span class="line"></span><br><span class="line">SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;</span><br><span class="line">// FIXME: 在 32 位的平台上分配了两个字大小的元数据。</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">HeapObject() = default;</span><br><span class="line"></span><br><span class="line">// 给新分配的堆内存初始化空间（对象alloc，是分配的堆内存）。</span><br><span class="line">constexpr HeapObject(HeapMetadata const *newMetadata) </span><br><span class="line">    : metadata(newMetadata)</span><br><span class="line">    , refCount(StrongRefCount::Initialized)</span><br><span class="line">    , weakRefCount(WeakRefCount::Initialized)</span><br><span class="line">&#123; &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Swift 的 <code>metadata</code> 字段就相当于 Objective-C 的 <code>isa</code> 字段，并且它们是兼容的。还有一些像 <code>NON_OBJC_MEMBERS</code> 这样的宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span><br><span class="line">  StrongRefCount refCount;                      \</span><br><span class="line">  WeakRefCount weakRefCount</span></span><br></pre></td></tr></table></figure>
<p>噢，快看！这就是我们的两个引用计数。</p>
<p>(附加问题：为什么这里强引用在前面，而在 dump 时确是弱引用在前面？)</p>
<p>引用计数是通过位于 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">stdlib/public/runtime/HeapObject.cpp</a> 文件中的一系列函数来进行管理的。比如，下面的 <code>swift_retain</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::swift_retain(HeapObject *object) &#123;</span><br><span class="line">SWIFT_RETAIN();</span><br><span class="line">    _swift_retain(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swift_retain_(HeapObject *object) &#123;</span><br><span class="line">    _swift_retain_inlined(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> swift::_swift_retain = _swift_retain_;</span><br></pre></td></tr></table></figure>
<p>这里面拐了几个弯，但它最终是调用头文件中的内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _swift_retain_inlined(HeapObject *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (object) &#123;</span><br><span class="line">    object-&gt;refCount.increment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，它会增加引用计数。下面是 increment 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  __atomic_fetch_add(&amp;refCount, RC_ONE, __ATOMIC_RELAXED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RC_ONE</code> 来自于一个枚举类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  RC_PINNED_FLAG = <span class="number">0x1</span>,</span><br><span class="line">  RC_DEALLOCATING_FLAG = <span class="number">0x2</span>,</span><br><span class="line"></span><br><span class="line">  RC_FLAGS_COUNT = <span class="number">2</span>,</span><br><span class="line">  RC_FLAGS_MASK = <span class="number">3</span>,</span><br><span class="line">  RC_COUNT_MASK = ~RC_FLAGS_MASK,</span><br><span class="line"></span><br><span class="line">  RC_ONE = RC_FLAGS_MASK + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相信你已经明白为什么每一个新的强引用会让头字段增加 4 了吧。这个枚举类型的前两位用来作为标志位。回想一下之前的 dump 结果，我们可以看到这些标志位。下面是一个弱目标对象在最后一个强引用消失之前和之后的结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">Weak target deinit</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000002</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>其中第二个字段开始是 4，表示引用计数为 1 并且没有标志位，之后变成了 2，表示引用计数为 0 和 <code>RC_DEALLOCATING_FLAG</code> 标志位被设定了。这个被析构的对象被放在了处于 <code>DEALLOCATING</code> 状态的位置。</p>
<p>（顺便说一句，<code>RC_PINNED_FLAG</code> 到底是用来干什么的呢？我查找了相关代码，除了能够表明一个「固定的对象（pinned object）」外，其它对于这个标记一无所知。如果你弄清楚了或者有一些相关的猜测，请给我留言。）</p>
<p>现在让我们看一看弱引用计数的实现。它有同样的枚举结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  <span class="comment">// There isn't really a flag here.</span></span><br><span class="line">  <span class="comment">// Making weak RC_ONE == strong RC_ONE saves an</span></span><br><span class="line">  <span class="comment">// instruction in allocation on arm64.</span></span><br><span class="line">  RC_UNUSED_FLAG = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RC_FLAGS_COUNT = <span class="number">1</span>,</span><br><span class="line">  RC_FLAGS_MASK = <span class="number">1</span>,</span><br><span class="line">  RC_COUNT_MASK = ~RC_FLAGS_MASK,</span><br><span class="line"></span><br><span class="line">  RC_ONE = RC_FLAGS_MASK + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是 2 的来源：其中有一个保留的标志位，目前尚未被使用。奇怪的是，关于这段代码的注释似乎是不正确的，这的 <code>RC_ONE</code> 等于 2，而强引用的 <code>RC_ONE</code> 等于 4。我猜它们曾经是相等的，但后来它被修改了而注释却没有更新。我只是想表明如果注释是无用的，那你为什么还要写它呢。</p>
<p>所有这些是如何和加载弱引用相关联的呢？它是由 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/runtime/HeapObject.cpp#L636" target="_blank" rel="external">swift_weakLoadStrong</a> 函数来处理的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HeapObject *swift::swift_weakLoadStrong(WeakReference *ref) &#123;</span><br><span class="line">  <span class="keyword">auto</span> object = ref-&gt;Value;</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (object-&gt;refCount.isDeallocating()) &#123;</span><br><span class="line">    swift_weakRelease(object);</span><br><span class="line">    ref-&gt;Value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> swift_tryRetain(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，惰性归零是如何工作的已经一目了然了。当加载一个弱引用时，如果目标对象正在被销毁，就会对这个引用进行归零。反之，会保留目标对象并返回它。进一步深挖一点，我们可以看到 <code>swift_weakRelease</code> 如何释放对象的内存，前提是它是最后一个引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::swift_weakRelease(HeapObject *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123;</span><br><span class="line">    <span class="comment">// 只有对象可以 weak-retained 和 weak-released</span></span><br><span class="line">    <span class="keyword">auto</span> metadata = object-&gt;metadata;</span><br><span class="line">    assert(metadata-&gt;isClassObject());</span><br><span class="line">    <span class="keyword">auto</span> classMetadata = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> ClassMetadata*&gt;(metadata);</span><br><span class="line">    assert(classMetadata-&gt;isTypeMetadata());</span><br><span class="line">    swift_slowDealloc(object, classMetadata-&gt;getInstanceSize(),</span><br><span class="line">                      classMetadata-&gt;getInstanceAlignMask());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：如果你正在查看版本库中的代码，使用「weak」命名的地方大多数都改成了「unowned」。上面的命名是截至撰写本文时最新的快照，但开发仍在继续。你可以查看和我这对应的版本库中的 2.2 版本的快照，或者获取最新的版本但是要注意命名的变化，并且实现也有可能发生了改变。)</p>
<h3 id="整合">整合</h3><p>我们已经在层级上自上往下地看到了 Swift 中的弱引用是如何实现的。那么在高层观察 Swift 的弱引用又是如何工作的呢？</p>
<ol>
<li>弱引用只是指向目标对象的指针。</li>
<li>在 Objective-C 中是<em>没有</em>办法单独追踪弱引用的。</li>
<li>相反，每一个 Swift 对象都有一个弱引用计数，和它的强引用计数相邻。</li>
<li>Swift 将对象的析构过程（deinit）和对象的释放（dealloc）解耦。一个对象可以被析构并释放它的外部资源，但不必释放对象本身所占用的内存。</li>
<li>当一个 Swift 对象的强引用计数变成零而弱引用计数仍大于零时，那么这个对象会被析构，但是不会被释放。</li>
<li>这意味着一个被释放对象的弱指针<em>仍然是一个有效的指针</em>，它可以被反向引用而不会崩溃或者加载垃圾数据。它们只是指向一个处于僵尸状态的对象。</li>
<li>当一个弱引用被加载时，运行时会检查目标对象的状态。如果目标对象是一个僵尸对象，然后它会对弱引用进行归零，也就是减少弱引用计数并返回 <code>nil</code>。</li>
<li>当僵尸对象的所有弱引用都被归零，那么这个僵尸对象就会被释放。</li>
</ol>
<p>比起 Objective-C 中的实现，这种设计会带来一些有趣的结果：</p>
<ul>
<li>不需要维护一个弱引用列表。这样既简化代码也提高了性能。</li>
<li>在一个线程归零一个弱引用和另外一个线程加载一个弱引用之间就不会存在竞态条件了。这也意味着加载一个弱引用和销毁一个弱引用对象不需要加锁。这也提高了性能。</li>
<li>一个对象即便没有了强引用，但是弱引用任然会导致该对象被分配的内存被占用，直到所有弱引用被加载或者被丢弃。这种做法临时增加了内存使用。但是要注意的是这个影响很小，当目标对象没有被释放时，它所占的内存大小只是实例本身。当最后一个强引用变成零时，所有的外部资源（包括用于存储的 <code>Array</code> 或 <code>Dictionary</code> 属性）都会被释放。弱引用会导致被分配的单个实例不会被释放，而不是整个对象树。</li>
<li>每一个对象都需要额外的内存来存储弱引用计数。但在实际的 64 位系统中，这似乎是无关紧要的。头字段要占据所有指针大小的块的数量，并且强和弱引用计数共享一个头字段。如果没有弱引用计数，强引用计数就会占据整个 64 位。通过使用<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="external">非指针（non-pointer）</a> <code>isa</code> 可以将强引用移到 <code>isa</code> 中，但我不确定那是不是很重要或者它未来会如何发展。 对于 32 位系统，弱引用计数会将对象的大小增加四个字节。然而，32 位系统如今已经没有那么重要了.</li>
<li>因为访问一个弱指针是如此的方便，所以 <code>unowned</code> 的语义也采用了相同的机制来实现。<code>unowned</code> 和 <code>weak</code> 工作方式是一样的，只是当目标对象被释放，<code>unowned</code> 会给你一个大大的失败，而不是给你返回一个 <code>nil</code> 。在 Objective-C 中，<code>__unsafe_unretained</code> 是作为一个带有未定义行为的原始指针来实现的，你可以快速的访问它，毕竟加载一个弱指针还是有点慢。</li>
</ul>
<h3 id="总结">总结</h3><p>Swift 的弱指针通过一种有趣的方式，既保证了速度和正确性，也保证较低的内存开销。通过追踪每个对象的弱引用计数，将对象的销毁和对象的析构过程分离开来，弱引用问题被安全而又快速的得到解决。正是由于可以查看标准库的源代码，这让我们可以在源代码级别看到究竟发生了什么，而不是像我们之前通过反编译和 dump 内存来进行研究。当然，正如你上面看到的那样，我们很难完全打破这个习惯。</p>
<p>今天就这样了。下次回来会带来更多的干货。由于假期的缘故，可能需要几周，但是我会在之前发布一篇稍微短一点的文章。不管怎样，给接下来的话题提更多的建议吧。周五问答是由读者们的想法驱动的，如果你有一个你希望了解的想法，<a href="mailto:mike@mikeash.com" target="_blank" rel="external">请告知我</a>!</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html">原文链接</a>，原文日期：2015-12-11<br>译者：<a href="http://weibo.com/riven0951">riven</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即便你已经在火星的一个洞穴里，紧闭着你的双眼并且捂住你的耳朵，<a href="https://swift.org/">也避免不了 Swift 已经开源的事实</a>。正因为开源，我们能够更加方便地去探索 Swift 中的很多有趣的特性，其中之一便是 Swift 中弱引用是如何工作的问题。</p>]]>
    
    </summary>
    
      <category term="Mike Ash" scheme="http://swiftggteam.github.io/tags/Mike-Ash/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于 Swift 演变的趣味探讨]]></title>
    <link href="http://swiftggteam.github.io/2015/12/25/interesting-discussions-on-swift-evolution/"/>
    <id>http://swiftggteam.github.io/2015/12/25/interesting-discussions-on-swift-evolution/</id>
    <published>2015-12-24T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/" target="_blank" rel="external">原文链接</a>，原文日期：2015/12/15<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>记得我曾分享过一些想法和建议，比如：</p>
<h3 id="newtype">newtype</h3><p>一个是建议 Swift 推出一个 <code>newtype</code> 的关键词，它可以添加完全不同于原生的可扩展的派生类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newtype <span class="type">Currency</span> = <span class="type">NSDecimal</span></span><br></pre></td></tr></table></figure>
<p>这创建了一个拥有所有 <code>NSDecimal</code> 所有行为的 <code>Currency</code> 类型。然而，你不能让一个 <code>NSDecimal</code> 类型的元素和一个 <code>Currency</code> 类型的元素相加，因为 Swift 中有类型检测。此外，你也可以扩展 <code>Currency</code> 类型。这样看起来就更加有针对性，因为不需要子类化或者添加新的存储属性。</p>
<a id="more"></a>
<p><code>newtype</code> 的另一个特性是能够创建柯里化类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newtype <span class="type">Counter</span>&lt;<span class="type">A</span>&gt; = <span class="type">Dictionary</span>&lt;<span class="type">A</span>, <span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>
<p>类型是部分确定的，具体行为可以在扩展中实现，从而能包含键（key）类型不相同但值类型都是 Int 的字典。</p>
<p>期待看到你们的评论。</p>
<h3 id="self">self</h3><p>另外一个提议是将 <code>self</code> 作为强制前缀，取代上下文语境推断。Greg Parker 在回复中写道：</p>
<blockquote>
<p>在 Objective-C 中 <code>self.property</code> 这种写法很不优雅。</p>
<p>第一种方法是只使用 <code>property</code>。但是同名变量（ivar）会产生歧义，Swift 没有这样的问题。</p>
<p>第二种方法是用 <code>property</code> 访问属性，用 <code>self-&gt;ivar</code> 去访问同名变量。这是不可行的，因为会和现有的大量代码冲突。Swift 也没有这样的问题。</p>
</blockquote>
<h3 id="前置条件与断言（Precondition_vs_Assert）">前置条件与断言（Precondition vs Assert）</h3><p>Dave Abrahams 提出了一个有关重命名断言和前置条件的建议，我立刻将其中的一些深刻见解记在笔记本上：</p>
<blockquote>
<p>从语言设计层面来说，这两个函数扮演不同的角色：<br>– assert：检查内部的错误代码。<br>– precondition：检查客户端给你的参数是否有效。</p>
<p>两者的区别很大，第二个要求有公共文档，第一个不需要。</p>
<p>例如：在 Swift 的标准库中，我们保证永远不会出现内存错误，除非你调用 (Obj)C 代码或者使用一个明确地标着「unsafe」的结构。我们需要去检验客户端参数，为了避免给了非法的参数引起内存泄露，我们要在参数中文档化这些需求作为前置条件，并且使用（等价的）precondition() 去检验它。我们还有一系列的内部合理检查，用以确定我们代码假定的正确性，而类型系统还不能保证这个代码的假定。由于这些原因，我们使用（等价的）assert()，因为我们不想降低<em>你的</em>代码性能（使用合理的检查）。</p>
<p>下面是几个具体的例子：</p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一个集合，其中的元素类型为 Element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Repeat</span>&lt;<span class="title">Element</span>&gt; : <span class="title">CollectionType</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/// 获取 `position` 位置的元素</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - 要求: `position` 是 `self` 中的有效位置并且 `position != endIndex`.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">    _precondition(position &gt;= <span class="number">0</span> &amp;&amp; position &lt; <span class="built_in">count</span>, <span class="string">"Index out of range"</span>)</span><br><span class="line">    <span class="keyword">return</span> repeatedValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">UTF8View</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">_encodeSomeContiguousUTF16AsUTF8</span><span class="params">(i: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">UTF8Chunk</span>) &#123;</span><br><span class="line">    _sanityCheck(elementWidth == <span class="number">2</span>)</span><br><span class="line">    _sanityCheck(!_baseAddress._isNull)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> storage = <span class="type">UnsafeBufferPointer</span>(start: startUTF16, <span class="built_in">count</span>: <span class="keyword">self</span>.<span class="built_in">count</span>)</span><br><span class="line">    <span class="keyword">return</span> _transcodeSomeUTF16AsUTF8(storage, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一个例子中，我们有一个判断客户的 collection 没有越界的前置条件。在这个例子中，我们其实可以不做检查，因为越界也不会导致内存错误（因为返回的都是同一个 repeatedValue），但是我们还是加上了这个检查，这样我们的用户可以快速发现他们的 bug 。</p>
<p>第二个例子中是一个私有函数，它只能在我们保证 elementWidth == 2 和 _baseAddress 不为 null 的条件下调用（_sanityCheck 在 stdlib 下等价于 assert）。因为这是私有函数，使用者就是我们自己，所以看起来这个检查可以省略。但是有时候会出意外，比如后续的开发者可能会错误地使用它，因此我们需要添加检查。因为我们在 debug 和 release 的环境下运行我们的测试，并且有较高的测试覆盖率，因此（如果错误使用函数）断言很可能在某处被触发。</p>
<p>读完上面的内容，你可能认为 assert() 只能在私有方法中使用，而 precondition() 只能在公共方法中使用。事实并非如此；你可以内联任何私有方法到继承的公有方法的方法体内，因此合理的检查依然有意义。前置条件检查也会偶尔在私有方法中使用，最简单的例子就是公有方法转私有方法，复制代码的时候可以把原来的前置条件检查提取成一个私有的辅助方法（Helper）。</p>
<p><sup>*</sup>注意，有些前置条件实际上不会被执行，所以你不能指望所有的前置条件都被执行。</p>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/">原文链接</a>，原文日期：2015/12/15<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>记得我曾分享过一些想法和建议，比如：</p>
<h3 id="newtype">newtype</h3><p>一个是建议 Swift 推出一个 <code>newtype</code> 的关键词，它可以添加完全不同于原生的可扩展的派生类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newtype <span class="type">Currency</span> = <span class="type">NSDecimal</span></span><br></pre></td></tr></table></figure>
<p>这创建了一个拥有所有 <code>NSDecimal</code> 所有行为的 <code>Currency</code> 类型。然而，你不能让一个 <code>NSDecimal</code> 类型的元素和一个 <code>Currency</code> 类型的元素相加，因为 Swift 中有类型检测。此外，你也可以扩展 <code>Currency</code> 类型。这样看起来就更加有针对性，因为不需要子类化或者添加新的存储属性。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Friday Q&A 2015-11-20：协变与逆变]]></title>
    <link href="http://swiftggteam.github.io/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/"/>
    <id>http://swiftggteam.github.io/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/</id>
    <published>2015-12-23T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-20<br>译者：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在现代的编程语言中，子类型（Subtypes）和超类型（Supertypes）已经成为了非常常见的一部分了。协变（Convariance）和逆变（Contravariance）则能告诉我们什么时候使用子类型或超类型会优于原来使用的类型。这在我们使用的大多数编程语言中非常的常见，但是很多开发者仍然对这些概念感到模糊不清。今天我们就来详细讨论一下。</p>
<a id="more"></a>
<h3 id="子类型（Subtypes）和超类型（Supertypes）">子类型（Subtypes）和超类型（Supertypes）</h3><p>我们都知道子类（Subclass）是什么。当你创建一个子类的时候，你就在创建一个子类型。用一个经典的例子来讲，就是用 <code>Animal</code> 的子类去创建一只 <code>Cat</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这让 <code>Cat</code> 成为了 <code>Animal</code> 的子类型，也就意味着所有的 <code>Cat</code> 都是 <code>Animal</code>。但并不意味着所有的 <code>Animal</code> 都是 <code>Cat</code>。</p>
<p>子类型通常能够替代超类型。很明显懂一点编程知识的任何程序员都知道，在 Swift 中，下面的代码的第一行能够正常的运行，然而第二行则不能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = <span class="type">Cat</span>()</span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">Cat</span> = <span class="type">Animal</span>()</span><br></pre></td></tr></table></figure>
<p>对于函数类型也是适用的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">animalF</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Animal</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">catF</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Cat</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> returnsAnimal: () -&gt; <span class="type">Animal</span> = catF  <span class="comment">//可以运行</span></span><br><span class="line"><span class="keyword">let</span> returnsCat: () -&gt; <span class="type">Cat</span> = animalF  <span class="comment">//出错</span></span><br></pre></td></tr></table></figure>
<p>这些在 Objective-C 下也能实现，只不过要用 block，而且语法上会显得比较丑。所以我坚定地使用 Swift。</p>
<p>注意，以下的代码是有问题的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">catCatF</span><span class="params">(inCat: Cat)</span></span> -&gt; <span class="type">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> inCat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animalAnimal: <span class="type">Animal</span> -&gt; <span class="type">Animal</span> = catCatF</span><br></pre></td></tr></table></figure>
<p>很困惑，不是吗？不用担心，整篇文章就是为了彻底了解为什么第一个版本是可行而第二个版本是不可行的。除此之外，我们在探索的过程中还会了解很多非常有用的东西。</p>
<h3 id="重写（Override）方法">重写（Override）方法</h3><p>类似的事情在重写方法中也能正确地执行，想象一下有这样一个类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们建立它的子类，然后重写父类的方法，并改变返回值的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyCatLady</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做对吗？对。为什么呢？</p>
<p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="external">Liskov 替换原则</a>被用于指导何时该使用子类。简明扼要的来说，它指出任何子类的实例总是能够替代父类的实例。比如你有一个 <code>Animal</code>，你就能用 <code>Cat</code> 替代它；你也总是能够用 <code>CrazyCatLady</code> 替代 <code>Person</code>。</p>
<p>下面是使用 <code>Person</code> 作为例子写的一段代码，接下来会有解释来解释清楚：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: <span class="type">Person</span> = getAPerson()</span><br><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = person.purchaseAnimal()</span><br><span class="line">animal.pet()</span><br></pre></td></tr></table></figure>
<p>想象一下当 <code>getAPerson</code> 返回一位 <code>CrazyCatLady</code>。整段代码还可行吗？<code>CrazyCatLady.purchaseAnimal</code> 会返回一只 <code>Cat</code>。这个实例被放入了 <code>animal</code> 中。<code>Cat</code> 是 <code>Animal</code> 的一种，所以它也能够做 <code>Animal</code> 能够做的事情，包括 <code>pet</code> 方法。类似，<code>CrazyCatLady</code> 返回的 <code>Cat</code> 也是有效的。</p>
<p>我们这时把 <code>pet</code> 函数放入 <code>Person</code> 类中，所以我们能够知道一个人所养的特定的动物：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">pet</span><span class="params">(animal: Animal)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然，<code>CrazyCatLady</code> 只拥有宠物猫：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyCatLady</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">pet</span><span class="params">(animal: Cat)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这样对吗？<em>不对！</em></p>
<p>为了理解为什么不对，我们来看一下使用这个方法的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: <span class="type">Person</span> = getAPerson()</span><br><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = getAnAnimal()</span><br><span class="line">person.pet(animal)</span><br></pre></td></tr></table></figure>
<p>假设 <code>getAPerson</code> 方法返回了一位 <code>CrazyCatLady</code>，第一行非常的正确：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: <span class="type">Person</span> = getAPerson()</span><br></pre></td></tr></table></figure>
<p>如果 <code>getAnAnimal</code> 方法返回了一只 <code>Dog</code>，它也是 <code>Animal</code> 的子类但是和 <code>Cat</code> 有截然不同的表现。接下来的一行看上去也非常的正确：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = getAnAnimal()</span><br></pre></td></tr></table></figure>
<p>接下来我们的 <code>person</code> 变量中有一位 <code>CrazyCatLady</code>，以及在 <code>animal</code> 变量中有一只 <code>Dog</code>，然后执行了这一行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">person.pet(animal)</span><br></pre></td></tr></table></figure>
<p>爆炸了噜！<code>CrazyCatLady</code> 的 <code>pet</code> 方法期望参数是一只 <code>Cat</code>。对于这只 <code>Dog</code> 就显得无计可施。这个方法也有可能会访问其他的属性或者调用其他 <code>Dog</code> 类所不具备的方法。</p>
<p>这段代码原本是完全正确的。首先它得到 <code>Person</code> 和 <code>Animal</code>，然后调用 <code>Person</code> 中的方法让人拥有这个 <code>Animal</code>。上面的问题在于我们把 <code>CrazyCatLady.pet</code> 方法的参数类型变成了 <code>Cat</code>。这破坏了 Liskov 替换原则：此时的 <code>CrazyCatLady</code> 并不能在任意的地方替代 <code>Person</code> 的使用。</p>
<p>感谢编译器给我们留了一手。它明白使用子类型用于重写方法的参数类型是不正确的，会拒绝编译这个代码。</p>
<p>那在重写方法时使用不同的类型究竟对不对呢？对！事实上，你需要<em>超类型（Supertype）</em>。举一个例子，假设 <code>Animal</code> 是 <code>Thing</code> 的子类，那么当我们重写 <code>pet</code> 方法时，参数类型变为 <code>Thing</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">pet</span><span class="params">(thing: Thing)</span></span></span><br></pre></td></tr></table></figure>
<p>这保证了可替换性。如果是一个 <code>Person</code>，那么这个方法所传进来的参数类型始终是 <code>Animal</code>，这是 <code>Thing</code> 的一种。</p>
<p>有个重要的规则来了：函数的返回值可以换成原类型的<em>子类型</em>，在层级上<em>降</em>了一级；反之函数的参数可以换成原类型的<em>超类型</em>，在层级上<em>升</em>了一级。</p>
<h3 id="单独的函数（Standalone_functions）">单独的函数（Standalone functions）</h3><p>这种子类型和超类型的关系我们已经在类上面了解得很清楚了。它能够通过类与类之间的层级关系直接推出。那么如果是单独的函数关系呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f1: <span class="type">A</span> -&gt; <span class="type">B</span> = ...</span><br><span class="line"><span class="keyword">let</span> f2: <span class="type">C</span> -&gt; <span class="type">D</span> = f1</span><br></pre></td></tr></table></figure>
<p>这种关系什么时候是对的，什么时候又是错的呢？</p>
<p>这可以被看做是 Liskov 替换原则的一种精简版本。 事实上，你可以把函数想象成是非常小的（mini-objects）、只有一个方法的对象。当你有两个不同的对象类型时，怎么做才能够让这两个对象也遵循我们的原则呢？只有当原对象类型是后者类型的子类型就可以了。那什么时候函数是另一个函数的子类型呢？正如上面所见，当前者的参数是后者的超类型并且返回值是后者的子类型即可。</p>
<p>把这个方法应用在这儿，上面的代码当 <code>A</code> 是 <code>C</code> 的超类型且 <code>B</code> 是 <code>D</code> 的子类型时可以正常的执行。用具体的例子来说：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f1: <span class="type">Animal</span> -&gt; <span class="type">Animal</span> = ...</span><br><span class="line"><span class="keyword">let</span> f2: <span class="type">Cat</span> -&gt; <span class="type">Thing</span> = f1</span><br></pre></td></tr></table></figure>
<p>参数和返回值的类型朝着相反的方向移动。可能不是你所想的那样，但是这就是能让函数正确执行的唯一方法。</p>
<p>这又是一个重要的规则：一个函数若是另外一个函数的子类型，那么它的参数是原函数参数的<em>超类型</em>，返回值是原函数返回值的<em>子类型</em>（译者注：又叫做 <a href="http://www.wikiwand.com/en/Robustness_principle" target="_blank" rel="external">Robustness 原则</a>）。</p>
<h3 id="属性（Property）">属性（Property）</h3><p>如果是只读的属性那就很简单。子类的属性必须是父类属性的子类型。只读的属性本质上是一个不接收参数而返回成员值的函数，所以上述的规则依旧适用。</p>
<p>可读可写的属性其实也非常的简单。子类的属性必须和父类的属性类型相同。一个可读可写的属性其实由一对函数组成。<code>Getter</code> 是一个不接收参数而返回成员值的函数，<code>Setter</code> 则是一个需要传入一个参数但无需返回值的函数。看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> animal: <span class="type">Animal</span></span><br><span class="line"><span class="comment">// 这等价于：</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setAnimal</span><span class="params">(animal: Animal)</span></span></span><br></pre></td></tr></table></figure>
<p>正如我们之前得到的结论一样，函数的参数和返回值需要各自向上和向下改变一级。然而参数和返回值的类型却是固定的，所以它们的类型都不能被改变：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意到 animal 的类型是 Animal</span></span><br><span class="line"><span class="comment">// 这样不对（向下）</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">getAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">setAnimal</span><span class="params">(animal: Cat)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也不对（向上）</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">getAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Thing</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">setAnimal</span><span class="params">(animal: Thing)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="泛型（Generics）">泛型（Generics）</h3><p>那如果是泛型呢？给定泛型类型的参数，什么时候又是正确的呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var1: <span class="type">SomeType</span>&lt;<span class="type">A</span>&gt; = ...</span><br><span class="line"><span class="keyword">let</span> var2: <span class="type">SomeType</span>&lt;<span class="type">B</span>&gt; = var1</span><br></pre></td></tr></table></figure>
<p>理论上来说，这要看泛型参数是如何使用的。一个泛型类型参数本身并不做什么事情，但是它会被用作于属性的类型、函数方法的参数类型和返回类型。</p>
<p>如果泛型参数仅仅被用作函数返回值的类型和只读属性身上，那么 <code>B</code> 需要是 <code>A</code> 的超类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var1: <span class="type">SomeType</span>&lt;<span class="type">Cat</span>&gt; = ...</span><br><span class="line"><span class="keyword">let</span> var2: <span class="type">SomeType</span>&lt;<span class="type">Animal</span>&gt; = var1</span><br></pre></td></tr></table></figure>
<p>如果泛型参数仅被用作于函数方法的参数类型，那么 <code>B</code> 需要是 <code>A</code> 的子类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var1: <span class="type">SomeType</span>&lt;<span class="type">Animal</span>&gt; = ...</span><br><span class="line"><span class="keyword">let</span> var2: <span class="type">SomeType</span>&lt;<span class="type">Cat</span>&gt; = var1</span><br></pre></td></tr></table></figure>
<p>如果泛型参数在上述提到的两方面都被使用了，那么当且仅当 <code>A</code> 和 <code>B</code> 是相同类型的时候才是有效的。这也同样适用于当泛型参数作为可读可写属性的情况。</p>
<p>这就是理论部分，看上去有些复杂但其实很简短。与此同时，Swift 寻求到了其简便的解决之道。对于两个需要相互匹配的泛型类型，Swift 要求它们的泛型参数的类型也需要相同。子类型和超类型都是不被允许的，尽管理论上可行。</p>
<p>Objective-C 事实上比 Swift 更好一些。一个在 Objective-C 中的泛型参数可以在声明时增加 <code>__covariant</code> 关键字来表示它能够接受子类型，而在声明时增加 <code>__contravariant</code> 关键字来表示它能够接受超类型。这在 <code>NSArray</code> 和其他的类的接口中有所体现：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@interface NSArray&#60;__covariant ObjectType&#62; : NSObject ...</span><br></pre></td></tr></table></figure>
<h3 id="协变和逆变（Convariance_and_Contravariance）">协变和逆变（Convariance and Contravariance）</h3><p>那些细心的读者会注意到：在标题中提到的两个词至今为止我通篇未提。现在我们既然了解了这些概念，那就来谈一下这几个专业术语。</p>
<p><em>协变（Convariance）</em>指可接受子类型。重写只读的属性是「协变的」。</p>
<p><em>逆变（Contravariance）</em>指可接受超类型。重写方法中的参数是「逆变的」。</p>
<p><em>不变（Invariance）</em>指既不接受子类型，又不接受超类型。Swift 中泛型是「不变的」。</p>
<p><em>双向协变（Bivariate）</em>指既接受子类型，又接受超类型。我想不到在 Objective-C 或 Swift 中的任何例子。</p>
<p>你会发现这种专业术语非常难记。那就对了，因为这并不重要。只要你懂得子类型、超类型，以及什么时候在特定位置适用一个类的子类或者超类就够了。在需要用到术语的时候看一下就够了。</p>
<h3 id="小结">小结</h3><p>协变和逆变决定了在特定位置该怎样使用子类型或超类型。通常出现在重写方法以及改变传入参数或者返回值类型的地方。这种情况下我们已经知道返回值必须是原来的子类型，而参数是原来的超类型。整个指导我们这么做的原则就叫做 Liskov 替换原则，意思是任何子类的实例总是能够使用在父类的实例所使用的地方。子类型和超类型就是从这条原则中衍生出来。</p>
<p>今天就到这儿了。记得回来探索更多有趣的事情；或者说就来探索有趣的事情。「更多」可能在这不适用，因为协变这件事并不是那么的令人激动。无论如何，我们的 Friday Q&amp;A 都会听从读者的建议，所以有什么更高的建议或者文章的话，记得<a href="mailto:mike@mikeash.com" target="_blank" rel="external">给我们写信</a>！</p>
<hr>
<p>译者注：</p>
<ol>
<li>Swift 中的泛型的确是「不变的（Invariance）」，但是 Swift 标准库中的 Collection 类型通常情况下是「协变的（Convariance）」。举个例子：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// 亦可以使用结构体 struct 声明</span></span><br><span class="line">    <span class="keyword">var</span> thing: <span class="type">T</span> </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> thing: <span class="type">T</span>) &#123; <span class="keyword">self</span>.thing = thing &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Thing</span>&lt;<span class="type">UIView</span>&gt; = <span class="type">Thing</span>(<span class="type">UIView</span>()) </span><br><span class="line"><span class="keyword">var</span> bar: <span class="type">Thing</span>&lt;<span class="type">UIButton</span>&gt; = <span class="type">Thing</span>(<span class="type">UIButton</span>()) </span><br><span class="line">foo = bar <span class="comment">// 报错：error: cannot assign value of type 'Thing&lt;UIButton&gt;' to type 'Thing&lt;UIView&gt;' </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 则不会报错 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> views: <span class="type">Array</span>&lt;<span class="type">UIView</span>&gt; = [<span class="type">UIView</span>()] </span><br><span class="line"><span class="keyword">var</span> buttons: <span class="type">Array</span>&lt;<span class="type">UIButton</span>&gt; = [<span class="type">UIButton</span>()] </span><br><span class="line">views = buttons</span><br></pre></td></tr></table></figure>
<ol>
<li>Swift 中的 Protocol 不支持这里的类型改变。如果某个协议是继承自另外一个协议而且尝试着「重写」父协议的方法，Swift 会把它当做是另外一个方法。举个例子：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">Thing</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SuperP</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(animal: Animal)</span></span> -&gt; <span class="type">Animal</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SubP1</span>: <span class="title">SuperP</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(thing: Thing)</span></span> -&gt; <span class="type">Cat</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SubP2</span>: <span class="title">SuperP</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(cat: Cat)</span></span> -&gt; <span class="type">Thing</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementsSubP1</span>: <span class="title">SubP1</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(thing: Thing)</span></span> -&gt; <span class="type">Cat</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Cat</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementsSubP2</span>: <span class="title">SubP2</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(cat: Cat)</span></span> -&gt; <span class="type">Thing</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Thing</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ImplementSubP1 和 ImplementSubP2 将不被认为遵循了 SuperP 的协议</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html">原文链接</a>，原文日期：2015-11-20<br>译者：<a href="https://github.com/Cee">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在现代的编程语言中，子类型（Subtypes）和超类型（Supertypes）已经成为了非常常见的一部分了。协变（Convariance）和逆变（Contravariance）则能告诉我们什么时候使用子类型或超类型会优于原来使用的类型。这在我们使用的大多数编程语言中非常的常见，但是很多开发者仍然对这些概念感到模糊不清。今天我们就来详细讨论一下。</p>]]>
    
    </summary>
    
      <category term="Mike Ash" scheme="http://swiftggteam.github.io/tags/Mike-Ash/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 3 及展望]]></title>
    <link href="http://swiftggteam.github.io/2015/12/23/swift-3/"/>
    <id>http://swiftggteam.github.io/2015/12/23/swift-3/</id>
    <published>2015-12-22T16:00:00.000Z</published>
    <updated>2016-01-12T01:05:23.230Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-3/" target="_blank" rel="external">原文链接</a>，原文日期：2015/12/10<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<!--此处开始正文-->
<p>2015 年 12 月 3 日，Swift 正式开源。同时，官方也公布了 Swift 3 的最新消息，即 Swift 3 将会在 2016 年秋天发布。</p>
<a id="more"></a>
<h2 id="API_设计指南与_Swift_中_Objective-C_的导入">API 设计指南与 Swift 中 Objective-C 的导入</h2><p>Swift 3 的 API 设计指南将与 Objective-C 中 Cocoa 的完全不同。这就意味着 Objective-C 中的 API 映射到 Swift 时会与以往不同。<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="external">这里</a>有一个相关的例子可以研究一下。以下这行代码的方法调用是从现有的 Objective-C 中「翻译」成 Swift 的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> contentString = listItemView.stringValue.stringByTrimmingCharactersInSet(</span><br><span class="line">   <span class="type">NSCharacterSet</span>.whitespaceAndNewlineCharacterSet())</span><br></pre></td></tr></table></figure>
<p>而在 Swift 3 中同样的方法调用将会是下面这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = listItem.stringValue.trimming(.whitespaceAndNewlines)</span><br></pre></td></tr></table></figure>
<p>这样让语法看上去更「Swift 化」。然而，这也意味着已经导入的 Objective-C API 将会有很大变动，因此，现有的这些代码将会报错。</p>
<h2 id="彻底的泛型">彻底的泛型</h2><p>Swift 有泛型，但是这次是为了引进新的特性，就像递归协议约束（使得受限的扩展遵循新协议的能力），比如遵循 <code>Equatable</code> 的数组的元素也是遵循 <code>Equatable</code> 的。</p>
<h2 id="精简的语言">精简的语言</h2><p>对于那些「和 Swift 语法不是很配」的语言特性仍然会有一些小改动。同样的，这也会使得现有的这些代码报错。</p>
<h2 id="展望_Swift_3">展望 Swift 3</h2><ul>
<li><p>Swift 目前还没有在语言层面支持并发操作。取而代之的是使用 NSOpertion 或 dispatch queues 来处理。这种状况在 Swift 3 中仍然不会改变。但是，在未来（Swift 4？）可能会有一个语言层面上并发操作的支持。</p>
</li>
<li><p>Swift 和 C，特别是 Objective-C，现在已经有了很好的兼容。但是，却缺乏与 C++ 的兼容。虽然，这也不会在 Swift 3 上有所改变，但是这需要一个比较长期的目标来引进它。</p>
</li>
</ul>
<h2 id="小结">小结</h2><p>首先，Swift 将会在未来大规模的改善和提升，这是一个非常好的消息。另一方面，Swift 3 的发布会使得现有的 Swift 2 代码报错，因此，需要做一些代码迁移的工作才行。</p>
<h2 id="参考">参考</h2><p><a href="http://swift.org/" target="_blank" rel="external">Swift.org</a><br><a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">Swift Programming Language Evolution</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-3/">原文链接</a>，原文日期：2015/12/10<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<!--此处开始正文-->
<p>2015 年 12 月 3 日，Swift 正式开源。同时，官方也公布了 Swift 3 的最新消息，即 Swift 3 将会在 2016 年秋天发布。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
