<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SwiftGG]]></title>
  <subtitle><![CDATA[走心的 Swift 翻译组]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://swiftggteam.github.io/"/>
  <updated>2015-12-10T01:00:18.924Z</updated>
  <id>http://swiftggteam.github.io/</id>
  
  <author>
    <name><![CDATA[SwiftGG]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[化零为整：Reduce 详解]]></title>
    <link href="http://swiftggteam.github.io/2015/12/10/reduce-all-the-things/"/>
    <id>http://swiftggteam.github.io/2015/12/10/reduce-all-the-things/</id>
    <published>2015-12-09T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/11/30/reduce-all-the-things/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-30<br>译者：<a href="undefined">PMST</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即使早在 Swift 正式发布之前，iOS / Cocoa 开发者都可以使用诸如 ObjectiveSugar 或者 ReactiveCocoa 第三方库，实现类似 <code>map</code>、<code>flatMap</code> 或 <code>filter</code> 等函数式编程的构建。而在 Swift 中，这些家伙（<code>map</code> 等几个函数）已经入驻成为「头等公民」了。比起标准的 <code>for</code> 循环，使用函数式编程有很多优势。它们通常能够更好地表达你的意图，减少代码的行数，以及使用链式结构构建复杂的逻辑，更显清爽。</p>
<a id="more"></a>
<p>本文中，我将介绍附加于 Swift 中的一个非常酷的函数：「Reduce」。相对于 <code>map</code> / <code>filter</code> 函数，<code>reduce</code> 有时不失为一个更好的解决方案。</p>
<h3 id="一个简单的问题">一个简单的问题</h3><p>思考这么一个问题：你从 JSON 中获取到一个 persons 列表，意图计算所有来自 California 的居民的平均年龄。需要解析的数据如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> persons: [[<span class="type">String</span>: <span class="type">AnyObject</span>]] = [[<span class="string">"name"</span>: <span class="string">"Carl Saxon"</span>, <span class="string">"city"</span>: <span class="string">"New York, NY"</span>, <span class="string">"age"</span>: <span class="number">44</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Travis Downing"</span>, <span class="string">"city"</span>: <span class="string">"El Segundo, CA"</span>, <span class="string">"age"</span>: <span class="number">34</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Liz Parker"</span>, <span class="string">"city"</span>: <span class="string">"San Francisco, CA"</span>, <span class="string">"age"</span>: <span class="number">32</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"John Newden"</span>, <span class="string">"city"</span>: <span class="string">"New Jersey, NY"</span>, <span class="string">"age"</span>: <span class="number">21</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Hector Simons"</span>, <span class="string">"city"</span>: <span class="string">"San Diego, CA"</span>, <span class="string">"age"</span>: <span class="number">37</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Brian Neo"</span>, <span class="string">"age"</span>: <span class="number">27</span>]] <span class="comment">//注意这家伙没有 city 键值</span></span><br></pre></td></tr></table></figure>
<p>注意最后一个记录，它遗漏了问题中 person 的居住地 city 。对于这些情况，默默忽略即可…</p>
<p>本例中，我们期望的结果是那三位来自 California 的居民。让我们尝试在 Swift 中使用 <code>flatMap</code> 和 <code>filter</code> 来实现这个任务。使用 <code>flatMap</code> 函数替代 <code>map</code> 函数的原因在于前者能够忽略可选值为 nil 的情况。例如 <code>flatMap([0,nil,1,2,nil])</code> 的结果是 <code>[0,1,2]</code>。处理那些没有 city 属性的情况这会非常有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">infoFromState</span><span class="params">(state state: String, persons: [[String: AnyObject]])</span></span> </span><br><span class="line">     -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">	 <span class="comment">// 先进行 flatMap 后进行 filter 筛选</span></span><br><span class="line">     <span class="comment">// $0["city"] 是一个可选值，对于那些没有 city 属性的项返回 nil</span></span><br><span class="line">     <span class="comment">// componentsSeparatedByString 处理键值，例如 "New York, NY" </span></span><br><span class="line">     <span class="comment">// 最后返回的 ["New York","NY"]，last 取到最后的 NY</span></span><br><span class="line">    <span class="keyword">return</span> persons.flatMap( &#123; $<span class="number">0</span>[<span class="string">"city"</span>]?.componentsSeparatedByString(<span class="string">", "</span>).last &#125;)</span><br><span class="line">	   .<span class="built_in">filter</span>(&#123;$<span class="number">0</span> == state&#125;)</span><br><span class="line">	   .<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">personsFromState(state: <span class="string">"CA"</span>, persons: persons)</span><br><span class="line"><span class="comment">//#+RESULTS:</span></span><br><span class="line"><span class="comment">//: 3</span></span><br></pre></td></tr></table></figure>
<p>这非常简单。</p>
<p>不过，现在来思考另外一个难题：你想要获悉居住在 California 的人口数，接着计算他们的平均年龄。如果我们想要在上面函数的基础上尝试做修改，立马会发现难度不小。解决方法倒是有几种，不过大都看起来不适用函数式结构解决方案。倒是通过循环的方式能简单的解决这个问题。</p>
<p>这时候我们要琢磨为啥不适用了，原因很简单：数据的形式（Shape）改变了。而 <code>map</code>、<code>flatMap</code> 和 <code>filter</code> 函数能够始终保持数据形式的相似性。数组传入，数组返回。当然数组的元素个数和内容可以改变，不过始终是数组形式（Array-shape）。但是，上面所描述的问题要求我们最后转换成的结果是个结构体（Struct），或者说是以元组（Tuple）的形式包含<strong>一个整型平均值（平均年龄）</strong>和<strong>一个整型总和（人口数）</strong>。</p>
<p>对于这种类型的问题，我们可以使用 <code>reduce</code> 来救场。</p>
<h3 id="Reduce">Reduce</h3><p>Reduce 是 <code>map</code>、<code>flatMap</code> 或 <code>filter</code> 的一种扩展的形式（译者注：后三个函数能干嘛，reduce 就能用另外一种方式实现）。<strong>Reduce</strong> 的基础思想是将一个序列转换为一个不同类型的数据，期间通过一个<strong>累加器（Accumulator）</strong>来持续记录递增状态。为了实现这个方法，我们会向 reduce 方法中传入一个用于处理序列中每个元素的<strong>结合（Combinator）</strong>闭包 / 函数 / 方法。这听起来有点复杂，不过通过几个例子练手，你就会发现这相当简单。</p>
<p>它是 <code>SequenceType</code> 中的一个方法，看起来是这样的（简化版本）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">reduce</span><span class="generics">&lt;T&gt;</span><span class="params">(initial: T, combine: <span class="params">(T, <span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>
<p>此刻，我们拥有一个初始值（Initial value）以及一个闭包（返回值类型和初始值类型一致）。函数最后的返回值同样和初始值类型一致，为 <code>T</code>。</p>
<p>假设我们现在要实现一个 reduce 操作 — 对一个整数列表值做累加运算，方案如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">combinator</span><span class="params">(accumulator: Int, current: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> accumulator + current</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: combinator)</span><br><span class="line"><span class="comment">// 执行步骤如下</span></span><br><span class="line">combinator(<span class="number">0</span>, <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">0</span> + <span class="number">1</span> &#125; = <span class="number">1</span></span><br><span class="line">combinator(<span class="number">1</span>, <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> &#125; = <span class="number">3</span></span><br><span class="line">combinator(<span class="number">3</span>, <span class="number">3</span>) &#123; <span class="keyword">return</span> <span class="number">3</span> + <span class="number">3</span> &#125; = <span class="number">6</span></span><br><span class="line">= <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><code>[1, 2, 3]</code> 中的每个元素都将调用一次<strong>结合（Combinator）</strong>函数进行处理。同时我们使用<strong>累加器（Accumulator）</strong>变量实时记录递增状态（递增并非是指加法），这里是一个整型值。</p>
<p>接下来，我们重新实现那些函数式编程的「伙伴」（自己来写 map、flatMap 和 filter 函数）。简便起见，所有这些方法都是对 <code>Int</code> 或 <code>Optional&lt;Int&gt;</code> 进行操作的；换言之，我们此刻不考虑泛型。另外牢记下面的实现只是为了展示 <code>reduce</code> 的实现过程。原生的 Swift 实现相比较下面 reduce 的版本，速度要快很多<a href="#1">1</a>。不过，Reduce 能在不同的问题中表现得很好，之后会进一步地详述。</p>
<h3 id="Map">Map</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新定义一个 map 函数</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; (<span class="keyword">var</span> acc: [<span class="type">Int</span>], obj: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line">       acc.append(transform(obj))</span><br><span class="line">       <span class="keyword">return</span> acc</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rmap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], transform: &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>这个例子能够很好地帮助你理解 <code>reduce</code> 的基础知识。</p>
<ul>
<li>首先，elements 序列调用 reduce 方法：<code>elements.reduce...</code>。</li>
<li>然后，我们传入初始值给累加器（Accumulator），即一个 Int 类型空数组（<code>[Int]()</code>）。</li>
<li>接着，我们传入 <code>combinator</code> 闭包，它接收两个参数：第一个参数为 accumulator，即 <code>acc: [Int]</code>；第二个参数为从序列中取得的当前对象 <code>obj: Int</code>（译者注：对序列进行遍历，每次取到其中的一个对象 obj）。</li>
<li><code>combinator</code> 闭包体中的实现代码非常简单。我们对 obj 做变换处理，然后添加到累加器 accumulator 中。最后返回 accumulator 对象。</li>
</ul>
<p>相比较调用 <code>map</code> 方法，这种实现代码看起来有点冗余。的确如此！但是，上面这个版本相当详细地解释了 <code>reduce</code> 方法是怎么工作的。我们可以对此进行简化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">	<span class="comment">// $0 表示第一个传入参数，$1 表示第二个传入参数，依次类推...</span></span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123;$<span class="number">0</span> + [transform($<span class="number">1</span>)]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rmap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], transform: &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>依旧能够正常运行。这个版本都有哪些不同呢？实际上，我们使用了 Swift 中的小技巧，<code>+</code> 运算符能够对两个序列进行加法操作。因此 <code>[0, 1, 2] + [transform(4)]</code> 表达式将左序列和右序列进行相加，其中右序列由转换后的元素构成。</p>
<p>这里有个地方需要引起注意：<code>[0, 1, 2] + [4]</code> 执行速度要慢于 <code>[0, 1, 2].append(4)</code>。倘若你正在处理庞大的列表，应取代集合 + 集合的方式，转而使用一个可变的 accumulator 变量进行递增：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; (<span class="keyword">var</span> ac: [<span class="type">Int</span>], b: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span> </span><br><span class="line">	<span class="comment">// 作者提倡使用这种，因为执行速度更快</span></span><br><span class="line">	ac.append(transform(b))</span><br><span class="line">	<span class="keyword">return</span> ac</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了进一步加深对 <code>reduce</code> 的理解，我们将继续重新实现 <code>flatMap</code> 和 <code>filter</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rflatMap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>?) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), </span><br><span class="line">       combine: &#123; <span class="keyword">guard</span> <span class="keyword">let</span> m = transform($<span class="number">1</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> $<span class="number">0</span> &#125; </span><br><span class="line">		  <span class="keyword">return</span> $<span class="number">0</span> + [m]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rflatMap([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], transform: &#123; <span class="keyword">guard</span> $<span class="number">0</span> != <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;; <span class="keyword">return</span> $<span class="number">0</span> * <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// [2, 8]</span></span><br></pre></td></tr></table></figure>
<p>这里 rflatMap 和 rmap 主要差异在于，前者增加了一个 <code>guard</code> 表达式确保可选类型始终有值（换言之，摒弃那些 nil 的情况）。</p>
<h3 id="Filter">Filter</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rFilter</span><span class="params">(elements: [Int], <span class="built_in">filter</span>: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), </span><br><span class="line">       combine: &#123; <span class="keyword">guard</span> <span class="built_in">filter</span>($<span class="number">1</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> $<span class="number">0</span> &#125; </span><br><span class="line">		  <span class="keyword">return</span> $<span class="number">0</span> + [$<span class="number">1</span>]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rFilter([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], <span class="built_in">filter</span>: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;))</span><br><span class="line"><span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure>
<p>依旧难度不大。我们再次使用 guard 表达式确保满足筛选条件。</p>
<p>到目前为止，<code>reduce</code> 方法看起来更像是 <code>map</code> 或 <code>filter</code> 的复杂版本，除此之外然并卵。不过，所结合的内容不需要是一个数组，它可以是其他任何类型。这使得我们依靠一种简单的方式，就可以轻松地实现各种 reduction 操作。</p>
<h3 id="Reduce_范例">Reduce 范例</h3><p>首先介绍我最喜欢的数组元素求和范例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值 initial 为 0，每次遍历数组元素，执行 + 操作</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>仅传入 <code>+</code> 作为一个 <code>combinator</code> 函数是有效的，它仅仅是对 <code>lhs（Left-hand side，等式左侧）</code> 和 <code>rhs（Right-hand side，等式右侧）</code> 做加法处理，最后返回结果值，这完全满足 <code>reduce</code> 函数的要求。</p>
<p>另外一个范例：通过一组数字计算他们的乘积：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值 initial 为 1，每次遍历数组元素，执行 * 操作</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">1</span>, combine: *)</span><br><span class="line"><span class="comment">// 24</span></span><br></pre></td></tr></table></figure>
<p>甚至我们可以反转数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $0 指累加器（accumulator），$1 指遍历数组得到的一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; [$<span class="number">1</span>] + $<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure>
<p>最后，来点有难度的任务。我们想要基于某个标准对列表做划分（Partition）处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为元组定义个别名，此外 Acc 也是闭包传入的 accumulator 的类型</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Acc</span> = (l: [<span class="type">Int</span>], r: [<span class="type">Int</span>])</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(lst: [Int], criteria: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Acc</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> lst.<span class="built_in">reduce</span>((l: [<span class="type">Int</span>](), r: [<span class="type">Int</span>]()), combine: &#123; (ac: <span class="type">Acc</span>, o: <span class="type">Int</span>) -&gt; <span class="type">Acc</span> <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">if</span> criteria(o) &#123;</span><br><span class="line">	<span class="keyword">return</span> (l: ac.l + [o], r: ac.r)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (r: ac.r + [o], l: ac.l)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">partition</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], criteria: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">//: ([2, 4, 6, 8], [1, 3, 5, 7, 9])</span></span><br></pre></td></tr></table></figure>
<p>上面实现中最有意思的莫过于我们使用 <code>tuple</code> 作为 accumulator。你会渐渐发现，一旦你尝试将 <code>reduce</code> 进入到日常工作流中，<code>tuple</code> 是一个不错的选择，它能够将数据与 reduce 操作快速挂钩起来。</p>
<h3 id="执行效率对比：Reduce_vs-_链式结构">执行效率对比：Reduce vs. 链式结构</h3><p><code>reduce</code> 除了较强的灵活性之外，还具有另一个优势：通常情况下，<code>map</code> 和 <code>filter</code> 所组成的链式结构会引入性能上的问题，因为它们需要多次遍历你的集合才能最终得到结果值，这种操作往往伴随着性能损失，比如以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span>(&#123; $<span class="number">0</span> + <span class="number">3</span>&#125;).<span class="built_in">filter</span>(&#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;).<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br></pre></td></tr></table></figure>
<p>除了毫无意义之外，它还浪费了 CPU 周期。初始序列（即 [0, 1, 2, 3, 4]）被重复访问了三次之多。首先是 map，接着 filter，最后对数组内容求和。其实，所有这一切操作我们能够使用 <code>reduce</code> 完全替换实现，极大提高执行效率：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里只需要遍历 1 次序列足矣</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: &#123; (ac: <span class="type">Int</span>, r: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> </span><br><span class="line">   <span class="keyword">if</span> (r + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ac + r + <span class="number">3</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ac</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里给出一个快速的基准运行测试，使用以上两个版本以及 for-loop 方式对一个容量为 100000 的列表做处理操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-loop 版本</span></span><br><span class="line"><span class="keyword">var</span> ux = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="type">Array</span>(<span class="number">0</span>...<span class="number">100000</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">	ux += (i + <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xiol9.com1.z0.glb.clouddn.com/pic测试结果.png" alt="测试结果"></p>
<p>正如你所看见的，<code>reduce</code> 版本的执行效率和 <code>for-loop</code> 操作非常相近，且是链式操作的一半时间。</p>
<p>不过，在某些情况中，链式操作是优于 <code>reduce</code> 的。思考如下范例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">0</span>...<span class="number">100000</span>).<span class="built_in">map</span>(&#123; $<span class="number">0</span> + <span class="number">3</span>&#125;).<span class="built_in">reverse</span>().<span class="keyword">prefix</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 0.027 Seconds</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">0</span>...<span class="number">100000</span>).<span class="built_in">reduce</span>([], combine: &#123; (<span class="keyword">var</span> ac: [<span class="type">Int</span>], r: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line">    ac.insert(r + <span class="number">3</span>, atIndex: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ac</span><br><span class="line">&#125;).<span class="keyword">prefix</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 2.927 Seconds</span></span><br></pre></td></tr></table></figure>
<p>这里，注意到使用链式操作花费 0.027s，这与 reduce 操作的 2.927s 形成了鲜明的反差，这究竟是怎么回事呢？<a href="#2">2</a></p>
<p>Reddit 网站的搜索结果指出，从 reduce 的语义上来说，传入闭包的参数（如果可变的话，即 mutated），会对底层序列的每个元素都产生一份 copy 。在我们的案例中，这意味着 <strong>accumulator</strong> 参数 <code>ac</code> 将为 0…100000 范围内的每个元素都执行一次复制操作。有关对此更好、更详细的解释请看这篇 <a href="http://airspeedvelocity.net/2015/08/03/arrays-linked-lists-and-performance/" target="_blank" rel="external">Airspeedvelocity</a> 博客文章。</p>
<p>因此，当我们试图使用 <code>reduce</code> 来替换掉一组操作时，请时刻保持清醒，问问自己：reduction 在问题中的情形下是否确实是最合适的方式。</p>
<p>现在，可以回到我们的初始问题：计算人口总数和平均年龄。请试着用 <code>reduce</code> 来解决吧。</p>
<h3 id="再一次尝试来写_infoFromState_函数">再一次尝试来写 infoFromState 函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">infoFromState</span><span class="params">(state state: String, persons: [[String: AnyObject]])</span></span> </span><br><span class="line">      -&gt; (<span class="built_in">count</span>: <span class="type">Int</span>, age: <span class="type">Float</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在函数内定义别名让函数更加简洁</span></span><br><span class="line">      <span class="keyword">typealias</span> <span class="type">Acc</span> = (<span class="built_in">count</span>: <span class="type">Int</span>, age: <span class="type">Float</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reduce 结果暂存为临时的变量</span></span><br><span class="line">      <span class="keyword">let</span> u = persons.<span class="built_in">reduce</span>((<span class="built_in">count</span>: <span class="number">0</span>, age: <span class="number">0.0</span>)) &#123;</span><br><span class="line">	  (ac: <span class="type">Acc</span>, p) -&gt; <span class="type">Acc</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 获取地区和年龄</span></span><br><span class="line">	  <span class="keyword">guard</span> <span class="keyword">let</span> personState = (p[<span class="string">"city"</span>] <span class="keyword">as</span>? <span class="type">String</span>)?.componentsSeparatedByString(<span class="string">", "</span>).last,</span><br><span class="line">		personAge = p[<span class="string">"age"</span>] <span class="keyword">as</span>? <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 确保选出来的是来自正确的洲</span></span><br><span class="line">	    <span class="keyword">where</span> personState == state</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 如果缺失年龄或者地区，又或者上者比较结果不等，返回</span></span><br><span class="line">	    <span class="keyword">else</span> &#123; <span class="keyword">return</span> ac &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 最终累加计算人数和年龄</span></span><br><span class="line">	  <span class="keyword">return</span> (<span class="built_in">count</span>: ac.<span class="built_in">count</span> + <span class="number">1</span>, age: ac.age + <span class="type">Float</span>(personAge))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们的结果就是上面的人数和除以人数后的平均年龄</span></span><br><span class="line">  <span class="keyword">return</span> (age: u.age / <span class="type">Float</span>(u.<span class="built_in">count</span>), <span class="built_in">count</span>: u.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(infoFromState(state: <span class="string">"CA"</span>, persons: persons))</span><br><span class="line"><span class="comment">// prints: (count: 3, age: 34.3333)</span></span><br></pre></td></tr></table></figure>
<p>和早前的范例一样，我们再次使用了 <code>tuple</code> 作为 accumulator 记录状态值。除此之外，代码读起来简明易懂。</p>
<p>同时，我们在函数体中定义了一个别名 <strong>Acc</strong>：<code>typealias Acc = (count: Int, age: Float)</code>，起到了简化类型注释的作用。</p>
<h3 id="总结">总结</h3><p>本文是对 <code>reduce</code> 方法的一个简短概述。倘若你不想将过多函数式方法通过链式结构串联起来调用，<strong>亦或</strong>是数据的输出形式与传入数据的形式不一致时，reduce 就相当有用了。最后，我将向你展示通过使用 reduce 的各种范例来结束本文，希望能为你带来些许灵感。</p>
<h3 id="更多范例">更多范例</h3><p>以下范例展示了 <code>reduce</code> 的其他使用案例。请记住例子只作为展示教学使用，即它们更多地强调 reduce 的使用方式，而非为你的代码库提供通用的解决方法。大多数范例都可以通过其他更好、更快的方式来编写（即通过 extension 或 generics）。并且这些实现方式已经在许多 Swift 库中都有实现，诸如 <a href="https://github.com/oisdk/SwiftSequence" target="_blank" rel="external">SwiftSequence</a> 以及 <a href="https://github.com/ankurp/Dollar.swift" target="_blank" rel="external">Dollar.swift</a></p>
<h3 id="Minimum">Minimum</h3><p>返回列表中的最小项。显然，<code>[1, 5, 2, 9, 4].minElement()</code> 方法更胜一筹。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值为 Int.max，传入闭包为 min：求两个数的最小值</span></span><br><span class="line"><span class="comment">// min 闭包传入两个参数：1. 初始值 2. 遍历列表时的当前元素</span></span><br><span class="line"><span class="comment">// 倘若当前元素小于初始值，初始值就会替换成当前元素</span></span><br><span class="line"><span class="comment">// 示意写法： initial = min(initial, elem)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="type">Int</span>.<span class="built_in">max</span>, combine: <span class="built_in">min</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Unique">Unique</h3><p>剔除列表中重复的元素。当然，最好的解决方式是使用<code>集合（Set）</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>].<span class="built_in">reduce</span>([], combine: &#123; (a: [<span class="type">Int</span>], b: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> a.<span class="built_in">contains</span>(b) &#123;</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + [b]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// prints: 1, 2, 5, 7</span></span><br></pre></td></tr></table></figure>
<h3 id="Group_By">Group By</h3><p>遍历整个列表，通过一个鉴别函数对列表中元素进行分组，将分组后的列表作为结果值返回。问题中的鉴别函数返回值类型需要遵循 <code>Hashable</code> 协议，这样我们才能拥有不同的键值。此外保留元素的排序，而组内元素排序则不一定被保留下来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">groupby</span><span class="generics">&lt;T, H: Hashable&gt;</span><span class="params">(items: [T], f: <span class="params">(T)</span></span></span> -&gt; <span class="type">H</span>) -&gt; [<span class="type">H</span>: [<span class="type">T</span>]] &#123;</span><br><span class="line">   <span class="keyword">return</span> items.<span class="built_in">reduce</span>([:], combine: &#123; (<span class="keyword">var</span> ac: [<span class="type">H</span>: [<span class="type">T</span>]], o: <span class="type">T</span>) -&gt; [<span class="type">H</span>: [<span class="type">T</span>]] <span class="keyword">in</span> </span><br><span class="line">	   <span class="comment">// o 为遍历序列的当前元素</span></span><br><span class="line">       <span class="keyword">let</span> h = f(o) <span class="comment">// 通过 f 函数得到 o 对应的键值</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">var</span> <span class="built_in">c</span> = ac[h] &#123; <span class="comment">// 说明 o 对应的键值已经存在，只需要更新键值对应的数组元素即可</span></span><br><span class="line">	   <span class="built_in">c</span>.append(o)</span><br><span class="line">	   ac.updateValue(<span class="built_in">c</span>, forKey: h)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明 o 对应的键值不存在，需要为字典新增一个键值，对应值为 [o]</span></span><br><span class="line">	   ac.updateValue([o], forKey: h)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ac</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(groupby([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], f: &#123; $<span class="number">0</span> % <span class="number">3</span> &#125;))</span><br><span class="line"><span class="comment">// prints: [2: [2, 5, 8, 11], 0: [3, 6, 9, 12], 1: [1, 4, 7, 10]]</span></span><br><span class="line"><span class="built_in">print</span>(groupby([<span class="string">"Carl"</span>, <span class="string">"Cozy"</span>, <span class="string">"Bethlehem"</span>, <span class="string">"Belem"</span>, <span class="string">"Brand"</span>, <span class="string">"Zara"</span>], f: &#123; $<span class="number">0</span>.characters.first! &#125;))</span><br><span class="line"><span class="comment">// prints: ["C" : ["Carl" , "Cozy"] , "B" : ["Bethlehem" , "Belem" , "Brand"] , "Z" : ["Zara"]]</span></span><br></pre></td></tr></table></figure>
<h3 id="Interpose">Interpose</h3><p>函数给定一个 <code>items</code> 数组，每隔 <code>count</code> 个元素插入 <code>element</code> 元素，返回结果值。下面的实现确保了 element 仅在中间插入，而不会添加到数组尾部。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">interpose</span><span class="generics">&lt;T&gt;</span><span class="params">(items: [T], element: T, <span class="built_in">count</span>: Int = <span class="number">1</span>)</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">   <span class="comment">// cur 为当前遍历元素的索引值 cnt 为计数器，当值等于 count 时又重新置 1</span></span><br><span class="line">   <span class="keyword">typealias</span> <span class="type">Acc</span> = (ac: [<span class="type">T</span>], cur: <span class="type">Int</span>, cnt: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">return</span> items.<span class="built_in">reduce</span>((ac: [], cur: <span class="number">0</span>, cnt: <span class="number">1</span>), combine: &#123; (a: <span class="type">Acc</span>, o: <span class="type">T</span>) -&gt; <span class="type">Acc</span> <span class="keyword">in</span> </span><br><span class="line">       <span class="keyword">switch</span> a &#123;</span><br><span class="line">	  <span class="comment">// 此时遍历的当前元素为序列中的最后一个元素</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="keyword">let</span> (ac, cur, <span class="number">_</span>) <span class="keyword">where</span> (cur+<span class="number">1</span>) == items.<span class="built_in">count</span>: <span class="keyword">return</span> (ac + [o], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	  <span class="comment">// 满足插入条件</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="keyword">let</span> (ac, cur, <span class="built_in">c</span>) <span class="keyword">where</span> <span class="built_in">c</span> == <span class="built_in">count</span>:</span><br><span class="line">	     <span class="keyword">return</span> (ac + [o, element], cur + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	  <span class="comment">// 执行下一步</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="keyword">let</span> (ac, cur, <span class="built_in">c</span>):</span><br><span class="line">	     <span class="keyword">return</span> (ac + [o], cur + <span class="number">1</span>, <span class="built_in">c</span> + <span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).ac</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(interpose([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], element: <span class="number">9</span>))</span><br><span class="line"><span class="comment">// : [1, 9, 2, 9, 3, 9, 4, 9, 5]</span></span><br><span class="line"><span class="built_in">print</span>(interpose([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], element: <span class="number">9</span>, <span class="built_in">count</span>: <span class="number">2</span>))</span><br><span class="line"><span class="comment">// : [1, 2, 9, 3, 4, 9, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="Interdig">Interdig</h3><p>该函数允许你有选择从两个序列中挑选元素合并成为一个新序列返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">interdig</span><span class="generics">&lt;T&gt;</span><span class="params">(list1: [T], list2: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">   <span class="comment">// Zip2Sequence 返回 [(list1, list2)] 是一个数组，类型为元组</span></span><br><span class="line">   <span class="comment">// 也就解释了为什么 combinator 闭包的类型是 (ac: [T], o: (T, T)) -&gt; [T]</span></span><br><span class="line">   <span class="keyword">return</span> <span class="type">Zip2Sequence</span>(list1, list2).<span class="built_in">reduce</span>([], combine: &#123; (ac: [<span class="type">T</span>], o: (<span class="type">T</span>, <span class="type">T</span>)) -&gt; [<span class="type">T</span>] <span class="keyword">in</span> </span><br><span class="line">	<span class="keyword">return</span> ac + [o.<span class="number">0</span>, o.<span class="number">1</span>]</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(interdig([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], list2: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="comment">// : [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="Chunk">Chunk</h3><p>该函数返回原数组分解成长度为 <code>n</code> 后的多个数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chunk</span><span class="generics">&lt;T&gt;</span><span class="params">(list: [T], length: Int)</span></span> -&gt; [[<span class="type">T</span>]] &#123;</span><br><span class="line">   <span class="keyword">typealias</span> <span class="type">Acc</span> = (stack: [[<span class="type">T</span>]], cur: [<span class="type">T</span>], cnt: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">let</span> l = list.<span class="built_in">reduce</span>((stack: [], cur: [], cnt: <span class="number">0</span>), combine: &#123; (ac: <span class="type">Acc</span>, o: <span class="type">T</span>) -&gt; <span class="type">Acc</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">if</span> ac.cnt == length &#123;</span><br><span class="line">	  <span class="keyword">return</span> (stack: ac.stack + [ac.cur], cur: [o], cnt: <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> (stack: ac.stack, cur: ac.cur + [o], cnt: ac.cnt + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> l.stack + [l.cur]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(chunk([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], length: <span class="number">2</span>))</span><br><span class="line"><span class="comment">// : [[1, 2], [3, 4], [5, 6], [7]]</span></span><br></pre></td></tr></table></figure>
<p>函数中使用一个更为复杂的 <code>accumulator</code>，包含了 stack、current list 以及 count 。</p>
<p>译者注：有关 Reduce 底层实现，请看<a href="http://www.jianshu.com/p/06c90c0470b2" target="_blank" rel="external">这篇文章</a>。</p>
<p>2015/12/01 改动：</p>
<ol>
<li>修复 <code>rFlatMap</code> 类型签名</li>
<li>为代码范例新增注解</li>
<li>修复了变量属性为 lazy 时执行效率不一致的问题</li>
</ol>
<hr>
<p><a name="1">1、这么做的原因来看<a href="http://airspeedvelocity.net/2015/08/03/arrays-linked-lists-and-performance/" target="_blank" rel="external">这篇博文</a>。<br><a name="2">2、这篇文章的早期版本中，我错误地认为 Swift 的懒惰特性是造成这种差异的罪魁祸首。<a href="https://www.reddit.com/r/swift/comments/3uv1hy/reduce_all_the_things_alternatives_to_mapfilter/" target="_blank" rel="external">感谢 Reddit 的这个讨论指出了我的错误</a>。</a></a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/11/30/reduce-all-the-things/">原文链接</a>，原文日期：2015-11-30<br>译者：<a href="undefined">PMST</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即使早在 Swift 正式发布之前，iOS / Cocoa 开发者都可以使用诸如 ObjectiveSugar 或者 ReactiveCocoa 第三方库，实现类似 <code>map</code>、<code>flatMap</code> 或 <code>filter</code> 等函数式编程的构建。而在 Swift 中，这些家伙（<code>map</code> 等几个函数）已经入驻成为「头等公民」了。比起标准的 <code>for</code> 循环，使用函数式编程有很多优势。它们通常能够更好地表达你的意图，减少代码的行数，以及使用链式结构构建复杂的逻辑，更显清爽。</p>]]>
    
    </summary>
    
      <category term="Benedikt Terhechte" scheme="http://swiftggteam.github.io/tags/Benedikt-Terhechte/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Realm 和 Swift 创建 ToDo 应用]]></title>
    <link href="http://swiftggteam.github.io/2015/12/08/building-a-todo-app-using-realm-and-swift/"/>
    <id>http://swiftggteam.github.io/2015/12/08/building-a-todo-app-using-realm-and-swift/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Hossam Ghareeb，<a href="http://www.appcoda.com/realm-database-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-28<br>译者：<a href="http://www.futantan.com" target="_blank" rel="external">Prayer</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>智能手机的快速发展的同时，涌现出了很多对开发者友好的开发工具。这些工具不仅使得开发变得更加简单和容易，同时也保证了性能和产品质量。如今想要在 App Store 中占据一席之地，并非易事。而且想要使得应用易于扩展就更加困难了。当你成功获得百万量级的用户时，应用中的每一个细节都不能放过，并且需要在很短的时间完成对细节的打磨。所以和数据库打交道，是很多开发者都会面临的一个问题。<a id="more"></a>相信我们每个人都会因为数据库引起的各种问题而头疼不已，对于数据库，我想如今我们只有两种选择：<a href="http://www.appcoda.com/sqlite-database-ios-app-tutorial/" target="_blank" rel="external">SQLite</a> 和 <a href="http://www.appcoda.com/introduction-to-core-data/" target="_blank" rel="external">Core Data</a>。我是 Core Data 的忠实粉丝，它对记录（records）的处理和持久化数据的能力非常强大，但是我意识到，在开发应用的过程中，我在 Core Data 上浪费了太多的时间。最近，我无意中发现了 Realm，一个可以替代 SQLite 和 Core Data 的更好的解决方案。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-db-1024x683.jpg" alt=""></p>
<!--more-->
<h2 id="Realm_是什么？">Realm 是什么？</h2><p>Realm 是一个跨平台的移动终端数据库，支持 iOS（Swift 和 Objective-C 语言都支持）和 Android。Realm 的目的就是提供比 SQLite 和 Core Data 更好更快的数据库支持。它不仅仅是更好和更快，而且更加易于使用，短短几行代码就可以完成很多操作。Realm 完全免费，你可以随意使用它。Realm 是为移动设备而生的，因为在过去的十年中，移动终端的数据库技术没有任何的革新。现在如果和移动终端的数据库打交道，你只有一种选择，使用 SQLite 或者是底层封装了 SQLite 的技术比如 Core Data。Realm 的目的是更加易用，它并不是一个建立在 SQLite 之上的 ORM，而是一个基于自己的持久化引擎，简单并且快速的面向对象移动数据库。</p>
<h2 id="为什么选择_Realm？">为什么选择 Realm？</h2><p><a href="https://realm.io/cn/" target="_blank" rel="external">Realm</a>拥有令人难以置信的速度并且使用起来非常简单，你会发现，无论是想完成数据库的读还是写操作，都只需要短短的几行代码。下面我会列出它的所有优势，并说明为什么 Realm 是你在移动应用上数据库的不二选择：</p>
<ul>
<li><p><strong>安装简单</strong>：在下一个章节 — 如何使用 Realm 中你会了解到，安装 Realm 会比你想象的更为简单。使用简单的 Cocoapods 命令，你就可以完成所有的安装工作。</p>
</li>
<li><p><strong>速度更快</strong>：使用 Realm 库操作数据库的速度非常快。它比 SQLite 和 CoreData 都更加快速，<a href="https://realm.io/news/introducing-realm/#fast" target="_blank" rel="external">这里</a>有它们之间的比较指标作为证据。</p>
</li>
<li><p><strong>跨平台</strong>：Realm 的数据库文件是跨平台的，可以在 iOS 和 Android 间共享。无论你是使用 Java、Objective-C 或者 Swift，都可以使用相同的抽象模型访问。</p>
</li>
<li><p><strong>易于扩展</strong>：如果你的移动应用需要处理大量的用户数据记录，数据库的可扩展性就显得十分重要。在开始着手开发应用之前，这一点就应该被考虑在内。Realm 提供很好的可扩展性，在操作大量的数据时，速度也非常之快。选择使用 Realm 可以为你的应用带来更快的速度和更加流畅的用户体验。</p>
</li>
<li><p><strong>规范的文档和很好的支持</strong>：Realm 提供了丰富的大量条理清晰、易于阅读的文档。如果你有任何的问题，你也可以通过 Twitter、Github 或 Stackoverflow 来获得帮助。</p>
</li>
<li><p><strong>可信任</strong>：Realm 已经被大量的初创公司和大公司用于它们的移动应用中，像 Pinterest、Dubsmash 和 Hipmunk。</p>
</li>
<li><p><strong>免费</strong>：除了以上这些极好的优点以外，它还是完！全！免！费！的！</p>
</li>
</ul>
<h2 id="让我们开始动手吧">让我们开始动手吧</h2><p>让我们开始学习 Realm，使用它来构建一个简单的使用 Swift 语言的 iPhone 应用。所完成的 demo 程序是一个简单的 Todo 应用。用户可以增加任务清单，每个任务清单都能够包含多个任务。任务拥有名称、备注、到期日期，可以添加图片，并且拥有一个布尔值来表示该任务是否已经完成。在开始创建 Xcode 项目之前，我们需要先配置好 Xcode，安装使用 Realm 所需的工具。</p>
<h2 id="环境要求">环境要求</h2><p>请注意需要满足下列要求</p>
<ul>
<li>iOS 8 及更高的版本，OS X 10.9 及更高的版本</li>
<li>Xcode 6.3 及更高版本</li>
<li>Realm 有两个发行版，一个针对 Swift 2.0，另一个针对 Swift 1.2。我们推荐您使用 Swift 2.0 的版本。当然你也可以使用针对 Swift 1.2 的版本，但是以后这个版本 Realm 不会再进行更新支持，所以为了保险起见，使用 Swift 2.0 对应的版本，是个更好的选择。</li>
</ul>
<h2 id="配置_Xcode_和所需的工具">配置 Xcode 和所需的工具</h2><p>在开始配置 Xcode 项目之前，请确保运行环境已经正确安装了 CocoaPods，我们将使用它来为项目安装 Realm。如果对 <a href="https://cocoapods.org/" target="_blank" rel="external">CocoaPods</a> 不熟悉，你可以查看在线的教程，这些教程的材料足够让你明白如何开始使用它。</p>
<p>现在，使用 <code>Single View Application</code> 项目模板创建一个 Xcode 工程，命名为 <code>RealmTasks</code> 或者其他你喜欢的名字。请确保选择 Swift 作为开发语言。之后在终端中进入到该工程目录，使用如下命令来初始化 CocoaPods：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure>
<p>然后使用 Xcode 打开生成的 Podfile 文件，在 target 之后，添加 <code>pod &#39;RealmSwift&#39;</code>，修改完之后，应该是下面这个样子：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-podfile-1024x430.png" alt=""></p>
<p>下面运行 <code>pod install</code> 命令来把 Realm 下载安装到项目中。完成之后，你会在你的工程文件目录发现一个新生成的 Xcode 工作空间。请确保打开 <strong>RealmTasks.xcworkspace</strong> 而不是 xcodeproj。打开工作空间后，你会看到像下面这样的情形：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-pod-folder-1024x446.png" alt=""></p>
<p>现在就可以在 Xcode 中使用 Realm 啦，但是我们将安装下面的小工具来让使用 Realm 的过程更加容易。</p>
<h2 id="在_Xcode_中安装_Realm_插件">在 Xcode 中安装 Realm 插件</h2><p>Realm 开发团队提供了一个生成 Realm 模型非常有用的插件。为了安装这个插件，我们要使用 <a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>。如果你不知道 Alcatraz 是什么的话，这里解释一下，它是一个简单有用的开源包管理工具，它可以让你无需任何配置，自动地为 Xcode 安装插件、文件模板和颜色主题。为了安装 Alcatraz，你只需将以下代码复制到终端中执行，之后重启 Xcode：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>然后在 Xcode 中，选择 <code>Window</code> -&gt; <code>Package Manager</code>，如下图：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-package-manager-1024x334.png" alt=""></p>
<p>然后在弹出的窗口中，你可以选择安装你喜欢的插件或者文件模板，在搜索框中你可以搜索你喜欢的插件、配色。在搜索框输入「Realm」，在出现的结果中选择「RealmPlugin」，点击 <code>Install</code> 按钮</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-plugin-1024x996.png" alt=""></p>
<h2 id="Realm_浏览器">Realm 浏览器</h2><p>给大家介绍的最后一个工具是 Realm 浏览器。这个浏览器可以帮助你阅读和编辑你的 <code>.realm</code> 数据库文件。这些文件在应用程序中被创建，在数据库表中保存了所有的数据实体（entities）、属性（attributes）和记录（records）。之前我们说过，这些数据库文件可以在像 iOS 和 Android 这样不同的平台间共享。想要下载最新版本的 Realm 浏览器，请访问 <a href="https://itunes.apple.com/app/realm-browser/id1007457278" target="_blank" rel="external">iTunes store</a>。打开 Realm 浏览器，选择 <code>Tools</code> -&gt; <code>Generate demo database</code>。它会帮你生成 realm 数据库测试文件，你可以使用该浏览器打开和编辑它的内容。当你打开的时候，你会看到像下面的内容：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/browser.png" alt=""></p>
<p>正如你所见，在 RealmTestClass1 中，它拥有 1000 条记录，显示了多种不同的参数类型（即「列」）。我们会在下节介绍支持的属性类型。</p>
<p>现在，Realm 的所有准备工作都已就绪，那我们开始动手吧！</p>
<h2 id="数据模型类">数据模型类</h2><p>好戏才刚刚开始。首先我们来创建模型类或者说我们的数据库。为了创建 Realm 数据模型类，你只需要简单地新建一个普通的 Swift 类继承自 Object 就可以了。因为 Realm 数据模型类的基类是 Object，所以 Object 的子类都可以扩展为 Realm 的模型类。一旦创建类后，就可以添加属性了。Realm 支持以下多种数据类型：</p>
<p>– Int，Int8，Int16，Int32 和 Int64<br>– Boolean<br>– Float<br>– String<br>– NSDate<br>– NSData<br>– 继承自 Object 的类 =&gt; 作为一对一关系（Used for One-to-one relations）<br>– List<object> =&gt; 作为一对多关系（Used for one-to-many relations）</object></p>
<p>Realm 中的 List 可以包含多个 Object 实例，参考上面 demo 数据库的截图，最后一列表示在其他数据表中的存在的一组引用。在和 Realm 模型类打交道的时候，使用的方式和其他 Swift 类一样。例如，你可以添加方法或者遵循指定的协议。</p>
<p>多说无益，来看代码 😂</p>
<p>现在让我们使用之前在 Xcode 中安装的 Realm 插件来新建一个 Realm 类。打开 Xcode，新建文件，在右边的侧边栏选择 Realm：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm_model.png" alt=""></p>
<p>然后选择 Swift 语言，类名我们输入 Task。会得到如下结果：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Task_swift.png" alt=""></p>
<p>现在，可以向 Task 数据模型中添加属性了。</p>
<h2 id="属性">属性</h2><p>我们需要在数据模型中添加需要的属性。该例子中，Task 需要有 name（String），createdAt（NSDate)），notes（String），和 isCompleted（Bool）这些属性。添加这些之后，代码应该像下面这样子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> createdAt = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> notes = <span class="string">""</span></span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> isCompleted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明让 Realm 忽略的属性（Realm 将不持有这些属性）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  override static func ignoredProperties() -&gt; [String] &#123;</span></span><br><span class="line"><span class="comment">//    return []</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经为 Task 模型类添加了属性，所有的属性前面都加了 <code>dynamic var</code> 前缀，这使得属性可以被数据库读写。</p>
<p>接下来，我们要创建 TaskList 模型类，用来存储 Task 实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskList</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> createdAt = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">let</span> tasks = <span class="type">List</span>&lt;<span class="type">Task</span>&gt;()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 声明让 Realm 忽略的属性（Realm 将不持有这些属性）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  override static func ignoredProperties() -&gt; [String] &#123;</span></span><br><span class="line"><span class="comment">//    return []</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskList 模型类拥有 name，createAt 和一个包含 Task 的 List 属性。需要注意的是：</p>
<ol>
<li>List<object> 用来表示一对多的关系：一个 TaskList 中拥有多个 Task。</object></li>
<li>List 和 Array 在使用上非常相似，所用的方法和访问数据的方式（索引和下标）都相同。正如你所见的一样，List 后标明了数据类型，所包含的所有对象都应该是相同类型的。</li>
<li>List<t> 是泛型，这也是为什么我们没有在声明前面加上 dynamic 的原因，因为在 Objective-C 运行时无法表示泛型属性。</t></li>
</ol>
<p>就像在之前实现中你看到的一对多关系那样，在 Realm 中创建数据关系非常简单。在使用一对一的关系时，我们不使用 List<t> 而是使用 Object 类型，来看下面的例子：</t></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> owner:<span class="type">Person</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，owner 属性表示 Car 和 Person 之间的一对一数据关系。</p>
<p>现在基本的数据模型都已经创建好了。接下来我们会通过创建一个 ToDo 应用的过程，来讨论 Realm。首先，<a href="https://github.com/hossamghareeb/realmtasks" target="_blank" rel="external">从这里下载 app</a> 并且一窥究竟。在 Xcode 7 或更高的版本中运行，就像下面这样：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-todo-list-app-1024x661.png" alt=""></p>
<p>在项目中，我添加了两个视图控制器：TasksViewController 和 TaskListViewController。第一个视图控制器用来显示单个 task，第二个视图控制器用来显示所有的 TaskList。在 list 视图中，点击 + 按钮来添加一个任务清单。选择一个任务清单将会详情视图。你可以在这里添加多个 task。</p>
<p>了解了 demo 的大体思路之后，现在让我们来看看如何向 Realm 数据库中添加一个新的任务清单。为了实现这个功能，需要如下处理：</p>
<ol>
<li>创建 TaskList 实例对象，并将其保存到 Realm 数据库中。</li>
<li>向数据库中查询 list 数据，并更新 UI。</li>
</ol>
<p>为了在 Realm 中保存数据，你只需要实例化继承自 Object 的数据模型类，然后将对象写入到 Realm 中，下面是示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taskListA = <span class="type">TaskList</span>()</span><br><span class="line">taskListA.name = <span class="string">"Wishlist"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> wish1 = <span class="type">Task</span>()</span><br><span class="line">wish1.name = <span class="string">"iPhone6s"</span></span><br><span class="line">wish1.notes = <span class="string">"64 GB, Gold"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> wish2 = <span class="type">Task</span>(value: [<span class="string">"name"</span>: <span class="string">"Game Console"</span>, <span class="string">"notes"</span>: <span class="string">"Playstation 4, 1 TB"</span>])</span><br><span class="line"><span class="keyword">let</span> wish3 = <span class="type">Task</span>(value: [<span class="string">"Car"</span>, <span class="type">NSDate</span>(), <span class="string">"Auto R8"</span>, <span class="literal">false</span>])</span><br><span class="line"> </span><br><span class="line">taskListA.tasks.appendContentsOf([wish1, wish2, wish3])</span><br></pre></td></tr></table></figure>
<p>通过实例化 TaskList 类，我们创建了一个任务清单，之后设置了它的属性。随后我们创建了 3 个 Task 类型的对象（即 wish1，wish2 和 wish3）。这里我们演示了创建 Realm 对象的三种途径：</p>
<ol>
<li>wish1 的实例化方式：简单的实例化 Realm 类，然后设置属性。</li>
<li>wish2 的实例化方式：传入一个字典，字典中的 key 为属性名，值为要设置的值。</li>
<li>wish3 的实例化方式：使用数组传入的方式。数组中值的顺序需要和模型类中的声明顺序一致。</li>
</ol>
<h3 id="嵌套对象">嵌套对象</h3><p>在 Realm 中还可以是使用嵌套的方式来创建对象。在一对一关系和一对多关系的时候，你可以使用这种方式，这时候，一个类型对象的初始化需要一个 Object 或多个另一个类型的对象 List<object>。面临这种情况的时候，你可以选择上面的第二或者第三种方法，使用一个字典或者一个数组来表示一个对象。下面是嵌套对象的一个例子：</object></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taskListB = <span class="type">TaskList</span>(value: [<span class="string">"MoviesList"</span>, <span class="type">NSDate</span>(), [[<span class="string">"The Martian"</span>, <span class="type">NSDate</span>(), <span class="string">""</span>, <span class="literal">false</span>], [<span class="string">"The Maze Runner"</span>, <span class="type">NSDate</span>(), <span class="string">""</span>, <span class="literal">true</span>]]])</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了一个电影清单，并设置了清单名称、创建时间和清单内容，清单内容包括多个 task。每个 task 使用数组的方式来创建，例如 <code>[&quot;The Maze Runner&quot;, NSDate(), &quot;&quot;, true]</code> 表示一个 task，内容分别对应了名称、创建时间、备注和是否已经完成。</p>
<h2 id="使用_Realm_持久化对象">使用 Realm 持久化对象</h2><p>现在你应该知道了如何在 Realm 中创建和使用对象，但是为了能够在应用程序重新启动的时候使用这些数据，需要使用写事务将它们持久化到 Realm 的数据库中。当使用 Realm 来持久化数据的时候，只要这些对象已经存储成功，你可以在任何线程中获取这些对象。一个 Realm 实例表示一个 Realm 数据库。可以像下面一样实例化它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uiRealm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br></pre></td></tr></table></figure>
<p>我们常常将上面这行代码写在 <code>AppDelegate.swift</code> 文件的顶端（译者注：类之外，全局变量），这样就可以在整个项目中获得该对象的引用。之后便可以很方便地调用它的读和写方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uiRealm.write &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">  uiRealm.add([taskListA, taskListB])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，uiRealm 对象已经在 AppDelegate 中创建，在整个 app 中都可以使用。Realm 对象在每个线程中都应该只被创建一次，因为它不是线程安全的，不能在不同的线程中共享。如果你想要在另一个线程中执行写操作，那么就需要创建一个新的 Realm 对象。我将这个实例命名为 <code>uiRealm</code>，就是因为它应该只在 UI 线程中被使用。</p>
<p>现在让我们回到我们的 app 中，我们需要在用户点击 Create 按钮的时候保存任务列表。在 <code>TasksViewController</code> 的 <code>displayAlertToAddTask</code>方法中，我们有一个 <code>createAction</code> 对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createAction = <span class="type">UIAlertAction</span>(title: doneTitle, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> taskName = alertController.textFields?.first?.text</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> updatedTask != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="comment">// update mode</span></span><br><span class="line">        uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            updatedTask.name = taskName!</span><br><span class="line">            <span class="keyword">self</span>.readTasksAndUpateUI()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> newTask = <span class="type">Task</span>()</span><br><span class="line">        newTask.name = taskName!</span><br><span class="line">        </span><br><span class="line">        uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.selectedList.tasks.append(newTask)</span><br><span class="line">            <span class="keyword">self</span>.readTasksAndUpateUI()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们从 TextField 中获取到任务名称，调用 Realm 的写方法来保存任务列表。</p>
<p><em>请注意，当你同时进行多个写操作的时候，他们会相互阻塞，阻塞住他们所运行的线程。所以应当考虑在 UI 之外的线程中来进行操作。另外需要注意的是，在进行写事务的时候，读操作并不会造成阻塞。这非常有用，尤其是当你在后台进行写操作的时候，用户可能会在不同界面切换，而这时候可以进行读操作。</em></p>
<h2 id="检索数据">检索数据</h2><p>现在你已经学会了如何在 Realm 中写数据，下面我们来看看如何检索数据。在 Realm 中检索数据的方式非常直观。Realm 提供了很多选项来过滤出你想要的数据。在 Realm 中进行查找操作的时候，它将会返回一个 Results 对象。可以把 Results 简单地当做是 Swift 的数组，因为它们的接口非常类似。</p>
<p>当得到 Results 实例的时候，这代表你已经从磁盘中直接获取到了数据。对这些数据的任何操作（使用事务）将会影响到磁盘上的数据。在 Realm 中来检索数据，只需要调用对象的方法，并将类名作为参数传进去。让我们看看如何使用这种方式来读取 TaskLists 并更新 UI：</p>
<p>我们在 <code>TasksListsViewController</code> 中定义了该属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lists : <span class="type">Results</span>&lt;<span class="type">TaskList</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>然后实现了 <code>readTasksAndUpdateUI</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">readTasksAndUpdateUI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    lists = uiRealm.objects(<span class="type">TaskList</span>)</span><br><span class="line">    <span class="keyword">self</span>.taskListsTableView.setEditing(<span class="literal">false</span>, animated: <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">self</span>.taskListsTableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>tableView(_:cellForRowAtIndexPath:_)</code> 方法中，我们将显示列表的名称，还有每个列表内的任务个数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"listCell"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> list = lists[indexPath.row]</span><br><span class="line">    </span><br><span class="line">    cell?.textLabel?.text = list.name</span><br><span class="line">    cell?.detailTextLabel?.text = <span class="string">"<span class="subst">\(list.tasks.<span class="built_in">count</span>)</span> Tasks"</span></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑非常直观吧。最后需要做的就是在 <code>viewWillAppear</code> 中调用 <code>readTasksAndUpdateUI</code> 方法，来确保总是显示数据更新之后的视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">    readTasksAndUpdateUI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面展示了如何使用 Realm 来进行任务列表的读写操作。接下来，我们来看看如何进行数据更新和删除操作。在开始之前，先来看看项目模板中的修改和删除部分的相关代码。</p>
<p>首先在 <code>TaskListsViewController</code> 中，我们用一个布尔值 <code>isEditingMode</code> 来表示是在正常状态还是编辑状态：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEditingMode = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当 Edit 按钮被点击的时候，将会调用 <code>didClickOnEditButton</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnEditButton</span><span class="params">(sender: UIBarButtonItem)</span></span> &#123;</span><br><span class="line">    isEditingMode = !isEditingMode</span><br><span class="line">    <span class="keyword">self</span>.taskListsTableView.setEditing(isEditingMode, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会使用 table view 的 <code>setEditing</code> 方法来启用或禁用 UITableView 的编辑模式。在表格视图中，默认的编辑操作是删除，但是从 iOS 8.0 开始，增加了一个 <code>editActionsForRowAtIndexPath</code> 方法来自定义一些操作，这些操作在在用户滑动表格 cell 的时候出现。</p>
<p>我们将使用该方法来添加两个功能 — 删除和编辑，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; [<span class="type">UITableViewRowAction</span>]? &#123;</span><br><span class="line">    <span class="keyword">let</span> deleteAction = <span class="type">UITableViewRowAction</span>(style: <span class="type">UITableViewRowActionStyle</span>.<span class="type">Destructive</span>, title: <span class="string">"Delete"</span>) &#123; (deleteAction, indexPath) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里开始是删除</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> listToBeDeleted = <span class="keyword">self</span>.lists[indexPath.row]</span><br><span class="line">        uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            uiRealm.delete(listToBeDeleted)</span><br><span class="line">            <span class="keyword">self</span>.readTasksAndUpdateUI()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> editAction = <span class="type">UITableViewRowAction</span>(style: <span class="type">UITableViewRowActionStyle</span>.<span class="type">Normal</span>, title: <span class="string">"Edit"</span>) &#123; (editAction, indexPath) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里开始是编辑</span></span><br><span class="line">        <span class="keyword">let</span> listToBeUpdated = <span class="keyword">self</span>.lists[indexPath.row]</span><br><span class="line">        <span class="keyword">self</span>.displayAlertToAddTaskList(listToBeUpdated)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [deleteAction, editAction]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用 <code>UITableViewRowAction</code> 添加了两个操作，方法中定义了操作的 <code>style</code>，<code>title</code> 和 <code>handler</code>。当在滑动 cell 或者以其他方式进入编辑模式的时候，会像下面这样：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/edit-mode-576x1024.png" alt=""></p>
<p>以上就是在进行删除和更新操作时候的 UI 代码逻辑。</p>
<h2 id="删除对象">删除对象</h2><p>想要从 Realm 数据库中删除对象或者数据，你只需要调用 Realm 对象的 <code>delete</code> 方法，同时将该对象作为参数传入。当然，这些操作会在写事务中完成。来看一下下面的代码的工作方式，我们从 Realm 数据库中删除了一个任务列表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> listToBeDeleted = <span class="keyword">self</span>.lists[indexPath.row]</span><br><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">           uiRealm.delete(listToBeDeleted)</span><br><span class="line">           <span class="keyword">self</span>.readTasksAndUpdateUI()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在删除之后，我们调用了 <code>readTasksAndUpdateUI</code> 方法来读取数据并更新 UI。</p>
<p>除了删除单个数据，在 Realm 中，还有一个方法叫做 <code>deleteAll</code>，它允许你删除数据库中所有 class 的所有数据。如果你想为当前用户持久化数据，但是在他退出登录的时候抹掉所有的相关数据，这个方法将会十分有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    uiRealm.deleteAll()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="更新_Objects">更新 Objects</h2><p>在 Realm 中有多种方式可以来更新 object，但是这些方法都应该在写事务中完成。下面我们来看一些更新对象的方式。</p>
<h3 id="使用属性（Property）">使用属性（Property）</h3><p>你可以通过直接在 Realm 的写闭包中设置属性的值来更新数据。例如，在 <code>TasksViewController</code> 中，我们可以简单地设置属性值来更新任务的状态信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    task.isCompleted = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用主键（Primary_Key）">使用主键（Primary Key）</h3><p>Realm 支持将某个 string 或 int 类型的属性设置为主键。当使用 <code>add()</code> 方法来创建 Realm 对象时，如果有相同主键的对象存在，就会更新这个对象的值。下面是示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="type">User</span>()</span><br><span class="line">user.firstName = <span class="string">"John"</span></span><br><span class="line">user.lastName = <span class="string">"Smith"</span></span><br><span class="line">user.email = <span class="string">"example@example.com"</span></span><br><span class="line">user.id = <span class="number">1</span></span><br><span class="line"><span class="comment">// 更新 id 是 1 的用户</span></span><br><span class="line">realm.write &#123;</span><br><span class="line">            realm.add(user, update: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里的 id 属性为主键。如果 id 为 1 的用户存在，Realm 会更新相应的对象。如果不存在，Realm 将会把该对象存入数据库中。</p>
<h3 id="使用_KVC（Key-Value_Coding）">使用 KVC（Key-Value Coding）</h3><p>如果你是 iOS 开发的老手，那么对 Key-Value Coding 肯定不会陌生。Realm 的类型，像是 Object、Results 和 List，都可以使用 Key-Value Coding。该特性可以帮助你在运行时设置或更新属性值。另外一个在 List 和 Results 中支持 KVC 的好处是，可以在无需遍历每个对象的情况下，批量更新对象数据。这么说你可能不是很理解，我们来看个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = uiRealm.objects(<span class="type">Task</span>)</span><br><span class="line">uiRealm.write &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    tasks.setValue(<span class="literal">true</span>, forKeyPath: <span class="string">"isCompleted"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用查询语句来请求所有的 Task 对象，之后将所有得到的对象的 <code>isCompleted</code> 属性设置为 true。可以看出，将 Realm 中的所有 tasks 标记为已完成，仅仅只用了一行代码。</p>
<p>让我们回过头来看看我们的 ToDo 应用。如果仔细观察 <code>displayAlertToAddTaskList</code> 方法，你会看到如下代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 更新状态</span></span><br><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">          updatedList.name = listName!</span><br><span class="line">          <span class="keyword">self</span>.readTasksAndUpdateUI()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当用户遍历列表名称的时候，上面的代码会被调用。通过设置 name 属性的方式，就更新了数据库中的内容。</p>
<h2 id="显示任务项">显示任务项</h2><p>我们已经一起看过了 <code>TaskListViewController</code> 的绝大部分代码。现在让我们打开 <code>TasksViewController</code> 来看看，这个视图控制器用来显示任务清单中的任务项。视图控制器拥有一个 UITableView, 该视图有两个 section：完成的任务和未完成的任务。在 <code>TasksViewController</code> 中，有如下属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedList : <span class="type">TaskList</span>!</span><br><span class="line"><span class="keyword">var</span> openTasks : <span class="type">Results</span>&lt;<span class="type">Task</span>&gt;!</span><br><span class="line"><span class="keyword">var</span> completedTasks : <span class="type">Results</span>&lt;<span class="type">Task</span>&gt;!</span><br></pre></td></tr></table></figure>
<p><code>selectedList</code> 用来存储 <code>TaskListsViewController</code> 传递过来的选中的任务列表。为了将完成和未完成的任务分开，声明了两个属性，<code>openTasks</code> 和 <code>completedTasks</code>。为了过滤出不同的任务完成状态，我们将使用 Realm 的方法 <code>filter()</code>。在解释该函数如何工作之前，让我们先来看看如何在代码中使用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">readTasksAndUpateUI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    completedTasks = <span class="keyword">self</span>.selectedList.tasks.<span class="built_in">filter</span>(<span class="string">"isCompleted = true"</span>)</span><br><span class="line">    openTasks = <span class="keyword">self</span>.selectedList.tasks.<span class="built_in">filter</span>(<span class="string">"isCompleted = false"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.tasksTableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法中，我们使用 <code>filter</code> 方法来过滤 <code>results</code>。Realm 提供了 <code>filter()</code> 方法来过滤数据。该方法可以被 List、Result 和 Object 对象调用。方法会返回过满足滤条件参数的特定对象。你可以把 <code>filter</code> 当做 <code>NSPredicate</code>。基本上来说，你可以认为这两者差不多。就像上面的代码一样，你同样可以使用 string 作为参数创建一个 <code>NSPredicate</code> 对象，并把它作为参数传给 <code>filter</code> 方法。</p>
<p>让我们来看另外一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用断言字符串</span></span><br><span class="line"><span class="keyword">var</span> redCars = realm.objects(<span class="type">Car</span>).<span class="built_in">filter</span>(<span class="string">"color = 'red' AND name BEGINSWITH 'BMW'"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 NSPredicate</span></span><br><span class="line"><span class="keyword">let</span> aPredicate = <span class="type">NSPredicate</span>(format: <span class="string">"color = %@ AND name BEGINSWITH %@"</span>, <span class="string">"red"</span>, <span class="string">"BMW"</span>)</span><br><span class="line">redCars = realm.objects(<span class="type">Car</span>).<span class="built_in">filter</span>(aPredicate)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用 <code>filter</code> 方法来过滤 <code>color</code> 为 red，并且 <code>name</code> 以 “BMW” 开头的对象。第一行代码使用 string 作为参数来进行过滤。另外，你也可以使用 NSPredicate 获得同样的效果。下面的表格总结了 filter 方法的大部分常用操作：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-database-info-1024x675.png" alt=""></p>
<h2 id="排序">排序</h2><p>既然我们谈到了 Realm 数据库的基本操作，在本教程结束之前，我还想给大家介绍另外一个特性。排序功能，这是 Realm 提供了另一个特别有用的特性。对于 List 和 Result 对象，你可以调用方法 <code>sorted（「排序标准」）</code> 来将一组数据进行排序。让我们来看看如何在任务列表中使用该方法让任务列表以字母表或者创建时间先后顺序排序。首先，在 UI 中，我们增加了一个 segment control，将会根据选择的情况来进行对应的排序。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Simulator-Screen-Shot-Oct-24-2015-8.47.06-PM-576x1024.png" alt=""></p>
<p>根据不同的选择来进行排序，代码逻辑如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didSelectSortCriteria</span><span class="params">(sender: UISegmentedControl)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sender.selectedSegmentIndex == <span class="number">0</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 按 A-Z 排序</span></span><br><span class="line">            <span class="keyword">self</span>.lists = <span class="keyword">self</span>.lists.sorted(<span class="string">"name"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 按日期排序</span></span><br><span class="line">            <span class="keyword">self</span>.lists = <span class="keyword">self</span>.lists.sorted(<span class="string">"createdAt"</span>, ascending:<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.taskListsTableView.reloadData()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>Realm 是一个非常简单易用，直观的本地数据库解决方案。Realm 提供了很好的可扩展性，只用很少的几行代码就可完成操作。对于大部分的应用甚至是游戏来说，我觉得如果需要使用数据库的话，Realm 值得尝试。</p>
<h2 id="下一步？">下一步？</h2><p>学习了本教程，你应该可以在项目中使用 Realm 来进行增删改查等基本的操作。Realm 还具有一些高阶特性，值得深入学习。最好的学习资料就是 Realm 网站的官方文档，Realm 的小伙伴把文档写得非常赞！</p>
<p>如果想要教程 ToDo 应用的的完整代码，你可以在<a href="https://github.com/hossamghareeb/realmtasks" target="_blank" rel="external">这里下载</a>。</p>
<p>如果对代码有任何的问题，都欢迎留言反馈，我们会很乐意帮助到您。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Hossam Ghareeb，<a href="http://www.appcoda.com/realm-database-swift/">原文链接</a>，原文日期：2015-10-28<br>译者：<a href="http://www.futantan.com">Prayer</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>智能手机的快速发展的同时，涌现出了很多对开发者友好的开发工具。这些工具不仅使得开发变得更加简单和容易，同时也保证了性能和产品质量。如今想要在 App Store 中占据一席之地，并非易事。而且想要使得应用易于扩展就更加困难了。当你成功获得百万量级的用户时，应用中的每一个细节都不能放过，并且需要在很短的时间完成对细节的打磨。所以和数据库打交道，是很多开发者都会面临的一个问题。]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS：选择 Realm 而不是 CoreData]]></title>
    <link href="http://swiftggteam.github.io/2015/12/08/ios-realm-instead-of-coredata/"/>
    <id>http://swiftggteam.github.io/2015/12/08/ios-realm-instead-of-coredata/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-realm-instead-of-coredata/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-29<br>译者：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>我已在网上多次看到「Realm」这个词。我甚至曾在十月时有机会参加由 Swift 用户组组织的 Realm 聚会。最终，我有机会用上了 Realm 这个框架。</p>
</blockquote>
<a id="more"></a>
<h2 id="案例">案例</h2><p>现在我正在节食。我需要减一些体重因为在加利福尼亚的时候胖了好多 – 好吃的食物实在是太多了:)！我浏览了一下 iTunes Store 中的那些能够追踪喝水记录的应用，但是在我看来这些应用要么看上去很糟糕，要么交互实在是很烂。我想：如果我决定做一个应用，岂不是一箭双雕吗 – 我又能写一个我想要的应用，又能选择使用 Realm 而不是 Core Data。所以我开工了。</p>
<p>你知道当我看完文档、开始使用 Realm 框架的第一感觉是什么吗？<strong>哇，这简直真是太棒了！这些开发的家伙做的简直超棒！</strong></p>
<p><strong>免责声明：</strong>接下来所写的仅仅只覆盖了 Realm 框架中最基本的一部分。我建议你们接下来可以去阅读<a href="https://realm.io/docs/swift/latest/" target="_blank" rel="external">官方文档</a>来获取更多的信息。在这儿我并不想向你们展示关于 Realm 框架的全部内容，因为这篇文章不可能像文档一样又臭又长，并且我自己也会避免这样的问题发生。官方的文档非常的棒，你在开工前可以先读一下它。</p>
<p>我的这个案例并不是很复杂而是非常简单的。整个 app 只有两个抽象模型（Model）类： <code>Day</code> 和 <code>DrinkLogEntry</code> 。此外，这个 app 也需要这些功能：添加、更新、筛选和排序存储的数据。正如我所说这是个简单的 app 。接下来我会呈现 app 中的一些代码片段。</p>
<h2 id="抽象模型（Model）">抽象模型（Model）</h2><p>Realm 中没有像 xcdatamodel-like 这样的文件。抽象模型仅仅是继承自 <code>Object</code> 类的文件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> 表示了用户一天的生活。 Day 这个类的信息包含用户所喝的水和他们的每天喝水的目标。</span><br><span class="line">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Day</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> identifier: <span class="type">String</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 表示一天的开始的时间戳（UTC+0 时区）</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> timestamp: <span class="type">NSTimeInterval</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 用户所喝的水的量（毫升）</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> waterDrank: <span class="type">Float</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 用户每天喝水的目标（毫升）</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> dailyGoal: <span class="type">Float</span> = <span class="number">0</span> <span class="comment">// ml</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> drinkLogs = <span class="type">List</span>&lt;<span class="type">DrinkLogEntry</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(timestamp: <span class="type">NSTimeInterval</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.timestamp = timestamp</span><br><span class="line">        <span class="keyword">self</span>.identifier = <span class="type">Day</span>.convertTimestampIntoIdentifier(timestamp)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">primaryKey</span>() -&gt; <span class="title">String</span>? </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"identifier"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">indexedProperties</span>() -&gt; [<span class="title">String</span>] </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"identifier"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">convertTimestampIntoIdentifier</span>(<span class="title">timestamp</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"%.0f"</span>, arguments: [timestamp])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有前有 <code>dynamic</code> 关键字的属性都会被转化成数据抽象层的一部分。Realm 也支持关系型数据。在这个例子中 Day 这个类中存在 drinkLogs 的一对多关系。一对一的关系就仅是类中的特定属性了。</p>
<p>Realm 也支持从 Core Data 中迁移数据。当你需要迁移的时候，可以定义一个闭包并且执行它，然后你就能顺利地执行迁移属性的所有步骤了（译者注：<a href="https://realm.io/news/migrating-from-core-data-to-realm/" target="_blank" rel="external">如何从 Core Data 迁移到 Realm</a>）。</p>
<h2 id="索引属性（Indexed_properties）和主键（Primary_keys）">索引属性（Indexed properties）和主键（Primary keys）</h2><p>Realm 框架有很多 Core Data 中没有的新特性（也有可能是我没找到，或者说我就是想提一下这点😊）。第一点就是「索引属性」了。你可以定义需要被索引的属性集合。当属性个数比较小的时候，搜索会变得很快。这有助于性能的提升。</p>
<p>接下来不得不提一下「主键」。你可以定义抽象模型中的一个属性作为它的主键。这能保证更加有效地更新数据以及保证数据的唯一性。</p>
<p>在我使用的这个例子中，主键和索引属性将作为「标识符」，被用于搜索和更新数据。</p>
<p>数据中也可以有被忽略的属性，那些属性将不被持久化保存。</p>
<h2 id="创建、更新并写入数据">创建、更新并写入数据</h2><p>你可以使用未被持久化过的抽象模型，而且这些数据可以被持久化时，你可以将它们写入 Realm 中。比起 Core Data，这就是我为什么喜欢 Realm 更多一点 – 因为它能够很好地解决一些临时数据的问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> day = <span class="type">Day</span>(timestamp: timestamp)</span><br><span class="line">day.dailyGoal = <span class="type">MenuSettings</span>().dailyGoal</span><br></pre></td></tr></table></figure>
<p>为了能够写入 Realm 或者从 Realm 中读取，你需要创建 <code>Realm</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br></pre></td></tr></table></figure>
<p>这是如何将数据添加到数据库的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>! realm.write &#123;</span><br><span class="line">    realm.add(day)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我特别喜欢 Realm 中更新数据的方式。我们假设一下有一部分数据是从网络上下载的，并且他们被映射过而且已经加进了数据库。在数据库中已经存在的数据仅需要更新而不是再次添加。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchAll</span><span class="params">(completion: [Day] -&gt; Void)</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     假设请求返回了 JSON 并且数据已经映射到了抽象数据层的 Day 类型。</span><br><span class="line">          </span><br><span class="line">     创建的数据还没有存入数据库 Realm 中。</span><br><span class="line">     数据的标识符是相等的时间戳。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">let</span> day1 = <span class="type">Day</span>(timestamp: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> day2 = <span class="type">Day</span>(timestamp: <span class="number">86400</span>)</span><br><span class="line">    <span class="keyword">let</span> day3 = <span class="type">Day</span>(timestamp: <span class="number">172800</span>)</span><br><span class="line">    </span><br><span class="line">    completion([day1, day2, day3])</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fetchAll &#123; (days) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">        <span class="keyword">try</span>! realm.write &#123;</span><br><span class="line">            <span class="comment">/// 如果有相同的标识符，那么它将会被更新。</span></span><br><span class="line">            realm.add(days, update: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种比手动查询带有相同标识符然后更新值域更好的方法。</p>
<p>如果更新的参数被置为 false，那么新的数据将具有和在数据库中存在的数据相同的主键。异常会被抛出。</p>
<p>还有其他一些方法来更新数据，在这篇文章中我就不涉及了。</p>
<p>这是如何得到所有 Day 类型数据的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> days = realm.objects(<span class="type">Day</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<p>筛选数据也很简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">realm.objects(<span class="type">Day</span>.<span class="keyword">self</span>).<span class="built_in">filter</span>(<span class="string">"identifier == %@"</span>, dayIdentifier)</span><br></pre></td></tr></table></figure>
<p>按照时间戳升序排列这些数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> days = realm.objects(<span class="type">Day</span>.<span class="keyword">self</span>).sorted(<span class="string">"timestamp"</span>, ascending: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>当你每次执行 <code>object()</code>、<code>sorted()</code> 和 <code>filter()</code> 后均会得到一个 <code>Results&lt;T&gt;</code> 类型的数据。这能让你对结果进行额外的筛选排序等操作 - 这功能非常的强大而且非常好使。</p>
<h2 id="小结">小结</h2><p>在下一个有更加复杂的数据模型的 app 中<strong>我还会使用</strong> Realm 吗？答案是<strong>肯定</strong>的。因为整个框架使用起来非常的简单、集成起来非常的快速，而且 Realm 提供了非常多而且强大的功能特性。</p>
<p>P.S. 这个 app 正在等待过审 :)</p>
<p>2015/12/06更新<br>这个应用上架了 - <a href="https://itunes.apple.com/pl/app/water-intake-drink-more-water/id1062053347?mt=8" target="_blank" rel="external">Water Intake</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-realm-instead-of-coredata/">原文链接</a>，原文日期：2015-11-29<br>译者：<a href="https://github.com/Cee">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>我已在网上多次看到「Realm」这个词。我甚至曾在十月时有机会参加由 Swift 用户组组织的 Realm 聚会。最终，我有机会用上了 Realm 这个框架。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="http://swiftggteam.github.io/tags/Tomasz-Szulc/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[几个 Swift 代码规范]]></title>
    <link href="http://swiftggteam.github.io/2015/12/07/a-handful-of-swift-style-rules-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/12/07/a-handful-of-swift-style-rules-swiftlang/</id>
    <published>2015-12-06T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/17/a-handful-of-swift-style-rules-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-17<br>译者：<a href="http://blog.csdn.net/mmoaay" target="_blank" rel="external">mmoaay</a>；校对：<a href="http://weibo.com/lfbWb" target="_blank" rel="external">lfb_CD</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>我们需要经常带着新问题来重新审视一下以前的代码规范。</p>
<a id="more"></a>
<p><strong><a href="http://twitter.com/Eridius" target="_blank" rel="external">Kevin</a> 提供的一套规范</strong>：“如果尾部的闭包参数是函数式的就用圆括号。如果是程序式的就用花括号。”</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">myCollection</span><span class="class">.map</span>(&#123;<span class="tag">blah</span>&#125;)<span class="class">.filter</span>(&#123;<span class="tag">blah</span>&#125;)<span class="class">.etc</span></span><br><span class="line"><span class="tag">myCollection</span><span class="class">.forEach</span> &#123;&#125; <span class="comment">// 或者 </span></span><br><span class="line"><span class="function">dispatch_after</span>(when, queue) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>样式一致性与闭包是否有返回值相关。目前存在的争议是我们是否应该在尾部花括号的左边留空格。</p>
<p><strong><code>self</code> 的使用规范</strong>：“当<a href="http://ericasadun.com/2015/04/21/swift-occams-code-razor/" target="_blank" rel="external">编译器可以自动推断</a>成员类型时，你就可以在使用隐式成员表达式时省略 <code>self</code>。但无论何时，只要一个方法调用会反射到一个实例，就要使用 <code>self</code>。“</p>
<p>仔细考虑下面 <code>for</code> 循环语句中的 <code>where</code> 分支。<code>contains</code> 方法就是在没有明确对象的情况下调用的。那是谁做了 <code>contains</code> 操作呢? 因为方法参数中没有传入容器对象，所以这个对象只能是调用这个方法的实例。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (flagLessOne, <span class="type">string</span>) <span class="keyword">in</span> strings.enumerate() </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">contains</span>(</span><br><span class="line">        Features(rawValue: <span class="number">1</span>&lt;&lt;(flagLessOne + <span class="number">1</span>))) &#123;</span><br><span class="line">    nameArray.append(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全合格的调用明确指出了原本模糊不清的对象，同时极大滴提高了代码的可读性：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (flagLessOne, <span class="type">string</span>) <span class="keyword">in</span> strings.enumerate() </span><br><span class="line">    <span class="keyword">where</span> self.<span class="keyword">contains</span>(</span><br><span class="line">        Features(rawValue: <span class="number">1</span>&lt;&lt;(flagLessOne + <span class="number">1</span>))) &#123;</span><br><span class="line">    nameArray.append(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件级联绑定的规范</strong>：“除非你做的是 <code>var</code> 和 <code>let</code> 混合的条件绑定，只用一个 <code>if let</code> 或者 <code>if var</code> 就可以了，需要的话可以自由添加空格。“</p>
<p>不要使用下面的方式：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = x, <span class="keyword">let</span> y = y, <span class="keyword">let</span> z = z &#123;blah&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = x, y = y, z = z &#123;blah&#125;</span><br></pre></td></tr></table></figure>
<p>省略多余的 <code>let</code> 关键字可以让级联绑定更加简洁，而且 Xcode 会帮你对这些代码的格式进行很好的调整：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span></span><br><span class="line">    x = x,</span><br><span class="line">    y = y,</span><br><span class="line">    z = z &#123;</span><br><span class="line">    <span class="attribute">...</span>blah<span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管级联绑定避免了 pre-Swift 2 中的“鞭尸金字塔(pyramids of doom)“，但它们又导致了“恐怖便秘块(constipated blocks of horror)“的问题。这种问题主要出现在下面两种情况：</p>
<ul>
<li>存在大量的串行绑定，再加上空行和注释时（就像下面的代码）</li>
<li>使用了一系列 <code>guard</code> 语句时。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span></span><br><span class="line">    <span class="comment">// 以字典的方式访问 JSON </span></span><br><span class="line">    json = json <span class="keyword">as</span>? NSDictionary,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查结果数组</span></span><br><span class="line">    resultsList = json[<span class="string">"results"</span>] <span class="keyword">as</span>? NSArray,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取第一项</span></span><br><span class="line">    results = resultsList.firstObject <span class="keyword">as</span>? NSDictionary,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取名字和价格</span></span><br><span class="line">    name = results[<span class="string">"trackName"</span>] <span class="keyword">as</span>? <span class="built_in">String</span>, </span><br><span class="line">    price = results[<span class="string">"price"</span>] <span class="keyword">as</span>? NSNumber &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... blah blah ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>模式匹配关键字的规范</strong>：“如果都是绑定，那就要把绑定组合起来。”</p>
<p>通过把关键字移动到元组外面的方式来把多模式匹配绑定组合起来。将下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> (<span class="built_in">let</span> x?, <span class="built_in">let</span> y?) = myOptionalTuple &#123;</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="built_in">let</span> (x?, y?) = myOptionalTuple &#123;</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>isEmpty</code> 的使用规范</strong>：“如果你在检测一个集合元素的个数，你可能就是在犯错。”用 <code>isEmpty</code> 替换 <code>count == 0</code>。</p>
<p><strong><code>void</code> 的使用规范</strong>：“使用 <code>void</code> 返回类型，而不是 <code>()</code>。”下面是一个返回 <code>-&gt; Void</code> 而不是 <code>-&gt; ()</code> 的方法。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doThis</span><span class="params">()</span> -&gt; <span class="title">Void</span> </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notThis</span><span class="params">()</span> -&gt; <span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong><code>!</code> 的使用规范</strong>：“每当你在 Swift 中用惊叹号的时候，一只小猫就会死。”尽可能的避免使用强制转换和强制解包。</p>
<p><strong>创建集合的规范</strong>：“使用显式类型和空集合。”类型在赋值操作符的左边，空实例在赋值操作符的右边。</p>
<p>把下面的代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var x = [<span class="link_label">String: Int</span>](<span class="link_url"></span>) // 以及</span><br><span class="line">var y = [<span class="link_label">Double</span>](<span class="link_url"></span>)</span><br><span class="line">var z = Set<span class="xml"><span class="tag">&lt;<span class="title">String</span>&gt;</span></span>()</span><br><span class="line">var mySet = MyOptionSet()</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span>: [String: <span class="typename">Int</span>] = [:]</span><br><span class="line"><span class="variable"><span class="keyword">var</span> y</span>: [<span class="typename">Double</span>] = []</span><br><span class="line"><span class="variable"><span class="keyword">var</span> z</span>: Set<span class="type">&lt;String&gt;</span> = []</span><br><span class="line"><span class="variable"><span class="keyword">var</span> mySet</span>: MyOptionSet = []</span><br></pre></td></tr></table></figure>
<p><a href="https://twitter.com/_jackhl/status/646723367576276992" target="_blank" rel="external">引用</a></p>
<p>“<a href="http://mikeash.com/" target="_blank" rel="external">Mike Ash</a>”的冒号规范：“右侧加上空格，而左侧不需要。”Or no soup for you!</p>
<p>应该使用：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">[key: <span class="keyword">value</span>] <span class="comment">// 以及</span></span><br><span class="line"><span class="keyword">struct</span> Foo: MyProtocol</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">[key : value]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> : <span class="title">MyProtocol</span></span></span><br></pre></td></tr></table></figure>
<p><strong>从 Objective-C 过来的规范</strong>：</p>
<ul>
<li>不要在 if 和 switch 条件两边或者 return 关键词上加 Objective-C 样式的圆括号。</li>
<li>为所有常量使用“骆驼拼写法”，如 allTheConstants 而不是 ALL_CAPS</li>
<li>用 Swift 的构造器替代传统的，例如：用 <code>CGPoint(x: 1, y:1)</code> 替代 <code>CGPointMake(1, 1)</code></li>
<li>避免使用行尾分号，尽管这样是可以编译通过的。但是它们会让你的代码看起来很糟糕，而且用起来体验也很差。</li>
</ul>
<p><strong>更新</strong></p>
<p>当然，这不是说说而已，我已经在代码中进行了实践：</p>
<p><img src="/img/articles/a-handful-of-swift-style-rules-swiftlang/Screen-Shot-2015-11-18-at-10.31.13-AM.png1449449055.5795417" alt="这里写图片描述"></p>
<p>github <a href="https://github.com/erica/testlint" target="_blank" rel="external">代码地址</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/17/a-handful-of-swift-style-rules-swiftlang/">原文链接</a>，原文日期：2015-11-17<br>译者：<a href="http://blog.csdn.net/mmoaay">mmoaay</a>；校对：<a href="http://weibo.com/lfbWb">lfb_CD</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
</blockquote>
<p>我们需要经常带着新问题来重新审视一下以前的代码规范。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[斐波那契数列型-从数学角度学习 Swift 序列]]></title>
    <link href="http://swiftggteam.github.io/2015/12/04/the-fibonacci-sequencetype/"/>
    <id>http://swiftggteam.github.io/2015/12/04/the-fibonacci-sequencetype/</id>
    <published>2015-12-03T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jacob Bandes-Storch，<a href="http://bandes-stor.ch/blog/2015/08/05/the-fibonacci-sequencetype/" target="_blank" rel="external">原文链接</a>，原文日期：2015/08/05<br>译者：<a href="undefined">Lou</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
<p>这篇博文启发自<a href="http://codereview.stackexchange.com/questions/60875/project-euler-2-even-fibonacci-numbers-in-swift" target="_blank" rel="external">Code Review.SE</a>上的一个讨论，同时<a href="https://xkcd.com/356/" target="_blank" rel="external">nerd-sniped</a>上的关于数学的有趣的学习。让我对数学和 Swift 的结合有了兴趣。所以我花了一段时间来把这些知识整理成一篇博文，特别是自从我完成了对我网站重建的第一步以后。更重要的是，我希望我能更勤勉的更新我的博客，这8年我只写了一篇而已，希望大家能对我的博客感兴趣。<br>这篇博文的目标对于初学者来讲，比较容易理解，同时也提供给那些已经对这个概念熟悉的人一些有用的细节和例子。希望大家能给我反馈。</p>
</blockquote>
<a id="more"></a> 
<p>假设你第一次学习 Swift，你实在是太兴奋了，花了一天时间反复练习，等到第二天就成了专家。于是第二天你就开始传授课程来教别人。</p>
<p>当然，我很愿意成为你的第一个学生。我也学的很快，一天学下来，我也可以教别人 Swift 了。我俩继续教别人，其他的学生也学的很快，马上跟上进度，都可以第二天就去教别人。</p>
<p>这是个多么让人兴奋的世界呀。但是问题来了，照这样的进度下去，Swift 学习者将大量涌入城市，基础设施将无法支撑庞大的人口。</p>
<p>市长叫来最好的科学家们：“我们需要精确的数学模型！<strong>每天到底有多少人会使用 Swift？什么时候这种疯狂会终止？</strong>”</p>
<h3 id="搭建数学模型">搭建数学模型</h3><p>为了方便理解问题，让我们画一副图来表示最初几天发生的事：<br><img src="/content/images/2015/08/Screen-Shot-2015-08-29-at-08-30-16.png" alt=""></p>
<p>仔细观察我们发现，特定的一天总的 Swifters 数量（我们用 \(S_{今天}\) 来表示）等于前一天的数量加上每个老师可以所教的学生。</p>
<p>$$ S_{今天} = S_{昨天} + 老师数 $$</p>
<p>那么老师数目是多少呢？记住，一个人需要花一天时间学习才能变成 Swift 专家，所以前天的每一个人都能成为老师，都可以教一个学生：\(S_{今天} = S_{昨天} + S_{前天}\)。</p>
<p>这下公式就简单了！我们可以用手算了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">    <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">        <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">            <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span></span><br><span class="line">                <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span></span><br><span class="line">                	   ...</span><br></pre></td></tr></table></figure>
<p>如果这个数列看上去有点熟悉，那是因为这是<strong>斐波纳契数列</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">34</span>,<span class="number">55</span>,<span class="number">89</span>,<span class="number">144</span>,<span class="number">233</span>,<span class="number">377</span>,<span class="number">610</span>,...</span><br></pre></td></tr></table></figure>
<p>不管你是否喜欢，我们的世界里处处都有斐波那契数的存在：<a href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibnat.html" target="_blank" rel="external">花瓣</a>的生长遵循斐波那契数列，大树的枝丫是斐波那契树丫，当然也有人吐槽说这不过是<a href="http://www.lhup.edu/~dsimanek/pseudo/fibonacc.htm" target="_blank" rel="external">确认偏误</a>罢了。我们发现，这个数列是基于非常简单的形式的，非常容易计算：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    (i, j) = (j, i + j)</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">// 打印1, 然后打印1, 继续打印2, 3, 5, 8, 13, 21, 34, 55...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成！</p>
<p>哈哈，骗你的。我们才刚刚开始。计算机美妙的地方就在于可以帮助我们快速的解决用手算很麻烦的问题。让我们尝试几个例子。</p>
<h4 id="42天后有多少个_Swifter？">42天后有多少个 Swifter？</h4><p>前面我们已经差不多解决了这个问题，只要在42那边停止循环即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">42</span> &#123;</span><br><span class="line">    (i, j) = (j, i + j)</span><br><span class="line">&#125;</span><br><span class="line">i <span class="comment">// returns 267914296</span></span><br></pre></td></tr></table></figure>
<h4 id="那么第_n_天呢？">那么第 n 天呢？</h4><p>和之前的问题类似，我们可以将其抽象成一个函数。用 n 来代替 42。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">nthFibonacci</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">        (i, j) = (j, i + j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nthFibonacci(<span class="number">42</span>) <span class="comment">// 返回 267914296</span></span><br><span class="line">nthFibonacci(<span class="number">64</span>) <span class="comment">// 返回 10610209857723</span></span><br></pre></td></tr></table></figure>
<h4 id="第一周到底写了多少_Swift？">第一周到底写了多少 Swift？</h4><p>为了简化问题，假定每个人写代码的速度是一样的。知道每个人每天写的代码量后，我们只需要把斐波那契数加起来即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fibonacciSumUpTo</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">        sum += nthFibonacci(i) </span><br><span class="line">        <span class="comment">// 第 i 天 使用 Swift 写代码的人数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fibonacciSumUpTo(<span class="number">7</span>) <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<h4 id="逐步简化">逐步简化</h4><p>不要急，Swift 的标准库里面已经有了一个函数叫做 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_SequenceType_Protocol/index.html#//apple_ref/swift/intfm/SequenceType/s:FeRq_Ss12SequenceType_SsS_6reduceu__Rq_S__Fq_FTqd__7combineFTqd__qqq_S_9GeneratorSs13GeneratorType7Element_qd___qd__" target="_blank" rel="external">reduce</a>，可以将数字加在一起。我们该怎么写呢?</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +) <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<p>这样可行，但是我们需要把每个数字都写出来。要是能用 nthFibonacci() 就好了。</p>
<p>既然这些是连续的斐波那契数，我们可以简单的使用1到7的范围：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="built_in">map</span>(nthFibonacci) </span><br><span class="line"><span class="comment">// 返回 [1, 1, 2, 3, 5, 8, 13]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>].<span class="built_in">map</span>(nthFibonacci).<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br><span class="line"> <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<p>或者我们可以更简单，用 Swift 的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_StandardLibrary_Operators/index.html" target="_blank" rel="external">range operator</a>(…):</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>...<span class="number">7</span>).<span class="built_in">map</span>(nthFibonacci).<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +) <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<p>这等同于 <code>fibonacciSumUpTo</code></p>
<h4 id="性能优化">性能优化</h4><p>看上去很不错，但是不要忘了 nthFibonacci(i) 从0开始加到 i，所需的工作量将随着i线性增加。</p>
<p>而且我们所写的 <code>(1...n).map(nthFibonacci).reduce(0, combine: +)</code> 从1到n每次凑要运行 nthFibonacci， 这将大大增加运算量。</p>
<blockquote>
<p>注意：计算越简单的斐波那契数，真实耗费每一步的时间几乎可以忽略不计（开启性能优化）。这篇文章之前的草稿版本包括了时间消耗的表格，但是我把表格去掉了，怕误导大家。取而代之的是，我们讨论的是一个相对的时间/性能的复杂度。</p>
</blockquote>
<p>让我们将 <code>nthFibonacci</code> 和 <code>fibonacciSumUpTo</code> 两个函数结合来减少一点运算量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fastFibonacciSumUpTo</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">        (i, j) = (j, i + j) <span class="comment">// 计算下一个数</span></span><br><span class="line">        sum += i <span class="comment">// 更新总数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fastFibonacciSumUpTo(<span class="number">7</span>) <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<p>现在我们已经将 <code>fastFibonacciSumUpTo</code> 的复杂度从二次降为线性了。</p>
<p>但是为了实现这个，我们不得不写了一个更加复杂的方程。我们在分离相关度(把计算斐波那契数和求和分为2步) 和优化性能之间进行了权衡。</p>
<p>我们的计划是用 Swift 的标准库来简化和解开我们的代码。首先我们来总结一些我们要做什么。</p>
<ol>
<li>将前n个斐波那契数用线性时间(linear time)和常量空间(constant space)的方式<strong>加起来</strong>。</li>
<li>将<strong>前</strong>n个斐波那契数用<strong>线性时间(linear time)和常量空间(constant space)的方式</strong>加起来。</li>
<li>将前n个<strong>斐波那契数</strong>用线性时间(linear time)和常量空间(constant space)的方式加起来。</li>
</ol>
<p>幸运的是，Swift 正好有我们需要的功能！</p>
<p>1、 <code>reduce</code> 函数，用 <code>+</code> 操作符来结合。</p>
<p>2、 <code>prefix</code> 函数和<a href="https://zh.wikipedia.org/wiki/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC" target="_blank" rel="external">惰性求值</a>(Lazy Evaluation)</p>
<blockquote>
<p>注意：prefix只有在 Xcode 7 beta 4中可用，作为 CollectionTypes 的一个全局函数使用，但其实已经在 OS X 10.11 beta 5 API 作为 SequenceType 的扩展出现了。我期望在下一个 Xcode beta 有一个延迟实现的版本；现在这里有一个<a href="https://gist.github.com/jtbandes/d8a600c51fa7e93162fa" target="_blank" rel="external">自定义的实现</a>。</p>
</blockquote>
<p>3、 定制数列，使用数列型协议(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Reference/Swift_SequenceType_Protocol/index.html" target="_blank" rel="external">SequenceType protocol</a>)</p>
<h3 id="定制数列">定制数列</h3><p>Swift 的 <code>for-in</code> 循环的基础是 <code>SequenceType</code> 协议。所有遵循这个协议的可以循环。</p>
<p>想要成为一个 SequenceType 只有一个要求，就是提供一个创建器( <code>Generator</code> )：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SequenceType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Generator</span>: <span class="type">GeneratorType</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">Generator</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而成为一个 <code>GeneratorType</code> 只有一个要求，就是生产元素( <code>Elements</code> )</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GeneratorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以一个数列就是一个可以提供元素创建器的东西。</p>
<p>最快创建定制数列的方法就是用<code>AnySequence</code>。这是一个内建的结构体，可以响应<code>generate()</code>，去调用一个你在初始化时所给的闭包。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">SequenceType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">G</span>: <span class="type">GeneratorType</span> <span class="keyword">where</span> <span class="type">G</span>.<span class="type">Element</span> == <span class="type">Element</span>&gt;</span><br><span class="line">    (<span class="number">_</span> makeUnderlyingGenerator: () -&gt; <span class="type">G</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，我们可以用 <code>AnyGenerator</code> 和 <code>anyGenerator</code> 函数来造创建器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">anyGenerator</span><span class="generics">&lt;Element&gt;</span><span class="params">(body: <span class="params">()</span></span></span> -&gt; <span class="type">Element</span>?) -&gt; </span><br><span class="line"><span class="type">AnyGenerator</span>&lt;<span class="type">Element</span>&gt;</span><br></pre></td></tr></table></figure>
<p>所以写一个斐波那契数列就相当简单了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacciNumbers = <span class="type">AnySequence</span> &#123; () -&gt; <span class="type">AnyGenerator</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// 为了创建一个生成器，我们首先需要建立一些状态...</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">anyGenerator</span> &#123;</span><br><span class="line">        <span class="comment">// ... 然后生成器进行改变</span></span><br><span class="line">        <span class="comment">// 调用 next() 一次获取每一项</span></span><br><span class="line">        <span class="comment">// (代码看起来是不是很熟悉？)</span></span><br><span class="line">        (i, j) = (j, i + j)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>fibonacciNumbers</code> 是一个 <code>SequenceType</code>，我们可以使用 <code>for</code> 循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fibonacciNumbers &#123;</span><br><span class="line">    <span class="built_in">print</span>(f) <span class="comment">// 打印 1, 然后打印 1, 继续打印 2, 3, 5, 8, 13, 21, 34, 55...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且我们可以自由的使用 <code>prefix</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> fibonacciNumbers.<span class="keyword">prefix</span>(<span class="number">7</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(f) <span class="comment">// 打印 1, 1, 2, 3, 5, 8, 13, 然后停止.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们可以用 <code>reduce</code> 来加起来：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fibonacciNumbers.<span class="keyword">prefix</span>(<span class="number">7</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +) <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<p>太棒了！这是线性时间的，常量空间的，最重要的是这非常清晰的展示了我们所要做的，而不需要使用 <code>...</code> 和 <code>map</code>。</p>
<blockquote>
<p>说明：如果你在playground里运行这段代码，可能会发现这个版本比之前的要慢。这个版本只改变了常数部分，复杂度本身没有变化，但是性能却有明显下降。和 fastFibonacciSumUpTo 进行对比可以发现，这段代码把单一的循环改成了函数调用，这可能就是性能降低的原因。没错，我们又需要进行权衡。</p>
</blockquote>
<h3 id="灵活度">灵活度</h3><p>目前的目标只是给了我们一个更好给工具去解答有关斐波那契数的问题。深入钻研来看，我们可能会问：为什么我要先研究斐波那契数？这不过是这个数列恰好符合我们所发现的规律：</p>
<p>$$S_{今天} = S_{昨天} + S_{前天}$$</p>
<p>这个公式在我们代码中表现为 <code>(i, j) = (j, i + j)</code>。但是这深藏了 <code>AnySequence</code> 和 <code>anyGenerator</code>。如果我们要写更加清晰的代码 — 可以描述我们想要解决的问题、不需要仔细分析 — 我们最好写的更加明显点。</p>
<p>斐波那契数列常写成这种形式：</p>
<p>$$F_{n} = F_{n-1} + F_{n-2}$$</p>
<p>这是类似的形式，但是最重要的是这表现出递推关系。这种数学关系指的是数列里某一个数的值取决于前面几个数的值。</p>
<p>定义递推关系的时候，首先要定义初始项。我们不能简单的利用 <code>(i, j) = (j, i + j)</code> 来计算斐波那契数如果我们不知道什么是 i 什么是 j。在我们的例子里，我们的初始项为 <code>i = 0</code> 和 <code>j = 1</code> —— 或者，我们可以把初始值定为1和1，因为我们是等第一个值返回以后才进行计算的。</p>
<p>递推关系的<strong>阶数</strong>(order)是指每一步所需的前面项的个数，而且初始项数目必须等于阶数（不然的话我们就没有足够的信息来计算下一项）。</p>
<p>现在我们可以来设计API了！你只需提供初始项和递推就可以创建递推关系了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecurrenceRelation</span>&lt;<span class="title">Element</span>&gt;</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/// - Parameter initialTerms: The first terms of the sequence.</span></span><br><span class="line">    <span class="comment">///     The `count` of this array is </span></span><br><span class="line">    <span class="comment">///     the **order** of the recurrence.</span></span><br><span class="line">    <span class="comment">/// - Parameter recurrence: </span></span><br><span class="line">    			<span class="type">Produces</span> the `n`th term from the previous terms.</span><br><span class="line">    			</span><br><span class="line">    <span class="comment">/// - 参数 initialTerms: 序列的第一个元素集合.</span></span><br><span class="line">    <span class="comment">/// 数组的个数也就代表这个递推的排序。</span></span><br><span class="line">   	<span class="comment">/// - 参数 recurrence：根据前面的元素推算出第 n 个元素</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> initialTerms: [<span class="type">Element</span>], <span class="number">_</span> recurrence: </span><br><span class="line">    (<span class="type">T</span>: <span class="type">UnsafePointer</span>&lt;<span class="type">Element</span>&gt;, n: <span class="type">Int</span>) -&gt; <span class="type">Element</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（我们在使用 <code>UnsafePointer&lt;Element&gt;</code> 而不是 <code>[Element]</code>，这样我们就可以使用 <code>T[n]</code> 而不需要存储先前计算的项）。</p>
<p>现在，我们的初始任务变得更加简单了。<strong>多少人在使用Swift？</strong> 只要用这个公式即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> peopleWritingSwift = <span class="type">RecurrenceRelation</span>([<span class="number">1</span>, <span class="number">1</span>]) </span><br><span class="line">&#123; <span class="type">T</span>, n <span class="keyword">in</span> <span class="type">T</span>[n-<span class="number">1</span>] + <span class="type">T</span>[n-<span class="number">2</span>] &#125;</span><br><span class="line"></span><br><span class="line">peopleWritingSwift.<span class="keyword">prefix</span>(<span class="number">7</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +) <span class="comment">// 返回 33</span></span><br></pre></td></tr></table></figure>
<h4 id="那么，如何来实现这个API呢?">那么，如何来实现这个API呢?</h4><p>我们来做吧。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RecurrenceRelation</span>&lt;<span class="title">Element</span>&gt;: <span class="title">SequenceType</span>, <span class="title">GeneratorType</span></span><br><span class="line"></span>&#123;</span><br></pre></td></tr></table></figure>
<p>首先我们需要一些内存来存储元素，还需要一个引用来链接到我们所要传递的闭包。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> recurrence: (<span class="type">T</span>: <span class="type">UnsafePointer</span>&lt;<span class="type">Element</span>&gt;, n: <span class="type">Int</span>) -&gt; <span class="type">Element</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> storage: [<span class="type">Element</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/// - 参数 initialTerms: 序列的第一个元素集合.</span></span><br><span class="line"><span class="comment">/// 数组的个数也就代表这个递推的排序。</span></span><br><span class="line"><span class="comment">/// - 参数 recurrence：根据前面的元素推算出第 n 个元素</span></span><br><span class="line"><span class="keyword">init</span>(<span class="number">_</span> initialTerms: [<span class="type">Element</span>], <span class="number">_</span> recurrence: (<span class="type">T</span>: <span class="type">UnsafePointer</span>&lt;<span class="type">Element</span>&gt;, n: <span class="type">Int</span>) -&gt; <span class="type">Element</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.recurrence = recurrence</span><br><span class="line">    storage = initialTerms</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了简单点，我们同时采用 <code>SequenceType</code> and <code>GeneratorType</code>。对于 <code>generate()</code>，我们只返回 <code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SequenceType requirement</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">RecurrenceRelation</span>&lt;<span class="type">Element</span>&gt; &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，每次调用 <code>next()</code>，我们调用 <code>recurrence</code> 来产生下一个值， 并且将其存在 <code>storage</code> 里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// GeneratorType requirement</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> iteration = <span class="number">0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>?</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 首先推算出所有的初始元素值</span></span><br><span class="line">        <span class="keyword">if</span> iteration &lt; storage.<span class="built_in">count</span> &#123; <span class="keyword">return</span> storage[iteration++] &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> newValue = storage.withUnsafeBufferPointer &#123; buf <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 调用闭包，传入内存地址中的指针的偏移量，知道 T[n-1] 是数组中最后一个元素</span></span><br><span class="line">            <span class="keyword">return</span> recurrence(<span class="type">T</span>: buf.baseAddress + </span><br><span class="line">            storage.<span class="built_in">count</span> - iteration, n: iteration)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 存储下一个的值，丢弃到最旧的值</span></span><br><span class="line">        storage.removeAtIndex(<span class="number">0</span>)</span><br><span class="line">        storage.append(newValue)</span><br><span class="line">        iteration++</span><br><span class="line">        <span class="keyword">return</span> newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更新：<a href="https://twitter.com/oisdk/status/629296752538066945" target="_blank" rel="external">@oisdk</a>指出 <code>UnsafePointer</code> 不是必须的。在原来的版本中，我使用它是为了让 n 的值在 recurrence 中更加精确 - 但是自从 recurrence 只依赖与前一项，而不是 n 本身时，n 的值不再改变时，这是ok的。 所以这个版本运行良好。不使用 <code>UnsafePointer</code> 感觉更加安全了! </p>
</blockquote>
<p>记住：有许多种方法可以定义自定义数列。<code>CollectionType</code>，<code>SequenceType</code>，和 <code>GeneratorType</code> 只是协议，你可以按照自己所需的方式来遵循它们。也就是说，在实践中也许你很少需要这么做 —— Swift 的标准库里有大多数你所需的。不过如果你觉得需要自定义的数据结构，你可以使用 <code>CollectionType</code> 和 <code>SequenceType</code>。</p>
<h4 id="更多的例子">更多的例子</h4><p>现在我们已经归纳了递推关系，我们可以轻松地计算许多东西了。比如说卢卡斯数（<a href="https://en.wikipedia.org/wiki/Lucas_number" target="_blank" rel="external">Lucas Number</a>）。和斐波那契数类似，只不过初始项不同：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, 322, 521...</span></span><br><span class="line"><span class="keyword">let</span> lucasNumbers = <span class="type">RecurrenceRelation</span>([<span class="number">2</span>, <span class="number">1</span>]) &#123; <span class="type">T</span>, n <span class="keyword">in</span> <span class="type">T</span>[n-<span class="number">1</span>] + <span class="type">T</span>[n-<span class="number">2</span>] &#125;</span><br></pre></td></tr></table></figure>
<p>或者”Tribonacci Numbers“，一个拥有<a href="http://math.stackexchange.com/a/1128994/21666" target="_blank" rel="external">有趣性质</a>的三阶递推：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504...</span></span><br><span class="line"><span class="keyword">let</span> tribonacciNumbers = <span class="type">RecurrenceRelation</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]) </span><br><span class="line">&#123; <span class="type">T</span>, n <span class="keyword">in</span> </span><br><span class="line">	<span class="type">T</span>[n-<span class="number">1</span>] + <span class="type">T</span>[n-<span class="number">2</span>] + <span class="type">T</span>[n-<span class="number">3</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>花一些额外的功夫，我们可以视觉化<a href="https://en.wikipedia.org/wiki/Logistic_map#Chaos_and_the_logistic_map" target="_blank" rel="external">单峰映像的混沌二根分支</a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">logisticMap</span><span class="params">(r: Double)</span></span> -&gt; <span class="type">RecurrenceRelation</span>&lt;<span class="type">Double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">RecurrenceRelation</span>([<span class="number">0.5</span>]) &#123; x, n <span class="keyword">in</span> </span><br><span class="line">    	r * x[n-<span class="number">1</span>] * (<span class="number">1</span> - x[n-<span class="number">1</span>]) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">2.5</span>, to: <span class="number">4</span>, by: <span class="number">0.005</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">map</span> = logisticMap(r)</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">50</span> &#123; <span class="built_in">map</span>.next() &#125; </span><br><span class="line">    <span class="comment">// 处理一些得到的值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Array</span>(<span class="built_in">map</span>.<span class="keyword">prefix</span>(<span class="number">10</span>))[<span class="type">Int</span>(arc4random_uniform(<span class="number">10</span>))] </span><br><span class="line">    <span class="comment">// 随机选择接下来 10 个值当中的一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/content/images/2015/08/QQ20150831-1-2x.png" alt=""><br>是不是很有数学的简洁性呀？</p>
<h4 id="相关推荐">相关推荐</h4><ul>
<li>TED 演讲，<a href="https://www.ted.com/talks/arthur_benjamin_the_magic_of_fibonacci_numbers" target="_blank" rel="external">The magic of Fibonacci numbers</a>, 演讲者，Arthur Benjamin.</li>
<li><a href="http://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html" target="_blank" rel="external">Binet’s Formula</a>, 使用一个几乎常量时间的公式来计算斐波那契数。</li>
<li><a href="http://airspeedvelocity.net/2015/08/03/arrays-linked-lists-and-performance/" target="_blank" rel="external">Arrays, Linked Lists, and Performance</a>，作者 Airspeed Velocity, 对序列使用其他有意思的方法，包括对ManagedBuffer的讨论。<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Jacob Bandes-Storch，<a href="http://bandes-stor.ch/blog/2015/08/05/the-fibonacci-sequencetype/">原文链接</a>，原文日期：2015/08/05<br>译者：<a href="undefined">Lou</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
<p>这篇博文启发自<a href="http://codereview.stackexchange.com/questions/60875/project-euler-2-even-fibonacci-numbers-in-swift">Code Review.SE</a>上的一个讨论，同时<a href="https://xkcd.com/356/">nerd-sniped</a>上的关于数学的有趣的学习。让我对数学和 Swift 的结合有了兴趣。所以我花了一段时间来把这些知识整理成一篇博文，特别是自从我完成了对我网站重建的第一步以后。更重要的是，我希望我能更勤勉的更新我的博客，这8年我只写了一篇而已，希望大家能对我的博客感兴趣。<br>这篇博文的目标对于初学者来讲，比较容易理解，同时也提供给那些已经对这个概念熟悉的人一些有用的细节和例子。希望大家能给我反馈。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Jacob Bandes-Storch" scheme="http://swiftggteam.github.io/tags/Jacob-Bandes-Storch/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 iOS 中实现一个可展开的 Table View]]></title>
    <link href="http://swiftggteam.github.io/2015/12/03/expandable-table-view/"/>
    <id>http://swiftggteam.github.io/2015/12/03/expandable-table-view/</id>
    <published>2015-12-02T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：AppCoda，<a href="http://www.appcoda.com/expandable-table-view/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-16<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>几乎所有的应用程序都有一个共同的特点：允许用户在多个视图控制器之间导航和协同工作。这些视图控制器应用非常广泛，例如简单显示某些形式的信息到屏幕上，或从用户处收集复杂的输入数据。为了实现一款应用的不同功能，经常需要创建新的视图控制器，且多数任务比较艰巨。不过，倘若你利用<code>expandable tableviews</code>（之后统一译为可展开的 tableview ） ，我们就能避免创建新的视图控制器（以及相关的界面和 storyboard）。</p>
<a id="more"></a>
<p>顾名思义，可展开的 tableview “允许”其单元格展开和折叠，显示和隐藏那些始终可见的单元格下的其他单元格。当需要收集简单数据或向用户显示请求信息时，创建可展开的 tableview 是一个不错的选择。通过这种方式，我们无需再创建新的视图控制器，只需给定几种选项供用户抉择（只能选其一）。例如，利用可展开的 tableview ，你可以显示和隐藏用于收集数据的表格选项，而不再需要其他额外的视图控制器。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/expandable-uitableview.jpg" alt=""></p>
<p>是否应该使用可展开的 tableview 取决于你所开发的应用程序的性质。应用程序的外观和体验通常来说不需要考虑，我们可以继承 <code>UITableViewCell</code> 并自定义单元格的 UI，还可以创建额外的 xib 文件。总之，它仅仅和需求有关。</p>
<p>本教程中，我将向你展示一种简单但实用的可展开 <code>tableview</code> 创建方式。注意，实现 tableview 展开功能并不是只有本文介绍的这种方法。大部分实现都要考虑应用的具体需求，但我旨在提供一个相对通用的可以在大多数情况下重用的方法。好了，下面我们来看看本文要实现什么应用。</p>
<h3 id="关于演示应用">关于演示应用</h3><p>我们将看到如何创建并使用一个可展开的 tableview ，我们会用一个包含 tableview 的视图控制器来实现整个应用。首先，我们来制作一个表单供用户输入数据，该 tableview 包含以下三个部分：</p>
<ol>
<li>个人信息（ Personal ）</li>
<li>爱好（ Preferences ）</li>
<li>工作经验（ Work Experience ）</li>
</ol>
<p>每个 section 包含一些可展开的单元格，用于触发显示或隐藏当前 section 中其他单元格。每个 section 的顶级单元格（用于展开和折叠其他单元格）具体描述如下：</p>
<p>“Personal” section 内容如下：</p>
<ol>
<li><em>Full name</em>：显示用户的全名，当点击展开时，显示两个可用的子单元格用于键入 first name 以及 last name。</li>
<li><em>Data of birth</em>：显示用户的出生日期。当展开该单元格时，提供一个日期选择视图（<code>date pickerview</code>）供用户选择日期，以及一个提交按钮将所选日期显示到对应的顶级单元格中。</li>
<li><em>Martial status</em>：显示用户是已婚还是单身。展开时，提供一个开关控件（switch control）用于设置用户婚姻状态。</li>
</ol>
<p>“Preferences” section 内容如下：</p>
<ol>
<li><em>Favorite sport</em>：我们的表单还应要求用户选择最喜欢的运动,选中后显示在该单元格中。当该单元格呈展开状态时,出现四个运动条目可供选择,当其中一个子条目选中后，单元格自动折叠。</li>
<li><em>Favorite color</em>：基本和上面一致，这里我们将显示三个不同的颜色条目供用户选择。</li>
</ol>
<p>“Work Experience” section 内容如下：</p>
<ol>
<li><em>Level</em>：当点击展开这个顶级单元格时，显示另外一个包含滑动控件（slider control）的单元格，要求用户指定一个大概的工作经验水平。值的范围限定在 [0,10] 之间，以整型数据保存。</li>
</ol>
<p>下面的动画图形展示了我们将要实现的内容：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_7_expand_collapse.gif" alt="gif"></p>
<p>上面的动画中可以看到 tableview 展开时显示了各式各样的单元格。所有这些都能在<a href="https://www.dropbox.com/s/37qu76zlzg8yg8p/ExpandableTableStarter.zip?dl=0" target="_blank" rel="external">初始项目</a>中找到，项目中已经预先做好了一些准备工作。所有自定义单元格均采用 xib 文件设计，指定它们的 Custom Class 为自定义 CustomCell 类，继承自 <code>UITableViewCell</code>: </p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_2_custom_class.png" alt="img1"></p>
<p>项目中你可以找到以下单元格的 xib 文件：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_3_cell_list.png" alt="img2"></p>
<p>它们的文件名已经表明了每一个单元格的用途，你也可以对它们做深入探究。</p>
<p>除了单元格之外，你还可以找到一些已经实现的代码。尽管它们非常重要，完成了演示应用程序的功能，但是那些代码并不包含本教程的核心部分，所以我选择直接跳过，只是提供实现代码。教程中我们感兴趣的代码将随着章节学习逐步添加进来。</p>
<p>好了，现在你已经知道我们的最终目标是什么了，是时候去创建一个可展开的 tableview 了。</p>
<h3 id="描述单元格">描述单元格</h3><p>本教程中，我向你展示的所有有关可展开 tableview 的实现和技术都遵循一个单一和简单的思想：描述应用中每个单元格的细节。通过这种方式，你就可以知晓哪些单元格是可展开的、哪些是可见的、每一个单元格中的标签值是什么等等。确切来说，整体思想如下：为每一个单元格分配一组描述信息、描述属性或特定的值，接着向应用提供这些描述来正确显示每一个单元格。</p>
<p>对于这个演示应用程序，我创建和使用的所有属性都显示在下面列表中。注意，你可以新增属性，也可以修改现有项。不管怎样，最重要的是你能统筹全局，这样你才能够执行所有你需要的改动。属性列表如下：</p>
<ul>
<li>isExpandable：这是一个布尔类型值，表明单元格是否允许被展开。它在本教程中是一个相当重要的属性值。</li>
<li>isExpanded：依旧是一个布尔类型值，指示一个可展开的单元格的当前状态（展开或折叠）。顶级单元格默认是折叠的，因此所有顶级单元格的初始值均将设置为<code>NO</code>。</li>
<li>isVisible：顾名思义，指示单元格是否可见。它将在之后起到举足轻重的作用，我们将根据该属性在 tableview 中显示合适的单元格。</li>
<li>value：这个属性对于保存 UI 控件的值（例如婚姻状况中的<code>switch</code>控件的状态值）相当有用。不是所有的单元格都有这样的控件,所以它们中的绝大部分的 value 属性值为空。</li>
<li>primaryTitle：用于显示单元格主标题标签（main title label）中的文本内容，还包含一些应该显示在单元格中的实际值。</li>
<li>secondaryTitle：用于显示单元格子标题标签（subtitle lable）或二级标签的文本内容，</li>
<li>cellIdentifier：自定义单元格的标识符所匹配的当前描述。通过使用 cellIdentifier，应用程序不仅能够出列合适的单元格（tableview 中的 dequeue 方法），而且可以根据显示的单元格来确定应该执行的 action ，以及指定每个单元格的高度。</li>
<li>additionalRows：它包含的附加行总数，即那些当单元格展开式需要显示的额外行数。</li>
</ul>
<p>我们将使用上文介绍的属性集合来描述 tableview 中的每一个单元格。在应用层面我们只需一个属性列表（plist）文件即可实现，简单易用。在 plist 文件中，我们将为所有单元格正确地填充上述属性的值，这样从应用角度来说，我们最终只要一份完整的技术描述，无需编写一行代码。这是不是灰常棒呢？</p>
<p>通常来说，我们会在项目中创建一个新的属性列表文件，接着开始往里面填充适当的数据。但这里无需自己动手，我已经为你提供了<a href="https://www.dropbox.com/s/8bjwn3k1e84xkmw/CellDescriptor.plist.zip?dl=0" target="_blank" rel="external">.plist</a>文件。所以，你只需下载并将它添加到启动项目即可。为所有单元格设置属性非常麻烦并且毫无意义，那些填充缺省值的复制粘贴行为只可能会让你感觉疲劳和枯燥。不过，我们还是需要介绍一下 plist 文件内容：</p>
<p>首先，你下载的文件名应该为 <code>CellDescriptor.plist</code>（希望没有错）。基础结构（请见下图中的 Root 键名）是一个数组，其中每个条目项分别对应 tableview 中所呈现的 section。这意味着 plist 文件包含三个条目项，和 tableview 中显示的 section 数目保持一致。</p>
<p>每个 section 中包含的条目项同样是一个数组（类型为字典），分别用于描述当前 section 中的每一个单元格。实际上，我们采用字典形式对上述属性进行分组，每一个字典匹配一个单独的单元格描述。下面是属性列表文件的一个示例：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_4_plist_sample.png" alt="img3"></p>
<p>现在是最佳时机，抽点时间出来，透彻地理解下所有我们将要显示到 tableview 中的单元格描述属性以及相关值。显然，通过使用单元格描述，能够帮助我们明显减少创建和管理可展开单元格的代码，此外我们无需告知应用关于这些单元格的状态（例如，哪些单元格是可扩展的，它是否允许特定单元格进行展开，在代码中确定单元格是否可见等等这些问题）。所有这些信息已经存储在你刚刚下载的属性列表文件之中。</p>
<h3 id="加载单元格描述">加载单元格描述</h3><p>终于可以开始编写代码了，尽管我们描述单元格的方式（即 plist 文件）节省了大量时间，但依旧需要向项目中添加代码。现在单元格的描述属性列表文件已经处于项目之中,我们首先要做的就是以编程方式把它的内容加载到一个数组中。这个数组将在下一小节作为 tableview 的数据源（datasource）。</p>
<p>首先，请打开项目中 ViewController.swift 文件，在类顶部声明如下属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cellDescriptors: <span class="type">NSMutableArray</span>!</span><br></pre></td></tr></table></figure>
<p>该数组将包含所有单元格字典类型的描述，从属性列表文件加载得到。</p>
<p>接着，让我们实现一个自定义函数，用于实现加载文件内容到数组中。我们为该函数命名为 <code>loadCellDescription()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">loadCellDescriptors</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> path = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"CellDescriptor"</span>, ofType: <span class="string">"plist"</span>) &#123;</span><br><span class="line">        cellDescriptors = <span class="type">NSMutableArray</span>(contentsOfFile: path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里的实现方法相当简单：首先我们确保属性列表文件在 bundle 中的路径是有效的，接着我们加载文件内容并初始化 <code>cellDescriptors</code> 数组。</p>
<p>下一步我们将调用上述方法，在视图将要显示之前、tableview 配置之后调用函数（我们希望先对 tableview 进行配置，然后在它上面显示数据）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line">    <span class="comment">// 先配置tableview</span></span><br><span class="line">    configureTableView()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后加载数据</span></span><br><span class="line">    loadCellDescriptors()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在上面代码最后一行键入<code>print(cellDescriptors)</code>命令，运行应用，你将看到命令控制台处打印了 plist 文件的所有内容。这意味着它们已经成功被加载到内存中了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_5_console_plist.png" alt="img4"></p>
<p>按照惯例，我们本节的任务应该到此结束，但恰恰相反；我们将继续下去，接下来的部分至关重要。到目前为止，你已经发现（特别是打印 <code>CellDescriptor.plist</code> 文件内容之后），当应用程序启动之后并不是所有单元格都是可见的（译者注： plist 文件中单元格的 Visible 属性，有些为 YES，有些则为 NO）。实际上，我们不能知晓它们究竟是否将同时可见，因为只有当每次用户要求时，它们才进行展开或折叠。</p>
<p>从编程角度来说，这意味着每个单元格的行索引值（row index）不允许为常量（一般我们处理单元格时，都喜欢使用<code>IndexPath.row</code>这种编程方式），所以我们不能通过单元格行号遍历数据源数组（cellDescriptors）并显示单元格。解决方式如下：仅提供可见的单元格行索引值。任何尝试显示描述中标记为不可见的单元格都会出错，当然还会导致其他异常应用行为。</p>
<p>所以，为此我们将要实现一个新函数<code>getIndicesOfVisibleRows()</code>。它的名字已经说明了它的作用: 它仅获取那些已经标记为可见的单元格。在我们继续执行之前，请再次回到类的顶部，新增如下声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> visibleRowsPerSection = [[<span class="type">Int</span>]]()</span><br></pre></td></tr></table></figure>
<p>该二维数组将用于存储每个 section 中可见的单元格行索引值（一维用作 section,另一维用作 rows）。</p>
<p>现在，让我们来看新函数的实现。你可能已经猜到，我们将检查所有单元格的描述信息，接着将那些“isVisible”属性值为<code>YES</code>的单元格索引值添加到二维数组中。很显然，我们不得不通过一个嵌套循环来处理，但是它用起来不难。这里是函数实现:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getIndicesOfVisibleRows</span><span class="params">()</span></span> &#123;</span><br><span class="line">    visibleRowsPerSection.removeAll()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历单元格描述数组</span></span><br><span class="line">    <span class="keyword">for</span> currentSectionCells <span class="keyword">in</span> cellDescriptors &#123;</span><br><span class="line">        <span class="comment">// 暂存每个 section 中，isVisible = true 的行号</span></span><br><span class="line">        <span class="keyword">var</span> visibleRows = [<span class="type">Int</span>]()</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="number">0</span>...((currentSectionCells <span class="keyword">as</span>! [[<span class="type">String</span>: <span class="type">AnyObject</span>]]).<span class="built_in">count</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查每个单元格的isVisible属性是否为true</span></span><br><span class="line">            <span class="keyword">if</span> currentSectionCells[row][<span class="string">"isVisible"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">                visibleRows.append(row)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将所有标记为可见的单元格行号保存到该数组中</span></span><br><span class="line">        <span class="comment">// 首次加载描述文件后 该数组值为 [[0, 3, 5], [0, 5], [0]]</span></span><br><span class="line">        visibleRowsPerSection.append(visibleRows)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，函数一开始需要清空<code>visibleRowsPerSection</code>数组中之前的所有内容，否则后续调用该函数我们将最终得到错误的数据。除此之外，实现方式非常简单，所以我不会过多介绍细节。</p>
<p>首次调用上述函数位置应该在从文件加载单元格描述信息操作之后（我们将在之后再次调用它）。因此，重新审视我们在这一部分中实现的第一个函数，我们修改如下:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">loadCellDescriptors</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> path = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"CellDescriptor"</span>, ofType: <span class="string">"plist"</span>) &#123;</span><br><span class="line">        cellDescriptors = <span class="type">NSMutableArray</span>(contentsOfFile: path)</span><br><span class="line">        getIndicesOfVisibleRows()</span><br><span class="line">        tblExpandable.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管 tableview 目前还不能正常使用（要知道还未实现 Datasource 方法！），但我们提前调用<code>reloadData()</code>进行 tableview 重载，确保应用程序启动后，能够正确显示单元格内容。</p>
<h3 id="显示单元格">显示单元格</h3><p>别忘了每一次应用程序启动时都要加载单元格描述，下面我们准备处理和显示这些单元格。本小节中，我们首先创建另一个新函数，在 <code>cellDescriptors</code> 数组中查找并返回适当的单元格描述信息。如你即将在下面代码片段中看到的一样，从 <code>visibleRowsPerSection</code> 数组中获取数据（即可见行的索引值）是新函数工作的先决条件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getCellDescriptorForIndexPath</span><span class="params">(indexPath: NSIndexPath)</span></span> -&gt; [<span class="type">String</span>: <span class="type">AnyObject</span>] &#123;</span><br><span class="line">    <span class="comment">// 步骤一：</span></span><br><span class="line">    <span class="keyword">let</span> indexOfVisibleRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line">    <span class="comment">// 步骤二：</span></span><br><span class="line">    <span class="keyword">let</span> cellDescriptor = cellDescriptors[indexPath.section][indexOfVisibleRow] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">return</span> cellDescriptor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数接受某个单元格的路径索引值（<code>NSIndexPath</code>），且该单元格此刻是 tableview 的处理项；函数返回值为一个字典，包含匹配单元格的所有属性。函数内部实现的首要任务在给定路径索引值（即 index path）的条件下，找到匹配的可见行的索引值,这一步很简单，只需要传入每个单元格的 section 和 row 即可（请见步骤一）。到目前为止，我们还未接触到 tableview 的代理方法，对上述内容也一知半解，但是我可以提前给你打个“预防针”：每个 section 的 row 总数将与每个 section 中的可见单元格数目保持一致。这意味着，上述实现中任意一个 indexPath.row 值（译者注：section是固定的），在 visibleRowsPerSection 数组中都能找到一个可见单元格的索引值与之匹配。</p>
<p>通过每个单元格的行索引值，我们可以从 <code>cellDescriptors</code> 数组中“提取”到单元格描述信息（字典类型）。请注意提取过程中，数组的第二个维度值为 <code>indexOfVisibleRow</code>，而不是 <code>indexPath.row</code>。倘若使用第二个将导致返回错误数据。</p>
<p>我们再次构建了一个非常有用的函数，事实证明在之后的开发中非常好用。现在我们开始实现 <code>viewController</code> 类中的已存在的 tableview 方法。首先，我们需要指定 tableview 的 section 数量。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> cellDescriptors != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cellDescriptors.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你要知道我们不能忽视 <code>cellDescriptors</code> 数组为<code>nil</code>的情况。当数组已经初始化完毕且填充了单元格描述信息，我们返回数组的元素个数。</p>
<p>接着，我们指定每个 section 的行数。正如我之前所说的，行数和可见单元格数量保持一致，所以我们可以仅用一行代码返回该信息。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> visibleRowsPerSection[section].<span class="built_in">count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，确定 tableview 中每个 section 的标题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, titleForHeaderInSection section: Int)</span></span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> section &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Personal"</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Preferences"</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Work Experience"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，是时候指定每一行的高度了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentCellDescriptor = getCellDescriptorForIndexPath(indexPath)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"idCellNormal"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">60.0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"idCellDatePicker"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">270.0</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">44.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我需要强调一些东西：这部分中我们首次调用早前实现的 <code>getCellDescriptorForIndexPath:</code>函数。我们需要获得正确的单元格描述信息，紧接着有必要取得“cellIdentifier”属性，只有依靠它的值才能指定行高。你可以在每个 xib 文件中检查每种类型的单元格行高（就是如下所示的行高）。</p>
<p>最后是显示实际的单元格。起初，每个单元格必须被 <code>dequeued</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentCellDescriptor = getCellDescriptorForIndexPath(indexPath)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 每个单元格都是通过出列得到</span></span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次，我们传入当前路径索引值获得正确的单元格描述。通过使用”cellIdentifier”属性出列一个正确的单元格，这样我们能够对每个单元格的特殊处理作进一步的深入探讨（译者注：说白了就是根据 cellIdentifier 标识符对单元格做分支处理）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> currentCellDescriptor = getCellDescriptorForIndexPath(indexPath)</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span>, forIndexPath: indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellNormal"</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> primaryTitle = currentCellDescriptor[<span class="string">"primaryTitle"</span>] &#123;</span><br><span class="line">            cell.textLabel?.text = primaryTitle <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> secondaryTitle = currentCellDescriptor[<span class="string">"secondaryTitle"</span>] &#123;</span><br><span class="line">            cell.detailTextLabel?.text = secondaryTitle <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellTextfield"</span> &#123;</span><br><span class="line">        cell.textField.placeholder = currentCellDescriptor[<span class="string">"primaryTitle"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellSwitch"</span> &#123;</span><br><span class="line">        cell.lblSwitchLabel.text = currentCellDescriptor[<span class="string">"primaryTitle"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> value = currentCellDescriptor[<span class="string">"value"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        cell.swMaritalStatus.on = (value == <span class="string">"true"</span>) ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellValuePicker"</span> &#123;</span><br><span class="line">        cell.textLabel?.text = currentCellDescriptor[<span class="string">"primaryTitle"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> currentCellDescriptor[<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellSlider"</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> value = currentCellDescriptor[<span class="string">"value"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        cell.slExperienceLevel.value = (value <span class="keyword">as</span> <span class="type">NSString</span>).floatValue</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于普通的单元格来说，我们仅需要设置 textLabel 标签的文本值为 primaryTitle，以及设置 detailTextLabel 标签的文本值为 secondaryTitle即可。在我们的演示应用中，使用 idCellNormal 标示符的单元格实际上就是顶级单元格（ top-level cells）,点击可展开和折叠内容。</p>
<p>对于那些包含 textfiled 的单元格，我们仅需将它的占位符值（placeholder value）设置为单元格描述信息中的 primaryTitle 即可。</p>
<p>对于那些包含 switch 控件的单元格，我们需要做两件事：首先指定 switch 控件前面的显示文本内容（示例中是常量，你可以通过修改 CellDescriptor.plist 文件改变它），其次我们需要为 switch 控件设置合适的状态，根据描述信息来决定“on”还是“off”。注意之后我们将有可能改变该值。</p>
<p>这里还有一些标识符为“idCellValuePicker”的单元格，这些单元格旨在提供一个选项列表。当点击选中某个选项时，父单元格会自动折叠当前内容。此时父单元格的文本标签值设置为选中值。</p>
<p>最后，有单元格包含了 slider 控件。这里我们从 currentCellDescriptor 字典中获取到当前值，将其转换为 float 类型的数字，再赋值给 slider 控件，这样它在可视情况下总能呈现正确的值。稍后我们会改变这个值，以及更新相应的单元格描述。</p>
<p>而那些没有添加上述几种情况标识符的单元格，在本演示应用中不会起任何作用。但是，倘若你想以不同的方式处理它们,可以随意修改代码并添加任何缺失的部分。</p>
<p>现在你可以运行应用，看看目前的成果。期望不要过高，因为你仅仅看到的只是顶级单元格内容。别忘了我们还未启用展开功能，所以当你点击它们时什么都不会出现。然而，不要气馁，正如你所看到的，到目前为止我们一切进展顺利。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_6_top_level_cells.png" alt=""></p>
<h3 id="展开和折叠">展开和折叠</h3><p>我猜想本节内容你可能期盼已久了，毕竟这是本教程实际目的所在。下面我们将通过每次点击顶级单元格控制展开和折叠，以及按要求显示或隐藏正确的子单元格。</p>
<p>首先，我们需要知道点击行的索引值（记住，不是实际的 indexPath.row,而是可见单元格中的行索引值），我们会首先将它分配给一个局部变量，如下 tableview 代理方法中所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然实现单元格展开和折叠的代码量不大，但是我们还是会逐步深入，这样你能理解每个步骤的作用。现在我们获取到了点击行的实际索引值，我们必须检查 cellDescriptors 数组中该单元格是否允许展开。如果它允许展开，且当前处于折叠状态时，我们将指示（我们将使用一个 flag 标志位）这个单元格必须展开，反之这个单元格必须折叠：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> shouldExpandAndShowSubRows = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpanded"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="comment">// In this case the cell should expand.</span></span><br><span class="line">            shouldExpandAndShowSubRows = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦上面的 flag 标志位设置为相应值，指示当前单元格的展开状态，这时候我们有责任将标志位值保存到单元格描述集合中，即更新 cellDescriptors 数组。我们要为选中的单元格更新 “isExpanded” 属性<br>，这样在随后的点击中它都能正常运行（当它处于展开时点击折叠，当折叠时点击展开）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> shouldExpandAndShowSubRows = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpanded"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">false</span> &#123;</span><br><span class="line">            shouldExpandAndShowSubRows = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        cellDescriptors[indexPath.section][indexOfTappedRow].setValue(shouldExpandAndShowSubRows, forKey: <span class="string">"isExpanded"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此刻，这里还有一个相当重要的细节不容我们忽视：如果你还记得，前文中指定了一个名为“isVisible”的属性表明单元格的显示状态，就存在于单元格的描述中。该属性必须随着上文 flag 值改变而改变，所以当单元格展开时，显示其他附加的不可见行，反之当单元格折叠时，隐藏那些附加行。实际上，通过更改该属性的值我们实现了单元格展开和折叠的效果。所以一旦点击了顶级单元格，需要立即更新附加单元格的信息，以下是修改后的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> shouldExpandAndShowSubRows = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpanded"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">false</span> &#123;</span><br><span class="line">            shouldExpandAndShowSubRows = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        cellDescriptors[indexPath.section][indexOfTappedRow].setValue(shouldExpandAndShowSubRows, forKey: <span class="string">"isExpanded"</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (indexOfTappedRow + <span class="number">1</span>)...(indexOfTappedRow + (cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"additionalRows"</span>] <span class="keyword">as</span>! <span class="type">Int</span>)) &#123;</span><br><span class="line">            cellDescriptors[indexPath.section][i].setValue(shouldExpandAndShowSubRows, forKey: <span class="string">"isVisible"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们距离追寻已久的功能实现仅一步之遥，但是我们首先必须关注一个更重要的事情：在上面代码片段中，我们仅改变了一些单元格的“isVisible”属性值，这意味着所有可见行的总数也随之改变了。所以，在我们重载 tableview 之前，我们必须重新向应用询问可见行的索引值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> shouldExpandAndShowSubRows = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpanded"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">false</span> &#123;</span><br><span class="line">            shouldExpandAndShowSubRows = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        cellDescriptors[indexPath.section][indexOfTappedRow].setValue(shouldExpandAndShowSubRows, forKey: <span class="string">"isExpanded"</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> (indexOfTappedRow + <span class="number">1</span>)...(indexOfTappedRow + (cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"additionalRows"</span>] <span class="keyword">as</span>! <span class="type">Int</span>)) &#123;</span><br><span class="line">            cellDescriptors[indexPath.section][i].setValue(shouldExpandAndShowSubRows, forKey: <span class="string">"isVisible"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getIndicesOfVisibleRows()</span><br><span class="line">    tblExpandable.reloadSections(<span class="type">NSIndexSet</span>(index: indexPath.section), withRowAnimation: <span class="type">UITableViewRowAnimation</span>.<span class="type">Fade</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你看见的那样，我仅对属于点击单元格的 section 部分进行动画重载，倘若你不喜欢这种方式的话，可以自己来实现。</p>
<p>现在快启动应用试试。点击顶级单元格进行展开和折叠，和子单元格互动下，尽管啥都不会发生，但是结果看起来相当棒！</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_7_expand_collapse.gif" alt=""></p>
<h3 id="取值">取值</h3><p>从现在开始，我们将把注意力完全集中在处理数据输入以及用户与子单元格内的控件的交互上。首先我们将为那些标识符为 “idCellValuePicker” 的单元格实现逻辑事务，处理点击事件。在我们的演示应用中，这些单元格都属于 tableview 中的 “Preferences” 部分，罗列最喜欢的运动和颜色选项内容。即使早前已经提及过，但是我觉得还是有必要重新让你回忆下，再次重申：当你点击选择某个选项后，相应的顶级单元格应该随之折叠（隐藏那些选项），并将选中的值显示到顶级单元格中。<br>。</p>
<p>我之所以选择处理这种类型的单元格为先，原因在于我可以继续在上部分的 tableview 代理方法中进行工作。方法中，我们将添加一个 <code>else</code> 分支处理 non-expandable 单元格的情况，接着检查点击单元格的标识符。如果标识符为“idCellValuePicker”，这就是我们感兴趣的单元格。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellValuePicker"</span> &#123;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getIndicesOfVisibleRows()</span><br><span class="line">    tblExpandable.reloadSections(<span class="type">NSIndexSet</span>(index: indexPath.section), withRowAnimation: <span class="type">UITableViewRowAnimation</span>.<span class="type">Fade</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>if</code> 分支内，我们将执行四种不同的任务：</p>
<ol>
<li>首先，我们需要找到顶级单元格的行索引值，即你点击选中的单元格的“父母”。事实上，我们采用自下而上（即从点击选中的单元格开始向上遍历）的方式对单元格描述数组执行一次搜索，首个属性<code>isExpandable = true</code>的单元格就是我们想要的家伙。</li>
<li>接着，将顶级单元格中的 textLabel 标签值设置为选中单元格的值。</li>
<li>然后，设置顶级单元格的 isExpanded 等于 false ，即折叠状态。</li>
<li>最后，标记顶级单元格下的所有子单元格为不可见状态。</li>
</ol>
<p>现在代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexOfTappedRow = visibleRowsPerSection[indexPath.section][indexPath.row]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cellDescriptors[indexPath.section][indexOfTappedRow][<span class="string">"cellIdentifier"</span>] <span class="keyword">as</span>! <span class="type">String</span> == <span class="string">"idCellValuePicker"</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> indexOfParentCell: <span class="type">Int</span>!</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 任务一</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">var</span> i=indexOfTappedRow - <span class="number">1</span>; i&gt;=<span class="number">0</span>; --i &#123;</span><br><span class="line">                <span class="keyword">if</span> cellDescriptors[indexPath.section][i][<span class="string">"isExpandable"</span>] <span class="keyword">as</span>! <span class="type">Bool</span> == <span class="literal">true</span> &#123;</span><br><span class="line">                    indexOfParentCell = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 任务二</span></span><br><span class="line">            cellDescriptors[indexPath.section][indexOfParentCell].setValue((tblExpandable.cellForRowAtIndexPath(indexPath) <span class="keyword">as</span>! <span class="type">CustomCell</span>).textLabel?.text, forKey: <span class="string">"primaryTitle"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 任务三</span></span><br><span class="line">            cellDescriptors[indexPath.section][indexOfParentCell].setValue(<span class="literal">false</span>, forKey: <span class="string">"isExpanded"</span>)</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 任务四</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> (indexOfParentCell + <span class="number">1</span>)...(indexOfParentCell + (cellDescriptors[indexPath.section][indexOfParentCell][<span class="string">"additionalRows"</span>] <span class="keyword">as</span>! <span class="type">Int</span>)) &#123;</span><br><span class="line">                cellDescriptors[indexPath.section][i].setValue(<span class="literal">false</span>, forKey: <span class="string">"isVisible"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getIndicesOfVisibleRows()</span><br><span class="line">    tblExpandable.reloadSections(<span class="type">NSIndexSet</span>(index: indexPath.section), withRowAnimation: <span class="type">UITableViewRowAnimation</span>.<span class="type">Fade</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再次修改了单元格中的“isVisible”属性，所有可见行的数量也随之改变。显然调用上述代码中的最后两个函数是非常有必要的。</p>
<p>现在如果你运行应用，实现效果如下：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/t45_8_select_preferences.gif" alt=""></p>
<h3 id="Responding_to_Other_User_Actions（求翻译）">Responding to Other User Actions（求翻译）</h3><p>打开 CustomCell.swift 文件，找到 CustomCellDelegate 的协议声明，其中定义了一系列需要的协议方法。通过在 ViewController 类中实现它们，我们将设法使应用程序响应所有缺省的用户操作。</p>
<p>让我们再次回到 ViewController.swift 文件，首先我们需要遵循该协议。定位到类的头部声明行，添加如下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDelegate</span>, <span class="title">UITableViewDataSource</span>, <span class="title">CustomCellDelegate</span></span></span><br></pre></td></tr></table></figure>
<p>接着，在 <code>tableView:cellForRowAtIndexPath:</code> 函数中，我们必须将每个自定义单元格的代理设置为 ViewController 类（即 self）。定位到那里，就在<code>return cell</code> 的上方添加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置代理</span></span><br><span class="line">    cell.delegate = <span class="keyword">self</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>干得不错，现在我们开始实现代理方法。首先，我们将 date picker 控件中选中的日期显示到相应顶级单元格中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dateWasSelected</span><span class="params">(selectedDateString: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dateCellSection = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> dateCellRow = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">    cellDescriptors[dateCellSection][dateCellRow].setValue(selectedDateString, forKey: <span class="string">"primaryTitle"</span>)</span><br><span class="line">    tblExpandable.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦我们指定了正确的 section 和 row, 直接赋值字符串类型的日期值。注意该字符串是代委托方法中的一个参数。</p>
<p>接着，我们处理有关 switch 控件的事务。当 switch 控件值改变时，我们需要做两件事：首先，将顶级单元格内容设置为结果值（“Single” 或 “Married”），接着更新 cellDescriptor 数组中的 switch 控件值，这样每次 tableview 刷新时它都拥有正确的状态。下面的代码片段中，你会注意我们首次根据 switch 控件状态来确定适当的值，接着将它们赋值给相应属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">maritalStatusSwitchChangedState</span><span class="params">(isOn: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> maritalSwitchCellSection = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> maritalSwitchCellRow = <span class="number">6</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> valueToStore = (isOn) ? <span class="string">"true"</span> : <span class="string">"false"</span></span><br><span class="line">    <span class="keyword">let</span> valueToDisplay = (isOn) ? <span class="string">"Married"</span> : <span class="string">"Single"</span></span><br><span class="line"> </span><br><span class="line">    cellDescriptors[maritalSwitchCellSection][maritalSwitchCellRow].setValue(valueToStore, forKey: <span class="string">"value"</span>)</span><br><span class="line">    cellDescriptors[maritalSwitchCellSection][maritalSwitchCellRow - <span class="number">1</span>].setValue(valueToDisplay, forKey: <span class="string">"primaryTitle"</span>)</span><br><span class="line">    tblExpandable.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是包含了 textField 控件的单元格。此处一旦有 first name 或 last name 输入，我们会动态组合成 full name。出于需要，我们将获取到包含 textField 控件单元格的行索引值，这样就能为 full name 设置给定值了（first name + last name）。最后我们更新顶级单元格内的显示本文内容（full name）和刷新 tableview 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textfieldTextWasChanged</span><span class="params">(newText: String, parentCell: CustomCell)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parentCellIndexPath = tblExpandable.indexPathForCell(parentCell)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> currentFullname = cellDescriptors[<span class="number">0</span>][<span class="number">0</span>][<span class="string">"primaryTitle"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> fullnameParts = currentFullname.componentsSeparatedByString(<span class="string">" "</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> newFullname = <span class="string">""</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> parentCellIndexPath?.row == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fullnameParts.<span class="built_in">count</span> == <span class="number">2</span> &#123;</span><br><span class="line">            newFullname = <span class="string">"<span class="subst">\(newText)</span> <span class="subst">\(fullnameParts[<span class="number">1</span>])</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newFullname = newText</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newFullname = <span class="string">"<span class="subst">\(fullnameParts[<span class="number">0</span>])</span> <span class="subst">\(newText)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cellDescriptors[<span class="number">0</span>][<span class="number">0</span>].setValue(newFullname, forKey: <span class="string">"primaryTitle"</span>)</span><br><span class="line">    tblExpandable.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在 “Work Experience” 部分中，我们处理那些内含 slider 控件的单元格。当用户改变 slider 控件值的同时，我们需要做两件事：<br>首先将顶级单元格中的文本标签内容设置为新的 slider 控件值，接着将 slider 控件值保存到对应的单元格描述中，这样即使刷新 tableview 后，它始终是最新数据。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sliderDidChangeValue</span><span class="params">(newSliderValue: String)</span></span> &#123;</span><br><span class="line">    cellDescriptors[<span class="number">2</span>][<span class="number">0</span>].setValue(newSliderValue, forKey: <span class="string">"primaryTitle"</span>)</span><br><span class="line">    cellDescriptors[<span class="number">2</span>][<span class="number">1</span>].setValue(newSliderValue, forKey: <span class="string">"value"</span>)</span><br><span class="line"> </span><br><span class="line">    tblExpandable.reloadSections(<span class="type">NSIndexSet</span>(index: <span class="number">2</span>), withRowAnimation: <span class="type">UITableViewRowAnimation</span>.<span class="type">None</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的缺省代码添加完毕，运行应用。</p>
<h3 id="总结">总结</h3><p>正如一开始我所说的，创建一个可展开的 tableview 有时真的很有用，它可以将你从麻烦中拯救出来，无须再为应用各部分创建一个新的视图控制器。本教程的前部分中，我向你介绍了一种创建可展开的 tableview 的方法，其主要特点是所有单元格的描述都存放在属性列表文件（plist 文件）中。教程中，我向你展示了如何在显示、展开和选中单元格情况下，编写代码处理单元格描述列表；另外，我还向你提供了一种方式来直接更新用户输入的数据。尽管演示应用中的伪造表格在实际应用开发中所有作为，但想要作为一个完整的组件之前，你还需要实现一些功能（比如，把表单描述列表保存到文件中）。不过，这已经超出了我们的教学范畴；一开始我们只想要实现一个可展开的 tableview ，随心所欲地显示或隐藏单元格，最终也得以实现。我确信你会找到本教程<br>的价值。通过已有的代码，你肯定能在此基础上改进，并根据需求使用它。现在留点时间给你；玩得开心，切记学无止境！</p>
<p><strong>参考：</strong> <a href="https://github.com/appcoda/expandable-table-view" target="_blank" rel="external">完整项目代码下载地址.</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：AppCoda，<a href="http://www.appcoda.com/expandable-table-view/">原文链接</a>，原文日期：2015-11-16<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>几乎所有的应用程序都有一个共同的特点：允许用户在多个视图控制器之间导航和协同工作。这些视图控制器应用非常广泛，例如简单显示某些形式的信息到屏幕上，或从用户处收集复杂的输入数据。为了实现一款应用的不同功能，经常需要创建新的视图控制器，且多数任务比较艰巨。不过，倘若你利用<code>expandable tableviews</code>（之后统一译为可展开的 tableview ） ，我们就能避免创建新的视图控制器（以及相关的界面和 storyboard）。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的 weak 和 unowned]]></title>
    <link href="http://swiftggteam.github.io/2015/12/02/swift-weak-and-unowned/"/>
    <id>http://swiftggteam.github.io/2015/12/02/swift-weak-and-unowned/</id>
    <published>2015-12-01T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-weak-and-unowned/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-30<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<p>使用 weak 和 unowned 关键字，我们可以避免所谓的循环引用。在这篇文章中，我们将讨论两者之间的差异。</p>
<a id="more"></a> 
<h3 id="何为循环引用？">何为循环引用？</h3><p>我曾在 <a href="http://www.thomashanning.com/a-trick-to-discover-retain-cycles/" target="_blank" rel="external">“A Trick To Discover Retain Cycles”</a> 博客一文中强调了内存管理的重要性，即使 ARC  已经为你分忧解难了：</p>
<p>首先，我们创建两个视图控制器：<code>RootViewController</code> 和 <code>SecondViewController</code>。如果点击了 <code>RootViewController</code> 视图中的按钮，就呈现 <code>SecondViewController</code>。我们可以通过在 storyboard 使用 segue 来简单实现这个目的。另外，我们还创建了一个名为 <code>ModelObject</code> 的类，内含一个类型为 <code>ModelObjectDelegate</code> 的委托对象（译者注：你也可以说这个对象遵循 ModelObjectDelegate 协议）。如果 <code>SecondViewController</code> 的视图加载完毕，当前视图控制器就将自己任命（译者注：即 self）为 <code>ModelObject</code> 的代理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ModelObject 类内容</span></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ModelObjectDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> delegate: <span class="type">ModelObjectDelegate</span>?</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SecondViewController 类内容</span></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondViewController</span>: <span class="title">UIViewController</span>, <span class="title">ModelObjectDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> modelObject: <span class="type">ModelObject</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        modelObject = <span class="type">ModelObject</span>()</span><br><span class="line">        modelObject!.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">closeButtonPressed</span><span class="params">(sender: UIButton)</span></span> &#123;</span><br><span class="line">        dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备工作完毕，现在来测试下内存管理：首先我们释放掉（dismiss）<code>SecondViewController</code> 视图控制器，你会发现使用内存并未有所下降。这是为什么呢？按照期望应该是释放掉 <code>SecondViewController</code> 对象,内存被释放才对。让我们首先来了解下对象之间的关系。假设 <code>SecondViewController</code> 加载完毕，对象之间关系应该看起来这样：</p>
<p><img src="/img/articles/swift-weak-and-unowned/retainc1.jpg1449449056.5054061" alt=""></p>
<p>现在，释放掉 <code>SecondViewController</code>，看起来应该这样：</p>
<p><img src="/img/articles/swift-weak-and-unowned/retain2c.jpg1449449057.561948" alt=""></p>
<p>如图所示：<code>RootViewController</code> 不再对 <code>SecondViewController</code> 拥有强引用关系。但是 <code>SecondViewController</code> 和 <code>ModelObject</code> 对象之间始终保持相互强引用。所以它们不会被释放掉。</p>
<h3 id="Weak">Weak</h3><p>为了避免这种情况发生，我们可以将引用关系声明为 <code>weak</code> ，它不会阻止 ARC 释放内存。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ModelObjectDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">ModelObjectDelegate</span>?</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在对象关系图应该看起来这样：</p>
<p><img src="/img/articles/swift-weak-and-unowned/retainc3.jpg1449449058.1724997" alt=""></p>
<p>由于 <code>SecondViewController</code> 和 <code>ModelObject</code> 对象之间仅存一个强引用关系，毫无疑问可以成功释放内存。</p>
<h3 id="Unowned">Unowned</h3><p>此外你还可以使用 <code>unowned</code> 关键字替换掉 <code>weak</code>,那么两者的区别在哪里？倘若你使用 <code>weak</code>,属性可以是可选类型，即允许有 <code>nil</code> 值的情况。另一方面，倘若你使用 <code>unowned</code>，它不允许设为可选类型。因为一个 unowned 属性不能为可选类型，那么它必须在 init 方法中初始化值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ModelObjectDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//译者注：swift 要求变量一定要有初始值</span></span><br><span class="line">    <span class="comment">//        可选类型默认初始值为 nil</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">var</span> delegate: <span class="type">ModelObjectDelegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(delegate:<span class="type">ModelObjectDelegate</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据属性是否为可选类型，你可以在 <code>weak</code> 和 <code>unowned</code> 之间进行选择。</p>
<h3 id="参考">参考</h3><p><a href="http://www.thomashanning.com/a-trick-to-discover-retain-cycles/" target="_blank" rel="external">A Trick To Discover Retain Cycles</a><br><a href="http://www.thomashanning.com/optionals-in-swift/" target="_blank" rel="external">Optionals In Swift</a><br><a href="https://itunes.apple.com/us/book-series/swift-programming-series/id888896989?mt=11" target="_blank" rel="external">Swift Programming Series (iBook Store)</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-weak-and-unowned/">原文链接</a>，原文日期：2015-11-30<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="https://github.com/Cee">Cee</a></p>
</blockquote>
<!--此处开始正文-->
<p>使用 weak 和 unowned 关键字，我们可以避免所谓的循环引用。在这篇文章中，我们将讨论两者之间的差异。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Xcode:用于管理多个 target 配置的 XCConfig 文件]]></title>
    <link href="http://swiftggteam.github.io/2015/12/01/xcode-xcconfig-files-for-managing-targets-configurations/"/>
    <id>http://swiftggteam.github.io/2015/12/01/xcode-xcconfig-files-for-managing-targets-configurations/</id>
    <published>2015-11-30T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/xcode-xcconfig-files-for-managing-targets-configurations/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-14<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<p>让我们来看看 XCConfig 文件如何才能在多个拥有不同配置的 target 中良好地工作。</p>
<p>今天我本计划学习一些新东西，因此我搜索了 <a href="https://github.com/mozilla/firefox-ios" target="_blank" rel="external">mozilla/firefox-ios</a> 库（译者：这是在火狐浏览器在 github 的一个开源项目）的相关信息，接着我发现他们会在项目中使用大量的配置文件。</p>
<a id="more"></a>
<p>我曾经在几个项目中使用过 XCConfig ，但是我并没有在现在开发的项目中使用它。因为这个项目有多个不同配置的 target，因此我开始思考如何才能有效且简单地管理这些 target 。</p>
<h3 id="用例">用例</h3><p>这个项目现在已经被我的团队接手了。客户的团队先开发了大约半年的时间，最后决定将项目完全外包出去。这个项目一个麻烦的事就是 target 有不同的配置，因此如何更好地解决，是个棘手的问题。</p>
<p>项目由十个应用 target 组成，2个总的 target 做些业务，以及一个测试 target 。每一个 target 使用不同的尾部和不同的 “api keys”，以及其他像用于 hockeyapp（HockeyApp 是一个用来分发你的程序并收集应用的崩溃报告的收集框架，类似友盟） token 的键（key）。每一个 target 有自己的预处理宏，如：“TARGET_A”, “TARGET_B”等…（虚构的名字）。然后，token，api keys，后端的 url 被存储在 plist 文件中。因此很自然需要一些类来封装这个文件，并且有语法分析程序以及可以提供给我们适当的键。这个类有超过200行的代码，对我来说仅仅阅读这些数据就要花费很多时间。</p>
<p>因此，我想或许可以使用 XCConfig 文件来简化和替代，而不是使用语法分析程序和十个个预处理宏（一个 target）去决定从 plist 文件应该返回什么值。你可以在下面找到我的解决方案。可能不是最好的方案，但是此刻应该是最好的。如果你有更好的方案，我很愿意去拜读 :)</p>
<h3 id="概述">概述</h3><p>核心思想是使用一些有层级的配置文件。第一层是用于存储最普通的数据，第二层用于区分 debug 和 release 模式，最后一层用于关联特殊 target 的设置。</p>
<p><img src="/img/articles/xcode-xcconfig-files-for-managing-targets-configurations/diagram_1.png1449449060.446657" alt=""></p>
<h3 id="Common-xcconfig">Common.xcconfig</h3><p>这个文件存储着类似应用名称，应用版本，bundle version，以及其他 debug和 release target 中通用的常见配置。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Common.xcconfig</span></span><br><span class="line"><span class="comment">//  &lt;truncated&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">APP_NAME</span> = <span class="type">App</span></span><br><span class="line"><span class="type">APP_VERSION</span> = <span class="number">1.6</span></span><br><span class="line"><span class="type">APP_BUNDLE_ID</span> = <span class="number">153</span></span><br></pre></td></tr></table></figure>
<p>考虑到为十个 target 改变相应的应用版本和 bundle 可能会消耗很多时间。其他的选项可能会创建聚合的 target ，这样可以在每次 Cmd+B的时候更新Info-plist 文件，但是我会避免这样的情况并且让项目不会比现在更复杂。</p>
<h3 id="Common-debug_和_Common-release">Common.debug 和 Common.release</h3><p>这个文件能够存储可用于 debug 和 release target 的最常用配置。文件包含 Common.xcconfig 并且能够重写它的变量。例如：你可以通过重写一个变量，轻易地把每个 debug target 的应用名称改为 “App Debug” 。对于存储常见的用于开发和发行版本 target 的 API Key，这里也是很好的地方。</p>
<p><strong>提示：使用通用配置文件和 CocoaPods</strong></p>
<p>如果你使用 CocoaPods，你应该相应地在你的配置文件之一中包括（include）Pods.debug.xcconfig 或者 Pods.release.xcconfig。我推荐先在项目信息标签中设置你的配置文件然后执行 <code>pod install</code> 去让 Pod 项目重新配置。在安装之后，你应该及时地把 Pod 配置文件中的其中一个包括（include）到你自己的文件中去。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Error</span>:</span><br><span class="line">[!] <span class="type">CocoaPods</span> did not <span class="keyword">set</span> the base configuration of your project because your project already has a custom config <span class="keyword">set</span>. <span class="type">In</span> order <span class="keyword">for</span> <span class="type">CocoaPods</span> integration to work at all, please either <span class="keyword">set</span> the base configurations of the target <span class="type">TARGET_NAME</span> to <span class="type">Pods</span>/<span class="type">Target</span> <span class="type">Support</span> <span class="type">Files</span>/<span class="type">Pods</span>/<span class="type">Pods</span>.debug.xcconfig or include the <span class="type">Pods</span>/<span class="type">Target</span> <span class="type">Support</span> <span class="type">Files</span>/<span class="type">Pods</span>/<span class="type">Pods</span>.debug.xcconfig <span class="keyword">in</span> your build configuration.</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Common.debug.xcconfig</span></span><br><span class="line"><span class="comment">//  &lt;truncated&gt;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Common.xcconfig"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"Pods/Target Support Files/Pods/Pods.debug.xcconfig"</span></span></span><br><span class="line"></span><br><span class="line">APP_NAME = App Debug</span><br><span class="line">API_KEY_A = API_KEY_HERE</span><br><span class="line">API_KEY_B = API_KEY_HERE</span><br></pre></td></tr></table></figure>
<h3 id="PerTarget-xcconfig">PerTarget.xcconfig</h3><p>我确实不需要在这个层级使用 debug/release 配置文件（因为项目中的其他遗留问题），所以我只是用包括适当的 Common.debug.xcconfig 或者 Common.release.xcconfig 的 PerTarget.xcconfig 文件。但是最好应该有 debug 和 release 配置文件。在这个层级，你可以配置关联到特殊 target 的东西。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">//&#10;//  Develop.xcconfig&#10;//  &#60;truncated&#62;&#10;//&#10;&#10;#include &#34;Common.debug.xcconfig&#34;&#10;&#10;BACKEND_URL = http:\/\/develop.api.szulctomasz.com&#10;SOME_KEY_A = VALUE_HERE&#10;SOME_KEY_B = VALUE_HERE</span><br></pre></td></tr></table></figure>
<h3 id="访问变量">访问变量</h3><p>所有的配置文件被存储了。现在是时候去使用他们了。像我例子中有这么多的 target，我可以把 Info.plist 文件的数量减少到只有1个，由于所有的不同的地方都已经在 xcconfig 文件中了，所以这一个文件可以替代多个文件。</p>
<p>你可以看到在你通过这些配置文件构建应用之后，有一些值出现在项目的 Build Setting 的 “User-Defined” 部分。</p>
<p>如果你想要使用配置文件中的变量，例如，在一个target的 Info.plist 文件中，你需要使用这种写法：<code>$(VARIABLE)</code>。使用这种方式，你可以设置 “Bundle Identifier” , “Bundle name” , “Bundle version” 以及其他你想要配置的事项。</p>
<p>在代码中访问其他变量看起来有点不一样，我发现最简单的方法就是在 Info.plist 中创建附加的区域，通过使用相同的变量名称和使用上述的写法去设置值。这样你就可以在你的代码中读到这些值。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> dictionary = <span class="type">NSBundle</span>.mainBundle().infoDictionary &#123;</span><br><span class="line">    <span class="keyword">let</span> appName = dictionary[<span class="string">"APP_NAME"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> appVersion = dictionary[<span class="string">"APP_VERSION"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> appBuildVersion = dictionary[<span class="string">"APP_BUILD_VERSION"</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(appName)</span> <span class="subst">\(appVersion)</span> (<span class="subst">\(appBuildVersion)</span>)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> backend = (dictionary[<span class="string">"BACKEND_URL"</span>] <span class="keyword">as</span>! <span class="type">String</span>).stringByReplacingOccurrencesOfString(<span class="string">"\\"</span>, withString: <span class="string">""</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"backend: <span class="subst">\(backend)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是 <a href="https://github.com/tomkowz/demo-xcconfig" target="_blank" rel="external">tomkowz/demo-xcconfig</a> 的代码，从里面你可以看到一些使用 xcconfig 文件的例子。</p>
<h3 id="总结">总结</h3><p>Xcode 配置文件给出了配置 target 的简易方式，并且支持方便地维护项目配置。在我用例中，可以很棒地切换到这些文件，因为现在维护项目配置和我没有使用这个解决方案之前比起来简单了很多。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/xcode-xcconfig-files-for-managing-targets-configurations/">原文链接</a>，原文日期：2015-11-14<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<p>让我们来看看 XCConfig 文件如何才能在多个拥有不同配置的 target 中良好地工作。</p>
<p>今天我本计划学习一些新东西，因此我搜索了 <a href="https://github.com/mozilla/firefox-ios">mozilla/firefox-ios</a> 库（译者：这是在火狐浏览器在 github 的一个开源项目）的相关信息，接着我发现他们会在项目中使用大量的配置文件。</p>]]>
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="http://swiftggteam.github.io/tags/Tomasz-Szulc/"/>
    
      <category term="Xcode" scheme="http://swiftggteam.github.io/categories/Xcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你应该把 Objective-C 的代码转为 Swift 吗？]]></title>
    <link href="http://swiftggteam.github.io/2015/11/30/should-you-migrate-objective-c-code-to-swift/"/>
    <id>http://swiftggteam.github.io/2015/11/30/should-you-migrate-objective-c-code-to-swift/</id>
    <published>2015-11-29T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/should-you-migrate-objective-c-code-to-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-23<br>译者：<a href="http://blog.csdn.net/yake_099" target="_blank" rel="external">Yake</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<h1 id="你应该把_Objective-C_的代码转为_Swift_吗？">你应该把 <code>Objective-C</code> 的代码转为 <code>Swift</code> 吗？</h1><p>未来是 <code>swift</code> 的，但是这就意味着你需要把 <code>Objective-C</code> 的代码都转为 <code>Swift</code> 吗？</p>
<a id="more"></a>
<h2 id="选择一：不转代码坚持使用_Objective-C">选择一：不转代码坚持使用 <code>Objective-C</code></h2><p>乍一看这似乎是最简单的方法了。既然你已经有了一个 <code>Objective-C</code> 编写的项目，继续用OC写下去肯定不是问题。不过。这会产生一些问题：</p>
<p>未来可能不会有很多优秀的 <code>Objective-C</code> 开发者，因为会有许多 <code>iOS</code> 开发者将注意力放在了 <code>Swift</code> 上面。如果你的项目依赖于其他的开发者，未来你想要继续维持纯粹的 <code>Objective-C</code> 的项目恐怕不是一件容易的事儿。</p>
<p>但是即使你自己可以维护一个项目，这种方法也有害处。如果你没有 <code>Swift</code> 方面的实践，你可能会错失许多苹果通过 <code>iOS SDK</code> 引入的最新的开发技术。如果你想跟得上时代的步伐，你不得不学习 <code>Swift</code> 。</p>
<h2 id="选择二：将_Objective-C_的代码转为_Swift">选择二：将 <code>Objective-C</code> 的代码转为 <code>Swift</code></h2><p>这是最激进的一种方法。但是想要将一个完整的项目从 <code>Objective-C</code> 转为 <code>Swift</code> 意味着要写一个新的项目了。虽然 <code>Objective-C</code> 与 <code>Swift</code> 有很好的互操作性，但是他们的编程规范是完全不同的。所以如果你想要将 <code>Objective-C</code> 转为 <code>Swift</code> ，使用错误的编程范式是很危险的。</p>
<p>你还需要投入大量的时间和金钱。所以如果你不打算重写你的项目，这个方法就有点太夸张了。</p>
<h2 id="选择三：将新的代码用_Swift_来写">选择三：将新的代码用 <code>Swift</code> 来写</h2><p>这是一种不错的折中办法。由于 <code>Objective-C</code> 与 <code>Swift</code> 之间的互用性很好，你可以用 <code>Swift</code> 来创建你新的类并让它们与你已有的 <code>Objective-C</code> 的代码交互。</p>
<p>使用这种方法你可以将你的项目一步步转为 <code>Swift</code> 而不需要投入过多的时间和金钱。更多的是这对于学习的过程也是很好的。与其重写一个完整的项目，不如将注意力集中在应用的某些部分。</p>
<p>并且这个方法的风险也小得多。如果采取这种方法你可能会发现自己一点儿都不喜欢 <code>Swift</code> （尽管不太可能会发生这种情况），你完全可以再回到 <code>Objective-C</code> 并且不会损失过多的时间和金钱。</p>
<h2 id="结论">结论</h2><p>虽然有些情况下值得你将 <code>Objective-C</code> 的代码转为 <code>Swift</code> ，但最好的折中的办法就是将新代码用 <code>Swift</code> 来写并与你旧的 <code>Objective-C</code> 的代码进行交互。</p>
<p>参考：<a href="http://www.thomashanning.com/should-you-use-objective-c-or-swift/" target="_blank" rel="external">Should You Use Objective-C or Swift?</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/should-you-migrate-objective-c-code-to-swift/">原文链接</a>，原文日期：2015-11-23<br>译者：<a href="http://blog.csdn.net/yake_099">Yake</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<h1 id="你应该把_Objective-C_的代码转为_Swift_吗？">你应该把 <code>Objective-C</code> 的代码转为 <code>Swift</code> 吗？</h1><p>未来是 <code>swift</code> 的，但是这就意味着你需要把 <code>Objective-C</code> 的代码都转为 <code>Swift</code> 吗？</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现可打印内容的 try? 和 try!]]></title>
    <link href="http://swiftggteam.github.io/2015/11/27/implementing-printing-versions-of-try-and-try-on-steroids-in-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/11/27/implementing-printing-versions-of-try-and-try-on-steroids-in-swiftlang/</id>
    <published>2015-11-27T01:20:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/05/implementing-printing-versions-of-try-and-try-on-steroids-in-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/5<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 2 中的<code>try?</code>运算符在可选类型(optionals)和错误处理机制中抛出 error 转换为输出 nil 结果值之间建立了桥接。这样你就可以使用 guard 语句和条件绑定，只关注处理成功的用例(case)。<br><a id="more"></a></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// try? 没有错误输出正确结果值</span></span><br><span class="line"><span class="comment">///      有错误发生，输出nil值</span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> foo = <span class="keyword">try</span>? somethingThatMayThrow <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//处理错误情况并退出作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若你使用这种方式进行错误处理，需要注意，它并不会返回 error 信息。本文想说的是：抛弃错误信息是一件让人郁闷的事情！为什么不有选择地使用<code>try?</code>和<code>try!</code>来自动建立上下文并打印错误信息呢？</p>
<p>前阵子，我分享了一个模仿<code>try?</code>语句的基础实现，可以保留错误信息。下面的实现首先打印返回的错误，接着继续返回你想要得到的<code>try?</code>的处理结果：结果是一个值或 nil。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">attempt</span><span class="generics">&lt;T&gt;</span><span class="params">(block: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Optional</span>&lt;<span class="type">T</span>&gt;&#123; </span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="keyword">return</span> <span class="keyword">try</span> block() &#125; </span><br><span class="line">    <span class="keyword">catch</span> &#123; <span class="built_in">print</span>(error); <span class="keyword">return</span> <span class="literal">nil</span> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这很有效，尤其是当你想要进一步使用返回值却发现 guard 语句在失败时无法返回错误信息。使用 attemp 函数就可以打印错误信息。举个例子，如果我们要使用 NSFileManager 来删除文件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSFileManager</span>.defaultManager().removeItemAtURL(someURL)</span><br></pre></td></tr></table></figure>
<p>你应该这样做：将上述代码包裹到<code>do-catch</code>的 block 中(略显冗长)，在 attempt 函数中使用<code>try?</code>，接着处理返回 nil 值的情况，或者使用<code>try!</code>忽视所有错误信息(译者注:倘若实际有错误发生，程序会直接崩溃，使用它之前你必须确保不会有错误产生)。</p>
<p>当然这里还有另外一种方式。在文章的最后，我构建了一个 attemptFailable 函数，它把 throwing 声明封装到 guard/try 的迷你打印系统中，后者会返回一个布尔类型值。下面是使用方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">NSFileManager</span>.defaultManager().fileExistsAtPath(myPath) &#123;</span><br><span class="line">    <span class="keyword">guard</span> (attemptFailable&#123;<span class="keyword">try</span> <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">         .removeItemAtURL(myURL)&#125;) <span class="keyword">else</span> &#123;abort()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然不是很理想，但是在 playground 中写一些小东西时相当方便，最近我经常使用。(Playground 相当不错，作者书籍<a href="https://itunes.apple.com/us/book/playground-secrets-power-tips/id982838034?mt=11" target="_blank" rel="external">购买链接</a>)。</p>
<p>你可以使用类似的方式增强<code>try!</code>。相比 Swift 的可选值，<code>doOrDie</code>函数提供了更多信息。就像<code>attemp</code>和<code>attemptFailable</code>函数一样，它能够捕获上下文，在继续使用标准<code>try!</code>终止执行前抛出并打印错误。</p>
<p>以下是完整代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;<span class="keyword">let</span> reason: <span class="type">String</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> Printing version of try? Call either with standard or autoclosure approach</span><br><span class="line"> </span><br><span class="line"> let contents = attempt&#123;try NSFileManager.defaultManager().contentsOfDirectoryAtPath(fakePath)&#125;</span><br><span class="line"> let contents = attempt&#123;try NSFileManager.defaultManager().contentsOfDirectoryAtPath(XCPlaygroundSharedDataDirectoryURL.path!)&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> - Returns: Optional that is nil when the called closure throws</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">attempt</span><span class="generics">&lt;T&gt;</span><span class="params">(source source: String = <span class="keyword">__FUNCTION__</span>, file: String = <span class="keyword">__FILE__</span>, line: Int = <span class="keyword">__LINE__</span>, closure: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Optional</span>&lt;<span class="type">T</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> closure()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileName = (file <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent</span><br><span class="line">        <span class="keyword">let</span> report = <span class="string">"Error <span class="subst">\(fileName)</span>:<span class="subst">\(source)</span>:<span class="subst">\(line)</span>:\n    <span class="subst">\(error)</span>"</span></span><br><span class="line">        <span class="built_in">print</span>(report)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 可以打印内容并返回布尔值的 try? 可选实现</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> let success = attemptFailable&#123;try "Test".writeToFile(fakePath, atomically: true, encoding: NSUTF8StringEncoding)&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> - Returns: Boolean 值，如果被调用的闭包抛出错误返回 false，否则返回 true</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">attemptFailable</span><span class="params">(source source: String = <span class="keyword">__FUNCTION__</span>, file: String = <span class="keyword">__FILE__</span>, line: Int = <span class="keyword">__LINE__</span>, closure: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> closure()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fileName = (file <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent</span><br><span class="line">        <span class="keyword">let</span> report = <span class="string">"Error <span class="subst">\(fileName)</span>:<span class="subst">\(source)</span>:<span class="subst">\(line)</span>:\n    <span class="subst">\(error)</span>"</span></span><br><span class="line">        <span class="built_in">print</span>(report)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> 另外一个包含更多信息的 try! 版本。shouldCrash 是 false 时，即使有错误抛出，也会继续执行</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> doOrDie(shouldCrash: false, closure: &#123;try "Test".writeToFile(fakePath, atomically: true, encoding: NSUTF8StringEncoding)&#125;)</span><br><span class="line"> // 或</span><br><span class="line"> doOrDie(shouldCrash:false)&#123;try NSFileManager.defaultManager().removeItemAtURL(fakeURL)&#125;</span><br><span class="line"> // 或</span><br><span class="line"> doOrDie&#123;try "Test".writeToFile(fakePath, atomically: true, encoding: NSUTF8StringEncoding)&#125;</span><br><span class="line"> </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">doOrDie</span><span class="params">(source: String = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">    file: String = <span class="keyword">__FILE__</span>, line: Int = <span class="keyword">__LINE__</span>, shouldCrash: Bool = <span class="literal">true</span>, closure: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> success = attemptFailable(source: source, file: file, line: line, closure: closure)</span><br><span class="line">        <span class="keyword">if</span> shouldCrash &amp;&amp; !success &#123;<span class="built_in">fatalError</span>(<span class="string">"Goodbye cruel world"</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/05/implementing-printing-versions-of-try-and-try-on-steroids-in-swiftlang/">原文链接</a>，原文日期：2015/11/5<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 2 中的<code>try?</code>运算符在可选类型(optionals)和错误处理机制中抛出 error 转换为输出 nil 结果值之间建立了桥接。这样你就可以使用 guard 语句和条件绑定，只关注处理成功的用例(case)。<br>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift：map 和 flatMap 基础入门]]></title>
    <link href="http://swiftggteam.github.io/2015/11/26/swift-map-and-flatmap/"/>
    <id>http://swiftggteam.github.io/2015/11/26/swift-map-and-flatmap/</id>
    <published>2015-11-25T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-map-and-flatmap/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-16<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>借助于 map和flapMap 函数能够很轻易地将数组转换成另外一个新数组。</p>
<a id="more"></a>
<h1 id="Map">Map</h1><p><code>map</code>函数能够被数组调用，它接受一个闭包作为参数，作用于数组中的每个元素。闭包返回一个变换后的元素，接着将所有这些变换后的元素组成一个新的数组。</p>
<p>这听起来有些复杂，但它是相当简单的。想象你拥有一个string类型的数组:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray = [<span class="string">"test1"</span>,<span class="string">"test1234"</span>,<span class="string">""</span>,<span class="string">"test56"</span>]</span><br></pre></td></tr></table></figure>
<p><code>map</code>函数的闭包接收一个字符串(类型为<code>string</code>)作为参数，原因在于我们调用函数处理的数组元素类型为<code>String</code>。本例中，我们想要返回一个整型数组，逐个对应字符串元素成员的字符长度。因此闭包的返回类型为<code>Int?</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherArray = testArray.<span class="built_in">map</span> &#123; (string:<span class="type">String</span>) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">let</span> length = string.characters.<span class="built_in">count</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> string.characters.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(anotherArray) <span class="comment">//[Optional(5), Optional(8), nil, Optional(6)]</span></span><br></pre></td></tr></table></figure>
<h1 id="FlatMap">FlatMap</h1><p><code>flatMap</code>很像<code>map</code>函数，但是它摒弃了那些值为<code>nil</code>的元素。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherArray2 = testArray.flatMap &#123; (string:<span class="type">String</span>) -&gt; <span class="type">Int</span>? <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">let</span> length = string.characters.<span class="built_in">count</span></span><br><span class="line"> </span><br><span class="line">     <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">return</span> string.characters.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(anotherArray2) <span class="comment">//[5, 8, 6]</span></span><br></pre></td></tr></table></figure>
<p>另外一个与<code>map</code>函数不同之处在于：倘若元素值不为nil情况下，<code>flapMap</code>函数能够将可选类型(<code>optional</code>)转换为非可选类型(<code>non-optionals</code>)。</p>
<h1 id="引用">引用</h1><p>Image:@ Fly_dragonfly / shutterstock.com</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-map-and-flatmap/">原文链接</a>，原文日期：2015-11-16<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>借助于 map和flapMap 函数能够很轻易地将数组转换成另外一个新数组。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tvOS 入门：开发你的第一个 tvOS 应用]]></title>
    <link href="http://swiftggteam.github.io/2015/11/25/tvos-introduction/"/>
    <id>http://swiftggteam.github.io/2015/11/25/tvos-introduction/</id>
    <published>2015-11-24T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：gregg mojica，<a href="http://www.appcoda.com/tvos-introduction/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-02<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p>上月在旧金山举办的苹果发布会中,苹果公司发布了第四代苹果电视。然而，此次更新不同于以往任何版本，苹果新电视将允许用户从 App Store 下载应用和游戏。</p>
<p>这样的声明无疑给开发者打了一剂鸡血。新苹果电视中，位于 Cupertino(译者注:苹果电脑的全球总公司所在地，位于美国旧金山)的巨人介绍了一个新的操作系统，有别于 iOS 系统，新系统名为 tvOS。tvOS 基于 iOS 开发，有少许改动。 我们将使用通用框架和你最喜欢编程语言(当然是 Swift 喽，毫无疑问！)来编写几个简单应用，初步了解 tvOS。</p>
<a id="more"></a>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/IMG_3302-1024x683.jpg" alt="image"></p>
<h2 id="了解_tvOS">了解 tvOS</h2><p>tvOS 基于 iOS 系统开发而成。你使用的许多框架可能都适用于 tvOS。然而，苹果删除了几个 iOS 框架，使得 tvOS 独一无二 (最有名的就是 WebKit)。</p>
<p>苹果支持两种类型的 tvOS 应用程序。第一个是传统的应用程序-这类应用程序会打包代码和图片等等资源。这基本上与 iOS 或 OS X 应用程序一样。tvOS 新增对<strong>client-server(客户端-服务器)</strong>应用的支持，即第二种类型。<strong>client-server</strong>应用程序简单地把服务器请求和网络开发过程集中到应用中来。换句话说，这些应用可以同常见的数据库，服务器等交互。例如，如果你使用 Node.js(一款基于 Chrome V8 引擎开发的 JavaScript 框架)实现了后端，接着你可以考虑使用<strong>client-server</strong>技术，使它更易于管理应用程序(即我们的客户端)和后端(又称之为服务器)。<strong>client-server</strong>应用程序可以直接与 JavaScript 进行交互。然而，由于这些应用程序比较特别，在本教程中我们将不讨论<strong>client-server</strong>应用程序，重点介绍传统应用的开发。</p>
<p>请将这些概念牢记于心，开始我们的教程!</p>
<h2 id="必备条件">必备条件</h2><p>在本教程中，我假设你已经了解常见的 iOS 框架、术语和网络知识。 我将在整个教程中使用 storyboard 进行讲解，希望你知道如何使用 storyboard。同样，我不会对 storyboard 中一些常见的操作做详细深入地讲解(例如改变背景颜色，修改对象尺寸等等)。如果你对 storyboard 还不太了解或者还只是个 iOS 的初学者，我建议你去 AppCoda 教程网站先学习下，再回过头来学习本教程。</p>
<p>开发环境为 Xcode7.1 以上。当然最好还是在苹果电视真机上进行调试(译者表示呵呵)，当然模拟器也足够了。</p>
<h2 id="创建一个新的_tvOS_工程">创建一个新的 tvOS 工程</h2><p>为了开发 tvOS 应用，你必须在你的 Mac 上安装 Xcode7.1。Xcode7.1 内置了 tvOS SDK,除此之外还有 iOS9.1 以及 Swift2.1。</p>
<p>启动 Xcode,创建一个新工程，选中一个新的 tvOS 应用。在右侧面板，选中击 Single View Application 并点击 next。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-10-31-at-11.07.02-PM-1024x732.png" alt="image2"></p>
<p>接着为新应用命名。对于第一个应用来说，我们习惯以一个 Hello World App 作为教程的开始。命名该工程为 HelloWorld，接着点击创建并选择项目存储位置。</p>
<h2 id="Hello,_tvOS">Hello, tvOS</h2><p>由于 tvOS 继承自 iOS，许多你熟悉的 iOS 开发基本概念在 tvOS 中都适用。</p>
<p>在你的 Main.storyboard 文件中，添加一个 button，将 title 修改为“Click Me!”，接着在其下方添加一个标签 label,如下所示：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-10-31-at-11.26.45-PM-1024x558.png" alt="image3"></p>
<p>注意到 tvOS 中的按钮与 iOS 的按钮稍有不同。此外，当你添加多个按钮时，苹果已经允许用户在按钮间无缝切换，比如向右，向左，向上或向下滑动。开发者只需要在 storyboard 中为按钮布局来利用该特性(稍后详述)。</p>
<p>和 iOS 一样，我们通过 control-drag 标签(label)和按钮(button)来创建 IBOutlet 以及 IBAction。这里分别命名 outlet 为 myLabel，IBAction 为 buttonPressed。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-10-31-at-11.32.31-PM-1024x647.png" alt=""></p>
<p>在 buttonPressed 动作中，请键入如下代码行:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.myLabel.text = <span class="string">"Hello,World"</span></span><br></pre></td></tr></table></figure>
<p>你应该很熟悉这行代码了。如果你不熟悉，上述代码实现了点击按钮，为标签(label)的 text 字段赋值”Hello,World”字符串值。</p>
<p>请在模拟器中运行应用。</p>
<p>你可能想要通过鼠标来点击按钮，但与模拟器中的 iOS 应用不同，苹果电视未配备触摸屏，仅仅依靠一个遥控器罢了。因此，单击Hardware &gt;Show Apple TV Remote 或者 Command + Shift + R 快捷键显示遥控器。通过遥控器实现按钮的点击，你的第一个 tvOS 应用就此完成了！<br><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-10-31-at-11.58.52-PM-1024x575.png" alt=""></p>
<h2 id="猜谜游戏_App">猜谜游戏 App</h2><p>接下来,我们将使用现有的 tvOS 知识开发一款简单的猜谜应用。这将是一个非常基本的猜谜应用(只有一个问题),这个迷你项目主要是像你展示按钮和遥控器之间是如何交互的。在接下来的项目中，我们将探索更多有关控制 tvOS 的知识。</p>
<p>再次启动 Xcode，依葫芦画瓢创建一个新的 tvOS 项目。不过请重新命名项目名称。</p>
<p>模仿我下面的布局做一些 storyboard 的基础操作。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-12.14.40-AM-1024x564.png" alt=""></p>
<p>如果你不确定我是如何实现的，下面是我使用的组件的列表:</p>
<ol>
<li>4 个 UIButton，尺寸为 960 X 325</li>
<li>1 个 UILabel，尺寸为 1400 X 120</li>
</ol>
<p>接着为 4 个按钮添加 text 并更改它们的背景颜色，均在 storyboard 完成(任何 iOS 应用都可以这么实现)。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-12.21.16-AM-1024x564.png" alt=""></p>
<p>像以前一样,让我们将这些按钮绑定到代码中。为了代码简洁和易于理解,我将创建 4 个 IBAction(虽然这并不一定是最优雅的解决方案,但它是最简单的)。</p>
<p>将这些按钮逐一连接到 ViewController.swift 文件中(通过拖拉方式创建 IBAction)，暂且命名为 :button0Tapped、button1Tapped、button2Tapped 和 button3Tapped，你可以随时修改这些名称。</p>
<p>上面图片中显示的 label 内容是询问加州的首府是哪个。给出四个选项供你选择(有关加州首都的知识)，答案是 Sacramento。其中 button1Pressed 动作响应 Sacramento 按钮的点击事件。</p>
<p>根据点击的按钮,我们想向用户显示一个警告信息,告知他们选择了正确还是错误的按钮。接着我们创建一个名为 showAlert 的函数来处理这件事,让我们的代码 DRY(DRY 是 Don’t Repeat YourSelf 的缩写，对于软件工程师来说这是惯例用法，确保代码可重用性和可维护性)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">showAlert</span><span class="params">(status: String, title:String)</span></span> &#123; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: status, message: title, preferredStyle: .<span class="type">Alert</span>) <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">let</span> cancelAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .<span class="type">Cancel</span>) &#123; (action) <span class="keyword">in</span> <span class="comment">//3 </span></span><br><span class="line">        &#125;</span><br><span class="line">        alertController.addAction(cancelAction)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ok = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>) &#123; (action) <span class="keyword">in</span></span><br><span class="line">        &#125; <span class="comment">// 4</span></span><br><span class="line">        alertController.addAction(ok)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.presentViewController(alertController, animated: <span class="literal">true</span>) &#123; <span class="comment">// 5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述函数接受两个参数，一个是用户的输入状态(表面他们回答问题的正确或者错误)，以及警告提示框中要显示的信息或者标题。</p>
<p>第二行创建并初始化一个新的 UIAlertController 对象。第三和第四行代码为 alert 警告框添加一个 cancel 取消按钮和 ok 确认按钮，第五行代码用于呈现这些内容。</p>
<p>如果你不确定这段代码是如何工作的,我强烈建议你先看看<a href="http://www.appcoda.com/uialertcontroller-swift-closures-enum/" target="_blank" rel="external">UIAlertController</a>教程,这里提供了有关该类的详细信息。</p>
<p>现在，请在不同的 IBActions 中调用这个方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button0Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        showAlert(<span class="string">"Wrong!"</span>, title: <span class="string">"Bummer, you got it wrong!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是唯一正确的</span></span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button1Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    showAlert(<span class="string">"Correct!"</span>, title: <span class="string">"Whoo! That is the correct response"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button2Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    showAlert(<span class="string">"Wrong!"</span>, title: <span class="string">"Bummer, you got it wrong!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button3Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">    showAlert(<span class="string">"Wrong!"</span>, title: <span class="string">"Bummer, you got it wrong!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，仅在 button1Tapped 函数中传入“Correct”的标题，剩下都传入“Wrong”。</p>
<p>你的代码应该看起来和下面的代码一样。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button0Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        showAlert(<span class="string">"Wrong!"</span>, title: <span class="string">"Bummer, you got it wrong!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button1Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        showAlert(<span class="string">"Correct!"</span>, title: <span class="string">"Whoo! That is the correct response"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button2Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        showAlert(<span class="string">"Wrong!"</span>, title: <span class="string">"Bummer, you got it wrong!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">button3Tapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">        showAlert(<span class="string">"Wrong!"</span>, title: <span class="string">"Bummer, you got it wrong!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">showAlert</span><span class="params">(status: String, title:String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> alertController = <span class="type">UIAlertController</span>(title: status, message: title, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cancelAction = <span class="type">UIAlertAction</span>(title: <span class="string">"Cancel"</span>, style: .<span class="type">Cancel</span>) &#123; (action) <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        alertController.addAction(cancelAction)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> ok = <span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>) &#123; (action) <span class="keyword">in</span></span><br><span class="line">        &#125;</span><br><span class="line">        alertController.addAction(ok)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.presentViewController(alertController, animated: <span class="literal">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模拟器中运行你的应用。如果一切顺利，你应当会看到类似下面的截图。</p>
<p>单机遥控器，选中 Cupertino 选项</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-12.49.37-AM-1024x552.png" alt=""></p>
<p>你应该看到弹出一个 UIAlertController。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-12.49.27-AM-1024x557.png" alt=""></p>
<p>不幸的是，模拟器并不支持 swiping，因此你可能需要在真机中测试成功的 alert 警告框。不过，你可以在模拟器(遥控)中通过按住 option 键 swipe 选项。在 Apple TV 真机中，你能够在所有按钮中无缝切换。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-12.53.00-AM-1024x575.png" alt=""></p>
<p>恭喜！ 你已经完成了第二个项目。</p>
<h2 id="在_tvOS_中使用_TableViews">在 tvOS 中使用 TableViews</h2><p>在 iOS 操作系统中，苹果大量使用 tableview。事实上，苹果在许多自家应用(包括信息、联系人等)都使用了它。随着 watchOS SDK 的发布，tableview 可用于 Apple Watch 开发。自然地，新的苹果电视和 tvOS 同样支持这个流行的 API。</p>
<p>依葫芦画瓢创建一个新的工程项目，命名为 TableViewPractice。</p>
<p>和先前创建的工程一样，Xcode 默认自动生成 ViewController.swift 文件。请在文件的第 11 行代码处添加如下声明(译者注:就是让 ViewController 遵循两个 tableView 的协议)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UITableViewDataSource</span>, <span class="type">UITableViewDelegate</span></span><br></pre></td></tr></table></figure>
<p>第 11 行的代码应该看起来这样:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UITableViewDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>由于 Swift 是一门注重安全的语言，编译器会报告说没有遵循 UITableView 的 Datasource 和 Delegate 协议。我们会很快解决这个问题。</p>
<p>接着在 storyboard 中添加一个 tableView 视图并拖拽到 ViewController 文件中生成一个 IBOutlet，将其命名为 tableView。同时在这个 IBOutlet 声明下方新增一个数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataArray = [<span class="string">"San Francisco"</span>, <span class="string">"San Diego"</span>, <span class="string">"Los Angeles"</span>, <span class="string">"San Jose"</span>, <span class="string">"Mountain View"</span>, <span class="string">"Sacramento"</span>]</span><br></pre></td></tr></table></figure>
<p>数组囊括了所有我们要在 tableView 显示的元素。</p>
<p>现在请在v iewDidLoad 方法的下方添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// section数量</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每个section的cell数量    </span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.dataArray.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 填充每个cell的内容    </span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = <span class="type">UITableViewCell</span>(style: .<span class="type">Subtitle</span>, reuseIdentifier: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    cell.textLabel?.text = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.dataArray[indexPath.row])</span>"</span></span><br><span class="line">    cell.detailTextLabel?.text = <span class="string">"Hello from sub title <span class="subst">\(indexPath.row + <span class="number">1</span>)</span>"</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能发现了，tvOS 中的 tableview 和 iOS 中的 tableView 非常相似。在上面的代码片段中，我们告诉 tableview 有多少行(rows),多少个部分(section)，以及每个单元格要显示的内容。</p>
<p>在 viewDidLoad 方法中，确保你把 tableview 的 delegate 和 datasource 设置为自身 self。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line"><span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure>
<p>在模拟器中运行应用。</p>
<p>不出意外，你应该看到一个 tableview 出现在界面中。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-9.21.21-AM-1024x567.png" alt=""></p>
<p>现在，我们将在 tableView 的右侧添加一个按钮(UIButton)。在模拟或者真机上构建并运行，Whoo<br>！我们现在可以在按钮和 tableview 之间无缝切换了。</p>
<h2 id="创建一个天气_App">创建一个天气 App</h2><p>在下一个小项目中，我们将开发一个简单的天气应用程序，显示当前的天气预报。在这个项目中，我们将使用非常稳定的天气 API：<strong>forecast.io</strong>，它为包括 Dark Sky 在内许多 iOS 应用提供 API 支持。</p>
<p>首先你需要在 developer.forecast.io 注册一个开发者账号。我们只是测试，免费的 API 调用(1000 次/天)应该足够使用了。</p>
<p>注意下面 url:<br><a href="https://api.forecast.io/forecast/d3250bf407f0579c8355cd39cdd4f9e1/37.7833,122.4167" target="_blank" rel="external">https://api.forecast.io/forecast/d3250bf407f0579c8355cd39cdd4f9e1/37.7833,122.4167</a></p>
<p><strong>forecast/</strong>之后的一串数字(即 d3250bf40…)是 API Key 键值(千万不要将项目的 API Key 透露给别人)；紧跟着 API Key 字符串后的是你想要解析天气数据位置的经度和纬度坐标。我选择 San Francisco，但是你可以通过简单修改经纬坐标值来显示其他地方的天气。</p>
<p>倘若在浏览器中打开该链接，你将注意到反馈数据为 JSON 格式。这是一个 Get请求。在 HTTP 世界中，GET 用于获取和下载数据。</p>
<p>为了理解数据并将其显示到应用中,我们需要解析它。解析 JSON 在 Swift 中一直是一个热议话题。目前有各种各样的 JSON 解析库，诸如 SwiftyJSON、Alamofire 等。它们都是很棒的资源，我强烈建议你先看看。然而，在本教程中我们将使用 NSJSONSerialization，一个 iOS 内置的类。首先，打开 ViewController.swift 文件。<code>didRecieveMemory</code>警告函数在本项目中没有存在的意义，所以删除它吧！</p>
<p>现在，在 ViewDidLoad 中键入如下代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"https://api.forecast.io/forecast/d3250bf407f0579c8355cd39cdd4f9e1/37.7833,122.4167"</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用可选类型声明一个 url 变量。</p>
<p>NSJSONSerialization 需要传入 NSData 进行解析。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfURL: url)&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>接着，在上面 data 花括号作用域中键入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> parsed = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragments</span>) <span class="comment">// 1</span></span><br><span class="line">                    </span><br><span class="line">     <span class="keyword">let</span> newDict = parsed <span class="keyword">as</span>? <span class="type">NSDictionary</span> <span class="comment">// 2</span></span><br><span class="line">     <span class="built_in">print</span>(newDict![<span class="string">"currently"</span>]![<span class="string">"summary"</span>])</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">"A JSON parsing error occurred, here are the details:\n <span class="subst">\(error)</span>"</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把 NSJSONSerialization 对象包裹在 do-catch 语句中。你可能对 do 语句不太了解，这是 Swift 2 中的新特性。Do-Catch 语句是一个新的改进性错误处理机制。Do-Catch 语句的使用方式如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> expression <span class="comment">// 不是必要的内容</span></span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">1</span> &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125; <span class="keyword">catch</span> pattern <span class="number">2</span> <span class="keyword">where</span> condition &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一行代码中，我们设定了一个 NSJSONSerialization 对象，并传入 data 对象。注意，对象(parsed)在使用之前必须先转换成一个 NSDictionary 字典。</p>
<p>接着，在第二行代码中，我们指定一个名为 newDict 的变量并使用<code>as</code>关键字将其转换 NSDictionary。</p>
<p>最后，在第三行代码中，我们捕获任何错误并打印到终端中。</p>
<p>你的整个 ViewController 文件应该类似于下面的代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"https://api.forecast.io/forecast/d3250bf407f0579c8355cd39cdd4f9e1/37.7833,122.4167"</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = <span class="type">NSData</span>(contentsOfURL: url)&#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> parsed = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(data, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">AllowFragments</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">let</span> newDict = parsed <span class="keyword">as</span>? <span class="type">NSDictionary</span></span><br><span class="line">                    <span class="built_in">print</span>(newDict![<span class="string">"currently"</span>]![<span class="string">"summary"</span>])</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"A JSON parsithng error occurred, here are the details:\n <span class="subst">\(error)</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查终端输出。你应该看到一个包裹了值的可选类型(你得到的值应该稍有不同，会根据不同的地理位置和天气来显示)。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-11.21.02-AM1.png" alt=""></p>
<p>现在我们将一些 UILabel 链接到应用中。拖拽两个 UILabel，一个叫 currentTemp，另一个叫 currentSummary。仔细看下 forecast 的 API，你会注意到它返回当前天气温度以及天气的概况(当然还有其他数据)。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-12.26.11-PM-1024x565.png" alt=""></p>
<p>在 newDict 变量下面放置如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.currentTemp.text = <span class="string">"<span class="subst">\(newDict!["currently"]!["temperature"]!!)</span>"</span></span><br><span class="line"><span class="keyword">self</span>.currentSummary.text = <span class="string">"<span class="subst">\(newDict!["currently"]!["summary"]!!)</span>"</span></span><br></pre></td></tr></table></figure>
<p>代码实现了获取天气数据并正确显示到界面。每一行语句最后都使用了双重叹号符号(!!)，用于强制解包 JSON 数据(否则它将被包裹到 Optional 中)。</p>
<p>在模拟器中构建并运行。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Screen-Shot-2015-11-01-at-11.41.44-AM-1024x549.png" alt=""></p>
<p>干的不错！你已经完成了天气预报项目！</p>
<h2 id="其他_tvOS_特性">其他 tvOS 特性</h2><p>我们只不过接触了点 tvOS 的皮毛。正如你所知道的，tvOS 建立在各种 iOS API 之上。但是，许多框架已经从 tvOS 中移除了。完整列表请看这篇<a href="https://developer.apple.com/library/prerelease/tvos/releasenotes/General/tvOS90APIDiffs/" target="_blank" rel="external">文章</a>。</p>
<p>除此之外，tvOS 的基础是焦点事件(按钮、单元格、标签等在选中状态时会凸显出来，此时为聚焦状态)。幸运的是，系统自动处理大多数聚焦事件。只要你使用了 storyboard，默认会自动聚焦。你可以在谷歌中找到一些聚焦<a href="https://www.google.com/search?sourceid=chrome-psyapi2&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;q=tvOS%20focus&amp;oq=tvOS%20focus&amp;aqs=chrome..69i57j0l4j69i60.2140j0j7" target="_blank" rel="external">API</a>。</p>
<p>正如教程开始所提到的，苹果支持 client-server 应用。这些应用使用 TVML、TVJS 以及 TVMLKit，它们的基础是当下最为流行的 web 技术(HTML、JavaScript 等)。</p>
<p>当前需要考虑的最大挑战是创建的 tvOS 应用中，SDK 并不支持数据持久化存储。这是和 iOS 不同，你不能保存任何大小超过 1MB 的照片、图标等内容。因此你必须配备一个后端服务，如 CloudKit、Parse、iCloud 等。建议你先了解下 tvOS 中对资源的需求(之前我写的<a href="http://www.appcoda.com/app-thinning/" target="_blank" rel="external">App 瘦包教程</a>)。此外，应用大小限制在 200MB 以内。</p>
<p>显然，tvOS 应用中有太多限制条件，我们需要多加小心。</p>
<h3 id="总结">总结</h3><p>在本教程中我们大致了解了 tvOS 以及它的各种特性。通过四个例子项目我们看到了 tvOS 的强大之处，当然还有局限性。tvOS 与 iOS 共享许多相似之处，但一些iOS框架却已经被移除了。</p>
<p><a href="https://www.dropbox.com/sh/83i9ahb3nabc698/AAAJ00LBMDEnbJWPy2gF3Iyza?dl=0" target="_blank" rel="external">这里</a>提供了完整的项目文件。</p>
<p>在项目一中，我们实现了一个 hello，world 应用程序；随后项目二中实现了简单的猜谜游戏应用，向你展示聚焦引擎；项目三详细介绍了在 tvOS 中如何使用 tableView；最后，我们结合已有知识在项目四中构建了一个简单的天气应用程序，可以从互联网上下载天气数据。</p>
<p>苹果的 tvOS 应用商店于上周推出，授权世界各地的开发者分享他们的作品。</p>
<p>你将作为见证者，看到 tvOS 和新的苹果电视永久性地改变 TV 行业！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：gregg mojica，<a href="http://www.appcoda.com/tvos-introduction/">原文链接</a>，原文日期：2015-11-02<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p>上月在旧金山举办的苹果发布会中,苹果公司发布了第四代苹果电视。然而，此次更新不同于以往任何版本，苹果新电视将允许用户从 App Store 下载应用和游戏。</p>
<p>这样的声明无疑给开发者打了一剂鸡血。新苹果电视中，位于 Cupertino(译者注:苹果电脑的全球总公司所在地，位于美国旧金山)的巨人介绍了一个新的操作系统，有别于 iOS 系统，新系统名为 tvOS。tvOS 基于 iOS 开发，有少许改动。 我们将使用通用框架和你最喜欢编程语言(当然是 Swift 喽，毫无疑问！)来编写几个简单应用，初步了解 tvOS。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
      <category term="Apple TV 开发" scheme="http://swiftggteam.github.io/categories/Apple-TV-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用闭包初始化来加速 Swift 的 playground]]></title>
    <link href="http://swiftggteam.github.io/2015/11/24/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/11/24/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/</id>
    <published>2015-11-23T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-15<br>译者：<a href="undefined">JackAlan</a>；校对：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 的 Playground 可能会莫名其妙地变慢，尤其当你使用 SpriteKit 或 SceneKit 时。尽可能的把代码迁移到外部资源文件中，可以优化编译并获得更好的运行时速度。</p>
<a id="more"></a>
<p>这种方法的最大问题在于，你会因此失去在 Playground 中的线性流 <code>linear flow</code>。模块编译不支持修改变量的顶层指令。比如，你有类似如下的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> lightNode = <span class="type">SCNNode</span>()</span><br><span class="line">lightNode.light = <span class="type">SCNLight</span>()</span><br><span class="line">lightNode.light!.type = <span class="type">SCNLightTypeOmni</span></span><br><span class="line">lightNode.position = <span class="type">SCNVector3</span>(x: <span class="number">0</span>, y: <span class="number">10</span>, z: <span class="number">10</span>)</span><br><span class="line">scnscene.rootNode.addChildNode(lightNode)</span><br></pre></td></tr></table></figure>
<p>(我很抱歉使用强制解包，但是这是来自苹果的示例代码。)</p>
<p>你不能将这些代码直接移到一个模块文件中，因为你使用的是顶级调用，这些代码不会在外部 Swift 文件中被编译。你可能会把这些代码放在一个函数里，来作为一种变通的方法，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="func"><span class="keyword">func</span> <span class="title">setupLightNode</span><span class="params">()</span></span> -&gt; <span class="type">SCNNode</span> &#123;</span><br><span class="line"><span class="keyword">let</span> theLight = <span class="type">SCNNode</span>()</span><br><span class="line">theLight.light = <span class="type">SCNLight</span>()</span><br><span class="line">theLight.light!.type = <span class="type">SCNLightTypeOmni</span></span><br><span class="line">theLight.position = <span class="type">SCNVector3</span>(x: <span class="number">0</span>, y: <span class="number">10</span>, z: <span class="number">10</span>)</span><br><span class="line">scnscene.rootNode.addChildNode(theLight)</span><br><span class="line"><span class="keyword">return</span> theLight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以在声明后调用该函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lightNode = setupLightNode()</span><br></pre></td></tr></table></figure>
<p>这挫爆了，这种方式创建了一个不必要的额外函数，而且它强制让你在一个新的实例被声明前去处理这个实例。</p>
<p>闭包提供了一种更吸引人、相对轻量的解决方案。正如下面你将看到的样例。在这里，将初始化的代码打包在一个单独的组中，执行并最终返回完全初始化的实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create and add a light to the scene</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">let</span> lightNode: <span class="type">SCNNode</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> theLight = <span class="type">SCNNode</span>()</span><br><span class="line">  theLight.light = <span class="type">SCNLight</span>()</span><br><span class="line">  theLight.light!.type = <span class="type">SCNLightTypeOmni</span></span><br><span class="line">  theLight.position = <span class="type">SCNVector3</span>(x: <span class="number">0</span>, y: <span class="number">10</span>, z: <span class="number">10</span>)</span><br><span class="line">  scnscene.rootNode.addChildNode(theLight)</span><br><span class="line">  <span class="keyword">return</span> theLight</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>这种方法使你可以使用单独的语句来创建和初始化一个对象，保留你在 Playground 中声明的流动性和可读性，而且运行的会更快一点。</p>
<p>这个<a href="https://vid.me/BrPC" target="_blank" rel="external">视频</a>包含了这次 lightNode 的代码与其他设置操作。在点击 Playground 的 “运行” 按钮后，只花了 3-4 秒，而不像此前的数分钟。这种加速方法对于建立以 SpriteKit 和 SceneKit 为元素的原型，在部署到实际的应用前，变得更有实际意义。</p>
<p><strong>更新</strong>：如下是另外一种可以建立类实例的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> •-&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prepare class instance</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> •-&gt; <span class="generics">&lt;T&gt;</span><span class="params">(object: T, f: <span class="params">(T)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">  f(object)</span><br><span class="line">  <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;<span class="keyword">var</span> (x, y, z) = (<span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> myInstance = <span class="type">MyClass</span>() •-&gt; &#123;</span><br><span class="line"> $<span class="number">0</span>.x = <span class="string">"NewX"</span></span><br><span class="line"> $<span class="number">0</span>.y = <span class="string">"NewY"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知你意下如何？</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/15/speeding-up-swift-playgrounds-with-closure-initialization-swiftlang/">原文链接</a>，原文日期：2015-11-15<br>译者：<a href="undefined">JackAlan</a>；校对：<a href="http://weibo.com/linusling">小铁匠Linus</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 的 Playground 可能会莫名其妙地变慢，尤其当你使用 SpriteKit 或 SceneKit 时。尽可能的把代码迁移到外部资源文件中，可以优化编译并获得更好的运行时速度。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 反射 API 及用法]]></title>
    <link href="http://swiftggteam.github.io/2015/11/23/swift-reflection-api-what-you-can-do/"/>
    <id>http://swiftggteam.github.io/2015/11/23/swift-reflection-api-what-you-can-do/</id>
    <published>2015-11-22T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/24/swift-reflection-api-what-you-can-do/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-24<br>译者：<a href="http://blog.csdn.net/mmoaay" target="_blank" rel="external">mmoaay</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>尽管 Swift 一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似<a href="http://design.featherless.software/enumerating-tuple-values-swift/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="external">Tuples</a>、<a href="http://design.featherless.software/enumerate-messages-midipacket-swift-reflection/" target="_blank" rel="external">Midi Packets</a> 和 <a href="https://github.com/terhechte/corevalue" target="_blank" rel="external">Core Data</a> 的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福 Macoun会议上的一次演讲，它对 Swift 的反射 API 做了一个概述。</p>
<a id="more"></a>
<h1 id="API_概述">API 概述</h1><p>理解这个主题最好的方式就是看 API，看它都提供了什么功能。</p>
<h2 id="Mirror"><code>Mirror</code></h2><p>Swift 的反射机制是基于一个叫 <strong>Mirror</strong> 的 <code>struct</code> 来实现的。你为具体的 <code>subject</code> 创建一个 <code>Mirror</code>，然后就可以通过它查询这个对象 <code>subject</code> 。</p>
<p>在我们创建 <code>Mirror</code> 之前，我们先创建一个可以让我们当做对象来使用的简单数据结构。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation.NSURL <span class="comment">// [译者注]此处应该为import Foundation</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> storesToDisk: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookmarkStore</span>: <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> itemCount: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Bookmark</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Tech</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">News</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">let</span> store = &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">BookmarkStore</span>()</span><br><span class="line">   &#125;()</span><br><span class="line">   <span class="keyword">let</span> title: <span class="type">String</span>?</span><br><span class="line">   <span class="keyword">let</span> url: <span class="type">NSURL</span></span><br><span class="line">   <span class="keyword">let</span> keywords: [<span class="type">String</span>]</span><br><span class="line">   <span class="keyword">let</span> group: <span class="type">Group</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aBookmark = <span class="type">Bookmark</span>(title: <span class="string">"Appventure"</span>, url: <span class="type">NSURL</span>(string: <span class="string">"appventure.me"</span>)!, keywords: [<span class="string">"Swift"</span>, <span class="string">"iOS"</span>, <span class="string">"OSX"</span>], group: .<span class="type">Tech</span>)</span><br></pre></td></tr></table></figure>
<h2 id="创建一个_Mirror">创建一个 <code>Mirror</code></h2><p>创建 <code>Mirror</code> 最简单的方式就是使用 <code>reflecting</code> 构造器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(reflecting subject: <span class="type">Any</span>)</span><br></pre></td></tr></table></figure>
<p>然后在 <code>aBookmark</code> <code>struct</code> 上使用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aMirror = <span class="type">Mirror</span>(reflecting: aBookmark)</span><br><span class="line"><span class="built_in">print</span>(aMirror)</span><br><span class="line"><span class="comment">// 输出 : Mirror for Bookmark</span></span><br></pre></td></tr></table></figure>
<p>这段代码创建了 <code>Bookmark 的 Mirror</code>。正如你所见，对象的类型是 <code>Any</code>。这是 Swift 中最通用的类型。Swift 中的任何东西至少都是 <code>Any</code> 类型的<a href="#1">1</a>。这样一来 <code>mirror</code> 就可以兼容 <code>struct</code>, <code>class</code>, <code>enum</code>, <code>Tuple</code>, <code>Array</code>, <code>Dictionary</code>, <code>set</code> 等。</p>
<p><code>Mirror</code> 结构体还有另外三个构造器，然而这三个都是在你需要自定义 <code>mirror</code> 这种情况下使用的。我们会在接下来<a href="#custom_mirrors">讨论自定义 <code>mirror</code> 时详细讲解这些额外的构造器</a>。</p>
<h2 id="Mirror_中都有什么？"><code>Mirror</code> 中都有什么？</h2><p><code>Mirror struct</code> 中包含几个 <code>types</code> 来帮助确定你想查询的信息。</p>
<p>第一个是 <code>DisplayStyle</code> <code>enum</code>，它会告诉你对象的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DisplayStyle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Struct</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Class</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Enum</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tuple</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Optional</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Collection</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dictionary</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是反射 API 的辅助类型。正如之前我们知道的，反射只要求对象是 <code>Any</code> 类型，而且Swift 标准库中还有很多类型为 <code>Any</code> 的东西没有被列举在上面的 <code>DisplayStyle</code> <code>enum</code> 中。如果试图反射它们中间的某一个又会发生什么呢？比如 <code>closure</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> closure = &#123; (a: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="keyword">return</span> a * <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> aMirror = <span class="type">Mirror</span>(reflecting: closure)</span><br></pre></td></tr></table></figure>
<p>在这种情况下，这里你会得到一个 <code>mirror</code>，但是 <code>DisplayStyle</code> 为 <code>nil</code> <a href="#2">2</a></p>
<p>也有提供给 <code>Mirror</code> 的子节点使用的 <code>typealias</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Child</span> = (label: <span class="type">String</span>?, value: <span class="type">Any</span>)</span><br></pre></td></tr></table></figure>
<p>所以每个 <code>Child</code> 都包含一个可选的 <code>label</code> 和 <code>Any</code> 类型的 <code>value</code>。为什么 <code>label</code> 是 <code>Optional</code> 的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。 <code>struct</code> 会以属性的名字做为 <code>label</code>，但是 <code>Collection</code> 只有下标，没有名字。<code>Tuple</code> 同样也可能没有给它们的条目指定名字。</p>
<p>接下来是 <code>AncestorRepresentation</code> <code>enum</code> <a href="#3">3</a>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AncestorRepresentation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 为所有 ancestor class 生成默认 mirror。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Generated</span></span><br><span class="line">    <span class="comment">/// 使用最近的 ancestor 的 customMirror() 实现来给它创建一个 mirror。    </span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Customized</span>(() -&gt; <span class="type">Mirror</span>)</span><br><span class="line">    <span class="comment">/// 禁用所有 ancestor class 的行为。Mirror 的 superclassMirror() 返回值为 nil。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Suppressed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>enum</code> 用来定义被反射的对象的父类应该如何被反射。也就是说，这只应用于 <code>class</code> 类型的对象。默认情况（正如你所见）下 Swift 会为每个父类生成额外的 <code>mirror</code>。然而，如果你需要做更复杂的操作，你可以使用 <code>AncestorRepresentation enum</code> 来定义父类被反射的细节。<a href="#custom_mirrors">我们会在下面的内容中进一步研究这个</a>。</p>
<h2 id="如何使用一个_Mirror">如何使用一个 <code>Mirror</code></h2><p>现在我们有了给 <code>Bookmark</code> 类型的对象<code>aBookmark</code> 做反射的实例变量 <code>aMirror</code>。可以用它来做什么呢？</p>
<p>下面列举了 <code>Mirror</code> 可用的属性 / 方法：</p>
<ul>
<li><code>let children: Children</code>：对象的子节点。</li>
<li><code>displayStyle: Mirror.DisplayStyle?</code>：对象的展示风格</li>
<li><code>let subjectType: Any.Type</code>：对象的类型</li>
<li><code>func superclassMirror() -&gt; Mirror?</code>：对象父类的 <code>mirror</code></li>
</ul>
<p>下面我们会分别对它们进行解析。</p>
<h3 id="displayStyle"><code>displayStyle</code></h3><p>很简单，它会返回 <code>DisplayStyle</code> <code>enum</code> 的其中一种情况。如果你想要对某种不支持的类型进行反射，你会得到一个空的 <code>Optional</code> 值（这个之前解释过）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> (aMirror.displayStyle)</span><br><span class="line"><span class="comment">// 输出: Optional(Swift.Mirror.DisplayStyle.Struct)</span></span><br><span class="line"><span class="comment">// [译者注]此处输出：Optional(Struct)</span></span><br></pre></td></tr></table></figure>
<h3 id="children"><code>children</code></h3><p>这会返回一个包含了对象所有的子节点的 <code>AnyForwardCollection&lt;Child&gt;</code>。这些子节点不单单限于 <code>Array</code> 或者 <code>Dictionary</code> 中的条目。诸如 <code>struct</code> 或者 <code>class</code> 中所有的属性也是由 <code>AnyForwardCollection&lt;Child&gt;</code> 这个属性返回的子节点。<code>AnyForwardCollection</code> 协议意味着这是一个支持遍历的 <code>Collection</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (label?, value) <span class="keyword">in</span> aMirror.children &#123;</span><br><span class="line">    <span class="built_in">print</span> (label, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"><span class="comment">//: store main.BookmarkStore</span></span><br><span class="line"><span class="comment">//: title Optional("Appventure")</span></span><br><span class="line"><span class="comment">//: url appventure.me</span></span><br><span class="line"><span class="comment">//: keywords ["Swift", "iOS", "OSX"]</span></span><br><span class="line"><span class="comment">//: group Tech</span></span><br></pre></td></tr></table></figure>
<h3 id="SubjectType"><code>SubjectType</code></h3><p>这是对象的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(aMirror.subjectType)</span><br><span class="line"><span class="comment">//输出 : Bookmark</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Mirror</span>(reflecting: <span class="number">5</span>).subjectType)</span><br><span class="line"><span class="comment">//输出 : Int</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Mirror</span>(reflecting: <span class="string">"test"</span>).subjectType)</span><br><span class="line"><span class="comment">//输出 : String</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Mirror</span>(reflecting: <span class="type">NSNull</span>()).subjectType)</span><br><span class="line"><span class="comment">//输出 : NSNull</span></span><br></pre></td></tr></table></figure>
<p>然而，Swift 的文档中有下面一句话：</p>
<blockquote>
<p>“当 <code>self</code> 是另外一个 <code>mirror</code> 的 <code>superclassMirror()</code> 时，这个类型和对象的动态类型可能会不一样。”</p>
</blockquote>
<h3 id="SuperclassMirror"><code>SuperclassMirror</code></h3><p>这是我们对象父类的 <code>mirror</code>。如果这个对象不是一个类，它会是一个空的 <code>Optional</code> 值。如果对象的类型是基于类的，你会得到一个新的 <code>Mirror</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 试试 struct</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Mirror</span>(reflecting: aBookmark).superclassMirror())</span><br><span class="line"><span class="comment">// 输出: nil</span></span><br><span class="line"><span class="comment">// 试试 class</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Mirror</span>(reflecting: aBookmark.store).superclassMirror())</span><br><span class="line"><span class="comment">// 输出: Optional(Mirror for Store)</span></span><br></pre></td></tr></table></figure>
<h1 id="实例">实例</h1><h2 id="Struct_转_Core_Data"><code>Struct</code> 转 <code>Core Data</code></h2><p>假设我们在一个叫 <strong>Books Bunny</strong> 的新兴高科技公司工作，我们以浏览器插件的方式提供了一个人工智能，它可以自动分析用户访问的所有网站，然后把相关页面自动保存到书签中。</p>
<p>现在是 2016 年，Swift 已经开源，所以我们的后台服务端肯定是用 Swift 编写。因为在我们的系统中同时有数以百万计的网站访问活动，我们想用 <code>struct</code> 来存储用户访问网站的分析数据。不过，如果我们 AI 认定某个页面的数据是需要保存到书签中的话，我们需要使用 <code>CoreData</code> 来把这个类型的对象保存到数据库中。</p>
<p>现在我们不想为每个新建的 <code>struct</code> 单独写自定义的 <code>Core Data</code> 序列化代码。而是想以一种更优雅的方式来开发，从而可以让将来的所有 <code>struct</code> 都可以利用这种方式来做序列化。</p>
<p>那么我们该怎么做呢？</p>
<h2 id="一个协议">一个协议</h2><p>记住，我们有一个 <code>struct</code>，它需要自动转换为 <code>NSManagedObject</code> （<strong>Core Data</strong>）。</p>
<p>如果我们想要支持不同的 <code>struct</code> 甚至类型，我们可以用协议来实现，然后确保我们需要的类型符合这个协议。所以我们假想的协议应该有哪些功能呢？</p>
<ul>
<li>第一，协议应该允许自定义我们想要创建的<strong>Core Data 实体</strong>的名字</li>
<li>第二，协议需要提供一种方式来告诉它如何转换为 <code>NSManagedObject</code>。</li>
</ul>
<p>我们的 <code>protocol</code>（协议） 看起来是下面这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StructDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们 Core Data 实体的名字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">EntityName</span>: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 返回包含我们属性集的 NSManagedObject</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">toCoreData</span><span class="params">(context: NSManagedObjectContext)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSManagedObject</span> <span class="comment">//[译者注]使用 NSManagedObjectContext 需要 import CoreData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>toCoreData</code> 方法使用了 Swift 2.0 新的异常处理来抛出错误，如果转换失败，会有几种错误情况，这些情况都在下面的 <code>ErrorType</code> <code>enum</code> 进行了列举：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SerializationError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们只支持 struct</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">StructRequired</span></span><br><span class="line">    <span class="comment">// 实体在 Core Data 模型中不存在</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnknownEntity</span>(name: <span class="type">String</span>)</span><br><span class="line">    <span class="comment">// 给定的类型不能保存在 core data 中</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnsupportedSubType</span>(label: <span class="type">String</span>?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面列举了三种转换时需要注意的错误情况。第一种情况是我们试图把它应用到非 <code>struct</code> 的对象上。第二种情况是我们想要创建的 <code>entity</code> 在 Core Data 模型中不存在。第三种情况是我们想要把一些不能存储在 Core Data 中的东西保存到 Core Data 中（即 <code>enum</code>）。</p>
<p>让我们创建一个 <code>struct</code> 然后为其增加协议一致性：</p>
<h2 id="Bookmark_struct"><code>Bookmark struct</code></h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bookmark</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> title: <span class="type">String</span></span><br><span class="line">   <span class="keyword">let</span> url: <span class="type">NSURL</span></span><br><span class="line">   <span class="keyword">let</span> pagerank: <span class="type">Int</span></span><br><span class="line">   <span class="keyword">let</span> created: <span class="type">NSDate</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们要实现 <code>toCoreData</code> 方法。</p>
<h2 id="协议扩展">协议扩展</h2><p>当然我们可以为每个 <code>struct</code> 都写新的 <code>toCoreData</code> 方法，但是工作量很大，因为 <code>struct</code> 不支持继承，所以我们不能使用基类的方式。不过我们可以使用 <code>protocol extension</code> 来扩展这个方法到所有相符合的 <code>struct</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StructDecoder</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">toCoreData</span><span class="params">(context: NSManagedObjectContext)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSManagedObject</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为扩展已经被应用到相符合的 <code>struct</code>，这个方法就可以在 <code>struct</code> 的上下文中被调用。因此，在协议中，<code>self</code> 指的是我们想分析的 <code>struct</code>。</p>
<p>所以，我们需要做的第一步就是创建一个可以写入我们 <code>Bookmark struct</code> 值的<code>NSManagedObject</code>。我们该怎么做呢？</p>
<h2 id="一点_Core_Data">一点 <code>Core Data</code></h2><p><code>Core Data</code> 有点啰嗦，所以如果需要创建一个对象，我们需要如下的步骤：</p>
<ol>
<li>获得我们需要创建的实体的名字（字符串）</li>
<li>获取 <code>NSManagedObjectContext</code>，然后为我们的实体创建 <code>NSEntityDescription</code></li>
<li>利用这些信息创建 <code>NSManagedObject</code>。</li>
</ol>
<p>实现代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Core Data 实体的名字</span></span><br><span class="line"><span class="keyword">let</span> entityName = <span class="keyword">self</span>.<span class="keyword">dynamicType</span>.<span class="type">EntityName</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实体描述</span></span><br><span class="line"><span class="comment">// 实体可能不存在, 所以我们使用 'guard let' 来判断，如果实体</span></span><br><span class="line"><span class="comment">// 在我们的 core data 模型中不存在的话，我们就抛出错误 </span></span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> desc = <span class="type">NSEntityDescription</span>.entityForName(entityName, inManagedObjectContext: context)</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">UnknownEntity</span>(name: entityName) &#125; <span class="comment">// [译者注] UnknownEntity 为 SerializationError.UnknownEntity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 NSManagedObject</span></span><br><span class="line"><span class="keyword">let</span> managedObject = <span class="type">NSManagedObject</span>(entity: desc, insertIntoManagedObjectContext: context)</span><br></pre></td></tr></table></figure>
<h2 id="实现反射">实现反射</h2><p>下一步，我们想使用反射 API 来读取 <code>bookmark</code> 对象的属性然后把它写入到 <code>NSManagedObject</code> 实例中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Mirror</span></span><br><span class="line"><span class="keyword">let</span> mirror = <span class="type">Mirror</span>(reflecting: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保我们是在分析一个 struct</span></span><br><span class="line"><span class="keyword">guard</span> mirror.displayStyle == .<span class="type">Struct</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">SerializationError</span>.<span class="type">StructRequired</span> &#125;</span><br></pre></td></tr></table></figure>
<p>我们通过测试 <code>displayStyle</code> 属性的方式来确保这是一个 <code>struct</code>。</p>
<p>所以现在我们有了一个可以让我们读取属性的 <code>Mirror</code>，也有了一个可以用来设置属性的 <code>NSManagedObject</code>。因为 <code>mirror</code> 提供了读取所有 <code>children</code> 的方式，所以我们可以遍历它们并保存它们的值。方式如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (label?, value) <span class="keyword">in</span> mirror.children &#123;</span><br><span class="line">    managedObject.setValue(value, forKey: label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>太棒了！但是，如果我们试图编译它，它会失败。原因是 <code>setValueForKey</code> 需要一个 <code>AnyObject?</code> 类型的对象，而我们的 <code>children</code> 属性只返回一个 <code>(String?, Any)</code> 类型的 <code>tuple</code>。也就是说 <code>value</code> 是 <code>Any</code> 类型但是我们需要 <code>AnyObject</code> 类型的。为了解决这个问题，我们要测试 <code>value</code> 的  <code>AnyObject</code> 协议一致性。这也意味着如果得到的属性的类型不符合 <code>AnyObject</code> 协议（比如 <code>enum</code>)，我们就可以抛出一个错误。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mirror = <span class="type">Mirror</span>(reflecting: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">guard</span> mirror.displayStyle == .<span class="type">Struct</span> </span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">SerializationError</span>.<span class="type">StructRequired</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (label?, anyValue) <span class="keyword">in</span> mirror.children &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> value = anyValue <span class="keyword">as</span>? <span class="type">AnyObject</span> &#123;</span><br><span class="line">	managedObject.setValue(child, forKey: label) <span class="comment">// [译者注] 正确代码为：managedObject.setValue(value, forKey: label)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="type">SerializationError</span>.<span class="type">UnsupportedSubType</span>(label: label)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，只有在 <code>child</code> 是 <code>AnyObject</code> 类型的时候我们才会调用 <code>setValueForKey</code> 方法。</p>
<p>然后唯一剩下的事情就是返回 <code>NSManagedObject</code>。完整的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StructDecoder</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">toCoreData</span><span class="params">(context: NSManagedObjectContext)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">NSManagedObject</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> entityName = <span class="keyword">self</span>.<span class="keyword">dynamicType</span>.<span class="type">EntityName</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建实体描述</span></span><br><span class="line">	<span class="keyword">guard</span> <span class="keyword">let</span> desc = <span class="type">NSEntityDescription</span>.entityForName(entityName, inManagedObjectContext: context)</span><br><span class="line">	    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">UnknownEntity</span>(name: entityName) &#125; <span class="comment">// [译者注] UnknownEntity 为 SerializationError.UnknownEntity</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建 NSManagedObject</span></span><br><span class="line">	<span class="keyword">let</span> managedObject = <span class="type">NSManagedObject</span>(entity: desc, insertIntoManagedObjectContext: context)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个 Mirror</span></span><br><span class="line">	<span class="keyword">let</span> mirror = <span class="type">Mirror</span>(reflecting: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 确保我们是在分析一个 struct</span></span><br><span class="line">	<span class="keyword">guard</span> mirror.displayStyle == .<span class="type">Struct</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">SerializationError</span>.<span class="type">StructRequired</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (label?, anyValue) <span class="keyword">in</span> mirror.children &#123;</span><br><span class="line">	    <span class="keyword">if</span> <span class="keyword">let</span> value = anyValue <span class="keyword">as</span>? <span class="type">AnyObject</span> &#123;</span><br><span class="line">		managedObject.setValue(child, forKey: label) <span class="comment">// [译者注] 正确代码为：managedObject.setValue(value, forKey: label)</span></span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="type">SerializationError</span>.<span class="type">UnsupportedSubType</span>(label: label)</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> managedObject</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞定，我们现在已经把 <code>struct</code> 转换为 <code>NSManagedObject</code> 了。</p>
<h1 id="性能">性能</h1><p>那么，速度如何呢？这个方法可以在生产中应用么？我做了一些测试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">创建 <span class="number">2000</span> 个 <span class="type">NSManagedObject</span></span><br><span class="line">原生: <span class="number">0.062</span> seconds</span><br><span class="line">反射: <span class="number">0.207</span> seconds</span><br></pre></td></tr></table></figure>
<p>这里的原生是指创建一个 <code>NSManagedObject</code>，然后通过 <code>setValueForKey</code> 设置属性值。如果你在 <code>Core Data</code> 内创建一个 <code>NSManagedObject</code> 子类然后把值直接设置到属性上（没有了动态 <code>setValueForKey</code> 的开销），速度可能更快。</p>
<p>所以正如你所见，使用反射使创建 <code>NSManagedObject</code> 的性能下降了<strong>3.5倍</strong>。当你在数量有限的项目上使用这个方法，或者你不关心处理速度时，这是没问题的。但是当你需要反射大量的 <code>struct</code> 时，这个方法可能会大大降低你 app 的性能。</p>
<p><a name="custom_mirrors"></a></p>
<h1 id="自定义_Mirror">自定义 <code>Mirror</code></h1><p>我们之前已经讨论过，创建 <code>Mirror</code> 还有其他的选项。这些选项是非常有用的，比如，你想自己定义 <code>mirror</code> 中<strong>对象</strong>的哪些部分是可访问的。对于这种情况 <code>Mirror Struct</code> 提供了其他的构造器。</p>
<h2 id="Collection"><code>Collection</code></h2><p>第一个特殊 <code>init</code> 是为 <code>Collection</code> 量身定做的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>, <span class="type">C</span> : <span class="type">CollectionType</span> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Generator</span>.<span class="type">Element</span> == <span class="type">Child</span>&gt;</span><br><span class="line">  (<span class="number">_</span> subject: <span class="type">T</span>, children: <span class="type">C</span>, </span><br><span class="line">   displayStyle: <span class="type">Mirror</span>.<span class="type">DisplayStyle</span>? = <span class="keyword">default</span>, </span><br><span class="line">   ancestorRepresentation: <span class="type">Mirror</span>.<span class="type">AncestorRepresentation</span> = <span class="keyword">default</span>)</span><br></pre></td></tr></table></figure>
<p>与之前的 <code>init(reflecting:)</code> 相比，这个构造器允许我们定义更多反射处理的细节。</p>
<ul>
<li>它只对 <code>Collection</code> 有效</li>
<li>我们可以设定被反射的对象<strong>以及</strong>对象的 <code>children</code> （<code>Collection</code> 的内容）</li>
</ul>
<h2 id="class_或者_struct"><code>class</code> 或者 <code>struct</code></h2><p>第二个可以在 <code>class</code> 或者 <code>struct</code> 上使用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(<span class="number">_</span> subject: <span class="type">T</span>, </span><br><span class="line">  children: <span class="type">DictionaryLiteral</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;, </span><br><span class="line">  displayStyle: <span class="type">Mirror</span>.<span class="type">DisplayStyle</span>? = <span class="keyword">default</span>, </span><br><span class="line">  ancestorRepresentation: <span class="type">Mirror</span>.<span class="type">AncestorRepresentation</span> = <span class="keyword">default</span>)</span><br></pre></td></tr></table></figure>
<p>有意思的是，这里是由你指定对象的 <code>children</code> （即属性），指定的方式是通过一个 <code>DictionaryLiteral</code>，它有点像字典，可以直接用作函数参数。如果我们为 <code>Bookmark struct</code> 实现这个构造器，它看起来是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Bookmark</span>: <span class="title">CustomReflectable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">customMirror</span><span class="params">()</span></span> -&gt; <span class="type">Mirror</span> &#123; <span class="comment">// [译者注] 此处应该为 public func customMirror() -&gt; Mirror &#123;</span></span><br><span class="line">	<span class="keyword">let</span> children = <span class="type">DictionaryLiteral</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;(dictionaryLiteral: </span><br><span class="line">	(<span class="string">"title"</span>, <span class="keyword">self</span>.title), (<span class="string">"pagerank"</span>, <span class="keyword">self</span>.pagerank), </span><br><span class="line">	(<span class="string">"url"</span>, <span class="keyword">self</span>.url), (<span class="string">"created"</span>, <span class="keyword">self</span>.created), </span><br><span class="line">	(<span class="string">"keywords"</span>, <span class="keyword">self</span>.keywords), (<span class="string">"group"</span>, <span class="keyword">self</span>.group))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="type">Mirror</span>.<span class="keyword">init</span>(<span class="type">Bookmark</span>.<span class="keyword">self</span>, children: children, </span><br><span class="line">	    displayStyle: <span class="type">Mirror</span>.<span class="type">DisplayStyle</span>.<span class="type">Struct</span>, </span><br><span class="line">	    ancestorRepresentation:.<span class="type">Suppressed</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在我们做另外一个性能测试，会发现性能甚至略微有所提升：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">创建 <span class="number">2000</span> 个 <span class="type">NSManagedObject</span></span><br><span class="line">原生: <span class="number">0.062</span> seconds</span><br><span class="line">反射: <span class="number">0.207</span> seconds</span><br><span class="line">反射: <span class="number">0.203</span> seconds</span><br></pre></td></tr></table></figure>
<p>但这个工作几乎没有任何价值，因为它与我们之前反射 <code>struct</code> 成员变量的初衷是相违背的。</p>
<h1 id="用例">用例</h1><p>所以留下来让我们思考的问题是什么呢？好的反射用例又是什么呢？很显然，如果你在很多 <code>NSManagedObject</code> 上使用反射，它会大大降低你代码的性能。同时如果只有一个或者两个 <code>struct</code>，根据自己掌握的<code>struct</code> 领域的知识编写一个序列化的方法会更容易，更高性能且更不容易让人困惑。</p>
<p>而本文展示反射技巧可以当你在有很多复杂的 <code>struct</code> ，且偶尔想对它们中的一部分进行存储时使用。</p>
<p>例子如下：</p>
<ul>
<li>设置收藏夹</li>
<li>收藏书签</li>
<li>加星</li>
<li>记住上一次选择</li>
<li>在重新启动时存储AST打开的项目</li>
<li>在特殊处理时做临时存储</li>
</ul>
<p>当然除此之外，反射当然还有其他的使用场景：</p>
<ul>
<li>遍历 <code>tuples</code></li>
<li>对类做分析</li>
<li>运行时分析对象的一致性</li>
<li>自动生成详细日志 / 调试信息（即外部生成对象）</li>
</ul>
<h1 id="讨论">讨论</h1><p>反射 API 主要做为 <code>Playground</code> 的一个工具。符合反射 API 的对象可以很轻松滴就在 <code>Playground</code> 的侧边栏中以分层的方式展示出来。因此，尽管它的性能不是最优的，在 <code>Playground</code> 之外仍然有很多有趣的应用场景，这些应用场景我们在<strong>用例</strong>章节中都讲解过。</p>
<h1 id="更多信息">更多信息</h1><p>反射 API 的源文件注释非常详细，我强烈建议每个人都去看看。</p>
<p>同时，GitHub 上的 <a href="http://github.com/terhechte/corevalue" target="_blank" rel="external">CoreValue</a> 项目展示了关于这个技术更详尽的实现，它可以让你很轻松滴把 <code>struct</code> 编码成 <code>CoreData</code>，或者把 <code>CoreData</code> 解码成  <code>struct</code>。</p>
<p><a name="1">1、实际上，<code>Any</code> 是一个空的协议，所有的东西都隐式滴符合这个协议。<br><a name="2">2、更确切地说，是一个空的可选类型。<br><a name="3">3、我对注释稍微做了简化。</a></a></a></p>
<p>本文对应代码地址：<a href="https://github.com/mmoaay/MBPlayGroundForSwiftGG/tree/master/SwiftReflectionAPIPlayground.playground" target="_blank" rel="external">下载</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/24/swift-reflection-api-what-you-can-do/">原文链接</a>，原文日期：2015-10-24<br>译者：<a href="http://blog.csdn.net/mmoaay">mmoaay</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>尽管 Swift 一直在强调强类型、编译时安全和静态调度，但它的标准库仍然提供了反射机制。可能你已经在很多博客文章或者类似<a href="http://design.featherless.software/enumerating-tuple-values-swift/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12">Tuples</a>、<a href="http://design.featherless.software/enumerate-messages-midipacket-swift-reflection/">Midi Packets</a> 和 <a href="https://github.com/terhechte/corevalue">Core Data</a> 的项目中见过它。也许你刚好对在项目中使用反射机制感兴趣，或者你想更好的了解反射可以应用的领域，那这篇文章就正是你需要的。文章的内容是基于我在德国法兰克福 Macoun会议上的一次演讲，它对 Swift 的反射 API 做了一个概述。</p>]]>
    
    </summary>
    
      <category term="APPVENTURE" scheme="http://swiftggteam.github.io/tags/APPVENTURE/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中枚举高级用法及实践]]></title>
    <link href="http://swiftggteam.github.io/2015/11/20/advanced-practical-enum-examples/"/>
    <id>http://swiftggteam.github.io/2015/11/20/advanced-practical-enum-examples/</id>
    <published>2015-11-19T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.924Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles" target="_blank" rel="external">小锅</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到<a href="https://github.com/colourful987/Topic_Demo/tree/master/Advanced%20%26%20Practical%20Enum%20usage%20in%20Swift" target="_blank" rel="external">这个github地址上进行下载</a>，这个代码由翻译组的另一位小伙伴 <a href="http://blog.csdn.net/colouful987" target="_blank" rel="external">ppt</a> 提供。</p>
</blockquote>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>
<a id="more"></a>
<p>和<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">switch语句</a>类似，<code>Swift</code>中的枚举乍看之下更像是<code>C</code>语言中枚举的进阶版本，即允许你定义一种类型，用于表示普通事情中某种用例。不过深入挖掘之后，凭借<code>Swift</code>背后特别的设计理念，相比较<code>C</code>语言枚举来说其在实际场景中的应用更为广泛。特别是作为强大的工具，<code>Swift</code>中的枚举能够清晰表达代码的意图。</p>
<p>本文中，我们将首先了解基础语法和使用枚举的可能性，接着通过实战教你如何以及何时使用枚举。最后我们还会大致了解下<code>Swift</code>标准库中枚举是如何被使用的。</p>
<p>正式开始学习之前，先给出枚举的定义。之后我们将回过头再来讨论它。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<h2 id="深入理解(Diving_In)">深入理解(Diving In)</h2><p>简要概述如何定义和使用枚举。</p>
<h3 id="定义基本的枚举类型(Defining_Basic_Enums)">定义基本的枚举类型(Defining Basic Enums)</h3><p>试想我们正在开发一款游戏，玩家能够朝四个方向移动。所以喽，玩家的运动轨迹受到了限制。显然，我们能够使用枚举来表述这一情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span></span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Left</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Right</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Top</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Bottom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，你可以使用<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">多种模式匹配结构</a>获取到<code>Movement</code>的枚举值，或者按照特定情况执行操作:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aMovement = <span class="type">Movement</span>.<span class="type">Left</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 分情况处理</span></span><br><span class="line"><span class="keyword">switch</span> aMovement&#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">Left</span>: <span class="built_in">print</span>(<span class="string">"left"</span>)</span><br><span class="line"><span class="keyword">default</span>:()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确的case情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">Left</span> = aMovement&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"left"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> aMovement == .<span class="type">Left</span> &#123; <span class="built_in">print</span>(<span class="string">"left"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>案例中，我们无须明确指出<code>enum</code>的实际名称(即<code>case Move.Left:print(&quot;Left&quot;)</code>)。因为类型检查器能够自动为此进行类型推算。这对于那些<strong>UIKit</strong>以及<strong>AppKit</strong>中错综复杂的枚举是灰常有用的。</p>
<h3 id="枚举值(Enum_Values)">枚举值(Enum Values)</h3><p>当然，你可能想要为<code>enum</code>中每个<code>case</code>分配一个值。这相当有用，比如枚举自身实际与某事或某物挂钩时，往往这些东西又需要使用不同类型来表述。在<code>C</code>语言中，你只能为枚举<code>case</code>分配整型值，而<code>Swift</code>则提供了更多的灵活性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 映射到整型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样你可以与字符串一一对应</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">House</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Baratheon</span> = <span class="string">"Ours is the Fury"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Greyjoy</span> = <span class="string">"We Do Not Sow"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Martell</span> = <span class="string">"Unbowed, Unbent, Unbroken"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Stark</span> = <span class="string">"Winter is Coming"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tully</span> = <span class="string">"Family, Duty, Honor"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tyrell</span> = <span class="string">"Growing Strong"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者float double都可以(同时注意枚举中的花式unicode)</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Constants</span>: <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> π = <span class="number">3.14159</span></span><br><span class="line">    <span class="keyword">case</span> e = <span class="number">2.71828</span></span><br><span class="line">    <span class="keyword">case</span> φ = <span class="number">1.61803398874</span></span><br><span class="line">    <span class="keyword">case</span> λ = <span class="number">1.30357</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>String</code>和<code>Int</code>类型来说，你甚至可以忽略为枚举中的<code>case</code>赋值，<code>Swift</code>编译器也能正常工作。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mercury = 1, Venus = 2, ... Neptune = 8</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// North = "North", ... West = "West"</span></span><br><span class="line"><span class="comment">// 译者注: 这个是swift2.0新增语法</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Swift</code>枚举中支持以下四种关联值类型:</p>
<ul>
<li>整型(Integer)</li>
<li>浮点数(Float Point)</li>
<li>字符串(String)</li>
<li>布尔类型(Boolean)</li>
</ul>
<p>因此你无法<a href="#c1"><sup>1<sup></sup></sup></a>为枚举分配诸如<code>CGPoint</code>类型的值。</p>
<p>倘若你想要读取枚举的值，可以通过<code>rawValue</code>属性来实现:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bestHouse = <span class="type">House</span>.<span class="type">Stark</span></span><br><span class="line"><span class="built_in">print</span>(bestHouse.rawValue)</span><br><span class="line"><span class="comment">// prints "Winter is coming"</span></span><br></pre></td></tr></table></figure>
<p>不过某种情形下，你可能想要通过一个已有的<code>raw value</code>来创建一个<code>enum case</code>。这种情况下，枚举提供了一个指定构造方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Movement</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Left</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Right</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Top</span> = <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bottom</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个movement.Right 用例,其raw value值为1</span></span><br><span class="line"><span class="keyword">let</span> rightMovement = <span class="type">Movement</span>(rawValue: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>倘若使用<code>rawValue</code>构造器，切记它是一个可失败构造器(<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-ID376" target="_blank" rel="external">failable initializer</a>)。换言之，构造方法返回值为<a href="http://appventure.me/2014/06/13/swift-optionals-made-simple/" target="_blank" rel="external">可选类型值</a>,因为有时候传入的值可能与任意一个<code>case</code>都不匹配。比如<code>Movement(rawValue:42)</code>。</p>
<p>如果你想要以底层 C 二进制编码形式呈现某物或某事，使得更具可读性，这是一个非常有用的功能。例如，可以看一下<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/kqueue.2.html" target="_blank" rel="external">BSD kqeue library</a>中的<strong>VNode Flags</strong>标志位的编码方式:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">VNodeFlags</span> : <span class="title">UInt32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Delete</span> = <span class="number">0x00000001</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Write</span> = <span class="number">0x00000002</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Extended</span> = <span class="number">0x00000004</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Attrib</span> = <span class="number">0x00000008</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Link</span> = <span class="number">0x00000010</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Rename</span> = <span class="number">0x00000020</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Revoke</span> = <span class="number">0x00000040</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> = <span class="number">0x00000080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此便可以使你的<strong>Delete</strong>或<strong>Write</strong>用例声明一目了然，稍后一旦需要，只需将<strong>raw value</strong>传入 C 函数中即可。</p>
<h3 id="嵌套枚举(Nesting_Enums)">嵌套枚举(Nesting Enums)</h3><p>如果你有特定子类型的需求，可以对<code>enum</code>进行嵌套。这样就允许你为实际的<code>enum</code>中包含其他明确信息的<code>enum</code>。以<strong>RPG</strong>游戏中的每个角色为例，每个角色能够拥有武器，因此所有角色都可以获取同一个武器集合。而游戏中的其他实例则无法获取这些武器(比如食人魔,它们仅使用棍棒)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Helmet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Wooden</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Iron</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Diamond</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过层级结构来描述角色允许访问的项目条。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> character = <span class="type">Character</span>.<span class="type">Thief</span></span><br><span class="line"><span class="keyword">let</span> weapon = <span class="type">Character</span>.<span class="type">Weapon</span>.<span class="type">Bow</span></span><br><span class="line"><span class="keyword">let</span> helmet = <span class="type">Character</span>.<span class="type">Helmet</span>.<span class="type">Iron</span></span><br></pre></td></tr></table></figure>
<h3 id="包含枚举(Containing_Enums)">包含枚举(Containing Enums)</h3><p>同样地，你也能够在<code>structs</code>或<code>classes</code>中内嵌枚举。接着上面的例子:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">CharacterType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> type: <span class="type">CharacterType</span></span><br><span class="line">  <span class="keyword">let</span> weapon: <span class="type">Weapon</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> warrior = <span class="type">Character</span>(type: .<span class="type">Warrior</span>, weapon: .<span class="type">Sword</span>)</span><br></pre></td></tr></table></figure>
<p>同样地，这也将有助于我们将相关的信息集中在一个位置。</p>
<h3 id="关联值(Associated_Value)">关联值(Associated Value)</h3><p>关联值是将额外信息附加到<code>enum case</code>中的一种极好的方式。打个比方，你正在开发一款交易引擎，可能存在<strong>买</strong>和<strong>卖</strong>两种不同的交易类型。除此之外每手交易还要制定明确的股票名称和交易数量:</p>
<h4 id="简单例程(Simple_Example)">简单例程(Simple Example)</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">trade</span><span class="params">(tradeType: Trade, stock: String, amount: Int)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然而股票的价值和数量显然从属于交易，让他们作为独立的参数显得模棱两可。你可能已经想到要往<code>struct</code>中内嵌一个枚举了，不过关联值提供了一种更清爽的解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">trade</span><span class="params">(type: Trade)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模式匹配(Pattern_Mathching)">模式匹配(Pattern Mathching)</h4><p>如果你想要访问这些值，<a href="http://appventure.me/2015/08/20/swift-pattern-matching-in-detail/" target="_blank" rel="external">模式匹配</a>再次救场:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> trade = <span class="type">Trade</span>.<span class="type">Buy</span>(stock: <span class="string">"APPL"</span>, amount: <span class="number">500</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Trade</span>.<span class="type">Buy</span>(stock, amount) = trade &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"buy <span class="subst">\(amount)</span> of <span class="subst">\(stock)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标签(Labels)">标签(Labels)</h4><p>关联值不需要附加标签的声明:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span>(<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span>(<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倘若你添加了，那么，每当创建枚举用例时，你都需要将这些标签标示出来。</p>
<h4 id="元组参数(Tuple_as_Arguments)">元组参数(Tuple as Arguments)</h4><p>更重要的是,<code>Swift</code>内部相关信息其实是一个元组,所以你可以像下面这样做:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tp = (stock: <span class="string">"TSLA"</span>, amount: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> trade = <span class="type">Trade</span>.<span class="type">Sell</span>(tp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> <span class="type">Trade</span>.<span class="type">Sell</span>(stock, amount) = trade &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"buy <span class="subst">\(amount)</span> of <span class="subst">\(stock)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints: "buy 100 of TSLA"</span></span><br></pre></td></tr></table></figure>
<p>语法允许您将元组当作一个简单的数据结构,稍后元组将自动转换到高级类型，就比如<code>enum case</code>。想象一个应用程序可以让用户来配置电脑:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Config</span> = (<span class="type">RAM</span>: <span class="type">Int</span>, <span class="type">CPU</span>: <span class="type">String</span>, <span class="type">GPU</span>: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Each of these takes a config and returns an updated config</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">selectRAM</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: <span class="number">32</span>, <span class="type">CPU</span>: config.<span class="type">CPU</span>, <span class="type">GPU</span>: config.<span class="type">GPU</span>)&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">selectCPU</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: config.<span class="type">RAM</span>, <span class="type">CPU</span>: <span class="string">"3.2GHZ"</span>, <span class="type">GPU</span>: config.<span class="type">GPU</span>)&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">selectGPU</span><span class="params">(<span class="number">_</span> config: Config)</span></span> -&gt; <span class="type">Config</span> &#123;<span class="keyword">return</span> (<span class="type">RAM</span>: config.<span class="type">RAM</span>, <span class="type">CPU</span>: <span class="string">"3.2GHZ"</span>, <span class="type">GPU</span>: <span class="string">"NVidia"</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Desktop</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Cube</span>(<span class="type">Config</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Tower</span>(<span class="type">Config</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Rack</span>(<span class="type">Config</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aTower = <span class="type">Desktop</span>.<span class="type">Tower</span>(selectGPU(selectCPU(selectRAM((<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>) <span class="keyword">as</span> <span class="type">Config</span>))))</span><br></pre></td></tr></table></figure>
<p>配置的每个步骤均通过递交元组到<code>enum</code>中进行内容更新。倘若我们从<strong>函数式编程</strong><a href="#c2"><sup>2<sup></sup></sup></a>中获得启发，这将变得更好。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt; &#123; <span class="keyword">associativity</span> <span class="keyword">left</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="generics">&lt;^&gt;</span><span class="params">(a: Config, f: <span class="params">(Config)</span></span></span> -&gt; <span class="type">Config</span>) -&gt; <span class="type">Config</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> f(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以将不同配置步骤串联起来。这在配置步骤繁多的情况下相当有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = (<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>) &lt;^&gt; selectRAM  &lt;^&gt; selectCPU &lt;^&gt; selectGPU</span><br><span class="line"><span class="keyword">let</span> aCube = <span class="type">Desktop</span>.<span class="type">Cube</span>(config)</span><br></pre></td></tr></table></figure>
<h4 id="使用案例(Use_Case_Example)">使用案例(Use Case Example)</h4><p>关联值可以以多种方式使用。常言道：一码胜千言, 下面就上几段简单的示例代码，这几段代码没有特定的顺序。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拥有不同值的用例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OpenURL</span>(url: <span class="type">NSURL</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">SwitchProcess</span>(processId: <span class="type">UInt32</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Restart</span>(time: <span class="type">NSDate</span>?, intoCommandLine: <span class="type">Bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设你在实现一个功能强大的编辑器，这个编辑器允许多重选择，</span></span><br><span class="line"><span class="comment">// 正如 Sublime Text : https://www.youtube.com/watch?v=i2SVJa2EGIw</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Selection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Single</span>(<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Multiple</span>([<span class="type">Range</span>&lt;<span class="type">Int</span>&gt;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者映射不同的标识码</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(numberSystem: <span class="type">Int</span>, manufacturer: <span class="type">Int</span>, product: <span class="type">Int</span>, check: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(productCode: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 又或者假设你在封装一个 C 语言库，正如 Kqeue BSD/Darwin 通知系统:</span></span><br><span class="line"><span class="comment">// https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">KqueueEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UserEvent</span>(identifier: <span class="type">UInt</span>, fflags: [<span class="type">UInt32</span>], data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReadFD</span>(fd: <span class="type">UInt</span>, data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">WriteFD</span>(fd: <span class="type">UInt</span>, data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">VnodeFD</span>(fd: <span class="type">UInt</span>, fflags: [<span class="type">UInt32</span>], data: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ErrorEvent</span>(code: <span class="type">UInt</span>, message: <span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后, 一个 RPG 游戏中的所有可穿戴装备可以使用一个枚举来进行映射，</span></span><br><span class="line"><span class="comment">// 可以为一个装备增加重量和持久两个属性</span></span><br><span class="line"><span class="comment">// 现在可以仅用一行代码来增加一个"钻石"属性，如此一来我们便可以增加几件新的镶嵌钻石的可穿戴装备</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Wearable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weight</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Light</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Mid</span> = <span class="number">4</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Heavy</span> = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Armor</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Light</span> = <span class="number">2</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Strong</span> = <span class="number">8</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Heavy</span> = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Helmet</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Breastplate</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shield</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> woodenHelmet = <span class="type">Wearable</span>.<span class="type">Helmet</span>(weight: .<span class="type">Light</span>, armor: .<span class="type">Light</span>)</span><br></pre></td></tr></table></figure>
<h3 id="方法和属性(Methods_and_properties)">方法和属性(Methods and properties)</h3><p>你也可以在<code>enum</code>中像这样定义方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Wearable</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weight</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Light</span> = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Armor</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">case</span> <span class="type">Light</span> = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Helmet</span>(weight: <span class="type">Weight</span>, armor: <span class="type">Armor</span>)</span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">attributes</span><span class="params">()</span></span> -&gt; (weight: <span class="type">Int</span>, armor: <span class="type">Int</span>) &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	         <span class="keyword">case</span> .<span class="type">Helmet</span>(<span class="keyword">let</span> w, <span class="keyword">let</span> a): <span class="keyword">return</span> (weight: w.rawValue * <span class="number">2</span>, armor: w.rawValue * <span class="number">4</span>)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> woodenHelmetProps = <span class="type">Wearable</span>.<span class="type">Helmet</span>(weight: .<span class="type">Light</span>, armor: .<span class="type">Light</span>).attributes()</span><br><span class="line"><span class="built_in">print</span> (woodenHelmetProps)</span><br><span class="line"><span class="comment">// prints "(2, 4)"</span></span><br></pre></td></tr></table></figure>
<p>枚举中的方法为每一个<code>enum case</code>而“生”。所以倘若想要在特定情况执行特定代码的话，你需要分支处理或采用<code>switch</code>语句来明确正确的代码路径。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> iPad, iPhone, <span class="type">AppleTV</span>, <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">introduced</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	     <span class="keyword">case</span> <span class="type">AppleTV</span>: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2006"</span></span><br><span class="line">	     <span class="keyword">case</span> iPhone: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2007"</span></span><br><span class="line">	     <span class="keyword">case</span> iPad: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2010"</span></span><br><span class="line">	     <span class="keyword">case</span> <span class="type">AppleWatch</span>: <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>)</span> was introduced 2014"</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="type">Device</span>.iPhone.introduced())</span><br><span class="line"><span class="comment">// prints: "iPhone was introduced 2007"</span></span><br></pre></td></tr></table></figure>
<h4 id="属性(Properties)">属性(Properties)</h4><p>尽管增加一个存储属性到枚举中不被允许，但你依然能够创建计算属性。当然，计算属性的内容都是建立在枚举值下或者枚举关联值得到的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> iPad, iPhone</span><br><span class="line">  <span class="keyword">var</span> year: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	    <span class="keyword">case</span> iPhone: <span class="keyword">return</span> <span class="number">2007</span></span><br><span class="line">	    <span class="keyword">case</span> iPad: <span class="keyword">return</span> <span class="number">2010</span></span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态方法(Static_Methods)">静态方法(Static Methods)</h4><p>你也能够为枚举创建一些静态方法(<code>static methods</code>)。换言之通过一个非枚举类型来创建一个枚举。在这个示例中,我们需要考虑用户有时将苹果设备叫错的情况(比如AppleWatch叫成iWatch)，需要返回一个合适的名称。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fromSlang</span><span class="params">(term: String)</span></span> -&gt; <span class="type">Device</span>? &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span> (<span class="type">Device</span>.fromSlang(<span class="string">"iWatch"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="可变方法(Mutating_Methods)">可变方法(Mutating Methods)</h4><p>方法可以声明为<code>mutating</code>。这样就允许改变隐藏参数<code>self</code>的<code>case</code>值了<a href="#c3"><sup>3<sup></sup></sup></a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Off</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">Low</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">Low</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">High</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">High</span>:</span><br><span class="line">	    <span class="keyword">self</span> = <span class="type">Off</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ovenLight = <span class="type">TriStateSwitch</span>.<span class="type">Low</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于.On</span></span><br><span class="line">ovenLight.next()</span><br><span class="line"><span class="comment">// ovenLight 现在等于.Off</span></span><br></pre></td></tr></table></figure>
<h3 id="小结(To_Recap)">小结(To Recap)</h3><p>至此，我们已经大致了解了Swift中枚举语法的基本用例。在开始迈向进阶之路之前，让我们重新审视文章开篇给出的定义，看看现在是否变得更清晰了。</p>
<blockquote>
<p>枚举声明的类型是囊括可能状态的有限集，且可以具有附加值。通过内嵌(<em>nesting</em>),方法(<em>method</em>),关联值(<em>associated values</em>)和模式匹配(<em>pattern matching</em>),枚举可以分层次地定义任何有组织的数据。</p>
</blockquote>
<p>现在我们已经对这个定义更加清晰了。确实，如果我们添加关联值和嵌套，<code>enum</code>就看起来就像一个封闭的、简化的<code>struct</code>。相比较<code>struct</code>，前者优势体现在能够为分类与层次结构编码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Struct Example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123; <span class="keyword">let</span> x: <span class="type">Int</span>, <span class="keyword">let</span> y: <span class="type">Int</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123; <span class="keyword">let</span> x: <span class="type">Int</span>, <span class="keyword">let</span> y: <span class="type">Int</span>, <span class="keyword">let</span> width: <span class="type">Int</span>, <span class="keyword">let</span> height: <span class="type">Int</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enum Example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">GeometricEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Point</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Rect</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, width: <span class="type">Int</span>, height: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法和静态方法的添加允许我们为<code>enum</code>附加功能，这意味着无须依靠额外函数就能实现<a href="#c4"><sup>4<sup></sup></sup></a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C-Like example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">order</span><span class="params">(trade: Trade)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift Enum example</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Sell</span></span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">order</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举进阶(Advanced_Enum_Usage）">枚举进阶(Advanced Enum Usage）</h2><h3 id="协议(Protocols)">协议(Protocols)</h3><p>我已经提及了<code>structs</code>和<code>enums</code>之间的相似性。除了附加方法的能力之外，<code>Swift</code>也允许你在枚举中使用<strong>协议(Protocols)</strong>和<strong>协议扩展(Protocol Extension)</strong>。</p>
<p><code>Swift</code>协议定义一个接口或类型以供其他数据结构来遵循。<code>enum</code>当然也不例外。我们先从<code>Swift</code>标准库中的一个例子开始.</p>
<p><code>CustomStringConvertible</code>是一个以打印为目的的自定义格式化输出的类型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该协议只有一个要求，即一个只读(<code>getter</code>)类型的字符串(<code>String</code>类型)。我们可以很容易为<code>enum</code>实现这个协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Buy</span>, <span class="type">Sell</span></span><br><span class="line">   <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	   <span class="keyword">case</span> <span class="type">Buy</span>: <span class="keyword">return</span> <span class="string">"We're buying something"</span></span><br><span class="line">	   <span class="keyword">case</span> <span class="type">Sell</span>: <span class="keyword">return</span> <span class="string">"We're selling something"</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> action = <span class="type">Trade</span>.<span class="type">Buy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"this action is <span class="subst">\(action)</span>"</span>)</span><br><span class="line"><span class="comment">// prints: this action is We're buying something</span></span><br></pre></td></tr></table></figure>
<p>一些协议的实现可能需要根据内部状态来相应处理要求。例如定义一个管理银行账号的协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AccountCompatible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> remainingFunds: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">addFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">removeFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会简单地拿<code>struct</code>实现这个协议，但是考虑应用的上下文，<code>enum</code>是一个更明智的处理方法。不过你无法添加一个存储属性到<code>enum</code>中，就像<code>var remainingFuns:Int</code>。那么你会如何构造呢？答案灰常简单，你可以使用关联值完美解决:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Funds</span>(remaining: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Overdraft</span>(amount: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> remainingFunds: <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Funds</span>(<span class="keyword">let</span> remaining): <span class="keyword">return</span> remaining</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保持代码清爽，我们可以在<code>enum</code>的协议扩展(<code>protocl extension</code>)中定义必须的协议函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Account</span>: <span class="title">AccountCompatible</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">addFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newAmount = amount</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Funds</span>(remaining) = <span class="keyword">self</span> &#123;</span><br><span class="line">      newAmount += remaining</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> newAmount &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">Error</span>.<span class="type">Overdraft</span>(amount: -newAmount)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> newAmount == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .<span class="type">Empty</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span> = .<span class="type">Funds</span>(remaining: newAmount)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">removeFunds</span><span class="params">(amount: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">self</span>.addFunds(amount * -<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> account = <span class="type">Account</span>.<span class="type">Funds</span>(remaining: <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"add: "</span>, <span class="keyword">try</span>? account.addFunds(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"remove 1: "</span>, <span class="keyword">try</span>? account.removeFunds(<span class="number">15</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">"remove 2: "</span>, <span class="keyword">try</span>? account.removeFunds(<span class="number">55</span>))</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// : add:  Optional(())</span></span><br><span class="line"><span class="comment">// : remove 1:  Optional(())</span></span><br><span class="line"><span class="comment">// : remove 2:  nil</span></span><br></pre></td></tr></table></figure>
<p>正如你所看见的，我们通过将值存储到<code>enum cases</code>中实现了协议所有要求项。如此做法还有一个妙不可言的地方:现在整个代码基础上你只需要一个模式匹配就能测试空账号输入的情况。你不需要关心剩余资金是否等于零。</p>
<p>同时，我们也在<strong>账号(Accout)</strong>中内嵌了一个遵循<code>ErrorType</code>协议的枚举，这样我们就可以使用<code>Swift2.0</code>语法来进行错误处理了。这里给出更详细的<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/#errortype" target="_blank" rel="external">使用案例</a>教程。</p>
<h3 id="扩展(Extensions)">扩展(Extensions)</h3><p>正如刚才所见，枚举也可以进行扩展。最明显的用例就是将枚举的<code>case</code>和<code>method</code>分离，这样阅读你的代码能够简单快速地消化掉<code>enum</code>内容，紧接着转移到方法定义:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Soldier</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tank</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Player</span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们为<code>enum</code>扩展方法:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entities</span> </span>&#123;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">move</span><span class="params">(dist: CGVector)</span></span> &#123;&#125;</span><br><span class="line">   <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">attack</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你同样可以通过写一个扩展来遵循一个特定的协议:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Entities</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Soldier</span>(x, y): <span class="keyword">return</span> <span class="string">"<span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span></span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Tank</span>(x, y): <span class="keyword">return</span> <span class="string">"<span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span></span><br><span class="line">       <span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Player</span>(x, y): <span class="keyword">return</span> <span class="string">"<span class="subst">\(x)</span>, <span class="subst">\(y)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举泛型(Generic_Enums)">枚举泛型(Generic Enums)</h3><p>枚举也支持泛型参数定义。你可以使用它们以适应枚举中的关联值。就拿直接来自<code>Swift</code>标准库中的简单例子来说，即<code>Optional</code>类型。你主要可能通过以下几种方式使用它:可选链(<code>optional chaining(?)</code>)、<code>if-let</code>可选绑定、<code>guard let</code>、或<code>switch</code>，但是从语法角度来说你也可以这么使用<code>Optional</code>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aValue = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">Some</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> noValue = <span class="type">Optional</span>&lt;<span class="type">Int</span>&gt;.<span class="type">None</span></span><br><span class="line"><span class="keyword">if</span> noValue == <span class="type">Optional</span>.<span class="type">None</span> &#123; <span class="built_in">print</span>(<span class="string">"No value"</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>这是<code>Optional</code>最直接的用例，并未使用任何语法糖，但是不可否认<code>Swift</code>中语法糖的加入使得你的工作更简单。如果你观察上面的实例代码，你恐怕已经猜到<code>Optional</code>内部实现是这样的<a href="#c5"><sup>5<sup></sup></sup></a>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simplified implementation of Swift's Optional</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyOptional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有啥特别呢？注意枚举的关联值采用泛型参数<code>T</code>作为自身类型，这样可选类型构造任何你想要的返回值。</p>
<p>枚举可以拥有多个泛型参数。就拿熟知的<code>Either</code>类为例，它并非是<code>Swift</code>标准库中的一部分，而是实现于众多开源库以及<br>其他函数式编程语言，比如<strong>Haskell</strong>或<strong>F#</strong>。设计想法是这样的:相比较仅仅返回一个值或没有值(née Optional)，你更期望返回一个成功值或者一些反馈信息(比如错误值)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The well-known either type is, of course, an enum that allows you to return either</span></span><br><span class="line"><span class="comment">// value one (say, a successful value) or value two (say an error) from a function</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Either</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Left</span>(<span class="type">T1</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Right</span>(<span class="type">T2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，<code>Swift</code>中所有在<code>class</code>和<code>struct</code>中奏效的类型约束，在<code>enum</code>中同样适用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Totally nonsensical example. A bag that is either full (has an array with contents)</span></span><br><span class="line"><span class="comment">// or empty.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Bag</span>&lt;<span class="title">T</span>: <span class="title">SequenceType</span> <span class="title">where</span> <span class="title">T</span>.<span class="title">Generator</span>.<span class="title">Element</span>==<span class="title">Equatable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Full</span>(contents: <span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归_/_间接(Indirect)类型">递归 / 间接(Indirect)类型</h3><p>间接类型是 Swift 2.0 新增的一个类型。 它们允许将枚举中一个 case 的关联值再次定义为枚举。举个例子，假设我们想定义一个文件系统，用来表示文件以及包含文件的目录。如果将<em>文件</em>和<em>目录</em>定义为枚举的 case，则<em>目录</em> case 的关联值应该再包含一个<em>文件</em>的数组作为它的关联值。因为这是一个递归的操作，编译器需要对此进行一个特殊的准备。Swift 文档中是这么写的：</p>
<blockquote>
<p>枚举和 case 可以被标记为间接的(indrect)，这意味它们的关联值是被间接保存的，这允许我们定义递归的数据结构。</p>
</blockquote>
<p>所以，如果我们要定义 <code>FileNode</code> 的枚举，它应该会是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FileNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">File</span>(name: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Folder</span>(name: <span class="type">String</span>, files: [<span class="type">FileNode</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处的 <code>indrect</code> 关键字告诉编译器间接地处理这个枚举的 case。也可以对整个枚举类型使用这个关键字。<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="external">作为例子，我们来定义一个二叉树</a>:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">Tree</span>&lt;<span class="title">Element</span>: <span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">Tree</span>&lt;<span class="type">Element</span>&gt;,<span class="type">Element</span>,<span class="type">Tree</span>&lt;<span class="type">Element</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很强大的特性，可以让我们用非常简洁的方式来定义一个有着复杂关联的数据结构。</p>
<h3 id="使用自定义类型作为枚举的值">使用自定义类型作为枚举的值</h3><p>如果我们忽略关联值，则枚举的值就只能是整型，浮点型，字符串和布尔类型。如果想要支持别的类型，则可以通过实现 <code>StringLiteralConvertible</code> 协议来完成，这可以让我们通过对字符串的序列化和反序列化来使枚举支持自定义类型。</p>
<p>作为一个例子，假设我们要定义一个枚举来保存不同的 iOS 设备的屏幕尺寸：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: <span class="title">CGSize</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> iPhone3GS = <span class="type">CGSize</span>(width: <span class="number">320</span>, height: <span class="number">480</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone5 = <span class="type">CGSize</span>(width: <span class="number">320</span>, height: <span class="number">568</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone6 = <span class="type">CGSize</span>(width: <span class="number">375</span>, height: <span class="number">667</span>)</span><br><span class="line">   <span class="keyword">case</span> iPhone6Plus = <span class="type">CGSize</span>(width: <span class="number">414</span>, height: <span class="number">736</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这段代码不能通过编译。因为 CGPoint 并不是一个常量，不能用来定义枚举的值。我们需要为想要支持的自定义类型增加一个扩展，让其实现 <code>StringLiteralConvertible</code> 协议。这个协议要求我们实现三个<em>构造方法</em>，这三个方法都需要使用一个<code>String</code>类型的参数，并且我们需要将这个字符串转换成我们需要的类型(此处是<code>CGSize</code>)。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">StringLiteralConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(extendedGraphemeClusterLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(unicodeScalarLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> size = <span class="type">CGSizeFromString</span>(value)</span><br><span class="line">	<span class="keyword">self</span>.<span class="keyword">init</span>(width: size.width, height: size.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以来实现我们需要的枚举了，不过这里有一个缺点：初始化的值必须写成字符串形式，因为这就是我们定义的枚举需要接受的类型(记住，我们实现了 StringLiteralConvertible，因此<strong>String</strong>可以转化成<code>CGSize</code>类型)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: <span class="title">CGSize</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> iPhone3GS = <span class="string">"&#123;320, 480&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone5 = <span class="string">"&#123;320, 568&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone6 = <span class="string">"&#123;375, 667&#125;"</span></span><br><span class="line">   <span class="keyword">case</span> iPhone6Plus = <span class="string">"&#123;414, 736&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，我们可以使用 CGPoint 类型的枚举了。需要注意的是，当要获取真实的 CGPoint 的值的时候，我们需要访问枚举的是 <code>rawValue</code> 属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Devices</span>.iPhone5</span><br><span class="line"><span class="keyword">let</span> b = a.rawValue</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"the phone size string is <span class="subst">\(a)</span>, width is <span class="subst">\(b.width)</span>, height is <span class="subst">\(b.height)</span>"</span>)</span><br><span class="line"><span class="comment">// prints : the phone size string is iPhone5, width is 320.0, height is 568.0</span></span><br></pre></td></tr></table></figure>
<p>使用字符串序列化的形式，会让使用自定义类型的枚举比较困难，然而在某些特定的情况下，这也会给我们增加不少便利(比较使用<strong>NSColor</strong> / <strong>UIColor</strong>的时候)。不仅如此，我们完全可以对自己定义的类型使用这个方法。</p>
<h3 id="对枚举的关联值进行比较">对枚举的关联值进行比较</h3><p>在通常情况下，枚举是很容易进行相等性判断的。一个简单的 <code>enum T { case a, b }</code> 实现默认支持相等性判断 <code>T.a == T.b, T.b != T.a</code></p>
<p>然而，一旦我们为枚举增加了关联值，Swift 就没有办法正确地为两个枚举进行相等性判断，需要我们自己实现 <code>==</code> 运行符。这并不是很困难：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> ==<span class="params">(lhs: Trade, rhs: Trade)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Buy</span>(stock1, amount1), .<span class="type">Buy</span>(stock2, amount2))</span><br><span class="line">	   <span class="keyword">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     <span class="keyword">case</span> <span class="keyword">let</span> (.<span class="type">Sell</span>(stock1, amount1), .<span class="type">Sell</span>(stock2, amount2))</span><br><span class="line">	   <span class="keyword">where</span> stock1 == stock2 &amp;&amp; amount1 == amount2:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我们所见，我们通过 switch 语句对两个枚举的 case 进行判断，并且只有当它们的 case 是匹配的时候(比如 Buy 和 Buy)才对它们的真实关联值进行判断。</p>
<h3 id="自定义构造方法">自定义构造方法</h3><p>在 <strong>静态方法</strong> 一节当中我们已经提到它们可以作为从不同数据构造枚举的方便形式。在之前的例子里也展示过，对出版社经常误用的苹果设备名返回正确的名字：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fromSlang</span><span class="params">(term: String)</span></span> -&gt; <span class="type">Device</span>? &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以使用自定义构造方法来替换静态方法。枚举与结构体和类的构造方法最大的不同在于，枚举的构造方法需要将隐式的 <code>self</code>  属性设置为正确的 case。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Device</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="type">AppleWatch</span> </span><br><span class="line">    <span class="keyword">init</span>?(term: <span class="type">String</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> term == <span class="string">"iWatch"</span> &#123;</span><br><span class="line">	  <span class="keyword">self</span> = .<span class="type">AppleWatch</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们使用了可失败(failable)的构造方法。但是，普通的构造方法也可以工作得很好：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NumberCategory</span> </span>&#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="type">Small</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Medium</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Big</span></span><br><span class="line">   <span class="keyword">case</span> <span class="type">Huge</span></span><br><span class="line">   <span class="keyword">init</span>(number n: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">10000</span> &#123; <span class="keyword">self</span> = .<span class="type">Small</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">1000000</span> &#123; <span class="keyword">self</span> = .<span class="type">Medium</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> n &lt; <span class="number">100000000</span> &#123; <span class="keyword">self</span> = .<span class="type">Big</span> &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="keyword">self</span> = .<span class="type">Huge</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> aNumber = <span class="type">NumberCategory</span>(number: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(aNumber)</span><br><span class="line"><span class="comment">// prints: "Small"</span></span><br></pre></td></tr></table></figure>
<h3 id="对枚举的_case_进行迭代">对枚举的 case 进行迭代</h3><p>一个特别经常被问到的问题就是如何对枚举中的 case 进行迭代。可惜的是，枚举并没有遵守<code>SequenceType</code>协议，因此没有一个官方的做法来对其进行迭代。取决于枚举的类型，对其进行迭代可能也简单，也有可能很困难。在<a href="http://stackoverflow.com/questions/24007461/how-to-enumerate-an-enum-with-string-type" target="_blank" rel="external">StackOverflow</a>上有一个很好的讨论贴。贴子里面讨论到的不同情况太多了，如果只在这里摘取一些会有片面性，而如果将全部情况都列出来，则会太多。</p>
<h3 id="对_Objective-C_的支持">对 Objective-C 的支持</h3><p>基于整型的枚举，如 <code>enum Bit: Int { case Zero = 0; case One = 1 }</code> 可以通过 <code>@objc</code> 标识来将其桥接到 Objective-C 当中。然而，一旦使用整型之外的类型(如 <code>String</code>)或者开始使用<strong>关联值</strong>，我们就无法在 Objective-C 当中使用这些枚举了。</p>
<p>有一个名为<a href="http://nshint.io/blog/2015/10/07/easy-cast-with-_ObjectiveCBridgeable/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_11" target="_blank" rel="external">_ObjectiveCBridgeable的隐藏协议</a>，可以让规范我们以定义合适的方法，如此一来，Swift 便可以正确地将枚举转成 Objective-C 类型，但我猜这个协议被隐藏起来一定是有原因的。然而，从理论上来讲，这个协议还是允许我们将枚举(包括其实枚举值)正确地桥接到 Objective-C 当中。</p>
<p>但是，我们并不一定非要使用上面提到的这个方法。为枚举添加两个方法，使用 <code>@objc</code> 定义一个替代类型，如此一来我们便可以自由地将枚举进行转换了，并且这种方式不需要遵守私有协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Buy</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Sell</span>(stock: <span class="type">String</span>, amount: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个类型也可以定义在 Objective-C 的代码中</span></span><br><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">OTrade</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> stock: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(type: <span class="type">Int</span>, stock: <span class="type">String</span>, amount: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">self</span>.type = type</span><br><span class="line">	<span class="keyword">self</span>.stock = stock</span><br><span class="line">	<span class="keyword">self</span>.amount = amount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Trade</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">toObjc</span><span class="params">()</span></span> -&gt; <span class="type">OTrade</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Buy</span>(stock, amount):</span><br><span class="line">	    <span class="keyword">return</span> <span class="type">OTrade</span>(type: <span class="number">0</span>, stock: stock, amount: amount)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Sell</span>(stock, amount):</span><br><span class="line">	    <span class="keyword">return</span> <span class="type">OTrade</span>(type: <span class="number">1</span>, stock: stock, amount: amount)</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">fromObjc</span><span class="params">(source: OTrade)</span></span> -&gt; <span class="type">Trade</span>? &#123;</span><br><span class="line">	<span class="keyword">switch</span> (source.type) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="type">Trade</span>.<span class="type">Buy</span>(stock: source.stock, amount: source.amount)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="type">Trade</span>.<span class="type">Sell</span>(stock: source.stock, amount: source.amount)</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有一个的缺点，我们需要将枚举映射为 Objective-C 中的 <code>NSObject</code> 基础类型(我们也可以直接使用 <code>NSDictionary</code>)，但是，当我们碰到一些确实<strong>需要</strong>在 Objective-C 当中获取有关联值的枚举时，这是一个可以使用的方法。</p>
<h3 id="枚举底层">枚举底层</h3><p>Erica Sadun 写过一篇很流弊的<a href="http://ericasadun.com/2015/07/12/swift-enumerations-or-how-to-annoy-tom/" target="_blank" rel="external">关于枚举底层的博客</a>，涉及到枚举底层的方方面面。在生产代码中绝不应该使用到这些东西，但是学习一下还是相当有趣的。在这里，我准备只提到那篇博客中一条，如果想了解更多，请移步到原文：</p>
<blockquote>
<p>枚举通常都是一个字节长度。[…]如果你真的很傻很天真，你当然可以定义一个有成百上千个 case 的枚举，在这种情况下，取决于最少所需要的比特数，枚举可能占据两个字节或者更多。</p>
</blockquote>
<h2 id="Swift_标准库中的枚举">Swift 标准库中的枚举</h2><p>在我们准备继续探索枚举在项目中的不同用例之前，先看一下在 Swift 标准库当中是如何使用枚举可能会更诱人，所以现在让我们先来看看。</p>
<ul>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Bit_Enumeration/index.html#//apple_ref/swift/enum/s:OSs3Bit" target="_blank" rel="external">Bit</a> 这个枚举有两个值，<strong>One</strong> 和 <strong>Zero</strong>。它被作为 <code>CollectionOfOne&lt;T&gt;</code> 中的 <code>Index</code> 类型。</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_FloatingPointClassification_Enumeration/index.html#//apple_ref/swift/enumelt/FloatingPointClassification/s:FOSs27FloatingPointClassification12SignalingNaNFMS_S_" target="_blank" rel="external">FloatingPointClassification</a> 这个枚举定义了一系列 IEEE 754 可能的类别，比如 <code>NegativeInfinity</code>, <code>PositiveZero</code> 或 <code>SignalingNaN</code>。</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-AncestorRepresentation_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror22AncestorRepresentation" target="_blank" rel="external">Mirror.AncestorRepresentation</a> 和 <a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Mirror-DisplayStyle_Enumeration/index.html#//apple_ref/swift/enum/s:OVSs6Mirror12DisplayStyle" target="_blank" rel="external">Mirror.DisplayStyle</a> 这两个枚举被用在 Swift 反射 API 的上下文当中。</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Optional_Enumeration/index.html#//apple_ref/swift/enum/s:Sq" target="_blank" rel="external">Optional</a> 这个就不用多说了</li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Swift/Reference/Swift_Process_Enumeration/index.html#//apple_ref/swift/enum/s:OSs7Process" target="_blank" rel="external">Process</a> 这个枚举包含了当前进程的命令行参数(<code>Process.argc</code>, <code>Process.arguments</code>)。这是一个相当有趣的枚举类型，因为在 Swift 1.0 当中，它是被作为一个结构体来实现的。</li>
</ul>
<h2 id="实践用例">实践用例</h2><p>我们已经在前面几个小节当中看过了许多有用的枚举类型。包括 <code>Optional</code>，<code>Either</code>, <code>FileNode</code> 还有二叉树。然而，还存在很多场合，使用枚举要胜过使用结构体和类。一般来讲，如果问题可以被分解为有限的不同类别，则使用枚举应该就是正确的选择。即使只有两种 case，这也是一个使用枚举的完美场景，正如 Optional 和 Either 类型所展示的。</p>
<p>以下列举了一些枚举类型在实战中的使用示例，可以用来点燃你的创造力。</p>
<h3 id="错误处理">错误处理</h3><p>说到枚举的实践使用，当然少不了在 Swift 2.0 当中新推出的错误处理。标记为可抛出的函数可以抛出任何遵守了 <code>ErrorType</code> 空协议的类型。正如 Swift 官方文档中所写的：</p>
<blockquote>
<p>Swift 的枚举特别适用于构建一组相关的错误状态，可以通过关联值来为其增加额外的附加信息。</p>
</blockquote>
<p>作为一个示例，我们来看下流行的<a href="https://github.com/thoughtbot/Argo" target="_blank" rel="external">JSON解析框架 Argo</a>。当 JSON 解析失败的时候，它有可能是以下两种主要原因：</p>
<ol>
<li>JSON 数据缺少某些最终模型所需要的键(比如你的模型有一个 <code>username</code> 的属性，但是 JSON 中缺少了)</li>
<li>存在类型不匹配，比如说 <code>username</code> 需要的是 String 类型，而 JSON 中包含的是 <code>NSNull</code><a href="#c6"><sup>6</sup></a>。</li>
</ol>
<p>除此之外，Argo 还为不包含在上述两个类别中的错误提供了自定义错误。它们的 <code>ErrorType</code> 枚举是类似这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DecodeError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TypeMismatch</span>(expected: <span class="type">String</span>, actual: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MissingKey</span>(<span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Custom</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 case 都有一个关联值用来包含关于错误的附加信息。</p>
<p>一个更加通用的用于完整 HTTP / REST API 错误处理的<code>ErrorType</code>应该是类似这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">APIError</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Can't connect to the server (maybe offline?)</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ConnectionError</span>(error: <span class="type">NSError</span>)</span><br><span class="line">    <span class="comment">// The server responded with a non 200 status code</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ServerError</span>(statusCode: <span class="type">Int</span>, error: <span class="type">NSError</span>)</span><br><span class="line">    <span class="comment">// We got no data (0 bytes) back from the server</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoDataError</span></span><br><span class="line">    <span class="comment">// The server response can't be converted from JSON to a Dictionary</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONSerializationError</span>(error: <span class="type">ErrorType</span>)</span><br><span class="line">    <span class="comment">// The Argo decoding Failed</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONMappingError</span>(converstionError: <span class="type">DecodeError</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>ErrorType</code> 实现了完整的 REST 程序栈解析有可能出现的错误，包含了所有在解析结构体与类时会出现的错误。</p>
<p>如果你看得够仔细，会发现在<code>JSONMappingError</code>中，我们将<strong>Argo</strong>中的<code>DecodeError</code>封装到了我们的<code>APIError</code>类型当中，因为我们会用 Argo 来作实际的 JSON 解析。</p>
<p>更多关于<code>ErrorType</code>以及此种枚举类型的示例可以参看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="观察者模式">观察者模式</h3><p>在 Swift 当中，有许多方法来构建观察模式。如果使用 <code>@objc</code> 兼容标记，则我们可以使用 <code>NSNotificationCenter</code> 或者 <strong>KVO</strong>。即使不用这个标记，<code>didSet</code>语法也可以很容易地实现简单的观察模式。在这里可以使用枚举，它可以使被观察者的变化更加清晰明了。设想我们要对一个集合进行观察。如果我们稍微思考一下就会发现这只有几种可能的情况：一个或多个项被插入，一个或多个项被删除，一个或多个项被更新。这听起来就是枚举可以完成的工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Insertion</span>(items: [<span class="type">Item</span>])</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Deletion</span>(items: [<span class="type">Item</span>])</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Update</span>(items: [<span class="type">Item</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后，观察对象就可以使用一个很简洁的方式来获取已经发生的事情的详细信息。这也可以通过为其增加 <strong>oldValue</strong> 和 <strong>newValue</strong> 的简单方法来扩展它的功能。</p>
<h3 id="状态码">状态码</h3><p>如果我们正在使用一个外部系统，而这个系统使用了状态码(或者错误码)来传递错误信息，类似 HTTP 状态码，这种情况下枚举就是一种很明显并且很好的方式来对信息进行封装<a href="#c7"><sup>7</sup></a> 。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HttpError</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code400</span> = <span class="string">"Bad Request"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code401</span> = <span class="string">"Unauthorized"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code402</span> = <span class="string">"Payment Required"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code403</span> = <span class="string">"Forbidden"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Code404</span> = <span class="string">"Not Found"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果类型映射(Map_Result_Types)">结果类型映射(Map Result Types)</h3><p>枚举也经常被用于将 JSON 解析后的结果映射成 Swift 的原生类型。这里有一个简短的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONString</span>(<span class="type">Swift</span>.<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONNumber</span>(<span class="type">Double</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONObject</span>([<span class="type">String</span> : <span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONArray</span>([<span class="type">JSONValue</span>])</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONBool</span>(<span class="type">Bool</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JSONNull</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，如果我们解析了其它的东西，也可以使用这种方式将解析结果转化我们 Swift 的类型。</p>
<h3 id="UIKit_标识">UIKit 标识</h3><p>枚举可以用来将字符串类型的重用标识或者 storyboard 标识映射为类型系统可以进行检查的类型。假设我们有一个拥有很多原型 Cell 的 UITableView：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CellType</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ButtonValueCell</span> = <span class="string">"ButtonValueCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">UnitEditCell</span> = <span class="string">"UnitEditCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LabelCell</span> = <span class="string">"LabelCell"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">ResultLabelCell</span> = <span class="string">"ResultLabelCell"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单位">单位</h3><p>单位以及单位转换是另一个使用枚举的绝佳场合。可以将单位及其对应的转换率映射起来，然后添加方法来对单位进行自动的转换。以下是一个相当简单的示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Liquid</span>: <span class="title">Float</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> ml = <span class="number">1.0</span></span><br><span class="line">  <span class="keyword">case</span> l = <span class="number">1000.0</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(amount amount: Float, to: Liquid)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">self</span>.rawValue &lt; to.rawValue &#123;</span><br><span class="line">	 <span class="keyword">return</span> (<span class="keyword">self</span>.rawValue / to.rawValue) * amount</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	 <span class="keyword">return</span> (<span class="keyword">self</span>.rawValue * to.rawValue) * amount</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Convert liters to milliliters</span></span><br><span class="line"><span class="built_in">print</span> (<span class="type">Liquid</span>.l.convert(amount: <span class="number">5</span>, to: <span class="type">Liquid</span>.ml))</span><br></pre></td></tr></table></figure>
<p>另一个示例是货币的转换。以及数学符号(比如角度与弧度)也可以从中受益。</p>
<h3 id="游戏">游戏</h3><p>游戏也是枚举中的另一个相当好的用例，屏幕上的大多数实体都属于一个特定种族的类型(敌人，障碍，纹理，…)。相对于本地的 iOS 或者 Mac 应用，游戏更像是一个白板。即开发游戏我们可以使用全新的对象以及全新的关联创造一个全新的世界，而 iOS 或者 OSX 需要使用预定义的 UIButtons，UITableViews，UITableViewCells 或者 NSStackView.</p>
<p>不仅如此，由于枚举可以遵守协议，我们可以利用协议扩展和基于协议的编程为不同为游戏定义的枚举增加功能。这里是一个用来展示这种层级的的简短示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">FlyingBeast</span> </span>&#123; <span class="keyword">case</span> <span class="type">Dragon</span>, <span class="type">Hippogriff</span>, <span class="type">Gargoyle</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Horde</span> </span>&#123; <span class="keyword">case</span> <span class="type">Ork</span>, <span class="type">Troll</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Player</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mage</span>, <span class="type">Warrior</span>, <span class="type">Barbarian</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">NPC</span> </span>&#123; <span class="keyword">case</span> <span class="type">Vendor</span>, <span class="type">Blacksmith</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Element</span> </span>&#123; <span class="keyword">case</span> <span class="type">Tree</span>, <span class="type">Fence</span>, <span class="type">Stone</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Hurtable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Killable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flying</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Obstacle</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FlyingBeast</span>: <span class="title">Hurtable</span>, <span class="title">Killable</span>, <span class="title">Flying</span>, <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Horde</span>: <span class="title">Hurtable</span>, <span class="title">Killable</span>, <span class="title">Attacking</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Player</span>: <span class="title">Hurtable</span>, <span class="title">Obstacle</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NPC</span>: <span class="title">Hurtable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Element</span>: <span class="title">Obstacle</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串类型化">字符串类型化</h3><p>在一个稍微大一点的 Xcode 项目中，我们很快就会有一大堆通过字符串来访问的资源。在前面的小节中，我们已经提过重用标识和 storyboard 的标识，但是除了这两样，还存在很多资源：图像，Segues，Nibs，字体以及其它资源。通常情况下，这些资源都可以分成不同的集合。如果是这样的话，一个类型化的字符串会是一个让编译器帮我们进行类型检查的好方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DetailViewImages</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Background</span> = <span class="string">"bg1.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sidebar</span> = <span class="string">"sbg.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ActionButton1</span> = <span class="string">"btn1_1.png"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ActionButton2</span> = <span class="string">"btn2_1.png"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 iOS 开发者，<a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="external">R.swift</a>这个第三方库可以为以上提到的情况自动生成结构体。但是有些时候你可能需要有更多的控制(或者你可能是一个Mac开发者<a href="#c8"><sup>8</sup></a>)。</p>
<h3 id="API_端点">API 端点</h3><p>Rest API 是枚举的绝佳用例。它们都是分组的，它们都是有限的 API 集合，并且它们也可能会有附加的查询或者命名的参数，而这可以使用关联值来实现。</p>
<p>这里有个 <a href="https://instagram.com/developer/endpoints/media/" target="_blank" rel="external">Instagram API</a> 的简化版：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Instagram</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Media</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Popular</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Shortcode</span>(id: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Search</span>(lat: <span class="type">Float</span>, min_timestamp: <span class="type">Int</span>, lng: <span class="type">Float</span>, max_timestamp: <span class="type">Int</span>, <span class="built_in">distance</span>: <span class="type">Int</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">User</span>(id: <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Feed</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Recent</span>(id: <span class="type">String</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/Moya/Moya" target="_blank" rel="external">Ash Furrow的<strong>Moya</strong>框架</a>就是基本这个思想，使用枚举对 rest 端点进行映射。</p>
<h3 id="链表">链表</h3><p>Airspeed Velocity有一篇<a href="http://airspeedvelocity.net/tag/swift/" target="_blank" rel="external">极好的文章</a>说明了如何使用枚举来实现一个链表。那篇文章中的大多数代码都超出了枚举的知识，并涉及到了大量其它有趣的主题<a href="#c9"><sup>9</sup></a>，但是，链表最基本的定义是类似这样的(我对其进行了一些简化)：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">End</span></span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Node</span>(<span class="type">Int</span>, next: <span class="type">List</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个节点(Node) case 都指向了下一个 case， 通过使用枚举而非其它类型，我们可以避免使用一个可选的 next 类型以用来表示链表的结束。</p>
<p>Airspeed Velocity 还写过一篇超赞的博客，关于如何使用 Swift 的间接枚举类型来实现红黑树，所以如果你已经阅读过关于链表的博客，你可能想继续阅读<a href="http://airspeedvelocity.net/2015/07/22/a-persistent-tree-using-indirect-enums-in-swift/" target="_blank" rel="external">这篇关于红黑树的博客</a>。</p>
<h3 id="设置字典(Setting_Dictionaries)">设置字典(Setting Dictionaries)</h3><p>这是 Erica Sadun 提出的<a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="external">非常非常机智的解决方案</a>。简单来讲，就是任何我们需要用一个属性的字典来对一个项进行设置的时候，都应该使用一系列有关联值的枚举来替代。使用这方法，类型检查系统可以确保配置的值都是正确的类型。</p>
<p><a href="http://ericasadun.com/2015/10/19/sets-vs-dictionaries-smackdown-in-swiftlang/?utm_campaign=Swift%252BSandbox&amp;utm_medium=email&amp;utm_source=Swift_Sandbox_12" target="_blank" rel="external">关于更多的细节，以及合适的例子，可以阅读下她的文章</a>。</p>
<h2 id="局限">局限</h2><p>与之前类似，我将会用一系列枚举的局限性来结束本篇文章。</p>
<h3 id="提取关联值">提取关联值</h3><p>David Owens写过一篇<a href="http://owensd.io/2015/09/15/associated-enum-cases-as-types.html" target="_blank" rel="external">文章</a>，他觉得当前的关联值提取方式是很笨重的。我墙裂推荐你去看一下他的原文，在这里我对它的要旨进行下说明：为了从一个枚举中获取关联值，我们必须使用模式匹配。然而，关联值就是关联在特定枚举 case 的高效元组。而元组是可以使用更简单的方式来获取它内部值，即 <code>.keyword 或者 .0</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enums</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ex</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mode</span>(ab: <span class="type">Int</span>, cd: <span class="type">Int</span>) &#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="type">Ex</span>.<span class="type">Mode</span>(<span class="keyword">let</span> ab, <span class="keyword">let</span> cd) = <span class="type">Ex</span>.<span class="type">Mode</span>(ab: <span class="number">4</span>, cd: <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(ab)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// vs tuples:</span></span><br><span class="line"><span class="keyword">let</span> tp = (ab: <span class="number">4</span>, cd: <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(tp.ab)</span><br></pre></td></tr></table></figure>
<p>如果你也同样觉得我们应该使用相同的方法来对枚举进行解构(deconstruct)，这里有个 rdar: <a href="http://openradar.me/22704262" target="_blank" rel="external">rdar://22704262</a> (译者注：一开始我不明白 rdar 是啥意思，后来我 google 了下，如果你也有兴趣，也可以自己去搜索一下)</p>
<h3 id="相等性">相等性</h3><p>拥有关联值的枚举没有遵守 <code>equatable</code> 协议。这是一个遗憾，因为它为很多事情增加了不必要的复杂和麻烦。深层的原因可能是因为关联值的底层使用是使用了元组，而元组并没有遵守 <code>equatable</code> 协议。然而，对于限定的 case 子集，如果这些关联值的类型都遵守了 <code>equatable</code> 类型，我认为编译器应该默认为其生成 <code>equatable</code> 扩展。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Int 和 String 是可判等的, 所以 Mode 应该也是可判等的</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Ex</span> </span>&#123; <span class="keyword">case</span> <span class="type">Mode</span>(ab: <span class="type">Int</span>, cd: <span class="type">String</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 应该能够自动生成这个函数</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> == <span class="params">(lhs: Ex.Mode, rhs: Ex.Mode)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (lhs, rhs) &#123;</span><br><span class="line">       <span class="keyword">case</span> (.<span class="type">Mode</span>(<span class="keyword">let</span> a, <span class="keyword">let</span> b), .<span class="type">Mode</span>(<span class="keyword">let</span> <span class="built_in">c</span>, <span class="keyword">let</span> d)):</span><br><span class="line">	   <span class="keyword">return</span> a == <span class="built_in">c</span> &amp;&amp; b == d</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">	   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元组(Tuples)">元组(Tuples)</h3><p>最大的问题就是对<a href="http://appventure.me/2015/07/19/tuples-swift-advanced-usage-best-practices/" target="_blank" rel="external">元组的支持</a>。我喜欢使用元组，它们可以使很多事情变得更简单，但是他们目前还处于无文档状态并且在很多场合都无法使用。在枚举当中，我们无法使用元组作为枚举的值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Devices</span>: (<span class="title">intro</span>: <span class="title">Int</span>, <span class="title">name</span>: <span class="title">String</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> iPhone = (intro: <span class="number">2007</span>, name: <span class="string">"iPhone"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AppleTV</span> = (intro: <span class="number">2006</span>, name: <span class="string">"Apple TV"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">AppleWatch</span> = (intro: <span class="number">2014</span>, name: <span class="string">"Apple Watch"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这似乎看起来并不是一个最好的示例，但是我们一旦开始使用枚举，就会经常陷入到需要用到类似上面这个示例的情形中。</p>
<h3 id="迭代枚举的所有case">迭代枚举的所有case</h3><p>这个我们已经在前面讨论过了。目前还没有一个很好的方法来获得枚举中的所有 case 的集合以使我们可以对其进行迭代。</p>
<h3 id="默认关联值">默认关联值</h3><p>另一个会碰到的事是枚举的关联值总是类型，但是我们却无法为这些类型指定默认值。假设有这样一种情况:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Characters</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Mage</span>(health: <span class="type">Int</span> = <span class="number">70</span>, magic: <span class="type">Int</span> = <span class="number">100</span>, strength: <span class="type">Int</span> = <span class="number">30</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Warrior</span>(health: <span class="type">Int</span> = <span class="number">100</span>, magic: <span class="type">Int</span> = <span class="number">0</span>, strength: <span class="type">Int</span> = <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Neophyte</span>(health: <span class="type">Int</span> = <span class="number">50</span>, magic: <span class="type">Int</span> = <span class="number">20</span>, strength: <span class="type">Int</span> = <span class="number">80</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然可以使用不同的值创建新的 case，但是角色的默认设置依然会被映射。</p>
<h2 id="变化">变化</h2><h3 id="10/26/2015">10/26/2015</h3><ul>
<li>增加局限性示例(相等性 &amp; 获取关联值)</li>
<li>增加 Erica Sadun 的关联枚举示例</li>
</ul>
<h3 id="10/22/2015">10/22/2015</h3><ul>
<li>合并<a href="https://github.com/terhechte/appventure-blog/pull/6" target="_blank" rel="external">来自 #6 @mabidakun</a>的PR</li>
<li>增加枚举底层的链接</li>
<li>将帐号示例拆分为两个更容易理解的片段。</li>
</ul>
<h3 id="10/21/2015">10/21/2015</h3><ul>
<li>合并<a href="https://github.com/terhechte/appventure-blog/pull/4" target="_blank" rel="external">来自 #4 @blixt</a>和<a href="https://github.com/terhechte/appventure-blog/pull/2" target="_blank" rel="external">#2 @kandelvijayavolare</a>和<a href="https://github.com/terhechte/appventure-blog/pull/3" target="_blank" rel="external">#3 @sriniram</a>以及<a href="https://github.com/terhechte/appventure-blog/pull/5" target="_blank" rel="external">#5 @SixFiveSoftware</a>的PR</li>
<li>为帐号示例添加调用代码</li>
<li>增加 <code>ErrorType</code> 示例</li>
</ul>
<h2 id="解释">解释</h2><p><a name="c1"></a></p>
<ul>
<li><p>1、可以使用一些小技术来达到这个目的，具体的请参照下面的文章内容<br><a name="c2"></a></p>
</li>
<li><p>2、为了演示的缘故，这个示例的实现经过的简化。在真实的开发中，应该使用可选类型以及反向顺序的参数。可以参考一下现在十分流行的函数式编程库，如 <a href="https://github.com/typelift/Swiftz" target="_blank" rel="external">Swiftz</a> 和 <a href="https://github.com/ankurp/Dollar.swift" target="_blank" rel="external">Dollar</a><br><a name="c3"></a></p>
</li>
<li><p>3、这个示例直接采用了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" target="_blank" rel="external">Swift 官方文档的示例</a><br><a name="c4"></a></p>
</li>
<li><p>4、经常使得他们定义的位置很难被发现<br><a name="c5"></a></p>
</li>
<li><p>5、这是一个简化版的，当然，Swift 为我们加了很多的语法糖<br><a name="c6"></a></p>
</li>
<li><p>6、如果你在应用中使用过 JSON，应该也曾经碰到过这个问题<br><a name="c6"></a></p>
</li>
<li><p>7、顺便一提，不能直接使用数字做为枚举 case 的名称，因此直接使用 400 是不行的<br><a name="c8"></a></p>
</li>
<li><p>8、虽然如此，不过支持 Mac 版的 R.swift 好像就快推出了<br><a name="c9"></a></p>
</li>
<li><p>9、这句话可以解释为: 打开链接，并开始阅读文章</p>
</li>
</ul>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/10/17/advanced-practical-enum-examples/">原文链接</a>，原文日期：2015-10-17<br>译者：<a href="http://www.jianshu.com/users/3b40e55ec6d5/latest_articles">小锅</a>，<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="http://codebuild.me/">shanks</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>译者注：作为一个走心且有逼格的翻译组，我们对本篇文章中的代码都进行了验证，并且写了将代码分为上下两篇做成了 playground，代码中有详尽的注释。可以到<a href="https://github.com/colourful987/Topic_Demo/tree/master/Advanced%20%26%20Practical%20Enum%20usage%20in%20Swift">这个github地址上进行下载</a>，这个代码由翻译组的另一位小伙伴 <a href="http://blog.csdn.net/colouful987">ppt</a> 提供。</p>
</blockquote>
<p>本文是一篇详细且具有实战意义的教程，涵盖几乎所有枚举(<code>Enum</code>)知识点，为你解答<code>Swift</code>中枚举的应用场合以及使用方法。</p>]]>
    
    </summary>
    
      <category term="APPVENTURE" scheme="http://swiftggteam.github.io/tags/APPVENTURE/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3D Touch介绍：电子秤App与快捷操作]]></title>
    <link href="http://swiftggteam.github.io/2015/11/19/3d-touch-tutorial/"/>
    <id>http://swiftggteam.github.io/2015/11/19/3d-touch-tutorial/</id>
    <published>2015-11-19T02:31:00.000Z</published>
    <updated>2015-12-10T01:00:18.920Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Maxime Defauw，<a href="http://www.appcoda.com/3d-touch-tutorial/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/09<br>译者：<a href="http://www.brighttj.com" target="_blank" rel="external">saitjr</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>随着 iPhone6s 与 6s plus 的到来，苹果给我们展现了一种全新的交互方式：重按手势。你可能知道，这个特性已经在 Apple Watch 和 MacBook 上推出了，不过那时叫 Force Touch，就是字面上的意思，给用户的交互添加一种新的维度。</p>
<p>如果你很好奇 iPhone 的 Force Touch 为啥要更名为 3D Touch，那告诉你吧，you’re not alone（译者注：请用 MJ 的调子唱出来…）。不久前，之前也对这名字纠结不已的 Craig Federighi（译者注：Apple 高级副总裁）介绍了这个新特性，第一条微博就这样产生了。也不知道 Force Touch 这名字有啥不好的，就因为有太多星球大战的梗？（译者注：其实我不知道这梗…）（校对注：译者是个妹子）（定稿注：还是单身）</p>
<a id="more"></a>
<p>但是，Force Touch 和 3d Touch 确实不一样！Force Touch 只能识别重按。这方面 3D Touch 要灵敏多了，它能够识别按压的力度。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3dtouch-intro.jpg" alt=""></p>
<p>虽然说，这点不同看起来无足轻重，但是这使开发者能开发更多精确计量方面的 App。比如这一款名为<a href="https://medium.com/swlh/turning-the-iphone-6s-into-a-digital-scale-f2197dc2b6e7" target="_blank" rel="external">Gravity</a>的应用，它利用 Force Touch 让你的 iPhone 成为了一个电子秤。虽然这款 App 被 Apple 拒了，但是这创意简直太棒了。为了展示 3D Touch 的工作流程，我们来做一个简单的 App。</p>
<p>先去下载这个<a href="https://www.dropbox.com/s/i3xwostpd87rqci/ScaleStarter.zip?dl=0" target="_blank" rel="external">初始案例</a>。初始案例中只有一个空的 Single View。我在里面创建了 App 必要的 UI 元素（<code>UILabel</code>和<code>UIImage</code>），并关联了<code>ViewController.swift</code>。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3dtouch-storyboard.png" alt=""></p>
<p>这个 App 的设计很简单：ViewController 上有两个 Label：一个标题和一个显示按压百分比的文本。</p>
<p>那…开始写代码吧！在 iPhone6s 和 6s Plus 上，<code>UITouch</code>对象多了两个<code>CGFloat</code>类型的属性，分别是<code>force</code>和<code>maximumPossibleForce</code>。<code>force</code>表示按得有多重，<code>1.0</code>表示常规状态的值。<code>maximumPossibleForce</code>表示能承受的最大压力值。</p>
<p>无论什么情况，当用户触摸屏幕时，<code>touchesBegan</code>方法会被调用，接着就是<code>touchesMoved</code>（如果用户手指在屏幕上滑动，那么<code>touchedCancelled</code>与<code>TouchesEnded</code>也会被调用）。在这个App中，我们只需要关注<code>touchesMoved</code>方法。<code>touchesMoved</code>有两个参数：<code>touches</code>和<code>event</code>。<code>touches</code>是一个装着<code>UITouch</code>对象的<code>NSSet</code>类型集合（集合无序，并且无重复）。我们必须要确保在<code>touches</code>中只有一个<code>UITouch</code>对象，但也有考虑不完全的时候，所以强烈建议大家先利用可选绑定来判断<code>touches.first</code>（<code>touches</code>中的第一个<code>UITouch</code>对象）是否是空。在<code>ViewController.swift</code>中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</span><br><span class="line">            <span class="keyword">if</span> traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">                <span class="comment">// 3D Touch capable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个<code>if</code>判断中，还需要添加判断当前设备是否支持 3D Touch 的代码。如果你只是做来玩，那就没必要验证。但是，如果是要上架的 App，那就必须要判断，毕竟像 iPhone6 这些旧设备不支持 3D Touch。</p>
<p>除此之外，我还使用了<code>#available</code>语句（Swift 2.0）对当前系统是否是 iOS9+ 做了判断。（如果你想学习更多 Swift 2.0 相关的知识，我就更加推荐你阅读这篇文章了。）同样，如果你的编译环境是 iOS9.0+，那么这个判断可以省略。</p>
<p>要得到按压百分比？那太简单了，只需要用<code>force</code>属性除以<code>maximumPossibleForce</code>就可以了（例如：<code>touch.maximumPossibleForce</code>），<code>maximumPossibleForce</code>表示能承受的最大压力值。然后，更新文本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</span><br><span class="line">            <span class="keyword">if</span> traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">                <span class="comment">// 3D Touch capable</span></span><br><span class="line">                <span class="keyword">let</span> force = touch.force/touch.maximumPossibleForce</span><br><span class="line">                forceLabel.text = <span class="string">"<span class="subst">\(force)</span>% force"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你在 iPhone6s/6s Plus 上跑这个程序，按屏幕时就能看到压力百分比了。但是，其实我们更想知道放在 iPhone 上物体的重量，而不是百分比。根据<a href="https://medium.com/swlh/turning-the-iphone-6s-into-a-digital-scale-f2197dc2b6e7" target="_blank" rel="external">Ryan McLeod</a>的 App 可以知道，传感器的计量范围的最大值是 385g。因此，<code>maximumPossibleForce</code>就相当于 385g（相当于3.8N）。通过简单的计算，就可以把压力百分比转为克。需要做的仅仅是用百分比*385。对于重于 385g 的物体，就把  label 改成类似于“385+ grams”这样的文本好了。</p>
<p>到此，<code>touchesMoved</code>方法中的代码更新为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesMoved</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> touch = touches.first &#123;</span><br><span class="line">        <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, *) &#123;</span><br><span class="line">            <span class="keyword">if</span> traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> touch.force &gt;= touch.maximumPossibleForce &#123;</span><br><span class="line">                    forceLabel.text = <span class="string">"385+ grams"</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> force = touch.force/touch.maximumPossibleForce</span><br><span class="line">                    <span class="keyword">let</span> grams = force * <span class="number">385</span></span><br><span class="line">                    <span class="keyword">let</span> roundGrams = <span class="type">Int</span>(grams)</span><br><span class="line">                    forceLabel.text = <span class="string">"<span class="subst">\(roundGrams)</span> grams"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后…你就有了一个电子秤 App…</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-scale-app-492x1024.png" alt=""></p>
<p>还有一个小问题：当物体或者触摸事件结束之后，文本没有重置。你可以实现<code>touchesEnded</code>方法来达到效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    forceLabel.text = <span class="string">"0 gram"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主屏幕上的快捷操作">主屏幕上的快捷操作</h2><p>另一个 3D Touch 的用法是主屏幕上的快捷操作。快捷操作可以让用户从快捷方式直接跳转到 App 的某个地方。按压 App icon 快捷方式就会出现。在介绍 3D Touch 的时候，Twitter、Instagram 等 App 就展示了这个新特性。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-quick-action.png" alt=""></p>
<p>让我们来给刚才的电子秤 App 添加一个快捷操作吧（把白色背景换成蓝色）。要添加快捷操作，先打开工程目录中的<code>info.plist</code>（在导航栏上点击工程名，在<code>TARTGET</code>中找到<code>info</code>选项卡）。在这个文件中，添加<code>UIApplicationShortcutItems</code>数组。数组中的元素是包含一个快捷操作配置的字典：</p>
<ul>
<li><code>UIApplicationShortcutItemType</code>(必填)：快捷操作的<strong>唯一</strong>标识符（String 类型）。建议将 bundle ID 或者其他唯一字符串作为标识符前缀。</li>
<li><code>UIApplicationShortcutItemTitle</code>（必填）：相当于快捷操作的 title（String 类型），用户可以看到。例如“显示最近一张照片”之类的文本。</li>
<li><code>UIApplicationShortcutItemSubtitle</code>（可选）：快捷操作的副标题（String 类型）。例如“昨天拍摄的照片”。如果你想要给快捷操作添加一个 icon，可以自定义，也可以使用系统自带的。</li>
<li><code>UIApplicationShortcutItemIconType</code>（可选）：表示你要选择哪种系统图标作为快捷操作的 icon（String 类型）。</li>
<li><code>UIApplicationShortcutItemIconFile</code>（可选）：表示给快捷操作添加自定义 icon（String 类型）。</li>
<li><code>UIApplicationShortcutItemUserInfo</code>（可选）：在快捷操作交互时传递的额外信息（译者注：类似于通知的 UserInfo 参数）（Dictionary 类型）。</li>
</ul>
<p>在这个数组中，我们将会给自定义的快捷操作添加 4 个配置。然后，你的<code>info.plist</code>文件看起来应该是这样滴：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-infoplist-600x102.png" alt=""></p>
<blockquote>
  <figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&gt;   注意，我用到了<span class="escape">`$</span>(PRODUCT_BUNDLE_IDENTIFIER)<span class="escape">`来</span>代替<span class="escape">`c</span>om.appcoda.Scale<span class="escape">`（</span>就是替代的 bundle ID）。这是出于安全考虑：无论在什么情况下，如果我在<span class="escape">`G</span>eneral<span class="escape">`中</span>修改了 bundle ID，那整个工程的 bundle ID 就都变了，这势必会给项目带来不晓得影响。这样的话，我就需要手动去修改每个 bundle ID。在<span class="escape">`i</span>nfo.plist<span class="escape">`里</span>面可以看到，其实每个 Bundle Identifier 配置项都是用的<span class="escape">`$</span>(PRODUCT_BUNDLE_IDENTIFIER)<span class="escape">`来</span>表示 bundle ID 在工程中的路径。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后一件事，就是实现用户触发快捷操作的处理流程。快捷方式需要在<code>AppDelegate.swift</code>的<code>performActionForShortcutItem</code>方法中处理。当使用快捷操作启动时，这个方法会被调用。所以，实现这个方法，并在方法中处理快捷操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle quick actions</span></span><br><span class="line">    completionHandler(handleQuickAction(shortcutItem))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法需要调用<code>completionHandler</code>，并传入布尔值，这个布尔值取决于快捷操作成功与否。这里我们封装了一个<code>handleQuickAction</code>方法来处理快捷方式。如果有多个快捷操作，最好的方式是使用枚举，<code>UIApplicationShortcutItemType</code>作为枚举的<code>rawValue</code>（译者注：对枚举不熟悉可以参考<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/08_Enumerations.html" target="_blank" rel="external">这篇文章</a>）。定义一个枚举，并实现<code>handleQuickAction</code>方法，在方法中修改背景色为蓝色。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Shortcut</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> openBlue = <span class="string">"OpenBlue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">handleQuickAction</span><span class="params">(shortcutItem: UIApplicationShortcutItem)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> quickActionHandled = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> type = shortcutItem.type.componentsSeparatedByString(<span class="string">"."</span>).last!</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> shortcutType = <span class="type">Shortcut</span>.<span class="keyword">init</span>(rawValue: type) &#123;</span><br><span class="line">        <span class="keyword">switch</span> shortcutType &#123;</span><br><span class="line">        <span class="keyword">case</span> .openBlue:</span><br><span class="line">            <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">151.0</span>/<span class="number">255.0</span>, green: <span class="number">187.0</span>/<span class="number">255.0</span>, blue: <span class="number">255.0</span>/<span class="number">255.0</span>, alpha: <span class="number">1.0</span>)</span><br><span class="line">            quickActionHandled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickActionHandled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切都是这么简单。现在把程序跑起来，使用快捷操作来启动 App，就可以看到背景已经是蓝色了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-scale-blue.png" alt=""></p>
<h2 id="还有一件事">还有一件事</h2><p>还有一个问题你别忘了…在程序启动顺序方面，<strong>启动</strong>程序和使用快捷操作<strong>唤醒</strong>是有区别的。我们都知道，程序启动会调用<code>willFinishLaunchingWithOptions</code>和<code>didFinishLaunchingWithOptions</code>方法。但是当使用快捷操作唤醒时，只会触发<code>performActionForShortcutItem</code>方法（译者注：这就意味着，使用快捷操作来<strong>启动</strong>会走三个方法，而使用快捷操作<strong>唤醒</strong>只会走一个，具体的方法列表如下图）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/3d-touch-quickaction-methods.png" alt=""></p>
<p>如果你回头看<code>didFinishLaunchingWithOptions</code>方法，会发现里面我写了一行设置背景色为白色的代码。这个是在直接启动程序时用的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions:</span><br><span class="line">    [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题来了：当使用快捷操作唤醒程序时，<code>willFinish</code>，<code>didFinish</code>和<code>performActionForShortcutItem</code>都会被调用。所以背景色会先设置成白色，接着又被设置成了蓝色。显然你不想在使用快捷操作启动时，背景色被设置成白色。</p>
<p>要解决这个问题，我们需要在<code>didFinishLaunchingWithOptions</code>方法的实现中添加条件判断：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions:</span><br><span class="line">    [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"didFinishLaunchingWithOptions called"</span>)</span><br><span class="line">    <span class="keyword">var</span> isLaunchedFromQuickAction = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if it's launched from Quick Action</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> shortcutItem = launchOptions?[<span class="type">UIApplicationLaunchOptionsShortcutItemKey</span>] <span class="keyword">as</span>? <span class="type">UIApplicationShortcutItem</span> &#123;</span><br><span class="line"></span><br><span class="line">        isLaunchedFromQuickAction = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// Handle the sortcutItem</span></span><br><span class="line">        handleQuickAction(shortcutItem)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return false if the app was launched from a shortcut, so performAction... will not be called.</span></span><br><span class="line">    <span class="keyword">return</span> !isLaunchedFromQuickAction</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断可选值的<code>UIApplicationLaunchOptionsShortcutItemKey</code>得到用户是否是通过快捷操作启动。<code>UIApplicationShortcutItem</code>可以作为可选值的类型。如果程序是通过快捷操作启动的，我们可以直接调用<code>handleQuickAction</code>方法将背景色改为蓝色。</p>
<p>因为我们已经在<code>didFinishLaunchingWithOption</code>方法中调用了<code>handleQuickAction</code>，所以没必要再在<code>performActionForShortcutItem</code>方法中调用一次。所以最后我们返回了一个<code>false</code>，告诉系统不要再去调用<code>performActionForShortcutItem</code>方法。</p>
<p>再次运行程序！完美！</p>
<h2 id="最后">最后</h2><p>3D Touch 是给程序添加另一种交互方式的好方法。但是你还是不要忘了，目前还不是所有设备都支持 3D Touch。</p>
<p>通过这篇文章，你应该能给你的 App 添加快捷操作，也能计量按压力度了。</p>
<p>顺便，你可以在<a href="https://www.dropbox.com/s/yf8nkupi9yt01hk/ScaleFinal.zip?dl=0" target="_blank" rel="external">这里</a>下载程序的最终版。同样，欢迎大家留言。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Maxime Defauw，<a href="http://www.appcoda.com/3d-touch-tutorial/">原文链接</a>，原文日期：2015/11/09<br>译者：<a href="http://www.brighttj.com">saitjr</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>随着 iPhone6s 与 6s plus 的到来，苹果给我们展现了一种全新的交互方式：重按手势。你可能知道，这个特性已经在 Apple Watch 和 MacBook 上推出了，不过那时叫 Force Touch，就是字面上的意思，给用户的交互添加一种新的维度。</p>
<p>如果你很好奇 iPhone 的 Force Touch 为啥要更名为 3D Touch，那告诉你吧，you’re not alone（译者注：请用 MJ 的调子唱出来…）。不久前，之前也对这名字纠结不已的 Craig Federighi（译者注：Apple 高级副总裁）介绍了这个新特性，第一条微博就这样产生了。也不知道 Force Touch 这名字有啥不好的，就因为有太多星球大战的梗？（译者注：其实我不知道这梗…）（校对注：译者是个妹子）（定稿注：还是单身）</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchConnectivity：通过用户信息共享所有数据]]></title>
    <link href="http://swiftggteam.github.io/2015/11/18/watchconnectivity-user-info/"/>
    <id>http://swiftggteam.github.io/2015/11/18/watchconnectivity-user-info/</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.920Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-user-info/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-21<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在看这篇文章之前，确认你已经看过之前发布的几篇 WatchOS 2 的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World</a>(<a href="http://swift.gg/2015/10/15/watchos-2-hello-world/" target="_blank" rel="external">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">WatchConnectivity Introduction: Say Goodbye To The Spinner</a>(<a href="http://swift.gg/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/" target="_blank" rel="external">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">WatchConnectivity: Say Hello to WCSession</a>(<a href="http://swift.gg/2015/11/02/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">译文链接</a>)</li>
</ul>
<p>通过 User Info 实现后台数据传输应该在你确保所有数据被传输的情况下（不仅仅像<a href="http://natashatherobot.com/watchconnectivity-application-context/" target="_blank" rel="external">Application Context</a>）。用户信息数据是在FIFO（先进先出）队列中排队传输的，所以不会有东西被重写。</p>
<a id="more"></a>
<p>一个典型的例子是在短信应用中使用它 —— 最后一条信息要确保能看到完整对话和上下文的重要部分。亦或者如果用户更新了他们文件信息的一小部分，则他们的个人信息和所有的修改应该被同步到 Watch 文件。</p>
<p>在这个教程中，我将会构建一个食物 emoji （表情符号）社交应用，因为我是个吃货，并且我喜欢🍦！</p>
<p>另外，这个应用可以成为一个基于食品杂货店展示的 Apple Watch 应用 —— 你在手机上选择打算购买的食物 emoji ，然后跳转到应用上，这样你就好像在食品杂货店上浏览商品了！</p>
<p><img src="/img/articles/watchconnectivity-user-info/Screen-Shot-2015-10-21-at-5.16.42-AM.png1447813695.0476735" alt=""></p>
<h2 id="免责声明">免责声明</h2><p>对于这个应用需要知道的是，我将会写很多抽象的数据更新层用于整个应用，因为 UI 中的多个地方需要有数据源更新，所以在示例应用中将会过度设计。</p>
<p>我同样尝试了不同的架构，尤其是 Swift，所以如果你知道如何在 Swift 中更好地抽象数据层，请在评论中提出。</p>
<h2 id="步骤">步骤</h2><p>在这个教程中，我假设你已经知道如何在<strong> Xcode 创建一个简单的单视图应用</strong>，以及创建一个简单的<strong>食物 Emoji 列表的表视图</strong>。如果你有任何问题，可以参考这个 <a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo/blob/master/WCUserInfoDemo/FoodSelectionViewController.swift" target="_blank" rel="external">FoodSelectionViewController</a> 。</p>
<p>同样地，我也假设你知道如何<strong>创建一个 Watch 应用并且在 Interface.storyboard 中做过基本的样式</strong>。如果你需要帮助，请查看<a href="http://natashatherobot.com/watchos-2-hello-world/" target="_blank" rel="external">WatchOS 2: Hello, World tutorial</a> 和 <a href="http://natashatherobot.com/watchkit-create-table/" target="_blank" rel="external">WatchKit: Let’s Create a Table tutorial</a>.</p>
<p>最后，你需要知道如何创建基础的用于管理 <code>WCSession</code> 的单例，以及在 <code>AppleDelegate</code> 中的<code>application:didFinishLaunchingWithOptions</code>和在Watch 扩展中<code>ExtensionDelegate</code> 的<code>applicationDidFinishLaunching</code>中启动它。如果你不清楚，请查看 <a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/" target="_blank" rel="external">WatchConnectivity: Say Hello to WCSession tutorial</a>。</p>
<p>你的 iOS 应用看起来应该像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your iOS app</span></span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span>? = <span class="type">WCSession</span>.isSupported() ? <span class="type">WCSession</span>.defaultSession() : <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> validSession: <span class="type">WCSession</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// paired - the user has to have their device paired to the watch</span></span><br><span class="line">        <span class="comment">// watchAppInstalled - the user must have your watch app installed</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Note: if the device is paired, but your watch app is not installed</span></span><br><span class="line">        <span class="comment">// consider prompting the user to install it for a better experience</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> session = session <span class="keyword">where</span> session.paired &amp;&amp; session.watchAppInstalled &#123;</span><br><span class="line">            <span class="keyword">return</span> session</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session?.delegate = <span class="keyword">self</span></span><br><span class="line">        session?.activateSession()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和在 Watch 应用中这样的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> WatchConnectivity</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span> = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">        session.activateSession()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你需要额外的提示，可以参考这个 <a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo" target="_blank" rel="external">教程的源码</a>。</p>
<p>现在让我们开始有趣的部分吧 🚀。</p>
<h2 id="发送数据">发送数据</h2><p>在我的应用中，每当用户选择一个食物项，都需要在后台传输给 Watch 应用。这意味着<strong> iOS 应用是发送者</strong>。显然这是非常简单的。</p>
<p>只需扩展 iOS 应用的 WatchSessionManager 单例去传输用户数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your iOS app</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: User Info</span></span><br><span class="line"><span class="comment">// use when your app needs all the data</span></span><br><span class="line"><span class="comment">// FIFO queue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Sender</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">transferUserInfo</span><span class="params">(userInfo: [String : AnyObject])</span></span> -&gt; <span class="type">WCSessionUserInfoTransfer</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> validSession?.transferUserInfo(userInfo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以现在，当用户选择一个食物的 cell，你只需简单地调用以下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FoodSelectionViewController.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodSelectionViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> food = [<span class="string">"🍦"</span>, <span class="string">"🍮"</span>, <span class="string">"🍤"</span>,<span class="string">"🍉"</span>, <span class="string">"🍨"</span>, <span class="string">"🍏"</span>, <span class="string">"🍌"</span>, <span class="string">"🍰"</span>, <span class="string">"🍚"</span>, <span class="string">"🍓"</span>, <span class="string">"🍪"</span>, <span class="string">"🍕"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Table Data Source methods truncated</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: Table view delegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> foodItem = food[indexPath.row]</span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.transferUserInfo([<span class="string">"foodItem"</span> : foodItem])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是酱紫！已选择的食物项就在 FIFO 队列中了，并且将会发送给 Watch 应用！</p>
<h2 id="接收数据">接收数据</h2><p><strong>现在 Watch 应用必须接收数据</strong>。这也很简单，只需要实现<code>WCSessionDelegate</code>中的<code>session:didReceiveUserInfo:</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: User Info</span></span><br><span class="line"><span class="comment">// use when your app needs all the data</span></span><br><span class="line"><span class="comment">// FIFO queue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Receiver</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveUserInfo userInfo: [String : AnyObject])</span></span> &#123;</span><br><span class="line">        <span class="comment">// handle receiving user info</span></span><br><span class="line">        <span class="comment">// this will be filled in in the Updating Data section below</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新数据">更新数据</h2><p>现在你接收到了数据，我们开始处理最棘手的部分。尝试去更新你的 Watch 扩展的 <code>InterfaceController</code> 以及其他视图或者数据源。一种方式是使用 <code>NSNotificationCenter</code>，但是我会尝试使用不同的方法。这个部分可以用多种方法来做，并且对于这个应用来说有点过度设计，因此要先说清楚。</p>
<p>因为我们正在写 Swift，我的目标是尽量使用值类型模型。不幸的是，正如我在 <code>WCSession</code> 中所提到的，<code>WCSessionDelegate</code>只能在一个<code>NSObject</code> 中实现。变通一下，我创建了一个可以携带用户信息数据的 <code>DataSource</code> 值，然后把它转换为可供多个交互控制器使用的可变的东西。因为用户信息是在一个 FIFO 队列顺序接收的，<code>DataSource</code> 应该持续追踪在队列中接收的数据。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// in your WatchKit Extension</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> items: [<span class="type">Item</span>]</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Food</span>(<span class="type">String</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Unknown</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(items: [<span class="type">Item</span>] = [<span class="type">Item</span>]()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.items = items</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">insertItemFromData</span><span class="params">(data: [String : AnyObject])</span></span> -&gt; <span class="type">DataSource</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> updatedItems: [<span class="type">Item</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> foodItem = data[<span class="string">"foodItem"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            updatedItems = [.<span class="type">Food</span>(foodItem)] + items</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            updatedItems = [.<span class="type">Unknown</span>] + items</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">DataSource</span>(items: updatedItems)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我可以现在设置一个 protocol ，通过更新的数据源更新所有需要知道数据改变的部分：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"><span class="comment">//  WatchSessionManager.swift</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DataSourceChangedDelegate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dataSourceDidUpdate</span><span class="params">(dataSource: DataSource)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们进入有趣的部分！你的<code>WatchSessionManager</code>将会以某种方式去追踪所有的<code>dataSourceChangedDelegates</code>。这可以通过一个数组以及一组可以添加和删除数组delegate的方法实现。<code>WatchSessionManager</code>还需要持续追踪最近的<code>DataSource</code>拷贝，这样就可以使用<code>DataSource</code>中的数据创建一个包含最新数据的<code>DataSource</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line">   <span class="comment">//  WatchSessionManager.swift</span></span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">WatchSessionManager</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>&#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">let</span> sharedManager = <span class="type">WatchSessionManager</span>()</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">       <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span> = <span class="type">WCSession</span>.defaultSession()</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> dataSource = <span class="type">DataSource</span>()</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> dataSourceChangedDelegates = [<span class="type">DataSourceChangedDelegate</span>]()</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">startSession</span><span class="params">()</span></span> &#123;</span><br><span class="line">       session.delegate = <span class="keyword">self</span></span><br><span class="line">       session.activateSession()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">addDataSourceChangedDelegate</span><span class="params">(delegate: T)</span></span> &#123;</span><br><span class="line">       dataSourceChangedDelegates.append(delegate)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="func"><span class="keyword">func</span> <span class="title">removeDataSourceChangedDelegate</span><span class="params">(delegate: T)</span></span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (index, dataSourceDelegate) <span class="keyword">in</span> dataSourceChangedDelegates.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">           <span class="keyword">if</span> <span class="keyword">let</span> dataSourceDelegate = dataSourceDelegate <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">where</span> dataSourceDelegate == delegate &#123;</span><br><span class="line">               dataSourceChangedDelegates.removeAtIndex(index)</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面实现接收用户信息的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in your WatchKit Extension</span></span><br><span class="line"><span class="comment">//  WatchSessionManager.swift</span></span><br><span class="line"><span class="comment">// MARK: User Info</span></span><br><span class="line"><span class="comment">// use when your app needs all the data</span></span><br><span class="line"><span class="comment">// FIFO queue</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WatchSessionManager</span> </span>&#123;</span><br><span class="line"><span class="comment">// Receiver</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">session</span><span class="params">(session: WCSession, didReceiveUserInfo userInfo: [String : AnyObject])</span></span> &#123;</span><br><span class="line">    <span class="comment">// handle receiving user info</span></span><br><span class="line">    dispatch_async(dispatch_get_main_queue()) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dataSource = <span class="keyword">self</span>?.dataSource.insertItemFromData(userInfo) &#123;</span><br><span class="line">            <span class="keyword">self</span>?.dataSource = dataSource</span><br><span class="line">            <span class="keyword">self</span>?.dataSourceChangedDelegates.forEach &#123;</span><br><span class="line">                $<span class="number">0</span>.dataSourceDidUpdate(dataSource)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们只需要确保我们的<code>InterfaceController</code>继承了<code>DataSourceChangedDelegate</code>，并且被<code>WatchSessionManager</code>持续追踪：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// in your WatchKit Extension</span></span><br><span class="line">    <span class="comment">//  InterfaceController.swift</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InterfaceController</span>: <span class="title">WKInterfaceController</span>, <span class="title">DataSourceChangedDelegate</span> </span>&#123;</span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> foodTable: <span class="type">WKInterfaceTable</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">awakeWithContext</span><span class="params">(context: AnyObject?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeWithContext(context)</span><br><span class="line"></span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.addDataSourceChangedDelegate(<span class="keyword">self</span>)</span><br><span class="line">        loadTableData(<span class="type">DataSource</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didDeactivate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remove InterfaceController as a dataSourceChangedDelegate</span></span><br><span class="line">        <span class="comment">// to prevent memory leaks</span></span><br><span class="line">        <span class="type">WatchSessionManager</span>.sharedManager.removeDataSourceChangedDelegate(<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">super</span>.didDeactivate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: DataSourceUpdatedDelegate</span></span><br><span class="line">    <span class="comment">// update the table once the data is changed!</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dataSourceDidUpdate</span><span class="params">(dataSource: DataSource)</span></span> &#123;</span><br><span class="line">        loadTableData(dataSource)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">extension</span> <span class="title">InterfaceController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">loadTableData</span><span class="params">(dataSource: DataSource)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        foodTable.setNumberOfRows(dataSource.items.<span class="built_in">count</span>, withRowType: <span class="string">"FoodTableRowController"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (index, item) <span class="keyword">in</span> dataSource.items.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> row = foodTable.rowControllerAtIndex(index) <span class="keyword">as</span>? <span class="type">FoodTableRowController</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> item &#123;</span><br><span class="line">                <span class="keyword">case</span> .<span class="type">Food</span>(<span class="keyword">let</span> foodItem):</span><br><span class="line">                    row.foodLabel.setText(foodItem)</span><br><span class="line">                <span class="keyword">case</span> .<span class="type">Unknown</span>:</span><br><span class="line">                    row.foodLabel.setText(<span class="string">"¯\\_(ツ)_/¯"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样啦！<br><a href="https://github.com/NatashaTheRobot/WatchConnectivityUserInfoDemo" target="_blank" rel="external">你可以在Github上查看完整源代码！</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/watchconnectivity-user-info/">原文链接</a>，原文日期：2015-10-21<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在看这篇文章之前，确认你已经看过之前发布的几篇 WatchOS 2 的文章：</p>
<ul>
<li><a href="http://natashatherobot.com/watchos-2-hello-world/">WatchOS 2: Hello, World</a>(<a href="http://swift.gg/2015/10/15/watchos-2-hello-world/">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-introduction-say-goodbye-to-the-spinner/">WatchConnectivity Introduction: Say Goodbye To The Spinner</a>(<a href="http://swift.gg/2015/11/03/watchconnectivity-introduction-say-goodbye-to-the-spinner/">译文链接</a>)</li>
<li><a href="http://natashatherobot.com/watchconnectivity-say-hello-to-wcsession/">WatchConnectivity: Say Hello to WCSession</a>(<a href="http://swift.gg/2015/11/02/watchconnectivity-say-hello-to-wcsession/">译文链接</a>)</li>
</ul>
<p>通过 User Info 实现后台数据传输应该在你确保所有数据被传输的情况下（不仅仅像<a href="http://natashatherobot.com/watchconnectivity-application-context/">Application Context</a>）。用户信息数据是在FIFO（先进先出）队列中排队传输的，所以不会有东西被重写。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="WatchOS 2" scheme="http://swiftggteam.github.io/categories/WatchOS-2/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 中的函数式编程]]></title>
    <link href="http://swiftggteam.github.io/2015/11/17/functional-programming-in-swift/"/>
    <id>http://swiftggteam.github.io/2015/11/17/functional-programming-in-swift/</id>
    <published>2015-11-17T04:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.920Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/functional-programming-in-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/13<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 一个强有力的语言特性就是能够用多样的函数式风格去编写代码。这在社区看来非常激动人心。</p>
<p>我在去年年底花费了一些时间学习函数式编程，所以我可以写更好的 Swift 代码。因此，我非常推荐你们也花时间去学习一下！</p>
<p>另外，我非常推荐推荐你们去看 <a href="http://2014.funswiftconf.com/" target="_blank" rel="external">Functional Swift conference</a>上的每一个视频。</p>
<p>所以在花了这么多时间后，我想要总结一下个人有关于函数式编程在 Swift 应用的一些思考。</p>
<a id="more"></a>
<h2 id="跟着概念走">跟着概念走</h2><p>函数式编程是令人生畏的，这要归咎于单子（monads）和 函数子（functors）！然而，一旦你领悟了它的核心概念，那么函数式编程的思想会超级简单：</p>
<blockquote>
<p>“函数式编程是一个编程范例…它把计算作为数学函数的评估，并避免改变状态和可变数据。”— <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>所以核心就是你应该用数学的方式去编写代码。你的函数应该有清晰的输入和输出，并且不会像可变对象一样有全局副作用。这就是了！</p>
<h2 id="避免可变状态">避免可变状态</h2><p>这和上述的注意点类似。函数式编程要编写的是没有副作用的数学代码。</p>
<p>在 Swift 中使用结构体和协议帮助你避免可变状态。</p>
<p>我极度推荐观看 <a href="https://twitter.com/andy_matuschak" target="_blank" rel="external">@andy_matuschak</a>的  <a href="https://realm.io/news/andy-matuschak-controlling-complexity/" target="_blank" rel="external">Controlling Complexity in Swift</a>，这可以让你理解如何去实现以及最终的代码会如何地强大。</p>
<h2 id="可读性第一">可读性第一</h2><p>我发现很多高级的函数式代码，通常由于五个以上的习惯性编程而变得特别难以阅读。如果你遵从函数式编程的概念，有很多方法让你的代码变得更清楚。</p>
<p>但是在今天结束之前，还要多说一句，如果你在一个团队中工作，最重要的事就是让代码可读性更强。如果一个内部或者一个新的开发者加入你们的团队，他们会不会完全迷失了？如果你专注于编写易读的代码（取代好玩和花哨的写法），他们可能会很快就有产出。</p>
<p>记住一点，可读性的优先级永远比花哨的代码高（除非你的目标就是用一个好玩的副作用去实现好玩和花哨的程序）。</p>
<h2 id="不要和_framework_作对">不要和 framework 作对</h2><p>当然，在 iOS 编程中，由于 Cocoa framework 的建立和用户的输入输出，没有副作用显然是不可能的（在纯粹的数学世界，确实存在完全没有外部副作用，但那不是我们生活的世界！）。</p>
<p>例如，如果你创建了一个通用的转换器（formatter）（例如货币转换器），并用在代码中的一些地方，用单例是一个很好的方法。你还必须为UI Layer 使用 <code>UIViewControllers</code> 以及 <code>UIViews</code>。总有办法去脱离你的逻辑，进而让很好的不可变组件去帮助你可变化这些东西，但是不要过火地把 freamwork 改变为面目全非（可读，不可读）的状态。</p>
<h2 id="深入学习函数式编程">深入学习函数式编程</h2><p>再次强调，你不应该执着于在你的 Swift 代码中使用花哨的技巧（除非你只是为了试验、或者好玩）。我非常推荐深入学习函数式编程的思想，从而理解那些高级概念，并且更好地应用在你的代码中。</p>
<p>推荐阅读 <a href="https://www.objc.io/books/fpinswift/" target="_blank" rel="external">Functional Programming in Swift</a> ！这里有<a href="http://natashatherobot.com/reading-functional-programming/" target="_blank" rel="external">更多的资源</a>去帮助你开始学习！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Natasha The Robot，<a href="http://natashatherobot.com/functional-programming-in-swift/">原文链接</a>，原文日期：2015/11/13<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 一个强有力的语言特性就是能够用多样的函数式风格去编写代码。这在社区看来非常激动人心。</p>
<p>我在去年年底花费了一些时间学习函数式编程，所以我可以写更好的 Swift 代码。因此，我非常推荐你们也花时间去学习一下！</p>
<p>另外，我非常推荐推荐你们去看 <a href="http://2014.funswiftconf.com/">Functional Swift conference</a>上的每一个视频。</p>
<p>所以在花了这么多时间后，我想要总结一下个人有关于函数式编程在 Swift 应用的一些思考。</p>]]>
    
    </summary>
    
      <category term="Natasha The Robot" scheme="http://swiftggteam.github.io/tags/Natasha-The-Robot/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[捕获上下文信息]]></title>
    <link href="http://swiftggteam.github.io/2015/11/16/capturing-context-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/11/16/capturing-context-swiftlang/</id>
    <published>2015-11-16T01:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.920Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/08/27/capturing-context-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-08-27<br>译者：<a href="https://github.com/chenmingbiao" target="_blank" rel="external">CMB</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>假设你正在使用一个类型，当有错误时发生时你想要输出异常发生时的上下文。通常你会使用一些内置的编译器关键字：<code>__FUNCTION__</code> ， <code>__LINE__</code> 和 <code>__FILE__</code> ，这些关键词提供了有关函数调用详细的文本插值：</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">String</span>; <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> reason: <span class="type">String</span>, source: <span class="type">String</span> = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">        file: <span class="type">String</span> = <span class="keyword">__FILE__</span>, line: <span class="type">Int</span> = <span class="keyword">__LINE__</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.reason = reason; <span class="keyword">self</span>.source = <span class="string">"<span class="subst">\(source)</span>:<span class="subst">\(file)</span>:<span class="subst">\(line)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一行典型的 <code>Error</code> 输出如下所示:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Error</span>(source: <span class="string">"myFunction():&lt;EXPR&gt;:14"</span>, reason: <span class="string">"An important reason"</span>)</span><br></pre></td></tr></table></figure>
<p>虽然这种结构能够让你捕获出现异常的函数、文件和行号，但你无法捕捉没有类型参数的原始父类型。为了捕获该类型，需要在 <code>Error</code> 结构体构造器中包含“原始类型”，并向构造器中传递 <code>self.dynamicType</code> 参数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">String</span>; <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> reason: <span class="type">String</span>, type: <span class="type">Any</span> = <span class="string">""</span>, </span><br><span class="line">        source: <span class="type">String</span> = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">        file: <span class="type">String</span> = <span class="keyword">__FILE__</span>, </span><br><span class="line">        line: <span class="type">Int</span> = <span class="keyword">__LINE__</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.reason = reason; <span class="keyword">self</span>.source = <span class="string">"<span class="subst">\(source)</span>:<span class="subst">\(file)</span>:<span class="subst">\(line)</span>:<span class="subst">\(type)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我很不喜欢这种额外添加类型参数的方式，它唯一的作用就是简化错误生成。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Error</span>(<span class="string">"An important reason"</span>, type: <span class="keyword">self</span>.<span class="keyword">dynamicType</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;<span class="keyword">try</span> <span class="type">Parent</span>().myFunction()&#125; <span class="keyword">catch</span>&#123;<span class="built_in">print</span>(error)&#125;</span><br><span class="line"><span class="comment">// Error(source: "myFunction():&lt;EXPR&gt;:14:Parent", reason: "An important reason")</span></span><br></pre></td></tr></table></figure>
<p>我更喜欢扩展 <code>Contextualizable</code> 来实现自动捕获类型上下文。注意，默认实现的协议方法中用到了 <code>self.dynamicType</code>，它不能被用在方法签名中（译者注：也就是说不能当做函数参数或者返回值）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Contextualizable</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Contextualizable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">currentContext</span><span class="params">(file : String = <span class="keyword">__FILE__</span>, function : String = <span class="keyword">__FUNCTION__</span>, line : Int = <span class="keyword">__LINE__</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(file)</span>:<span class="subst">\(function)</span>:<span class="subst">\(line)</span>:<span class="subst">\(<span class="keyword">self</span>.<span class="keyword">dynamicType</span>)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上述两种方法可以简化整个过程轻松实现我们的目标。共享 <code>Error</code> 类型之后就可以把变量改成常量，并且把上下文相关代码从 <code>Error</code> 构造器移动到遵循协议的类型中，这样就可以自动继承 <code>currentContext</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Error</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">String</span>; <span class="keyword">let</span> reason: <span class="type">String</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> source: <span class="type">String</span> = <span class="keyword">__FILE__</span>, <span class="number">_</span> reason: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.reason = reason; <span class="keyword">self</span>.source = source</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Parent</span>: <span class="title">Contextualizable</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFunction</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">Error</span>(currentContext(), <span class="string">"An important reason"</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>更新之后，错误输出中会包含原始类型。</p>
<p>正如读者 <code>Kametrixom</code> 所指出的，你还可以扩展 <code>Contextualizable</code> 协议并创建你自己的错误。（他还写了一个<a href="https://gist.github.com/Kametrixom/21da650bd7c7006a70e3" target="_blank" rel="external">非常棒的错误类型</a>，可以选择是否添加上下文。）</p>
<p>本文的所有代码可以在 <a href="https://gist.github.com/erica/b6f4884ed5d70c269107" target="_blank" rel="external">这个 Gist</a> 中找到（译者注：Gist 已经被墙，需要翻墙查看）。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/08/27/capturing-context-swiftlang/">原文链接</a>，原文日期：2015-08-27<br>译者：<a href="https://github.com/chenmingbiao">CMB</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>假设你正在使用一个类型，当有错误时发生时你想要输出异常发生时的上下文。通常你会使用一些内置的编译器关键字：<code>__FUNCTION__</code> ， <code>__LINE__</code> 和 <code>__FILE__</code> ，这些关键词提供了有关函数调用详细的文本插值：</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写给初学者的 Swift 教程 Part 1]]></title>
    <link href="http://swiftggteam.github.io/2015/11/13/swift-tutorial-for-beginners-part-1/"/>
    <id>http://swiftggteam.github.io/2015/11/13/swift-tutorial-for-beginners-part-1/</id>
    <published>2015-11-13T01:00:00.000Z</published>
    <updated>2015-12-10T01:00:18.920Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-tutorial-for-beginners-part-1/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-29<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 是苹果官方新推出的编程语言，它可以为 iOS、 watchOS、 tvOS 和 Mac OS 开发应用。在本教程中，你将会学到所有的基础操作。</p>
<a id="more"></a>
<h2 id="你将在这个“Swift_初学者教程”中学到些什么呢？">你将在这个“Swift 初学者教程”中学到些什么呢？</h2><p>本教程包含了以下这些话题：</p>
<ul>
<li>下载 Xcode</li>
<li>Playgrounds</li>
<li>Hello World!</li>
<li>变量</li>
<li>常量</li>
<li>类型标注</li>
<li>条件语句</li>
<li>循环语句</li>
<li>可选类型</li>
<li>函数</li>
</ul>
<p>将会有更多内容出现在“写给初学者的 Swift 教程”系列中。</p>
<p>本教程源码下载: <a href="https://github.com/kevin833752/MyTranslationPlaygrounds/tree/master/Swift_Tutorial_For_Beginners_Part_1.playground" target="_blank" rel="external">来自小铁匠的代码</a></p>
<h2 id="下载_Xcode">下载 Xcode</h2><p>成为 Swift 大牛的第一步当然是下载 Xcode 啦。你可以直接从 App Store 里下载。Xcode 是苹果官方的 IDE 工具，它可以为 iOS、 watchOS、 tvOS 和 Mac OS 这些平台开发应用。</p>
<h2 id="Playgrounds">Playgrounds</h2><p>你会把大部分编程的时间花在具体项目上。但是，Xcode 有一个非常有趣的特性，可以给初学者和大牛带来巨大帮助，它就是 Playgrounds。你可以在 Playground 里写 Swift 代码，写完就直接能看到执行的结果。因此，如果你想要学一些新特性或试验一些新功能，可以打开 Playground 直接编写，不用像在工程里那样先编译再执行。</p>
<p>如果你正在写一个项目，那也可以同时打开一个 Playground，你可以在 Playground 里快速试验一些小功能。</p>
<p>言归正传，讲讲如何使用 Playground。第一步打开 Xcode，接着在欢迎界面点击“Get started with a playground”。如果你没有看到这个欢迎界面，可以按 File -&gt; New -&gt; Playground 这样的路径打开 Playground。指定 Playground 的文件名和保存位置之后，你就可以开始写代码啦。</p>
<h2 id="Hello_World!">Hello World!</h2><p>在大多数的编程书籍中，都把打印“Hello World!”作为第一个项目。我们也不会打破这个传统的，哈哈。</p>
<p>因此，我们在 playground 里写下如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br></pre></td></tr></table></figure>
<p>输完这行代码，你就可以在 playground 的右边看到输出的结果。</p>
<p><img src="/img/articles/swift-tutorial-for-beginners-part-1/Screen-Shot-2015-10-03-at-18.26.55-1024x636.png1447379896.6408916" alt=""></p>
<p>恭喜，你已经成功编写了第一个 Swift 程序！</p>
<h2 id="变量">变量</h2><p>在打印出第一句代码后，我们可以开始真正的编程啦。你需要从变量开始。变量可以存储一个值，比如数字或字符串。可以使用<code>var</code>关键字来定义变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aNumber = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这样，我们就有了一个叫<code>aNumber</code>的变量，它的值为 5。接着，我们可以尝试着改变这个变量的值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aNumber = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>我们也可以把一个数学表示式的结果存到这个变量里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aNumber = <span class="number">5</span> + <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>当然也可以把变量的值打印出来，这需要用到特殊的术语，如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The number is equal <span class="subst">\(aNumber)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>变量可以有不同的类型。你可以为变量指定类型，比如字符串、浮点数或者布尔值：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aString = <span class="string">"A String"</span></span><br><span class="line"><span class="keyword">var</span> aDoble = <span class="number">13.3</span></span><br><span class="line"><span class="keyword">var</span> aBool = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>但是，一旦你给变量赋了某一类型的值之后，就只能为变量赋相同类型的值了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aBool = <span class="string">"A String"</span> <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>
<p>编译器是一段可以把你写的代码翻译成机器码的程序。如果你写了一段编译器不能理解或者违反编程规则的代码，编译器就会报错。</p>
<h2 id="常量">常量</h2><p>顾名思义，变量的值是可以改变的，而常量的值在第一次赋值后就不能修改了。对于常量，你可以使用关键字<code>let</code>来定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aConstantNumber = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>如果你尝试修改一个常量的值，就会报错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">aConstantNumber = <span class="number">10</span> <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure>
<p>那为什么还要有常量呢？因为，有时候并不希望一个值在第一次赋值后被修改，比如，在指定一个人的姓名后，就不希望这个值被再次修改。</p>
<h2 id="类型标注">类型标注</h2><p>我们已经知道，变量在第一次赋值之后会确定类型。当然，我们也可以在赋值时直接指定变量或常量的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aNumber: <span class="type">Int</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这个代码的结果和之前的是一样的，但是现在这段代码更加容易读懂。第一眼就知道这个变量的类型是<code>Int</code>。当然， 除了<code>Int</code>，还有许多其他的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aString: <span class="type">String</span> = <span class="string">"A String"</span></span><br><span class="line"><span class="keyword">var</span> aDouble: <span class="type">Double</span> = <span class="number">13.3</span></span><br><span class="line"><span class="keyword">var</span> aBool: <span class="type">Bool</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="条件语句">条件语句</h2><p>一个程序如果总是做相同的事情，这很无聊。因此，出现了所谓的条件语句来控制程序的流向。比如，你想要根据计算的结果有不同的输出。能控制程序流向的，也是最普遍的条件语句是<code>if</code>条件语句，举例如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is smaller than number2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段示例代码中，我们通过<code>if</code>条件语句来判断<code>number1</code>是否小于<code>number2</code>。如果满足这个条件的话，程序就会执行到大括号括起来的 if 代码块里。你也可以在代码块里添加你想要执行的代码。</p>
<p>另外，你还可以在<code>if</code>条件判断返回<code>false</code>的代码块里写相应代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number1 = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is smaller than number2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is not smaller than number2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你可以写多个<code>if</code>条件语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is smaller than number2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number2 &lt; number1 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number2 is than number2"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"number1 is equal number2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 里另外一种条件语句是<code>switch</code>条件语句。<code>switch</code>语句的形式就是把某个值与一个或若干个值作比较，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> name &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"Mick"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name is Mick"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"John"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name is John"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The name is neither Mick nor John"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>switch</code>关键字后写上需要匹配的值<code>name</code>。然后，每个<code>case</code>后跟上可能匹配的值。如果<code>name</code>匹配了某一个值，对应<code>case</code>里的代码将被执行；否则，继续进行匹配。假如没有一个值能够匹配，就会执行<code>default</code>后的代码。对于初学者来说，知道<code>switch</code>条件语句有很多可能匹配的值就足够了。</p>
<h2 id="循环">循环</h2><p>除了条件语句意外，还有一个控制程序流的重要结构：循环。循环的作用主要是能多次执行代码块里的代码。Swift 有三种循环的类型：while 循环, repeat-while 循环和 for 循环.</p>
<h3 id="while_循环">while 循环</h3><p>下面的例子使用了 while 循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while 循环以<code>while</code>关键字开始，在<code>while</code>关键字后跟上判断条件。如果条件为 true，会重复运行代码块里的一系列代码，比如本例子里的循环打印”Hello World”十次。如果没有修改变量<code>i</code>的值，循环将一直进行下去。</p>
<h3 id="repeat-while_循环">repeat-while 循环</h3><p>repeat-while 循环和 while 循环很相似。但是，不再像 while 循环那样先判断循环条件，例子如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>为什么要使用repeat-while 循环而不是 while 循环？repeat-while 循环和 while 循环的主要区别是在判断循环条件之前，先执行一次循环的代码块。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">11</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，尽管判断条件永远是 false，但是还是会打印一次“Hello World”。因此，有时候需要先判断，而有时候不想要先判断，这就要根据具体的情况决定到底使用哪种循环。</p>
<h3 id="for_循环">for 循环</h3><p>for 循环很好用，它可以对一个集合里面的每个元素执行一系列语句。同时，也有好几种遍历的方式，先来看一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This iteration number <span class="subst">\(i)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果像上面的例子一样使用三个点号（闭区间操作符）的话，最后一个数字（10）也会被包含。此外，也可以像下面的例子一样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This iteration number <span class="subst">\(i)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，最后一个数字（10）不会被包含进去。另外，还有一种方式可以写 for 循环，就是标准 C 样式的 for 循环：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"This iteration number <span class="subst">\(i)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环会执行十次。分号将循环的定义分为 3 个部分：首先，循环首次启动时，变量会被初始化，并赋一个起始值；其次，条件判断表达式被调用，如果表达式调用结果为true，则会执行大括号内部的代码；最后，执行所有语句之后，执行递增表达式，在本例中，变量<code>i</code>每次增加 1。其中，<code>i++</code>等同于<code>i = i + 1</code>。</p>
<h2 id="可选类型">可选类型</h2><p>可选类型是 Swift 里很特殊的新特性，它非常重要，因此我们在一开始就要介绍它。试想一下，一个变量有可能没有值，比如，一个变量用来存储一个人的 middle name，那某人没有 middle name 的话该怎么表示呢？我们很自然的能想到赋值一个空字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middleName: <span class="type">String</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>然而，如果我们让<code>middleName</code>成为可选类型，我们就可以为变量指定表示“这里没有值”的<code>nil</code>。可选类型的定义是在类型后面跟上问号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middleName: <span class="type">String</span>? = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>可选类型的变量可以有非空的值。但是，如果你像普通变量那样访问可选类型的变量，就会编译出错：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherName: <span class="type">String</span> = middleName <span class="comment">//编译出错</span></span><br></pre></td></tr></table></figure>
<p>你可以通过解包来访问，使用感叹号进行解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherName: <span class="type">String</span> = middleName!</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果你对一个非<code>nil</code>的值进行解包，可以得到具体的值；否则，就会在运行时报错，因为不能对<code>nil</code>进行解包。</p>
<p>因此，最好在使用可选类型变量前先判断是否是<code>nil</code>，使用所谓的可选绑定（optional binding）就可以搞定了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> middleName: <span class="type">String</span>? = <span class="string">"John"</span></span><br><span class="line"><span class="keyword">var</span> anotherName: <span class="type">String</span> = <span class="string">"Michael"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = middleName &#123;</span><br><span class="line">    anotherName = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，这段代码可能看起来会有点奇怪，实际上很简单，意思也很明确：如果<code>middleName</code>等于<code>nil</code>的话，对应的代码块就不会执行。如果<code>middleName</code>不等于<code>nil</code>的话，变量<code>name</code>就会获得<code>middleName</code>的值，对应的代码块就会被执行。在代码块里，<code>name</code>就不再是可选变量了，因此可以给其他变量赋值。</p>
<h2 id="函数">函数</h2><p>你可能经常会遇到，一些代码可以应用于许多不同的情况。而函数就是用来完成特定任务的独立的代码块，并且当函数需要执行的时候，这个名字会被用于“调用”函数。先从简单打印“Hello World”的函数开始吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，你把上面那段代码写到 playground 里，界面右边是没有输出的。如果你通过下面的方式调用这个函数的话，就会有对应的输出了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printHelloWorld()</span><br></pre></td></tr></table></figure>
<p>如果你调用这个函数两次的话，你会看到界面右边会出现两次输出：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printHelloWorld()</span><br><span class="line">printHelloWorld()</span><br></pre></td></tr></table></figure>
<p>你也可以给函数传递额外的信息，即传递参数。每个参数都需要指定参数名和类型，然后你就可以在函数里访问这些参数的值了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printANumber</span><span class="params">(number:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number is <span class="subst">\(number)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，你就可以像下面的方式调用有参数的函数了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printANumber</span><span class="params">(number:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number is <span class="subst">\(number)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printANumber(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>本例中，对应的输出就是：“The number is 5”。</p>
<p>你甚至可以指定多个参数。然后，你在调用函数时，除了不需要写第一个参数的参数名之外，其他参数都需要写参数名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(number1:Int, number2:Int, number3:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The number are <span class="subst">\(number1)</span>, <span class="subst">\(number2)</span>, <span class="subst">\(number3)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">printNumbers(<span class="number">5</span>, number2:<span class="number">10</span>, number3:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p>另外，函数最重要的一点就是返回值。如果需要函数有返回值，你就要指定返回值的类型，同时，返回值由<code>return</code>关键字返回。</p>
<p>举个例子：你需要写一个函数，实现返回两个数字中更大者的功能。大体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">maxOfNumbers</span><span class="params">(number1: Int, number2: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> number1 &lt; number2 &#123;</span><br><span class="line">        <span class="keyword">return</span> number2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">maxOfNumbers(<span class="number">5</span>, number2: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为 10。</p>
<h2 id="接下来该干什么">接下来该干什么</h2><p>现在已经基本熟悉 Swift 中大部分的基本语法了。这对之后的学习是个很重要的基础。接下来可以自己动手在 Playground 里试着写一些小功能，也可以看看关于本文知识点的其他文章：</p>
<ul>
<li><a href="http://www.thomashanning.com/should-you-use-objective-c-or-swift/" target="_blank" rel="external">该使用 Objective-C 还是 Swift？</a></li>
<li><a href="http://www.thomashanning.com/constants-in-swift/" target="_blank" rel="external">Swift 中的常量</a></li>
<li><a href="http://www.thomashanning.com/optionals-in-swift/" target="_blank" rel="external">Swift 中的可选类型</a></li>
</ul>
<p>在本系列的后续部分，我们会讨论更多关于 Swift 的新特性。请继续关注!</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-tutorial-for-beginners-part-1/">原文链接</a>，原文日期：2015-10-29<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>Swift 是苹果官方新推出的编程语言，它可以为 iOS、 watchOS、 tvOS 和 Mac OS 开发应用。在本教程中，你将会学到所有的基础操作。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
