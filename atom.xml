<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[SwiftGG]]></title>
  <subtitle><![CDATA[走心的 Swift 翻译组]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://swiftggteam.github.io/"/>
  <updated>2015-12-29T13:05:21.994Z</updated>
  <id>http://swiftggteam.github.io/</id>
  
  <author>
    <name><![CDATA[SwiftGG]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[如何使用 Swift、Foursquare API 及 Realm 构建一款 Coffee Shop 应用]]></title>
    <link href="http://swiftggteam.github.io/2015/12/29/foursquare-realm-swift/"/>
    <id>http://swiftggteam.github.io/2015/12/29/foursquare-realm-swift/</id>
    <published>2015-12-28T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：reinder de vries，<a href="http://www.appcoda.com/foursquare-realm-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/23<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="http://www.brighttj.com" target="_blank" rel="external">saitjr</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>我们经常说，程序员喝进去的是咖啡，吐出来的是代码。让我们换一个角度去思考，来做一个显示附近咖啡店的 App。</p>
<p>这篇文章中，用到了以下技能：</p>
<ul>
<li>Swift，Xcode 和 Interface Builder（Auto Layout, Constraints 和 Storyboards）</li>
<li>Realm，一种本地存储方案，轻量级的 Core Data</li>
<li>使用 Foursquare 和 Das Quadrat 库访问 REST API</li>
<li>CocoaPods 和 Geolocation</li>
</ul>
<p>这个 App 可以检测当前用户的 500 平方米的范围，并从 Foursquare 拿到附近咖啡店的地理信息。我们将使用 map view（<code>MKMapView</code>）和一个 table view（<code>UITableView</code>）来展示数据。当然，还要使用 Realm 来过滤数据，并使用闭包来对数据进行排序。</p>
<a id="more"></a>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/foursquare-api.jpg" alt=""></p>
<p>你可以从 GitHub <a href="https://github.com/reinderdevries/CoffeeGuide" target="_blank" rel="external">reinderdevries/CoffeeGuide</a> 上下载所有源代码和 Xcode 项目。</p>
<p>让我们开始码代码吧！</p>
<h2 id="设置_Xcode">设置 Xcode</h2><p>第一步，创建工程。打开 Xcode，选择 File -&gt; New -&gt; Project…</p>
<p>在分类中，选择 iOS -&gt; Application -&gt; Single View Application，然后填写一下信息：</p>
<ul>
<li>Product Name：Coffee</li>
<li>Organisation Name：随便写一个</li>
<li>Organisation Identifier：也随便写一个，使用的格式如：com.mycompanyname</li>
<li>Language：Swift（当然是 Swift 了）</li>
<li>Devices：iPhone</li>
<li>取消 Core Data，勾选 Unit Tests 和 UI Tests</li>
</ul>
<p>选择工程的存储路径，不用勾选 create a local Git repository。</p>
<p>接着创建 Podfile。在项目名称上（工程目录选项卡）点击右键，选择 New File … 如下图所示，选择 iOS -&gt; Other -&gt; Empty。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_2.png" alt=""></p>
<p>文件命名为 Podfile（不要文件扩展名）并<strong>确保</strong>它和 .xcodeproj 文件在同一级目录下！还要勾选 Target 栏里的 Coffee 选框。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_3.png" alt=""></p>
<p>然后复制下面的代码到 Podfile里：（译者注：以下是原文的代码，但是有个地方错了：<code>useframeworks!</code> 要改为 <code>use_frameworks!</code> ）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line">useframeworks!</span><br><span class="line"></span><br><span class="line">pod <span class="string">'QuadratTouch'</span>, <span class="string">'&gt;= 1.0'</span></span><br><span class="line">pod <span class="string">'RealmSwift'</span></span><br></pre></td></tr></table></figure>
<p>项目集成了两个第三方类库：Realm 和 Das Quadrat（一个  Foursquare REST API 的 Swift 库）。</p>
<p>然后，退出工程并关闭 Xcode（最好完全关闭）。打开 OS X 终端，cd 到你的工程目录下。详细步骤如下：</p>
<ol>
<li>打开终端</li>
<li>键入<code>cd</code>（c-d-空格）</li>
<li>打开文件夹</li>
<li>定位到你工程目录的那个文件夹，但是不要点进去</li>
<li>把文件夹拖到终端里</li>
<li>这样，工程的绝对路径会显示在 <code>cd</code>的后面</li>
<li>回车</li>
<li>这样，就进入正确的工程目录了</li>
</ol>
<p>现在，在终端里输入：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>稍等一会，会出现几行信息，这表示 Cocoapods 已按照之前设置的要求把需要的第三方库装进 Xcode 了，同时，我们的工程已经变成 workspace （编辑模式）了。</p>
<p>这步完成后，找到新生成的 .xcworkspace 文件并将其打开。以后都用它打开工程。</p>
<p>注意：如果打开 workspace 以后发现工程目录里面是空的，那就重新用 .xcodeproj 文件打开工程。然后关闭它，也关闭 workspace，然后再重新用 .xcworkspace 打开工程。这样应该就没什么问题了。</p>
<p>好了，这就是 Xcode 所需的全部设置。如果每个步骤都设置正确，那么现在工程目录中会有两个 Project。Pods 的 project 中包含 Realm 和 Das Quadrat 的库文件。</p>
<h2 id="在_Storyboards_中构建_UI_元素">在 Storyboards 中构建 UI 元素</h2><p>这个 App 的 UI 极其简单，一共就两个 UI 控件：map view 和 table view 。</p>
<p>Xcode 已经为你完成了大部分工作， Single View Application 模板包含了一个 <code>Main.storyboard</code>，它是程序入口。</p>
<p>接下来，配置 map view ，步骤如下：</p>
<ol>
<li>打开 <code>Main.storyboard</code> </li>
<li>在 Xcode 右下部分的 Object Library 里，找到 Map Kit View （<code>MKMapKitView</code>）</li>
<li>把它拖到 View Controller 里面，左上角顶格，宽度和 View Controller 一样，高度是 View Controller 的一半。（译者注：其实是 View Controller 的 View ，大家能理解就好）</li>
<li>接着，再从 Object Library 里找到 Table View （<code>UITableView</code>），并把它拖到 View Controller 里面，宽度与 View Controller 一样，高度填满屏幕的剩余部分。</li>
</ol>
<p>然后，给两个 View 设置右边距约束。首先，选中 map view ，点击 Pin 按钮（编辑区右下角的倒数第二个按钮，看起来像星球大战里面的战机…（译者注：感觉作者也被自己的比喻无语到了…））</p>
<p>点击以后，会有一个弹出框，操作步骤如下：</p>
<ol>
<li>取消 Constrain to margins 的选中状态</li>
<li>选中左、上、右的线，选中后会变成红色的高亮状态</li>
<li>每条线旁边都有一个输入框，确保输入框中的值都是 0</li>
<li>最后，点击 Add 3 constraints 按钮</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_5.png" alt=""></p>
<p>接着，也给 table view 添加约束。步骤和之前一样，但是 table view 添加的是 左、下、右三个约束。同样需要注意 Constrain to margins 是未选中状态，然后点击 Add 3 constraints 按钮。</p>
<p>现在已经给两个 View 添加了以下这些约束：各自上下边距的约束，宽度和父容器相同。还差最后一个步骤，需要确保两个 View 的高度各占父容器的一半。</p>
<p>你可以通过给约束设置一个倍数来达到效果，但是以下是一个更简单的方法：</p>
<ol>
<li>同时选中 table view 和 map view（按住 Command 键并选中两者）</li>
<li>点击 Pin 按钮</li>
<li>选中 Equal Heights 选框</li>
<li>点击 Add 1 constraint 按钮</li>
</ol>
<p>OK，这个时候 Xcode 可能会有报错，别担心，照下面的步骤来解决：</p>
<ol>
<li>选中 map view，点击 Pin 按钮</li>
<li>取消 Constrain to margins，选中下边距约束，并在输入框中键入0</li>
<li>点击 Add 1 constraint</li>
</ol>
<p>现在，红色的线（报错）消失了，但是有可能会出现黄色的线（警告）。意思是说，展示的 frame 可能和添加的约束不一致。其实这个时候所有的约束都加了，只是 Interface Builder 没有正确显示更新而已。</p>
<p>解决方式：在 Document Outline 中，点击有小箭头的黄色按钮。</p>
<p>点击黄色的小箭头以后，会跳到一个新的界面。然后，在新的界面中点击黄色的三角形 -&gt; Update frames -&gt; Fix misplacement 。如果还有黄色三角，重复上一个步骤。有可能，更新后的 frame 不是你想要的，所以添加约束的时候就一定要注意，一定要添加对。（译者注：作者这里解决警告的方式太麻烦了，其实可以在 Document Outline 中选中 View ，点击 Pin 按钮右边的 Resolve Auto Layout Issues 按钮，然后选择下面的那个 Update frames 就行了）。</p>
<p>在添加约束的过程中很容易出错，最简单的解决方式是，在 Document Outline 中删除所有约束，重新来一遍。（译者注：同样，选中要删除约束的 View ，点击 Resolve Auto Layout Issues ，点击 Clear Constraints 就行。植入硬广一则：@saitjr 的<a href="http://www.saitjr.com/ios/ios-autolayout-demo.html" target="_blank" rel="external">Autolayout 案例讲解</a>）</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_7.png" alt=""></p>
<h2 id="构建_App_并解决错误">构建 App 并解决错误</h2><p>在开发过程中，应该时不时跑一下程序，这样可以及时发现错误并解决。</p>
<p>在有了一定的开发经验以后，写一点代码就运行程序的现象会越来越少。但如果你是新手，那就尽量将开发步骤细分，每改动一点，就跑起来看看效果。这样就可以将代码错误定位到最小范围。</p>
<p>运行程序有两个快捷键：Command + B 或者 Command + R。前者是编译，后者是编译并运行。在 Xcode 的左上角可以选择 iPhone 型号和版本。这里也可以选择使用真机测试，那需要加入苹果开发者计划。</p>
<p>刚好我们的程序有个错误，来看一下怎么解决。运行程序，先找到控制台（在 Xcode 底部窗口的右栏）。如图：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_8.png" alt=""></p>
<p>如果没找到底栏，可以在 Xcode 右上角打开底栏，然后点击底栏右边的按钮，打开右栏。（译者注：一图胜千言，如上图）</p>
<p>然后控制台上可以看到如下错误：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">04</span> <span class="number">14</span><span class="symbol">:</span><span class="number">37</span><span class="symbol">:</span><span class="number">56.353</span> <span class="constant">Coffee</span>[<span class="number">85299</span><span class="symbol">:</span><span class="number">6341066</span>] *** <span class="constant">Terminating</span> app due to uncaught exception <span class="string">'NSInvalidUnarchiveOperationException'</span>, <span class="symbol">reason:</span> <span class="string">'Could not instantiate class named MKMapView'</span></span><br><span class="line">    *** <span class="constant">First</span> throw call <span class="symbol">stack:</span></span><br><span class="line">    (</span><br><span class="line">        <span class="number">0</span>   <span class="constant">CoreFoundation</span>                      <span class="number">0x0000000109fdff65</span> exceptionPreprocess + <span class="number">165</span></span><br></pre></td></tr></table></figure>
<p>苦逼的是，控制台显示的错误信息太复杂，而且，有些时候甚至连错误信息都没有显示。大多数运行时错误由以下三种组成：异常信息、崩溃原因和堆栈信息。</p>
<p>以上三个信息可以帮助你定位错误。举个例子，你可以通过异常信息找到抛出异常的代码段。堆栈信息显示的是报错前程序调用的类与方法。这个过程一般被称为回溯，可追溯到报错的代码。</p>
<p>现在来看看错误信息，其实很好理解：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="constant">Could</span> <span class="keyword">not</span> instantiate <span class="class"><span class="keyword">class</span> <span class="title">named</span> <span class="title">MKMapView</span></span></span><br></pre></td></tr></table></figure>
<p>咦，<code>MKMapView</code> 看起来很眼熟吧。对，刚刚才在 Interface Builder 里面见过，拖到界面上半部分的那个 View 就是。报错中出现的 “instantiate” 是实例化的意思，这是一个术语。错误含义是：编译器（Xcode 中，把代码转成二进制目标文件的工具）不能创建一个 <code>MKMapView</code> 给你。简单点理解就是：创建 map view 失败了。</p>
<p>其实，99%的错误信息都不告诉你怎么去解决问题，它们只是告诉你这里出错，却连错误原因都没写。</p>
<p>你能做的就两点：</p>
<ol>
<li>甩手不做了，剧终；</li>
<li>去 Google （度娘就算了，对英文支持太差）</li>
</ol>
<p>把错误信息复制下来，去 Google 吧，搜索结果一般是这样的：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/google-search.png" alt=""></p>
<p>点击第一个链接就行，这是个 Stack Overflow 的链接（一个专为程序员设计的问答网站）。这网站上的问题几乎涵盖了所有的编程语言，而且都解决得相当完美。</p>
<p>在 StackOverFlow 上解求问题的答案，你应该按照以下步骤：</p>
<ol>
<li>查看问题是否有答案，如果没有，就到 Google 里继续找。如果有些问题还没有答案，你也可以去回答。</li>
<li>回到我们的问题上来，撇开标题不看，答案通常隐藏在下面的评论当中。</li>
<li>找到被采纳的回答（回答下面有绿色的对勾），然后看看下面的评论（评论通常比回答有效）。左边的数字，是这个回答收到的赞。有时候被采用的回答不是最好的，所以也要留意评论和其他回答。</li>
<li>找到解决方案以后，不要盲目的照着做，要知其所以然。初学时，这可能会耗费大量时间，但是这些都是知识储备，以后肯定能派上用场。几乎每个程序员都有他们的知识缺口，这会削弱他们的技能。假如你能做到既知道错误出现原因，又能有效避免，那么你就是世上前 1% 的程序员了。</li>
</ol>
<p>那这个问题的原因到底是什么呢？其实是 <code>MapKit.framework</code> 没有导入到工程里面。看框架名字就知道， <code>MKMapView</code> 是被包含在这个外部框架里的。即使我们还没有直接显式的去调用 map view ，但也必须要导入框架到我们的工程里。</p>
<p>如果你通读了 StackOverflow 的解决方案，你会发现报错这种错的原因有很多。</p>
<p>根据以下步骤来解决我们的问题：</p>
<ol>
<li>在 Xcode 左导航栏上点击项目配置（左栏顶部蓝色的那一栏）</li>
<li>选择 Build Phases 选项卡</li>
<li>点击 Link Binary With Libraries ，展开列表</li>
<li>点击下面的 +- 按钮，会出来一个弹出框（这里选 + ）</li>
<li>搜索 mapkit </li>
<li>最后，双击 <code>MapKit.framework</code></li>
</ol>
<p>这样就把一个库导入到了工程中。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_10.png" alt=""></p>
<h2 id="处理地理位置">处理地理位置</h2><p>现在的工程没有报错了，接下来来看看下一个需求：地理位置。我们需要将用户的位置标记在 map view 上。</p>
<p>首先，需要将 Storyboard 中的 map view 和代码关联。在创建工程的时候，Xcode 就自动生成了 <code>ViewController.swift</code> 文件。这也是 Storyboard 中的 view controller 所关联的文件。</p>
<p>下面来做一个小测试，看看文件是否成功关联：</p>
<ol>
<li>打开 <code>ViewController.swift</code> 文件，看到 <code>class</code> 开头的那一行。这是在类的定义。包含的信息有：类名、父类、遵循的协议。在这个类中，类名是 <code>ViewController</code>。</li>
<li>打开 <code>Main.storyboard</code> 文件，在 Document Outline 中，找到顶上的一栏，这里应该标注的是 <code>View Controller Scene</code>。</li>
<li>在右上角点击 Identity Inpector （左起第三个按钮）</li>
<li>检查 Class 那一栏写得什么</li>
</ol>
<p>这样，就完成了 <code>ViewController</code> 与 Storyboard 的关联检查，如果你今后在 Storyboard 中创建了其他 view controller ，也可以在 Storyboard 中设置类名来进行关联。</p>
<h2 id="建立_Map_View_Outlet">建立 Map View Outlet</h2><p>现在，你已经知道 Storyboard 和代码是有关联的了，让我们为 Map View 添加 Outlet 吧。在你用自己的代码扩展 Map View 之前，需要将 Map View 的实例连接起来。</p>
<p>打开 <code>ViewController.swift</code> ，在第一个 <code>{</code> 下面添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> mapView:<span class="type">MKMapView</span>?</span><br></pre></td></tr></table></figure>
<p>这行代码含义如下：</p>
<ul>
<li>在 Swift 中，使用变量前需要先定义。在变量定义的同时，也可以进行初始化。在上面的代码中，并没有进行初始化，默认是 <code>nil</code> （空）。</li>
<li>上面代码给 <code>ViewController</code> 类的对象声明了一个实例属性，并且该属性在该类的每个实例对象中，都是唯一的。与实例属性相对的是类属性，类属性在每个实例对象中都是相同的。</li>
<li>属性名称为 <code>mapView</code> ，类型为 <code>MKMapView</code> 。<code>MKMapView</code> 是 <code>MapKit</code> 框架里的一个类。</li>
<li><code>@IBOutlet</code> 告诉 Xcode 这个属性将会作为 outlet 。outlet 会与 Storyboard (或 xib) 中的 UI 元素相关联。</li>
<li><code>var</code> 表示这个属性是可变的，与之相对的是 <code>let</code> ，表示常量，不可变。（译者注：可参照 <code>NSMutableArray</code> 与 <code>NSArray</code>）</li>
<li>关于 <code>?</code> 标识，是表明变量是个可选类型。这是 Swift 的一大特点，表示对象可以是 <code>nil</code> （空），与之相对的是 non-nil 。 可选类型提高了程序的安全性和可读性，之后也会用到很多可选类型。</li>
<li>为什么这行代码要放在这（class 的大括号内的顶部）呢？这表示变量的作用域是当前类。还有一种作用域是方法作用域，即在方法中定义的变量，只在当前方法中可用，当然，如果是全局作用域（全局变量），那就是在全局都可用了。</li>
</ul>
<p>是不是觉得变量、属性有点搞不清楚？变量就是用来存储数据的；而属性，它其实也是一个变量，但是他属于一个类。同时，属性分为两种：实例属性和类属性。</p>
<p>是不是觉得类、实例、类型有点搞不清楚？类就是具有同种属性的对象，它可以创建该对象的很多副本。类创建后的一个个副本就是实例。这里所说的“类型”其实是有歧义的，你可以想象成和“类”差不多的东西。</p>
<p>是不是觉得定义（声明）、初始化、实例有点搞不清楚？OK，首先，定义（声明）：即告诉编译器，要用的变量的名称与类型。初始化：给变量一个初始值。初始值可以写在声明之后，如果没有赋值，那默认为 <code>nil</code> 。实例：表示这个变量是一个实例（类的“副本”）。严格意义上来讲，应该解释为该变量是一个实例化对象。</p>
<p>好了，现在回到项目中来。这时，Xcode 应该会在当前行报错，错误信息是：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="constant">Use</span> of undeclared type <span class="constant">MKMapView</span></span><br></pre></td></tr></table></figure>
<p>这是因为 <code>MapKit</code> 还没有导入到当前文件。因此，在类定义的上面，引入 <code>UIKit</code> 代码的下面，添加这句话：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MapKit</span><br></pre></td></tr></table></figure>
<p>现在，来关联一下 outlet：</p>
<ol>
<li>打开 <code>Main.Storyboard</code> 。</li>
<li>显示 Document Outline，点击 View Controller Scene 。</li>
<li>打开左边栏的 Connections Inspector 。</li>
<li>在列表中找到 <code>mapView</code> 属性。（译者注：如果没找到，也可以通过 Show the Assistant editor 直接在代码中关联）</li>
<li>然后，把这个属性右边的小圆点拖拽到编辑器上的 map view 中。</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_11.png" alt=""></p>
<h2 id="添加第一个方法">添加第一个方法</h2><p>OK，现在来做下 map view 的相关实现。在 <code>ViewController</code> 类中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">super</span>.viewWillAppear(animated)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mapView = <span class="keyword">self</span>.mapView</span><br><span class="line">    &#123;</span><br><span class="line">        mapView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你是不是在问添加到哪里？你想放哪放哪，只要在类的大括号结束前就行，就是这么任性。</p>
<p>所有方法都必须在类作用域之内。类作用域即类定义之后的 <code>{</code> 到与之匹配的 <code>}</code> 之间。</p>
<p>你可以说这是平衡之美，每个 <code>{</code> 都有与之对应的 <code>}</code> 。同时，程序员也会使用缩进来突出作用域层级。一般来说，使用的是 1 个 tab 或 4 个空格来进行缩进。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_12.png" alt=""></p>
<p>下面来解释下刚才写的方法：</p>
<ul>
<li>方法，是类中的一块代码整体。这些代码相对独立，并实现某些特定的功能。方法能在当前类中调用，也可以在当前工程的其他地方被调用。</li>
<li>这个方法叫 <code>viewWillAppear</code>，带一个参数。这个参数是一个变量，在方法被调用的时候会传进来的。参数作用域在整个方法范围内。在父类调用的 <code>viewWillAppear</code> 方法中，参数名为 <code>animated</code> ，类型为 <code>Bool</code> （布尔值，真或假）。</li>
<li>所有方法都以 <code>func</code> 关键字开头，这是 <code>function</code> 的缩写。在这个例子中，<code>viewWillAppear</code> 是重写的父类方法，所以要加上 <code>override</code> 关键字。将父类的同名方法实现并替换成当前类的实现。父类与重写概念都属于面向对象编程范式范畴（ Object Oriented Programming ）。这个概念在本文中不做讲解。</li>
<li>该方法的主体：先将可选绑定的 <code>self.mapView</code> 赋值给了常量 <code>mapView</code> 。使用可选绑定可以验证可选变量是否为 <code>nil</code> 。如果有值，<code>if</code> 中的代码才会执行。同时，常量 <code>mapView</code> 只在 <code>if</code> 作用域内有效。</li>
<li>在 <code>if</code> 条件语句中，将 <code>mapView</code> 的 <code>delegate</code> 属性设置给当前类 <code>self</code> 。换句话说，当 <code>self.mapView</code> 不为 <code>nil</code> 的时候，<code>mapView</code> 的 <code>delegate</code> 就是 <code>self</code> 。再简单点说：如果当前类实例不为空，那就是 <code>mapView</code> 的 <code>delegate</code> （译者注：这里作者解释了N多遍，代码胜千言…）。之后还会用到其他 <code>delegate</code>。</li>
</ul>
<p>完成 <code>delegate</code> 的设置之后，Xcode 又报错了。告诉我们，<code>self</code> 不能作为 <code>delegate</code>，因为当前类 <code>ViewController</code> 没有遵循  <code>MKMapViewDelegate</code> 。现在进行修正：</p>
<p>改一下类定义的那行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MKMapViewDelegate</span></span></span><br></pre></td></tr></table></figure>
<h2 id="获取用户地理位置">获取用户地理位置</h2><p>现在 map view 已经配置好了，你可以将注意力集中在获取地理位置上了。</p>
<p>在 <code>ViewController</code> 类中，添加以下两个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> locationManager:<span class="type">CLLocationManager</span>?</span><br><span class="line"><span class="keyword">let</span> distanceSpan:<span class="type">Double</span> = <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>第一个属性 <code>locationManager</code> 是类型为 <code>CLLocationManager</code> 的变量。这是一个可选类型，所以它的值可以是 <code>nil</code> 。第二个属性是个类型为 <code>Double</code> 的常量，值为 500 。<code>Double</code> 即双精度浮点数类型（有效位长度是 <code>Float</code> 的两倍）。</p>
<p>现在，给当前类添加下面这个方法。可以将代码插入到 <code>viewWillAppear</code> 的下面。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidAppear</span><span class="params">(animated: Bool)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> locationManager == <span class="literal">nil</span> &#123;</span><br><span class="line">        locationManager = <span class="type">CLLocationManager</span>()</span><br><span class="line"></span><br><span class="line">        locationManager!.delegate = <span class="keyword">self</span></span><br><span class="line">        locationManager!.desiredAccuracy = kCLLocationAccuracyBestForNavigation</span><br><span class="line">        locationManager!.requestAlwaysAuthorization()</span><br><span class="line">        locationManager!.distanceFilter = <span class="number">50</span> <span class="comment">// Don't send location updates with a distance smaller than 50 meters between them</span></span><br><span class="line">        locationManager!.startUpdatingLocation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoah，这段代码是啥意思？</p>
<ol>
<li>首先，用 <code>if</code> 条件语句判断 <code>locationManager</code> 变量的值是否为空。</li>
<li>然后，实例化 <code>CLLocationManager</code> ，并赋值给 <code>locationManager</code>。换句话说：<code>locationManager</code> 变量指向的就是 <code>CLLocationManager</code> 的实例对象。 location manager 对象能用来获取用户地址。</li>
<li>接着，我们给 <code>locationManager</code> 设置了一些属性。将 delegate 设为当前类，并设置了 GPS 精度。还调用了 <code>requestAlwaysAuthorization()</code> 方法，这个方法在 app 中弹出提示框，提示用户 app 会用到 GPS ，并征得用户授权。</li>
<li>最后，调用 <code>startUpdatingLocation</code> 方法，location manager 就会开始轮询 GPS 坐标，并将最新的坐标通过代理方法传回。如果实现了代理方法，我们就能拿到用户的地理位置信息了。</li>
</ol>
<p>你是否注意到 <code>locationManager</code> 代码后面的感叹号？这是因为 <code>locationManager</code> 是可选值，所以有可能是 <code>nil</code> 。当我们要访问这个变量时，就需要先解包，确保非空。根据这个访问约定，解包有两种方式：</p>
<ul>
<li><strong>可选绑定</strong>。使用 <code>if let definitiveValue = optionalValue { …</code> 这样的结构（译者注：关于 <code>if let</code> 的使用，可以参考 SwiftGG 翻译组的另一篇文章：<a href="http://swift.gg/2015/11/06/if-let-assignment/" target="_blank" rel="external">if-let赋值运算符</a>）</li>
<li><strong>强制解包</strong>。使用感叹号，如 <code>optionalValue!</code>。</li>
</ul>
<p>在写第一个方法的时候，我们用的就是可选绑定的方式。当可选变量不为 <code>nil</code> 时，使用 <code>if let</code> 来定义一个新的变量。</p>
<p>强制解包不是一个很好的方案。要在需要解包的变量后面加上感叹号，那么它就会从可选状态 “强制转换” 为不可选状态。不幸的是，当你强制解包一个值为 <code>nil</code> 的可选变量时，程序会直接崩溃。 </p>
<p>所以不能对值为 <code>nil</code> 的可选变量强制解包。在上面的代码中，强制解包就不存在这个问题。为什么呢？因为在强制解包之前，我们先将 <code>CLLocationManager</code> 的实例变量赋给了 <code>locationManager</code> ，所以可以保证 <code>locationManager</code> 不是 <code>nil</code>。</p>
<p>OK，回到代码部分。当我们添加了上面方法以后，Xcode 又报错了…让我们继续来解决问题吧！</p>
<p>错误之处：我们想让 <code>self</code> 作为 <code>locationManager</code> 的委托（ <code>delegate</code> ），但是并没有遵循相应的协议。在类定义的地方，添加以下代码来遵循协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MKMapViewDelegate</span>, <span class="title">CLLocationManagerDelegate</span></span></span><br></pre></td></tr></table></figure>
<p>OK，给 <code>ViewController</code> 类添加以下代理方法。放在上一个方法的后面就行。（译者注：添加的这个方法已经被弃用了。取而代之的是 <code>func locationManager(manager: CLLocationManager, didUpdateLocations locations: [CLLocation])</code> 方法。）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">locationManager</span><span class="params">(manager: CLLocationManager, didUpdateToLocation newLocation: CLLocation, fromLocation oldLocation: CLLocation)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mapView = <span class="keyword">self</span>.mapView &#123;</span><br><span class="line">        <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(newLocation.coordinate, distanceSpan, distanceSpan)</span><br><span class="line">        mapView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法又在做什么呢？</p>
<ul>
<li>首先，方法名是 <code>locationManager:didUpdateToLocation:fromLocation</code> 。这个方法使用了命名参数，说明他的方法名会随着参数名的不同而不同（变量在方法内部）。简言之，这个方法有三个参数：调用该方法的 location manager，最新的 GPS 坐标，上一次的 GPS 坐标。</li>
<li>在方法内部，先使用可选绑定对 <code>self.mapView</code> 解包。当 <code>self.mapView</code> 不为 <code>nil</code> 时，<code>mapView</code> 变量就是它解包以后的值，然后执行 <code>if</code> 条件中的对应语句。</li>
<li>在 <code>if</code> 语句中，根据新的 GPS 坐标与之前定义的 <code>distanceSpan</code> 两个值，计算得到 <code>region</code> 值。这句代码创建了一个以 <code>newLocation</code> 为中心，500 * 500 的一个矩形区域（500 就是 <code>distanceSpan</code> 的值）。</li>
<li>最后，调用 map view 的 <code>setRegion</code> 方法。<code>animation</code> 参数设为 <code>true</code> ，这样 <code>region</code> 改变就会有动画。换句话说：地图可能会有平移或缩放操作，所以要保证他每次都能显示 500 * 500 的区域。</li>
</ul>
<p>最后一件事，为了让用户同意地理位置授权，你需要在 Xcode 中设置一个特别的授权请求。这个请求要用一句话涵盖为什么要获取用户地理位置。iPhone 会在申请授权时，弹框显示这句话（即在调用 <code>requestAlwaysAuthorization()</code> 方法时）。</p>
<p>配置请求的步骤如下：</p>
<ol>
<li>在工程目录中打开 <code>info.plist</code> 文件。</li>
<li>右键点击列表，选择 Add Row。</li>
<li>在 key 列，填入 <code>NSLocationAlwaysUsageDescription</code> 。</li>
<li>在 type 列，将类型改为 <code>String</code>。</li>
<li>在 value 列，填入 <code>We need to get your location!</code> （译者注：这个 value 就是申请授权并弹框时，显示给用户的文本）</li>
</ol>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/info-plist.png" alt=""></p>
<h2 id="运行程序">运行程序</h2><p>现在，让我们运行一下程序。确保你选择了相应的 iPhone Simulator，运行快捷键 Command - R 。第一次运行 App ，会弹出是否允许获取地理位置的授权框，选择 Allow，如下图。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_14.png" alt=""></p>
<p>当我们点击了 Allow 以后，map view 好像并没有更新位置。这是因为模拟器没有 GPS ，所以…我们需要模拟一下：</p>
<p>当 app 在模拟器上跑起来以后，在以下两种方式中，选择一种进行配置：</p>
<ul>
<li>iPhone Simulator: Debug -&gt; Location -&gt; Apple.</li>
<li>Xcode: Debug -&gt; Simulate Location -&gt; [随便选一个]</li>
</ul>
<p>当你选择了一个地理位置后，map view 就会定位到对应位置，并缩放到合适的大小。（译者注：可能定位这一步会有点慢，map 半天没有更新或没有图像出来，等等就好了）</p>
<p>搞定了吗？完美！</p>
<h2 id="从_Foursquare_上读取地理信息">从 Foursquare 上读取地理信息</h2><p>你以为到这一步就完了吗？其实并没有，还会有更有趣的事情！我们还需要使用 Das Quadrat 来读取 Foursquare 上的数据，然后用 Realm 将数据存入本地。</p>
<p>在使用 Foursquare 的 API 之前，首先需要到开发者中心注册这个 app 。这个步骤很简单。（译者注：如果只是练习，没必要去注册，直接使用作者提供的 Client ID 和 Client Secret 即可）</p>
<ul>
<li>首先，确保你有一个 Foursquare 账号，没有可以去注册一个：<a href="https://foursquare.com/" target="_blank" rel="external">foursquare.com</a>。</li>
<li>然后，进入 <a href="https://developer.foursquare.com/" target="_blank" rel="external">developer.foursquare.com</a>，点击顶部蓝色菜单栏中的 My Apps 。</li>
<li>接着，点击右边绿色的 new app 按钮。</li>
<li>接着，填写以下信息：<ul>
<li>App Name： Coffee</li>
<li>Download / Welcome page URL: <a href="http://example.com" target="_blank" rel="external">http://example.com</a></li>
</ul>
</li>
<li>最后，点击保存</li>
</ul>
<p>保存以后，网页自动跳转到了你创建的 app 页面。记录下 Client ID 和 Client Secret ，之后会用到。（译者注：作者提供的 Client ID 和 Client Secret 在后面的代码里有提供）</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_15.png" alt=""></p>
<h2 id="构建_Foursquare_API_连接">构建 Foursquare API 连接</h2><p>OK，下面开始连接 Foursquare API 。这里我们会用到单例模式。我们要做的部分用单例模式简直是完美。</p>
<p>单例是一个类的实例，它在整个 app 生命周期中，只允许有一份拷贝。所以你不能去创建第二个实例。为什么要使用单例呢？虽然单例的使用饱受争议，但是它有一个明显的优势：可以避免对外部资源发起并发连接。</p>
<p>设想一下。如果对网站同时发起两个请求，并且他们会写入同一个特定的文件，会发送什么呢？这样就很有可能读到脏数据，除非网站知道这两个请求发起的先后顺序。</p>
<p>而单例就能确保只有 app 的一部分能访问外部资源。在单例中，有很多种实现方式能保证没有请求冲突存在。将请求加入队列并添加依赖就是其中一种解决方案。这又是一个很大的主题，本文不进行讲解。</p>
<p>不扯了，继续实现：</p>
<ul>
<li>在工程目录中，右键点击 Coffee 文件夹。</li>
<li>选择 New File。</li>
<li>选择 iOS -&gt; Source 中的 Swift File ，点击继续。</li>
<li>文件命名为 <code>CoffeeAPI.swift</code> ，确认 target 中的 Coffee 是选中状态，选择和其他 swift 文件统计目录，点击 Create ，保存文件。</li>
</ul>
<p>Whoah，新文件里面空空如也！让我们来加点料吧。在 import 代码的后面，添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QuadratTouch</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"><span class="keyword">import</span> RealmSwift</span><br></pre></td></tr></table></figure>
<p>然后，添加：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">API</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">notifications</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">let</span> venuesUpdated = <span class="string">"venues updated"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简洁对吧。首先，你正确地引入了一些需要的库（Quadrat, MapKit, Realm），然后使用 <code>struct</code> 创建了一个名为 <code>venuesUpdated</code> 的静态常量。之后，通过以下方式访问该变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">API</span>.notifications.venuesUpdated</span><br></pre></td></tr></table></figure>
<p>接着，键入：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeAPI</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">CoffeeAPI</span>()</span><br><span class="line">    <span class="keyword">var</span> session:<span class="type">Session</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的作用：</p>
<ul>
<li>告诉 Xcode 编译器，当前类名为 <code>CoffeeAPI</code> 。这是一个单独的 Swift 类，没有继承 <code>NSObject</code>。</li>
<li>声明一个静态常量 <code>sharedInstance</code> ，类型为 <code>CoffeeAPI</code> 。这个 <code>sharedInstance</code> 只有 <code>CoffeeAPI</code> 类才能访问，并且在 app 启动的时候就已经被初始化了。</li>
<li>声明一个类型为 <code>Session?</code> 的可选变量 <code>session</code> （该类型包含在 <code>Das Quadrat</code> 中）。</li>
</ul>
<p>之后，我们访问 Coffee API 单例的方式都将是 <code>CoffeeAPI.sharedInstance</code> 。你可以在任何地方，通过这种方式访问单例，并且，访问的都是同一个对象，这也正是单例的一大特点。</p>
<p>接着，需要写一个构造器。给当前类添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Initialize the Foursquare client</span></span><br><span class="line">    <span class="keyword">let</span> client = <span class="type">Client</span>(clientID: <span class="string">"..."</span>, clientSecret: <span class="string">"..."</span>, redirectURL: <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> configuration = <span class="type">Configuration</span>(client:client)</span><br><span class="line">    <span class="type">Session</span>.setupSharedSessionWithConfiguration(configuration)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.session = <span class="type">Session</span>.sharedSession()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器是一个会在类实例化的时候调用的方法。这也是实例化时，系统自动调用的第一个方法。</p>
<p>还记得之前在 Foursquare 开发者网站上复制的  Client ID 和 Client Secret 吗？粘贴到下面代码中。可以先不填 <code>redirectURL</code> 参数。向下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> client = <span class="type">Client</span>(clientID: <span class="string">"X4I3CFADAN4MEB2TEVYUZSQ4SHSTXSZL34VNP4CJHSJGLKPV"</span>, clientSecret: <span class="string">"EDOLJK3AGCOQDRKVT2GK5E4GECU42UJUCGGWLTUFNEF1ZXHB"</span>, redirectURL: <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>OK，继续。复制下面的代码，粘贴在 <code>CoffeeAPI</code> 类外面（即最后的大括弧的后面）。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CLLocation</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">parameters</span><span class="params">()</span></span> -&gt; <span class="type">Parameters</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ll      = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.coordinate.latitude)</span>,<span class="subst">\(<span class="keyword">self</span>.coordinate.longitude)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> llAcc   = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.horizontalAccuracy)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> alt     = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.altitude)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> altAcc  = <span class="string">"<span class="subst">\(<span class="keyword">self</span>.verticalAccuracy)</span>"</span></span><br><span class="line">        <span class="keyword">let</span> parameters = [</span><br><span class="line">            <span class="type">Parameter</span>.ll:ll,</span><br><span class="line">            <span class="type">Parameter</span>.llAcc:llAcc,</span><br><span class="line">            <span class="type">Parameter</span>.alt:alt,</span><br><span class="line">            <span class="type">Parameter</span>.altAcc:altAcc</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> parameters</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这又是什么呢？这是一个 <code>extension</code> ，可以给当前类扩展其他的方法（译者注：关于 <code>extension</code> 的知识点，可以查看 SwiftGG 翻译组的其他文章：<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/21_Extensions.html" target="_blank" rel="external">扩展基础知识</a>。延伸到程序结构设计方面，还有进阶的 <a href="http://swift.gg/2015/12/15/mixins-over-inheritance/" target="_blank" rel="external">Mixins 比继承更好</a>）。无需创建新的类，就可以给 <code>CLLocation</code> 类扩展一个名为 <code>parameters()</code> 的方法。每次使用 <code>CLLocation</code> 的实例时，这个 <code>extension</code> 就会被加载，你可以通过实例来调用 <code>parameters</code> 方法，即使这个方法没包含在原生的 <code>MapKit</code> 中。</p>
<p>注意：不要混淆 Swift 中 <code>extension</code> 和编程术语 <code>extend</code> 。前者是给基类添加新的方法，后者意思是父类与子类间的继承关系。</p>
<p><code>parameter</code> 方法返回一个 <code>Parameters</code> 的实例对象。<code>Parameters</code> 是一个字典，里面包含了一些参数信息（ GPS 坐标和精度）。（译者注：<code>Parameters</code> 是在 <code>Session.swift</code> 中定义的 <code>typealias</code>，完整定义为：<code>public typealias Parameters = [String:String]</code> ）。</p>
<h2 id="给_Foursquare_发送请求">给 Foursquare 发送请求</h2><p>接下来，让我们从 Foursquare 获取数据吧。Foursquare 内部有一个 HTTP REST API 可以返回 JSON 数据。幸运的是，我们不需要知道这些，因为 Das Quadrat 库已经帮我们搞定了一切。</p>
<p>从 Foursquare 请求数据就和调用 <code>session</code> 里的属性一样简单，同时请求数据使用的是该属性里很多方法中的一个。这个方法返回一个 <code>Task</code> 的实例对象，即异步后台任务的引用。我们可以用闭包的形式实现，代码大致如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> searchTask = session.venues.search(parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        (result) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do something with "result"</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>session</code> 里的地理属性包含了与 Foursquare API 通讯的所有 venues 信息。你提供的这个 search 方法是带有参数（上段代码中的 parameters ）的，还有第二个闭包作为参数，该闭包会在 search 方法完成后执行。同时，该方法会返回一个耗时的后台 <code>Task</code> 引用。你可以在任务完成之前用它来停止，或着在你代码的其他地方用它检查进度。</p>
<p>OK，现在来看看下面这个方法。复制并粘贴到你的代码里，即放在初始构造函数的后面，但在 CoffeeAPI 这个类的右括号前面。接下来，我们会看到这个方法的用途。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getCoffeeShopsWithLocation</span><span class="params">(location:CLLocation)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> session = <span class="keyword">self</span>.session</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> parameters = location.parameters()</span><br><span class="line">        parameters += [<span class="type">Parameter</span>.categoryId: <span class="string">"4bf58dd8d48988d1e0931735"</span>]</span><br><span class="line">        parameters += [<span class="type">Parameter</span>.radius: <span class="string">"2000"</span>]</span><br><span class="line">        parameters += [<span class="type">Parameter</span>.limit: <span class="string">"50"</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start a "search", i.e. an async call to Foursquare that should return venue data</span></span><br><span class="line">        <span class="keyword">let</span> searchTask = session.venues.search(parameters)</span><br><span class="line">            &#123;</span><br><span class="line">                (result) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> response = result.response</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> venues = response[<span class="string">"venues"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">AnyObject</span>]]</span><br><span class="line">                    &#123;</span><br><span class="line">                        autoreleasepool</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">                                realm.beginWrite()</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">for</span> venue:[<span class="type">String</span>: <span class="type">AnyObject</span>] <span class="keyword">in</span> venues</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">let</span> venueObject:<span class="type">Venue</span> = <span class="type">Venue</span>()</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> id = venue[<span class="string">"id"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        venueObject.id = id</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> name = venue[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        venueObject.name = name</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span>  <span class="keyword">let</span> location = venue[<span class="string">"location"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">AnyObject</span>]</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> longitude = location[<span class="string">"lng"</span>] <span class="keyword">as</span>? <span class="type">Float</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            venueObject.longitude = longitude</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> latitude = location[<span class="string">"lat"</span>] <span class="keyword">as</span>? <span class="type">Float</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            venueObject.latitude = latitude</span><br><span class="line">                                        &#125;</span><br><span class="line"></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> formattedAddress = location[<span class="string">"formattedAddress"</span>] <span class="keyword">as</span>? [<span class="type">String</span>]</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            venueObject.address = formattedAddress.joinWithSeparator(<span class="string">" "</span>)</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    realm.add(venueObject, update: <span class="literal">true</span>)</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">do</span> &#123;</span><br><span class="line">                                    <span class="keyword">try</span> realm.commitWrite()</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"Committing write..."</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">catch</span> (<span class="keyword">let</span> e)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="built_in">print</span>(<span class="string">"Y U NO REALM ? <span class="subst">\(e)</span>"</span>)</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">API</span>.notifications.venuesUpdated, object: <span class="literal">nil</span>, userInfo: <span class="literal">nil</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        searchTask.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么多代码，你能从里面分辨出它完成的 5 个主要的任务吗？</p>
<ol>
<li>配置并启动 API 请求。</li>
<li>使用闭包实现请求的 Completion handler。</li>
<li>解析请求返回的数据，并开启 Realm 事务来处理。</li>
<li>使用 for-in 循环遍历所有的地理数据。</li>
<li>在 Completion handler 的最后发送通知。</li>
</ol>
<p>接下来，让我们一行行的来解释一下：</p>
<h3 id="设置请求的准备动作">设置请求的准备动作</h3><p>首先，使用可选绑定检查 <code>self.session</code> 是否为空。如果非空的话，常量 <code>session</code> 会被赋值解包后的值。</p>
<p>接着，<code>location</code> 的 <code>parameters()</code> 方法被调用。你问这个 <code>location</code> 是从哪里来的？你可以看下 <code>getCoffeeShopsWithLocation</code> 方法后面的那个参数。每次你调用这个方法，你也必须传入一个 <code>location</code> 参数，并检查传入的参数是不是你之前写的。</p>
<p>最后，我们添加了一个新的数据项到 <code>parameters</code> 字典。该数据项使用 <code>Parameter.categoryId</code> 作为 key ，字符串 <code>4bf58dd8d48988d1e0931735</code> 作为 value 。这个字符串就是之前 Foursquare 上 <code>Coffeeshops</code> 目录的编号，因此，没什么特殊的。</p>
<h3 id="配置请求">配置请求</h3><p>接着，让我们来配置真正的请求。获取 <code>session</code> 的 <code>venues</code> ，并开始搜寻这个 <code>venues</code> 。该方法有两个参数：你刚才创建的 <code>parameters</code> 字典和闭包。现在使用的闭包的形式叫尾随闭包（ trailing closure ）。它作为该方法的最后一个参数，没有采用圆括号括起来的形式，而是将它写在方法外部并用大括号括起来。这是个很耗时的方法，因此，我们并没有让它自动开始执行，而是在本方法的末尾再执行。</p>
<h3 id="书写闭包">书写闭包</h3><p>接着，我们进到闭包里去看看。值得注意的一点是，尽管这些代码看上去连续的，但是它们不会一个一个按你看到的顺序执行。该闭包会在搜寻任务完成后执行。当数据从 HTTP API 返回到应用中时，代码会从 <code>let searchTask …</code> 这行执行到 <code>searchTask.start()</code> 这行，接着会跳到 <code>if let response = …</code> 这行。</p>
<p>闭包的格式是这样的：<code>(result) -&gt; Void in</code> 。 <code>result</code> 作为闭包里的参数是可以拿到值的，并且该闭包没有返回值（ <code>Void</code> ）。这一点和普通的方法有点相似。</p>
<h3 id="解析数据">解析数据</h3><p>接着，我们使用了 <code>if</code> 可选绑定：</p>
<ul>
<li>如果 <code>result.response</code> 非空，就将其赋值给常量 <code>response</code> ，并继续执行 <code>if</code> 条件内的语句。</li>
<li>如果 <code>response[“venues”]</code> 非空，并且可以转换成 <code>[[String: AnyObject]]</code> 类型。</li>
</ul>
<p>这个类型转换可以确保我们拿到的是正确的类型。如果转换失败，即可选绑定失败，就不会执行 <code>if</code> 条件内的语句。这个方法有一石二鸟的效果：检查对应的值是否为空，同时尝试将数据转换成合适的类型。</p>
<p>你能说一下 <code>venues</code> 的类型是什么吗？首先它是一个数组，每个元素是字典类型，每个字典是以 <code>String</code> 类型为 key ， <code>AnyObject</code> 类型为 value 。</p>
<h3 id="自动释放内存">自动释放内存</h3><p>接着，我们开启了一个自动释放池。自动释放池本身就是一个很大的话题。你知道 iPhone 是如果进行内存管理的吗？</p>
<p>本质上来说，内存里的对象在没有被使用时，会在某个时间点从内存里被移除。有点类似垃圾回收，但还是有点区别的。当自动释放池里的一个变量被释放时，这个变量就和这个自动释放池紧紧联系在一起了。当这个自动释放池自己要被释放时，在内的所有变量的内存也会一起被释放。这个有点像，对内存释放的批处理。</p>
<p>为什么要这么做呢？因为，可以通过创建自己的自动释放池，来帮助 iPhone 系统管理内存。我们在处理数以百计的地理对象时，如果没有放在自己的自动释放池里，内存就会被未释放的内存拥塞了。而，能释放这些内存的时间点是在该方法结束的时候。因此，你在冒着用光内存的风险操作（自动释放的机理导致不会立马释放无用的内存）。使用自己创建的自动释放池，你就可以影响内存释放的时间点并能避免被内存不足困扰。（译者注：ARC 下，在方法内创建的临时变量，系统都会自动加上 <code>__strong</code> 修饰符，并在出该变量作用域时，进行 <code>release</code> 。所以，一般在处理有大量的临时变量的方法时，会自己加上 <code>autoreleasepool</code> ，提前释放已经不用的临时变量，及时释放内存。）</p>
<h3 id="开启_Realm">开启 Realm</h3><p>接着，你用 <code>let realm = try! Realm()</code> 这样一行代码初始化了一个 Realm 对象。你在从 Realm 获取数据之前肯定需要有一个 Realm 对象。 <code>try!</code> 关键字是 Swift 的一种错误处理。用了这个关键字，我们其实声明了：当前不会处理来自 Realm 的错误。虽然这样的做法对生产环境来说并不推荐，但是可以让我们的代码变得相当简单。</p>
<h3 id="开启事务处理">开启事务处理</h3><p>接下来，调用 Realm 实例方法 <code>beginWrite</code> 。其实这代码开启了一个事务。让我们先来谈谈效率的问题。以下哪种方式更高效：</p>
<ul>
<li>创建一个文件指针，打开文件，写入 1x 数据到文件里，关闭文件，再重复之前的步骤直到写入 50x 数据。</li>
<li>创建一个文件指针，打开文件，写入 50x 数据到文件里，关闭文件。</li>
</ul>
<p>确切地说，当然是后者更高效。和其他数据库系统一样， Realm 也是把数据存储在文本文件里的。文件处理就意味着：操作系统（ operation system ， OS ）需要打开着文件，赋予程序写入权限，并让程序可以一个字节一个字节的向文件里写入数据。</p>
<p>你需要使用打开一次文件，一次写入 50 个 Realm 对象的方式，而不是一次次的写入文件。因为，每个对象之间非常相似，它们可以被连续地写入。这种方式更快一点，其实这就是事务。</p>
<p>为了完整性，如果事务中的一次写入失败了，那么所有的写入都会失败。这种机制其实来源于银行和账户：如果你写入了 50 个事务到一个分类账簿，而其中的一个（比如，账上没有钱）被证明是错误的，但是你又不能找出来。你必须阻止这种“污染”整个账簿的行为。这时候使用事务就再好不过了，成功都写入，失败都回滚，这样的方式也能减少数据出错的风险。</p>
<h3 id="遍历地理数据">遍历地理数据</h3><p>OK，现在来看看 for-in 循环。你已经可选绑定上面创建了 <code>venues</code> 变量。在 for-in 循环遍历整个数组时，每次循环里都是数组中的一个元素：<code>venue</code>。</p>
<p>首先，创建了一个 <code>Venue</code> 类型的 <code>venueObject</code> 变量。这行代码暂时会报错，因为现在还没有一个类叫 <code>Venue</code> 。你等会就会添加这个类的，因此先放一边吧。</p>
<p>接着，一系列的可选绑定来了。每个可选绑定都尝试去访问 <code>venue</code> 的键值对（ key-value pair ），同时尝试将其转换成合适的类型。举个例子，当 <code>venue</code> 包含一个键 <code>id</code> ，并尝试转换成 <code>String</code> 类型，假如成功的话，会将 <code>venueObject</code> 的 <code>id</code> 属性赋值给它。</p>
<p><code>location</code> 的可选绑定看上去复杂一点，但是其实一点也不复杂。仔细看，你会发现 <code>lat</code> 、 <code>lng</code> 、 <code>formattedAddress</code> 这些都是<code>location</code> 的一部分 key （并不是 <code>venue</code> 的）。它们其实在数据结构中是属于同一层的。</p>
<p>接下来，是 for-in 循环最后一行代码：<code>realm.add(venueObject, update: true)</code> 。这行代码会把 <code>venueObject</code> 添加到 Realm，并写入到数据库（仍然是以事务的形式写入）。方法中的第二个参数 <code>update</code> 表示：当对应传入的对象已经存在，就用新数据覆盖掉之前写入的数据。之后，你会发现每个 <code>Venue</code> 对象都有一个唯一的编号，所以 Realm 可以根据编号知道对象已经存在。</p>
<h3 id="错误处理">错误处理</h3><p>OK，现在 Realm 已经将事务中所有要写入的数据保存起来了，接下来将尝试写入到 Realm 数据库。这一步当然也有可能出错了。庆幸的是，这里可以使用 Swift 的错误处理机制。步骤如下：</p>
<ol>
<li>尝试执行可能出错的操作。</li>
<li>如果出错，就抛出错误。</li>
<li>操作的调用者抓住对应错误。</li>
<li>进行错误处理。</li>
</ol>
<p>在大多数语言里，这种机制以 try-catch 闻名，但是 Swift 称它为 do-catch （同时，也将 do-while 重命名为 repeat-while ）。你的代码大概是这样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> realm.commitWrite()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Committing write..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">let</span> e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Y U NO REALM ? <span class="subst">\(e)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>realm.commitWrite()</code> 这行代码就是在尝试执行可能出错的操作。同时，这行代码前面写了 <code>try</code> 。回到你之前写 <code>try!</code> 的地方，<code>try!</code> 会摒弃错误。（译者注：<code>try!</code> 表示禁用错误传递，如果抛出错误，那么程序崩溃。一般用于，你知道这个步骤不会出错的情况。关于错误处理，可以看 SwiftGG 翻译组翻译的 Swift 官方文档：<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/18_Error_Handling.html" target="_blank" rel="external">错误处理</a>）。</p>
<p>当在 <code>do { }</code> 代码块里产生错误的时候， <code>catch</code> 代码块就会执行。它只有一个参数，<code>let e</code>，它会包含异常的具体信息。在后面的代码块里，我们将具体的错误信息打印出来。当程序运行过程中出现错误了，打印的信息就会告诉我们错误到底是由什么异常引起的。</p>
<p>这里的这个错误处理是很基础的。设想一下，一个错误处理很完善的系统，不仅仅需要抓住出错信息，还要对错误信息进行一下处理。举个例子，当你写数据到文件，而磁盘满了的时候，你就需要弹窗让用户知道磁盘已经满了。在较早版本的 Swift 中，处理错误比现在更艰难，而且如果你不处理得当，程序就崩溃了。</p>
<p>Swift 的错误处理或多或少还是加强了。你要不处理错误，要不摒弃掉错误，但是不管怎么样也不能忽视错误。处理错误可以让你的代码更健壮，因此，养成多使用 do-catch 处理错误的习惯，而不是使用 <code>try!</code> 来摒弃错误。</p>
<p>OK，该方法中还有最后两行代码，第一行如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().postNotificationName(<span class="type">API</span>.notifications.venuesUpdated, object: <span class="literal">nil</span>, userInfo: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码会给整个应用中监听它的地方发送一个通知。这实际上是应用中的通知机制，可以高效的将事件传递到应用中的不同位置。考虑到你刚从 Foursquare 获取到新数据，你可能要去更新显示数据的 table view ，也可能要更新代码的其他部分。通知是完成这个操作最好的方式了。</p>
<p>请牢记，通知会一直保留在发送它的那个线程上。如果你在主线程外（比如，发送通知的线程）更新你的 UI ，你的应用就会崩溃并抛出错误。</p>
<p>注意到这行代码里的硬编码 <code>API.notifications.venuesUpdated</code> 了吗？本来我们可以写成 <code>&quot;venuesUpdated&quot;</code> 的字符串， 而不是 <code>API.notifications.venuesUpdated</code>。使用硬编码的编译时常量能让你的代码更安全。如果你出错，编译器会报错。但是，如果你使用字符串的方式，拼写错 <code>&quot;venuesUpdated&quot;</code> ，编译器就不会报错了。</p>
<p>最后，闭包外的这行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">searchTask.start()</span><br></pre></td></tr></table></figure>
<p>再次注意，这行代码会在 <code>let searchTask …</code> 后执行，且和上面一大段闭包是独立的。这行代码到底是干什么的呢？现在，我们已经设置好请求，配置好所有需要的参数，这行代码就是让这个搜寻任务启动起来。</p>
<p>Das Quadrat 发送一条消息到 Foursquare ，等待数据的返回，然后就执行了处理数据的闭包。懂了吧？</p>
<p>暂时把这些代码放一边，因为接下来我们要写 <code>Venue</code> 对象了。</p>
<h2 id="编写_Realm_Venue_对象">编写 Realm Venue 对象</h2><p>你知道 Realm 酷在什么地方吗？它整个代码结构是很简短的。本质上来说，你只需要一个类文件就可以写 Realm 了。你创建了一系列的实例对象，把它们写到 Realm 文件中，然后 BAM！你已经完成了你自己的本地数据库。</p>
<p>Realm 有一系列很赞的特性，比如排序、过滤以及支持 Swift 数据类型。你再也不需要在 table view 里使用 Core Data 的 <code>NSFetchedResultsController</code> 来加载成千上万的对象。Realm 也有它自己的数据浏览器。</p>
<p>OK，接下来该写 Realm Venue 对象了。步骤如下：</p>
<ul>
<li>右击 Xcode 中 Project Navigator 的 Coffee 这个文件夹。</li>
<li>点击 <code>New File …</code> ，从 iOS -&gt; Source 目录选择 Swift 文件，并点击 <code>Next</code> 。</li>
<li>将新建的文件命名为 <code>Venue.swift</code> ，并确保选中了 Coffee 这个 target 。</li>
<li>最后，点击 <code>Create</code> 完成创建。</li>
</ul>
<p>好吧，又是一个无内容的文件。这个文件将会包含 Realm 的 Venue 对象的代码。</p>
<p>首先导入正确的库。在 Foundation 的导入代码添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RealmSwift</span><br><span class="line"><span class="keyword">import</span> MapKit</span><br></pre></td></tr></table></figure>
<p>接着，键入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Venue</span>: <span class="title">Object</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就为 Venue 新建了一个类。其中，这个冒号表示当前类继承自 <code>Object</code> 类。这其实是面向对象编程（ Object Oriented Programming ）中父类和子类之间的继承关系。此处代码就是将 <code>Venue</code> 类继承自 <code>Object</code> 类。</p>
<p>简单来说，作为一个子类会自动将父类的所有方法和属性拷贝到自己的类中。值得注意的是，这和我们之前使用的 <code>extension</code> 是不一样的，它是为现有的类添加新的方法，而没有创建一个独立的新类。</p>
<p>接着，将以下代码拷贝到该类中，记得要添加在大括号的范围内：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> id:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> latitude:<span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> longitude:<span class="type">Float</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> address:<span class="type">String</span> = <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>这些句子是什么意思呢？就是为这个类添加了 5 个属性。你可以像使用 <code>CoffeeAPI</code> 的代码那样，使用这些属性为类实例添加数据。</p>
<p>属性中的 <code>dynamic</code> 关键字可以确保该属性能被 Objective-C 运行时访问。这本身是另外一个主题，但是我们先假设 Swift 的代码和 Objective-C 代码在各自的 “沙盒” 里运行。在 Swift 2.0 之前，所有的 Swift 代码都是运行在 Objective-C 运行时里，但是现在 Swift 已经有自己的运行时了。我们用 <code>dynamic</code> 关键字修饰属性，就可以让 Objective-C 运行时访问到这个属性，因为 Realm 需要在内部用到该属性。</p>
<p>每个属性都是 <code>String</code> 或  <code>Float</code> 类型。 Realm 本身支持一些变量类型，包括 <code>NSData</code> 、<code>NSDate</code> 、<code>Int</code> 、<code>Float</code> 、<code>String</code> 等等。</p>
<p>接下来，在 <code>address</code> 属性下面添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> coordinate:<span class="type">CLLocation</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CLLocation</span>(latitude: <span class="type">Double</span>(latitude), longitude: <span class="type">Double</span>(longitude));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性的值要计算后才会有。它不能保存到 Realm 里，因为它的类型没有包含在 Realm 本身支持的类型中。这个属性保存的是表达式的结果值。它就像一个方法，但是接着它就可以用属性来访问了。以上属性返回的是一个 <code>CLLocation</code> 实例对象，它有 <code>latitude</code> 和 <code>longitude</code> 两个属性。</p>
<p>这种使用方法很便利，因为我们只需要访问 <code>venueObject.coordinate</code> 就能获得对应类型的实例，而不用我们自己创建。</p>
<p>OK，接下来，粘贴以下代码到最后的代码块下面：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">primaryKey</span><span class="params">()</span></span> -&gt; <span class="type">String</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"id"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个新出现的方法，它重写了父类 <code>Object</code> 的方法。这个自定义方法可以返回一个 Realm 的主键（ primary key ）。主键就是唯一标识。每个 Realm 数据库中的对象有且仅有一个唯一的值作为主键，就像一个村庄里的房子必须有且仅有一个唯一的地址一样。</p>
<p>Realm 会用主键去区分一个个不同的对象，并确定当前这个对象是否唯一。</p>
<p>该方法的返回值类型为 String，因此我们就可以返回主键对应的属性名或者返回 <code>nil</code>（不使用主键的情况）。</p>
<p>Realm 对象的属性（比如，<code>id</code> 和 <code>name</code>）类似于电子表格里的列。方法返回的主键返回值即是每一列的名字，其实就是 <code>id</code> 。</p>
<p>现在，我们需要按 Command-B 来编译当前应用，并确保没有报错。我们没必要运行当前的应用，因为我们没有改变前端的展示代码。取而代之的是，我们只要检查编译应用时候是否有报错。如果你这时候去查看 <code>CoffeeAPI.swift</code> 文件，之前关于 <code>venueObject</code> 的错误已经不存在了。</p>
<h2 id="在_Map_View_中展示地理数据">在 Map View 中展示地理数据</h2><p>OK，现在让我们来处理下载下来的数据吧。你将要把它们放入之前创建的 map view 里以注释（annotation）的形式展示。</p>
<p>首先，切换到 <code>ViewController.swift</code> 文件。检查用来在 map view 上显示用户位置的代码。</p>
<p>接着，在文件的最上部，添加如下的导入语句：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> RealmSwift</span><br></pre></td></tr></table></figure>
<p>接着，在类的最上部，添加以下这些属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastLocation:<span class="type">CLLocation</span>?</span><br><span class="line"><span class="keyword">var</span> venues:<span class="type">Results</span>?</span><br></pre></td></tr></table></figure>
<p>你需要 RealmSwift 库来支持你使用 Realm，并且你需要这两个属性分别处理位置和地理数据。</p>
<p>接下来，定位到文件中的 <code>locationManager:didUpdateToLocation:fromLocation</code> 方法。在该方法的右大括号后面，粘贴以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">refreshVenues</span><span class="params">(location: CLLocation?, getDataFromFoursquare:Bool = <span class="literal">false</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> location != <span class="literal">nil</span></span><br><span class="line">    &#123;</span><br><span class="line">        lastLocation = location</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> location = lastLocation</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> getDataFromFoursquare == <span class="literal">true</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">CoffeeAPI</span>.sharedInstance.getCoffeeShopsWithLocation(location)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"></span><br><span class="line">        venues = realm.objects(<span class="type">Venue</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> venue <span class="keyword">in</span> venues!</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> annotation = <span class="type">CoffeeAnnotation</span>(title: venue.name, subtitle: venue.address, coordinate: <span class="type">CLLocationCoordinate2D</span>(latitude: <span class="type">Double</span>(venue.latitude), longitude: <span class="type">Double</span>(venue.longitude)))</span><br><span class="line"></span><br><span class="line">            mapView?.addAnnotation(annotation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whoah，好长的方法，它是怎么执行的呢？</p>
<p>让我们从 <code>location</code> 的两行判断语句说起吧。第一行检查了 <code>location</code> 是否非空，第二行使用可选绑定检查了 <code>lastLocation</code> 属性是否非空。</p>
<p>虽然这两行代码看上去很相似，但是其实干的事情是不同的。让我们退一步想想。检查以下陈述是否是真实的：</p>
<ul>
<li>应用中的所有位置数据都来源于 <code>locationManager:didUpdateToLocation:fromLocation</code> 方法。即，该方法是唯一一个能获取到 <code>CLLocation</code> 实例（数据来自 GPS 硬件数据）的地方。</li>
<li><code>refreshVenues</code> 方法需要一个位置作为参数，该参数可能为空。</li>
<li><code>refreshVenues</code> 方法可能会在没有可用的位置时被调用。比如，在代码里，一个与位置数据方法没有联系的地方就调用 <code>refreshVenues</code> 方法。</li>
</ul>
<p>最后一句陈述很重要。其实也很简单：因为我们不一定要在获取到最新地理位置（<code>locationManager:didUpdateToLocation:fromLocation</code> ）时，才进行位置保存，所以，我们需要将保存位置的功能单独封装出来（封装为 <code>refreshVenues</code> 方法）。</p>
<p>因此，每次调用 <code>refreshVenues</code> 方法时，如果 <code>lastLocation</code> 属性非空的话，我们会将 <code>location</code> 参数保存起来。然后，我们会用可选绑定检查 <code>lastLocation</code> 是否为空。<code>if</code> 语句只会在有值的时候执行，因此我们可以 100% 确定 <code>if</code> 语句里的代码块肯定会包含一个有效的 GPS 位置信息！</p>
<p>当然，前提是 <code>refreshVenues</code> 方法确实获取到了位置数据。你肯定要确保它是非空的。如果你还是不太理解的话，可以重新读一下上一段内容。这样的代码非常优雅，而且这样的编码还可以确保你的应用数据是安全的且仍然是解耦的。</p>
<p>OK，<code>refreshVenues</code> 方法里的下一行代码讲了什么呢？该代码块里使用了 <code>CoffeeAPI</code> 单例来从 <code>Foursquare</code> 请求数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> getDataFromFoursquare == <span class="literal">true</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">CoffeeAPI</span>.sharedInstance.getCoffeeShopsWithLocation(location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码只会在 <code>getDataFromFoursquare</code> 这个变量为 <code>true</code> 的时候执行。这是一种简单的使用 CoffeeAPI 请求数据方式。你要事先监听 CoffeeAPI 里的通知，才能在获取数据完成的时候，得到状态的更新。我们会在稍后实现该功能。</p>
<p>在请求数据之后，是以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">venues = realm.objects(<span class="type">Venue</span>)</span><br></pre></td></tr></table></figure>
<p>这些代码看上去是不重要的，但是代码的主体却是在这几句上。首先，实例化 <code>Realm</code> 。然后，所有从 <code>Realm</code> 获取来的 <code>Venue</code> 类的对象都保存到 <code>venues</code> 这个属性里。该属性的类型是 <code>Results?</code>，该类型是以 <code>Venue</code> 实例为元素的数组。</p>
<p>最后，for-in 循环遍历 <code>venues</code>，并将每个元素以注释（annotation）的样式添加到 map view 里。这段代码很可能会报出错误，但我们将会解决掉它的。</p>
<h2 id="创建注释（Annotation）类">创建注释（Annotation）类</h2><p>创建注释类，需要以下步骤：</p>
<ol>
<li>右击 Coffee 文件夹，选择 <code>New File …</code> 。</li>
<li>从 iOS -&gt; Source 目录里选择 Swift 文件并点击 <code>Next</code> 。</li>
<li>将该 Swift 文件命名为 <code>CoffeeAnnotation</code>，并点击 <code>Create</code> 。</li>
</ol>
<p>然后，将以下代码粘贴到该文件里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MapKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeAnnotation</span>: <span class="title">NSObject</span>, <span class="title">MKAnnotation</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> title:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> subtitle:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">let</span> coordinate: <span class="type">CLLocationCoordinate2D</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">String</span>?, subtitle:<span class="type">String</span>?, coordinate: <span class="type">CLLocationCoordinate2D</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">self</span>.title = title</span><br><span class="line">        <span class="keyword">self</span>.subtitle = subtitle</span><br><span class="line">        <span class="keyword">self</span>.coordinate = coordinate</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码很简单：</p>
<ul>
<li>你新建了一个名叫 <code>CoffeeAnnotation</code> 的类，它继承自 <code>NSObject</code> 且遵循 <code>MKAnnotation</code> 协议。最后遵循协议的这个部分很重要，要想使用注释，必须要遵循这个 <code>MKAnnotation</code> 协议。</li>
<li>接着，创建了一大串属性。这些属性是由协议决定的，是类的一部分。</li>
<li>最后，还创建了构造器方法。该方法初始化了类的属性。</li>
</ul>
<p>切换回 <code>ViewController.swift</code> 文件，是不是发现原来 <code>CoffeeAnnotation</code> 那里的错误已经消失了？</p>
<p>接下来，添加以下的方法到 <code>ViewController</code> 这个类中。这个方法可以确保添加到地图的注释能被显示出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">mapView</span><span class="params">(mapView: MKMapView, viewForAnnotation annotation: MKAnnotation)</span></span> -&gt; <span class="type">MKAnnotationView</span>?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> annotation.isKindOfClass(<span class="type">MKUserLocation</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> view = mapView.dequeueReusableAnnotationViewWithIdentifier(<span class="string">"annotationIdentifier"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> view == <span class="literal">nil</span></span><br><span class="line">    &#123;</span><br><span class="line">       view = <span class="type">MKPinAnnotationView</span>(annotation: annotation, reuseIdentifier: <span class="string">"annotationIdentifier"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    view?.canShowCallout = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于 table view，map view 也用可重用的实例来让地图上的 <code>pin</code> 显示更平滑。以上代码大概是以以下的步骤展开：</p>
<ul>
<li>首先，检查 <code>annotation</code> 是不是用户的当前位置。</li>
<li>接着，在重用队列中取出 <code>pin</code> （并赋值给 <code>view</code> 变量）。</li>
<li>然后，如果没有 <code>pin</code> 在重用队列中，就创建一个新的。</li>
<li>接着，设置 <code>pin</code> 允许显示 callout（一块小小的用来显示信息的简介）。</li>
<li>最后，返回 <code>view</code> 。</li>
</ul>
<p>值得注意的是，这方法是代理模式的一部分。你之前设置了 <code>map view</code> 的代理为 <code>self</code>。因此，当 <code>map view</code> 准备显示 <code>pin</code> 时，都会调用代理中的 <code>mapView:viewForAnnotation:</code> 方法，应用才能执行到你刚定义的代码。</p>
<p>代理是一种很不错的自定义代码的方式，它不用重载整个类。</p>
<h2 id="回应地理数据的通知">回应地理数据的通知</h2><p>好的，现在让我们把这一切都整理一下。在之前，我们在 <code>ViewController.swift</code> 的 <code>viewDidLoad</code> 方法里添加了以下这行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="type">Selector</span>(<span class="string">"onVenuesUpdated:"</span>), name: <span class="type">API</span>.notifications.venuesUpdated, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码会告诉通知中心（ notification center ），<code>self</code>（当前类）正在监听名为 <code>API.notifications.venuesUpdated</code> 的通知。当发出通知的时候，<code>ViewController</code> 类的 <code>onVenuesUpdated:</code> 方法就会被调用。</p>
<p>添加以下方法到 <code>ViewController</code> 类里：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">onVenuesUpdated</span><span class="params">(notification:NSNotification)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    refreshVenues(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这里到底发生了什么吧：</p>
<ul>
<li>当从 Foursquare 接收到返回的位置数据时，<code>refreshVenues</code> 方法就会被调用。</li>
<li>该方法没有包含位置数据，也没有提供 <code>getDataFromFoursquare</code> 参数。如果没有传入参数，就默认是 <code>false</code>，因此没有向 <code>Foursquare</code> 请求数据。如果传入参数，那么就会再次发起请求，请求结束又会调用该方法，这样就会导致死循环。</li>
<li>本质上来说，从 <code>Foursquare</code> 返回的数据会触发相应方法，从而将注释画到 map view 上去。</li>
</ul>
<p>关于代码，还有一个很重要的部分。添加如下代码到 <code>locationManager:didUpdateToLocation:fromLocation:</code> 方法里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">refreshVenues(newLocation, getDataFromFoursquare: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>这行添加后大概是这样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> mapView = <span class="keyword">self</span>.mapView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(newLocation.coordinate, distanceSpan, distanceSpan)</span><br><span class="line">    mapView.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    refreshVenues(newLocation, getDataFromFoursquare: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码是怎么回事呢？简单来说：调用 <code>refreshVenues</code> 方法获取用户的 GPS 位置。同时，也用 API 向 Foursquare 请求数据。本质上来说，用户每次移动到新的位置都会向 Foursquare 请求数据。由于设置了间隔 50m 就更新，并且注册了通知，所以地图能正常更新。</p>
<p>运行应用并验证一下。是不是很酷？</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_16.png" alt=""></p>
<h2 id="在_Table_View_里显示地理数据">在 Table View 里显示地理数据</h2><p>现在，map view 已经能正常显示了。接着我们将会把同样的地理数据显示到 table view 中。实现起来也是很简单直接的。</p>
<p>首先，添加实例属性和 outlet 到 <code>ViewController</code>。在 <code>mapView</code> 属性下面添加如下的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">var</span> tableView:<span class="type">UITableView</span>?</span><br></pre></td></tr></table></figure>
<p>接着，切换到 <code>Main.storyboard</code> ，选中 View Controller Scene。将 table view 与 IBOutlet 关联。</p>
<p>与以 <code>self.mapView</code> 可选绑定相同的方法，添加如下的代码到 <code>ViewController.swift</code> 的  <code>viewWillAppear:</code> 方法里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> tableView = <span class="keyword">self</span>.tableView</span><br><span class="line">&#123;</span><br><span class="line">    tableView.delegate = <span class="keyword">self</span></span><br><span class="line">    tableView.dataSource = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并将当前的类遵循以下的协议：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">UITableViewDataSource</span>, <span class="type">UITableViewDelegate</span></span><br></pre></td></tr></table></figure>
<p>接着，再添加两个代理中的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> venues?.<span class="built_in">count</span> ?? <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">numberOfSectionsInTableView</span><span class="params">(tableView: UITableView)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法是 table view delegate 协议中方法的一部分。第一个方法确定了 table view 有多少个 cell，而第二个方法确定了 table view 有多少个 section。注意到代码中的 <code>??</code> 了吗？它是空和运算符（nil-coalescing operator）（译者注：如果对空和运算符有什么不理解的话，可以查看<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/02_Basic_Operators.html#nil_coalescing_operator" target="_blank" rel="external">中文版官方文档</a>的说明）。即，如果 <code>venues</code> 是空的话，使用 0 作为默认值。</p>
<p>接着，添加以下方法到 <code>ViewController</code> 类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"cellIdentifier"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cell == <span class="literal">nil</span></span><br><span class="line">    &#123;</span><br><span class="line">        cell = <span class="type">UITableViewCell</span>(style: <span class="type">UITableViewCellStyle</span>.<span class="type">Subtitle</span>, reuseIdentifier: <span class="string">"cellIdentifier"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> venue = venues?[indexPath.row]</span><br><span class="line">    &#123;</span><br><span class="line">        cell!.textLabel?.text = venue.name</span><br><span class="line">        cell!.detailTextLabel?.text = venue.address</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分都是易懂的代码。大致步骤如下：</p>
<ul>
<li>从重用队列中取出一个 cell。</li>
<li>如果没有 cell 存在，就以 <code>Subtitle</code> 的样式创建一个新的 cell 。</li>
<li>如果 <code>venues</code> 数组的第 <code>indexPath.row</code> 个元素存在，就赋值给常量 <code>venue</code> 。使用该数据去填充 cell 的 <code>textLabel</code> 和 <code>detailTextLabel</code> 。</li>
<li>返回 cell 。</li>
</ul>
<p>和 map view 的类似， 当 table view 需要一个 table cell 的时候，就会调用 <code>tableView:cellForRowAtIndexPath:</code> 方法。你可以使用该方法来自定义你的 table view cell。这比写个子类简单多了。</p>
<p>接下来，是 table view 的最后一个方法。把一些方法添加到 <code>ViewController</code> 类中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> venue = venues?[indexPath.row]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(<span class="type">CLLocationCoordinate2D</span>(latitude: <span class="type">Double</span>(venue.latitude), longitude: <span class="type">Double</span>(venue.longitude)), distanceSpan, distanceSpan)</span><br><span class="line">            mapView?.setRegion(region, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户点击 cell 时，就会调用这个代理方法。代码的内容是比较简单的：当 <code>venues</code> 数组的第 <code>indexPath.row</code> 个元素存在时，使用它去填充该数据项所在区域的 map view。换句话说，把点击的项显示到 map view 的中心。</p>
<p>现在唯一剩下的事情就是，当通知事件发生时，及时地刷新 table view 数据。当数据更新时，你就想要把它们显示出来。</p>
<p>在第二个 <code>if</code> 条件判断的末尾，添加以下这行代码到 <code>refreshVenues:</code> 方法。定位到 <code>if let location = lastLocation</code> 这行代码，在该语句的有括号后面，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">tableView?.reloadData()</span><br></pre></td></tr></table></figure>
<p>OK，现在检查一下应用能否运行。使用 Command-R 编译并运行后验证结果。如果所有的设置都正确的话，地理数据会在 table view 中显示出来。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_17.png" alt=""></p>
<h2 id="基于位置过滤地理数据">基于位置过滤地理数据</h2><p>OK，现在有个奇怪的现象，即 table view 显示了所有的数据。如果你在应用中点击过日本，然后点了旧金山，仍然会将日本的咖啡店显示在 table view 里。</p>
<p>我们当然不想要这样。因此，让我们使用一些 Realm 的小魔法只让准确的数据显示。</p>
<p>首先，把 <code>ViewController</code> 类中的 <code>venues</code> 属性改变一下。不再使用 <code>Results?</code>，而是设置为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> venues:[<span class="type">Venue</span>]?</span><br></pre></td></tr></table></figure>
<p>两者之间的区别，只是类型不同而已。之前那种是包含 <code>Venue</code> 对象的 <code>Results</code> 实例。它是 Realm 的一部分。而第二种新的类型是 <code>Venue</code> 实例的数组。</p>
<p>最大的区别是懒加载。Realm 在加载需要使用的数据时很高效，比如你的代码访问 Realm 数据。不幸的是，Realm 并不支持对属性计算后排序的特性。因此，我们需要加载所有从 Realm 获取的数据，并执行自己定义的过滤操作。通常你会使用 Realm 来处理数据检索（使用延迟加载），并给它一个过滤器。这次暂不考虑使用这种方法。</p>
<p>OK，还记得这两行代码吗？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">venues = realm.objects(<span class="type">Venue</span>)</span><br></pre></td></tr></table></figure>
<p>用以下的代码段来代替以上两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (start, stop) = calculateCoordinatesWithRegion(location)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>(format: <span class="string">"latitude &lt; %f AND latitude &gt; %f AND longitude &gt; %f AND longitude &lt; %f"</span>, start.latitude, stop.latitude, start.longitude, stop.longitude)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line"></span><br><span class="line">venues = realm.objects(<span class="type">Venue</span>).<span class="built_in">filter</span>(predicate).<span class="built_in">sort</span> &#123;</span><br><span class="line">     location.distanceFromLocation($<span class="number">0</span>.coordinate) &lt;; location.distanceFromLocation($<span class="number">1</span>.coordinate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，在 <code>ViewController</code> 类里添加一下方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">calculateCoordinatesWithRegion</span><span class="params">(location:CLLocation)</span></span> -&gt; (<span class="type">CLLocationCoordinate2D</span>, <span class="type">CLLocationCoordinate2D</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> region = <span class="type">MKCoordinateRegionMakeWithDistance</span>(location.coordinate, distanceSpan, distanceSpan)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> start:<span class="type">CLLocationCoordinate2D</span> = <span class="type">CLLocationCoordinate2D</span>()</span><br><span class="line">    <span class="keyword">var</span> stop:<span class="type">CLLocationCoordinate2D</span> = <span class="type">CLLocationCoordinate2D</span>()</span><br><span class="line"></span><br><span class="line">    start.latitude  = region.center.latitude  + (region.span.latitudeDelta  / <span class="number">2.0</span>)</span><br><span class="line">    start.longitude = region.center.longitude - (region.span.longitudeDelta / <span class="number">2.0</span>)</span><br><span class="line">    stop.latitude   = region.center.latitude  - (region.span.latitudeDelta  / <span class="number">2.0</span>)</span><br><span class="line">    stop.longitude  = region.center.longitude + (region.span.longitudeDelta / <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (start, stop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，这方法也没什么特别的。只是一些基本的数学计算，把 <code>CLLocation</code> 实例基于区域的距离转换成左上和右下两个坐标。</p>
<p>第一行代码创建了基于位置和距离的区域。接着，设置好位置和它们的经纬度。这些值是根据中心的坐标计算出来的。最后，该方法返回一个元组：两个有序的变量。</p>
<p>可以把任意顺序的类型组合成元组（译者注：如果对元组有什么不理解的话，可以查看<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/01_The_Basics.html#tuples" target="_blank" rel="external">中文版官方文档</a>的相应说明）。圆括号里的变量有特定的顺序，且是不可变的数组。</p>
<p>OK，回到我们的过滤器代码（译者注：位于上上段代码）。让我们一行一行来解读。</p>
<ul>
<li>首先，创建了两个常量，<code>start</code> 和 <code>stop</code>。它们是 <code>calculateCoordinatesWithRegion:</code> 方法的返回结果。该方法返回的是一个元组，由 <code>start</code> 和 <code>stop</code> 组成。<code>calculateCoordinatesWithRegion:</code> 方法的功能就是返回当前用户的地理位置。</li>
<li>接着，创建了一个 <code>predicate</code> 变量。<code>NSPredicate</code> 是一个过滤器，它可以适用于数组，序列（译者注：也可以理解为元组）等等。<code>predicate</code> 变量定义了一个范围，<code>venues</code>数组里的 GPS 坐标必须落在该范围内。它主要是用于过滤 Realm 的数据（下一行代码会过滤）。值得注意的是，该 <code>predicate</code> 变量假设 GPS 数据是平面的，虽然地球明显是球体的。现在暂时这样假设是没事的，但是当你在南极点或北极点附近使用本应用去寻找咖啡店时就会出问题。</li>
<li>接下来，让我们来剖析一下 <code>realm</code> 对象获取数据的那部分内容。所有方法都是有关联的，也就意味着每次方法调用都用到了前一个方法调用的结果。<ul>
<li>首先，创建了一个 <code>realm</code> 变量来保存 Realm 的引用对象。</li>
<li>接着，<code>Venue</code> 的所有对象都被懒加载：<code>objects(Venue)</code>。</li>
<li>接着，过滤器（ <code>predicate</code> ）来过滤这些对象。Realm 可以快速的处理过滤，而且它并不是所有的对象都过滤，而只是过滤能访问到的对象。</li>
<li>接着，调用 Swift 本地的排序算法。这里的 <code>sort</code> 并不是 Realm 的那部分，Realm 的排序算法叫<code>sorted</code>。换句话说，这部分没用上 Realm。该排序算法会访问所有的 Realm 对象，也就意味着它们都会被加载进内存，这里也没用上 Realm 的懒加载特性。该排序算法只有一个参数：一个确定两个无序对象顺序的闭包。通过返回 <code>true</code> 或 <code>false</code>，来标识闭包里两个对象比较后的关系。在上面那段代码里，前后顺序是基于离用户位置的距离的。这也是坐标属性派上用场的地方。其中，<code>$0</code> 和 <code>$1</code> 是两个无序对象的缩写。从根本上来说，该方法将地理数据以用户位置距离远近进行排序（距离越近，排在越前面）。</li>
</ul>
</li>
</ul>
<p>就说到这里吧。以上是的代码量比较大，但是效率很高。 Realm 优化的特性，方法链（method chaining）以及 Swift 本地的排序算法可以让一大票地理数据按特定的顺序保存。而且，还有一个很炫酷的事情：随着你的移动，它会随时更新。</p>
<p>就这样了！用 Command-R 来看看应用的效果吧。干的漂亮！</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/coffee_18.png" alt=""></p>
<p>注意：不幸的是，当你在 Xcode 里模拟 GPS 坐标时，从 Foursquare 获取的数据可能会少的可怜。假如你想要获得更多数据的话，你可以去除 CoffeeAPI 中硬编码的部分，或者把地点模拟到有更多咖啡店的位置。</p>
<p>你对本教程有什么想法呢？留下你的留言和想法吧。</p>
<p>最后再安利一波。你可以从 GitHub <a href="https://github.com/reinderdevries/CoffeeGuide" target="_blank" rel="external">reinderdevries/CoffeeGuide</a> 上下载所有源代码和 Xcode 项目。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：reinder de vries，<a href="http://www.appcoda.com/foursquare-realm-swift/">原文链接</a>，原文日期：2015/11/23<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="http://www.brighttj.com">saitjr</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>我们经常说，程序员喝进去的是咖啡，吐出来的是代码。让我们换一个角度去思考，来做一个显示附近咖啡店的 App。</p>
<p>这篇文章中，用到了以下技能：</p>
<ul>
<li>Swift，Xcode 和 Interface Builder（Auto Layout, Constraints 和 Storyboards）</li>
<li>Realm，一种本地存储方案，轻量级的 Core Data</li>
<li>使用 Foursquare 和 Das Quadrat 库访问 REST API</li>
<li>CocoaPods 和 Geolocation</li>
</ul>
<p>这个 App 可以检测当前用户的 500 平方米的范围，并从 Foursquare 拿到附近咖啡店的地理信息。我们将使用 map view（<code>MKMapView</code>）和一个 table view（<code>UITableView</code>）来展示数据。当然，还要使用 Realm 来过滤数据，并使用闭包来对数据进行排序。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聚焦 Swift #0]]></title>
    <link href="http://swiftggteam.github.io/2015/12/29/swift-open-source/"/>
    <id>http://swiftggteam.github.io/2015/12/29/swift-open-source/</id>
    <published>2015-12-28T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/swift-open-source/" target="_blank" rel="external">原文链接</a>，原文日期：2015/12/06<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
<p>译者注：这个系列的关注重点是 Swift 开源项目本身的发展，作者会截取每周发生的大事（比如合并了一个大改动）并进行分析，还会写一些有趣的小发现，很有意思。我们已经拿到翻译授权，会每周进行更新，欢迎关注。</p>
</blockquote>
<p>革命起源：<strong>2015.12.06</strong></p>
<p>Apple 宣告 “<a href="https://developer.apple.com/swift/blog/?id=34" target="_blank" rel="external">Swift即将开源</a>” 的随后几天里，项目的活跃度让人瞠目结舌。回想今年早些时候的 <a href="https://developer.apple.com/wwdc/" target="_blank" rel="external">WWDC</a> 大会上 Apple 提及 Swift 不久会被开源，我可不认为任何人会像这样期待该发布版本。</p>
<p><img src="/img/articles/swift-open-source/swift-logo.png1451394012.0965536" alt=""></p>
<a id="more"></a>
<h3 id="Expectations（期望）">Expectations（期望）</h3><p>没人真正知道接下来会发生什么。譬如 Swift 项目将会被投放到 <a href="http://www.opensource.apple.com/" target="_blank" rel="external">opensource.apple.com</a> 上，变得和其他开源项目一样毫无新意？还是说它会像 <a href="https://github.com/ResearchKit" target="_blank" rel="external">ResearchKit</a> 一样放置到 GitHub 上？最终，Swift 不仅发布到 <a href="https://github.com/apple/" target="_blank" rel="external">GitHub</a> 上，而且 Swift 团队将会以一种彻底透明化的方式工作。Apple 为该发布版所做的工作是令人瞩目的。我们不但可以获得所有的源代码，同时还能浏览每个项目<a href="https://github.com/apple/swift/commits/master" target="_blank" rel="external">完整的提交历史</a>，提供非常详细的视图展示 Swift 团队的开发流程，以及 Swift 的<a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">演变史</a>。 任何你想要获悉的东西都可以在 <a href="http://swift.org/" target="_blank" rel="external">Swift.org</a>上找到。</p>
<h3 id="Swift_in_the_open">Swift in the open</h3><p>过去的几天里我浏览了 <a href="https://github.com/apple/" target="_blank" rel="external">GitHub</a> 的源码仓以及 Swift 的<a href="https://swift.org/community/#mailing-lists" target="_blank" rel="external">邮件列表</a>。真是太有意思了！很好奇 Swift 开发在之后的发展中会变成什么样子？下面分享到目前为止我觉得很有意思的一些东西。</p>
<ul>
<li>Chris Lattner 于 2010.7.17 提交了首个 <a href="https://github.com/apple/swift/commit/18844bc65229786b96b89a9fc7739c0fc897905e" target="_blank" rel="external">commit</a>。</li>
<li>Swift 源代码发布到 GitHub 上的短短24小时里，<a href="https://github.com/apple/swift" target="_blank" rel="external">Swift repo</a> 星星数以超过 10,000 之多。到目前为止已经拥有 19,000 星星数 和超过 2,000次 fork。在写这篇文章时候，它依旧占据 GitHub 热门榜单第一位。（pmst注：翻译时 <strong>24,724</strong> stars，<strong>3043</strong> fork，遗憾的是不在热门榜单中。）</li>
<li>所有 repos 的 pull requests 加起来超过 400 之多。许多都已经被接收并合并了。</li>
<li><a href="https://developer.apple.com/videos/play/wwdc2014-402/" target="_blank" rel="external">WWDC 2014</a> 宣告发布 Swift 语言之后，我想 Swift 团队在 twitter 上的活跃度是有目共睹的：一边答疑解惑；一边是 <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">Chris Lattner</a>，<a href="https://twitter.com/jckarter" target="_blank" rel="external">Joe Groff</a> 以及 <a href="https://twitter.com/UINT_MIN" target="_blank" rel="external">Jordan Rose</a> 大神时不时地举例说明。正是因为这些推文加速了 bug 的修复！😄</li>
<li>还记得 <a href="https://www.apple.com/pr/library/2014/07/15Apple-and-IBM-Forge-Global-Partnership-to-Transform-Enterprise-Mobility.html" target="_blank" rel="external">Apple 和 IBM</a> 的<a href="http://www.apple.com/business/mobile-enterprise-apps/" target="_blank" rel="external">合作关系</a>吗？因此 IBM 对服务器端 Swift 开发的<a href="https://developer.ibm.com/swift/2015/12/03/introducing-the-ibm-swift-sandbox/" target="_blank" rel="external">投入</a>也就没什么令人吃惊的。就目前来看，Swift 应用到服务器端的趋势尤为明显。</li>
<li>Chris Lattner 于星期六下午10点合并了 <a href="https://github.com/apple/swift/pull/166" target="_blank" rel="external">pull requests</a>。😆</li>
<li>我们已经确切获悉了 Swift3.0 即将做出的改变。没有啥让人惊喜的东东拉。</li>
<li>Swift3.0 中 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md" target="_blank" rel="external">++ 和 – 运算符将被移除</a>。感谢 <a href="https://twitter.com/ericasadun" target="_blank" rel="external">Erica Sadun</a>，以及 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md" target="_blank" rel="external">C 风格的 for 循环</a>。她同一天中提交了2个建议！👏</li>
<li>Chris lattner <a href="https://github.com/apple/swift/commit/22c3aa0588d2df1a207dcbad85946bab7976894c" target="_blank" rel="external">提交</a>了“Pull some ancient history off an internal wiki page for possible historical interest.” 什么？是的，没错！奇客们注意了。</li>
<li>自从2014年9月开始 <a href="https://twitter.com/practicalswift" target="_blank" rel="external">@practicalswift</a> 这个专门收集 <a href="https://github.com/practicalswift/swift-compiler-crashes" target="_blank" rel="external">swift 编译崩溃信息的系列</a>已经作为<a href="https://github.com/apple/swift/commit/e5ca8be1a090335d401cd1d7dfcf9b2104674d5b" target="_blank" rel="external">仓库内容</a>的一部分了。</li>
<li>使用 <code>associated</code> 类型声明取代 <code>typealias</code> 声明方式看起来是一个不错的<a href="https://github.com/apple/swift-evolution/pull/33/files" target="_blank" rel="external">机会</a>。</li>
<li><a href="https://twitter.com/jtbandes" target="_blank" rel="external">Jacob Bandes-Storch</a> 提交了两个 <a href="https://github.com/apple/swift/pull/272" target="_blank" rel="external">pull request</a> 修复了将近 400 个 crash 。😲</li>
<li>Swift 团队似乎很热衷于让社区参与进来。无所谓贡献大小！</li>
<li><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="external">swift-corelibs-foundation</a> 框架大部分都还<a href="https://github.com/apple/swift-corelibs-foundation/search?utf8=✓&amp;q=NSUnimplemented" target="_blank" rel="external">未实现</a>。看起来还有很多低挂的“果实”能让你来采摘。我很好奇这是否是 Apple 故意而为之，鼓励开发者参与贡献，还是说真的是因为时间紧迫导致的？</li>
<li>自2010起的<a href="https://github.com/apple/swift/commit/afc81c1855bf711315b8e5de02db138d3d487eeb" target="_blank" rel="external">initial checkin</a> 实际上是版本4，从内部 SVN 仓库中导入的。“Swift SVN r4”。 你将注意到下面头文件中的注释说到：“该源文件是 Swift.org 开源项目中的一部分。Copyright(c)2014-2015 Apple Inc.” 我的看法有三点：<br>  1 在将项目发布到 GitHub 之前，提交历史已经被重新编辑以及整理过了。<br>  2 2010年时，Swift 团队指定的截止日期就是“2014-2015”，无关其他。这本就是 Apple 的一贯做法，反正 Swift 跌跌撞撞地已经到来。<br>  3 Chris Lattner 是个“巫师”。</li>
</ul>
<p>我想我们已经有了一个良好的开端。社区实在强大且狂热，仅仅<strong>三天</strong>,Swift 就有了极大地改进。正如 Lattner 所说，革命是属于 Swift 的！</p>
<p>以上就是我所获知的所有东西了。如果你喜欢该文章，<a href="https://twitter.com/jesse_squires" target="_blank" rel="external">请让我知道</a>。或许我会坚持下去，分享我的发现。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Jesse Squires，<a href="http://www.jessesquires.com/swift-open-source/">原文链接</a>，原文日期：2015/12/06<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
<p>译者注：这个系列的关注重点是 Swift 开源项目本身的发展，作者会截取每周发生的大事（比如合并了一个大改动）并进行分析，还会写一些有趣的小发现，很有意思。我们已经拿到翻译授权，会每周进行更新，欢迎关注。</p>
</blockquote>
<p>革命起源：<strong>2015.12.06</strong></p>
<p>Apple 宣告 “<a href="https://developer.apple.com/swift/blog/?id=34">Swift即将开源</a>” 的随后几天里，项目的活跃度让人瞠目结舌。回想今年早些时候的 <a href="https://developer.apple.com/wwdc/">WWDC</a> 大会上 Apple 提及 Swift 不久会被开源，我可不认为任何人会像这样期待该发布版本。</p>
<p><img src="/img/articles/swift-open-source/swift-logo.png1451394012.0965536" alt=""></p>]]>
    
    </summary>
    
      <category term="Open Source Swift" scheme="http://swiftggteam.github.io/tags/Open-Source-Swift/"/>
    
      <category term="Swift 开源信息" scheme="http://swiftggteam.github.io/categories/Swift-%E5%BC%80%E6%BA%90%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Friday Q&A 2015-12-11：Swift 中的弱引用]]></title>
    <link href="http://swiftggteam.github.io/2015/12/28/friday-qa-2015-12-11-swift-weak-references/"/>
    <id>http://swiftggteam.github.io/2015/12/28/friday-qa-2015-12-11-swift-weak-references/</id>
    <published>2015-12-27T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-11<br>译者：<a href="http://weibo.com/riven0951" target="_blank" rel="external">riven</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即便你已经在火星的一个洞穴里，紧闭着你的双眼并且捂住你的耳朵，<a href="https://swift.org/" target="_blank" rel="external">也避免不了 Swift 已经开源的事实</a>。正因为开源，我们能够更加方便地去探索 Swift 中的很多有趣的特性，其中之一便是 Swift 中弱引用是如何工作的问题。</p>
<a id="more"></a>
<h3 id="弱引用">弱引用</h3><p>在采用垃圾回收器或者引用计数进行内存管理的语言中，强引用可以使得特定的对象一直存活，但弱引用就无法保证。当一个对象被强引用时，它是不能够被销毁的；但是如果它是个弱引用，就可以。</p>
<p>当我们所提到「弱引用」时，通常的意思是指一个<em>归零</em>弱引用（Zeroing Weak Reference）。也就是说，当弱引用的目标对象被销毁时，弱引用就会变成 <code>nil</code>（校者注：<a href="https://www.mikeash.com/pyblog/friday-qa-2010-07-16-zeroing-weak-references-in-objective-c.html" target="_blank" rel="external">看这篇文章了解更多</a>）。非归零弱引用也是存在的，它会导致一些陷阱（Trap）、崩溃（Crash）或者未定义行为的调用。比如你在 Objective-C 中使用 unsafe_unretained，或者在 Swift 中使用 unowned（Objective-C 未定义行为处理方式，而 Swift 却很可靠地处理这些崩溃）。</p>
<p>归零弱引用很方便使用，在基于引用计数进行内存管理的语言中他们是非常有用的。它们允许循环引用存在却不会产生死循环，并且不需要手动打破逆向引用。他们非常的有用，在苹果引入 ARC 和让弱引用在垃圾收集代码之外的语言层面上可用之前，<a href="https://www.mikeash.com/pyblog/introducing-mazeroingweakref.html" target="_blank" rel="external">我就已经实现了我自己的弱引用版本</a>。</p>
<h3 id="它是如何工作的呢？">它是如何工作的呢？</h3><p>归零弱引用比较典型的实现方式是保持一个对每个对象的所有弱引用列表。当对一个对象创建了弱引用，这个引用就会被添加到这个列表中。当这个引用被重新赋值或者超出了其作用域，它就会从列表中被移除。当一个对象被销毁，这个列表中的所有引用都会被归零。在多线程的情况下，其实现必须是同步获取一个弱引用并销毁一个对象，以避免竞态条件的出现：比如当一个线程释放某个对象的最后一个强引用而同时另一个线程却试图加载一个它的一个弱引用。</p>
<p>在我的实现中，每一个弱引用都是一个完整的对象。弱引用列表是一个弱引用对象的集合。虽然由于额外的转换和内存使用让效率变低了，但这种方式可以很方便的让这些引用变成完整的对象。</p>
<p>苹果公司的 Objective-C 的实现是这样的，每一个弱引用是一个指向目标对象的普通指针。编译器并不直接读写指针，而是使用一些帮助函数。当存储一个弱指针时，存储函数会将指针的位置注册为目标对象的一个弱引用。由于读取函数被集成进了引用计数系统，这就确保了在读取一个弱指针时，不会返回一个已经被释放了的对象的指针。</p>
<h3 id="归零操作">归零操作</h3><p>让我们创建一些代码来研究一下它们究竟是怎么运行的。</p>
<p>我们希望写一个函数能够 dump 一个对象的内存内容。这个函数接受一块内存区域，将其按指针大小进行分块，并且将最终的结果转换成一个易于查看的十六进制字符串：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">contents</span><span class="params">(ptr: UnsafePointer&lt;Void&gt;, <span class="number">_</span> length: Int)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wordPtr = <span class="type">UnsafePointer</span>&lt;<span class="type">UInt</span>&gt;(ptr)</span><br><span class="line">    <span class="keyword">let</span> words = length / <span class="built_in">sizeof</span>(<span class="type">UInt</span>.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> wordChars = <span class="built_in">sizeof</span>(<span class="type">UInt</span>.<span class="keyword">self</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> buffer = <span class="type">UnsafeBufferPointer</span>&lt;<span class="type">UInt</span>&gt;(start: wordPtr, <span class="built_in">count</span>: words)</span><br><span class="line">    <span class="keyword">let</span> wordStrings = buffer.<span class="built_in">map</span>(&#123; word -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">var</span> wordString = <span class="type">String</span>(word, radix: <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">while</span> wordString.characters.<span class="built_in">count</span> &lt; wordChars &#123;</span><br><span class="line">            wordString = <span class="string">"0"</span> + wordString</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordString</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> wordStrings.joinWithSeparator(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个函数会为一个对象创建一个 dump 函数。调用时传入一个对象，它会返回一个 dump 这个对象内容的函数。在函数内部，我们给对象保存了一个 <code>UnsafePointer</code>，而不是普通的引用。这样可以确保它不会和语言的引用计数系统发生交互。它允许我们可以在这个对象被销毁之后 dump 出它的内存，后面我们会介绍。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dumperFunc</span><span class="params">(obj: AnyObject)</span></span> -&gt; (<span class="type">Void</span> -&gt; <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> objString = <span class="type">String</span>(obj)</span><br><span class="line">    <span class="keyword">let</span> ptr = <span class="built_in">unsafeBitCast</span>(obj, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> length = class_getInstanceSize(obj.<span class="keyword">dynamicType</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bytes = contents(ptr, length)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(objString)</span> <span class="subst">\(ptr)</span>: <span class="subst">\(bytes)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个包含弱引用变量的类，后面我会观察这个弱引用。我在弱引用变量的前后分别添加了一个 dummy 变量，以便于我们区分弱引用在 dump 出来的内存结构中的位置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakReferer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dummy1 = <span class="number">0x1234321012343210</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">WeakTarget</span>?</span><br><span class="line">    <span class="keyword">var</span> dummy2: <span class="type">UInt</span> = <span class="number">0xabcdefabcdefabcd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们试一下! 我们先创建一个引用，然后 dump 它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007f8</span>a<span class="number">3861b920</span>: <span class="number">0000000107</span>ab<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>我们看到 <code>isa</code> 指针位于最开始的位置，紧随其后的是其它一些内部字段。<code>dummy1</code> 变量占据了第四块，<code>dummy2</code> 变量占据了第六块。正如我们所期望的那样，在他们之间的弱引用正好是零。</p>
<p>现在我们让这个弱引用指向一个目标对象，看看会变成什么样。我将这段代码放入一个 <code>do</code>语句中，以便于当目标对象超出作用域和被销毁时我们可以进行控制：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">NSObject</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(target)</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">&lt;NSObject: 0x7fda<span class="number">6a21c6a0</span>&gt;</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fda6a000ad0: <span class="number">00000001050</span>a<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fda<span class="number">6a21c6a0</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>正如我们期望的那样，目标对象的指针直接存储在弱引用中。在目标对象被销毁之后，我们在 <code>do</code> 代码块之后再次调用 dump 函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"></span><br><span class="line"><span class="type">WeakReferer</span> <span class="number">0x00007ffe32300060</span>: 000000010cfb44a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>它被归零了。点个赞!</p>
<p>仅仅为了好玩，我们用一个纯 Swift 对象作为对象来重复这个实验。不必要时，我并不是很想使用 Objective-C 中的东西。下面是一个纯 Swift 对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>让我们试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br></pre></td></tr></table></figure>
<p>目标对象像我们期望的那样被归零了，然后被重新赋值：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fbe95121ce0 abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>然后当目标对象被销毁，引用应该被归零：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fbe<span class="number">95000270</span>: <span class="number">00000001071</span>d<span class="number">24a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fbe95121ce0 abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>不幸的是它并没有被归零。可能是目标对象没有被销毁。一定是有某些东西让它继续活着！让我们再检查一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行代码，结果如下：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fd<span class="number">29a42a920</span> abcdefabcdefabcd</span><br><span class="line">WeakTarget deinit</span><br><span class="line">WeakReferer <span class="number">0x00007</span>fd29a61fa10: <span class="number">0000000107</span>ae<span class="number">44a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fd<span class="number">29a42a920</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>它消失了，但是弱引用并没有归零。怎么回事呢，我们发现了 Swift 的一个 bug！很神奇，这个 bug 一直没有被解决。你会想之前肯定已经有人已经注意到了这个问题。接下来，我们通过访问弱引用来产生一个崩溃，然后我们可以用这个 Swift 工程提交这个 bug ：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">        <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    referer.target = target</span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(referer.target)</span><br></pre></td></tr></table></figure>
<p>下面就是崩溃信息：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>ff7aa2157f0 abcdefabcdefabcd</span><br><span class="line">WeakTarget deinit</span><br><span class="line">WeakReferer <span class="number">0x00007</span>ff7aa20d060: <span class="number">00000001047</span>a<span class="number">04a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>ff7aa2157f0 abcdefabcdefabcd</span><br><span class="line">nil</span><br></pre></td></tr></table></figure>
<p>哦，我的天呐！大爆炸在哪呢？应该有一个惊天动地的大爆炸呀！输出的内容表明一切工作正常，但我们可以清楚地从 dump 内容看到它并没有正常工作。</p>
<p>让我们再仔细检查一下。下面是一个经过修改的 <code>WeakTarget</code> 类，我们添加了一个 dummy 变量以便于区分 dump 的内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dummy = <span class="number">0x0123456789abcdef</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Weak target deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一段新的代码，运行的程序和之前的基本相同，只不过每次 dump 都会输出两个对象（校者注：Target 和 Referer）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> referer = <span class="type">WeakReferer</span>()</span><br><span class="line"><span class="keyword">let</span> refererDump = dumperFunc(referer)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="keyword">let</span> targetDump: <span class="type">Void</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line">    targetDump = dumperFunc(target)</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line"></span><br><span class="line">    referer.target = target</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(refererDump())</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br><span class="line"><span class="built_in">print</span>(referer.target)</span><br><span class="line"><span class="built_in">print</span>(refererDump())</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br></pre></td></tr></table></figure>
<p>让我们检查一下输出内容。referer 对象的生命周期和之前一样，它的 <code>target</code> 字段被顺利的归零了：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p><code>target</code> 首先作为一个普通对象，在各种头字段之后紧跟着我们的 <code>dummy</code> 字段：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>在给 <code>target</code> 字段赋值后，我们可以看到被填充的指针的值：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fe<span class="number">17341d270</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p><code>target</code> 对象还是和之前一样，但是它其中一个头字段增加了 2：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>目标对象像我们期望的那样被销毁了：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">Weak <span class="keyword">target</span> deinit</span><br></pre></td></tr></table></figure>
<p>我们看到引用对象一直都有一个指针指向目标对象：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00007</span>fe<span class="number">17341d270</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>并且目标对象本身一直存活着。和上次我们看到的相比，它的头字段减少了 2：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000002</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>访问 <code>target</code> 字段会产生 <code>nil</code> ，即便它没有被归零：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>再次 dump referer 对象的内容，从中我们看出仅仅访问 <code>target</code> 字段的行为已经改变了它。现在它被归零了：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakReferer <span class="number">0x00007</span>fe<span class="number">174802520</span>: <span class="number">000000010</span>faa<span class="number">64a0 00000</span><span class="number">00200000004</span> <span class="number">123432101234</span><span class="number">3210 00000</span><span class="number">00000000000</span> abcdefabcdefabcd</span><br></pre></td></tr></table></figure>
<p>目标对象现在被完全抹掉了：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: 200007fe<span class="number">17342a04 30</span>0007fe<span class="number">17342811</span> ffffffffffff0002</span><br></pre></td></tr></table></figure>
<p>现在变的越来越有趣了。我们看到头字段会一会儿增加，一会儿减少；让我们看看是否能有重现出更多的信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</span><br><span class="line"><span class="keyword">let</span> targetDump = dumperFunc(target)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> a = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> b = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> <span class="built_in">c</span> = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> d = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> e = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> f = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> g = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> h = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> i = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> j = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">    <span class="keyword">var</span> k = target</span><br><span class="line">    <span class="built_in">print</span>(targetDump())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(targetDump())</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00600000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00800000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00a00000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000008</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c0000000</span>c <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000010</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000014</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c00000018</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00c0000001</span>c <span class="number">0123456789</span>abcdef</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fd883205df0: <span class="number">00000001093</span>a<span class="number">4840 00000</span><span class="number">00200000004</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>我们看到每一个新的弱引用会让头字段中的第一个数增加 2。每一个新的强引用会让头字段中的第二个数增加 4。</p>
<p>回顾一下，下面这些就是目前我们所发现的：</p>
<ul>
<li>在内存中弱指针和普通指针是一样的.</li>
<li>当一个弱目标对象（WeakTarget）的 <code>deinit</code> 方法调用时，目标对象是<em>不会</em>被释放的，并且弱指针也<em>不会</em>被归零。</li>
<li>当目标对象的 <code>deinit</code> 方法执行之后，访问弱指针，它就会被归零并且弱目标对象也会被释放。</li>
<li>弱目标对象包含一个弱引用的引用计数，与强引用计数分离开。</li>
</ul>
<h3 id="Swift_代码">Swift 代码</h3><p>既然 Swift 已经开源，我们可以通过查看源代码来继续我们的观察。</p>
<p>在 Swift 标准库中用 <code>HeapObject</code> 类型来表示一个分配在堆上的对象，其实现可参考 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/SwiftShims/HeapObject.h#L33" target="_blank" rel="external">stdlib/public/SwiftShims/HeapObject.h</a>。看起来是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">struct HeapObject &#123;</span><br><span class="line">/// 这始终是一个有效的元数据对象的指针。</span><br><span class="line">struct HeapMetadata const *metadata;</span><br><span class="line"></span><br><span class="line">SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;</span><br><span class="line">// FIXME: 在 32 位的平台上分配了两个字大小的元数据。</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">HeapObject() = default;</span><br><span class="line"></span><br><span class="line">// 给新分配的堆内存初始化空间（对象alloc，是分配的堆内存）。</span><br><span class="line">constexpr HeapObject(HeapMetadata const *newMetadata) </span><br><span class="line">    : metadata(newMetadata)</span><br><span class="line">    , refCount(StrongRefCount::Initialized)</span><br><span class="line">    , weakRefCount(WeakRefCount::Initialized)</span><br><span class="line">&#123; &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Swift 的 <code>metadata</code> 字段就相当于 Objective-C 的 <code>isa</code> 字段，并且它们是兼容的。还有一些像 <code>NON_OBJC_MEMBERS</code> 这样的宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span><br><span class="line">  StrongRefCount refCount;                      \</span><br><span class="line">  WeakRefCount weakRefCount</span></span><br></pre></td></tr></table></figure>
<p>噢，快看！这就是我们的两个引用计数。</p>
<p>(附加问题：为什么这里强引用在前面，而在 dump 时确是弱引用在前面？)</p>
<p>引用计数是通过位于 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/runtime/HeapObject.cpp" target="_blank" rel="external">stdlib/public/runtime/HeapObject.cpp</a> 文件中的一系列函数来进行管理的。比如，下面的 <code>swift_retain</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::swift_retain(HeapObject *object) &#123;</span><br><span class="line">SWIFT_RETAIN();</span><br><span class="line">    _swift_retain(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _swift_retain_(HeapObject *object) &#123;</span><br><span class="line">    _swift_retain_inlined(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> swift::_swift_retain = _swift_retain_;</span><br></pre></td></tr></table></figure>
<p>这里面拐了几个弯，但它最终是调用头文件中的内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _swift_retain_inlined(HeapObject *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (object) &#123;</span><br><span class="line">    object-&gt;refCount.increment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，它会增加引用计数。下面是 increment 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  __atomic_fetch_add(&amp;refCount, RC_ONE, __ATOMIC_RELAXED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RC_ONE</code> 来自于一个枚举类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  RC_PINNED_FLAG = <span class="number">0x1</span>,</span><br><span class="line">  RC_DEALLOCATING_FLAG = <span class="number">0x2</span>,</span><br><span class="line"></span><br><span class="line">  RC_FLAGS_COUNT = <span class="number">2</span>,</span><br><span class="line">  RC_FLAGS_MASK = <span class="number">3</span>,</span><br><span class="line">  RC_COUNT_MASK = ~RC_FLAGS_MASK,</span><br><span class="line"></span><br><span class="line">  RC_ONE = RC_FLAGS_MASK + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相信你已经明白为什么每一个新的强引用会让头字段增加 4 了吧。这个枚举类型的前两位用来作为标志位。回想一下之前的 dump 结果，我们可以看到这些标志位。下面是一个弱目标对象在最后一个强引用消失之前和之后的结果：</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00400000004</span> <span class="number">0123456789</span>abcdef</span><br><span class="line">Weak target deinit</span><br><span class="line">WeakTarget <span class="number">0x00007</span>fe<span class="number">17341d270</span>: <span class="number">000000010</span>faa<span class="number">63e0 00000</span><span class="number">00200000002</span> <span class="number">0123456789</span>abcdef</span><br></pre></td></tr></table></figure>
<p>其中第二个字段开始是 4，表示引用计数为 1 并且没有标志位，之后变成了 2，表示引用计数为 0 和 <code>RC_DEALLOCATING_FLAG</code> 标志位被设定了。这个被析构的对象被放在了处于 <code>DEALLOCATING</code> 状态的位置。</p>
<p>（顺便说一句，<code>RC_PINNED_FLAG</code> 到底是用来干什么的呢？我查找了相关代码，除了能够表明一个「固定的对象（pinned object）」外，其它对于这个标记一无所知。如果你弄清楚了或者有一些相关的猜测，请给我留言。）</p>
<p>现在让我们看一看弱引用计数的实现。它有同样的枚举结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> : <span class="keyword">uint32_t</span> &#123;</span><br><span class="line">  <span class="comment">// There isn't really a flag here.</span></span><br><span class="line">  <span class="comment">// Making weak RC_ONE == strong RC_ONE saves an</span></span><br><span class="line">  <span class="comment">// instruction in allocation on arm64.</span></span><br><span class="line">  RC_UNUSED_FLAG = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RC_FLAGS_COUNT = <span class="number">1</span>,</span><br><span class="line">  RC_FLAGS_MASK = <span class="number">1</span>,</span><br><span class="line">  RC_COUNT_MASK = ~RC_FLAGS_MASK,</span><br><span class="line"></span><br><span class="line">  RC_ONE = RC_FLAGS_MASK + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是 2 的来源：其中有一个保留的标志位，目前尚未被使用。奇怪的是，关于这段代码的注释似乎是不正确的，这的 <code>RC_ONE</code> 等于 2，而强引用的 <code>RC_ONE</code> 等于 4。我猜它们曾经是相等的，但后来它被修改了而注释却没有更新。我只是想表明如果注释是无用的，那你为什么还要写它呢。</p>
<p>所有这些是如何和加载弱引用相关联的呢？它是由 <a href="https://github.com/apple/swift/blob/swift-2.2-SNAPSHOT-2015-12-01-b/stdlib/public/runtime/HeapObject.cpp#L636" target="_blank" rel="external">swift_weakLoadStrong</a> 函数来处理的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HeapObject *swift::swift_weakLoadStrong(WeakReference *ref) &#123;</span><br><span class="line">  <span class="keyword">auto</span> object = ref-&gt;Value;</span><br><span class="line">  <span class="keyword">if</span> (object == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (object-&gt;refCount.isDeallocating()) &#123;</span><br><span class="line">    swift_weakRelease(object);</span><br><span class="line">    ref-&gt;Value = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> swift_tryRetain(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，惰性归零是如何工作的已经一目了然了。当加载一个弱引用时，如果目标对象正在被销毁，就会对这个引用进行归零。反之，会保留目标对象并返回它。进一步深挖一点，我们可以看到 <code>swift_weakRelease</code> 如何释放对象的内存，前提是它是最后一个引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> swift::swift_weakRelease(HeapObject *object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!object) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (object-&gt;weakRefCount.decrementShouldDeallocate()) &#123;</span><br><span class="line">    <span class="comment">// 只有对象可以 weak-retained 和 weak-released</span></span><br><span class="line">    <span class="keyword">auto</span> metadata = object-&gt;metadata;</span><br><span class="line">    assert(metadata-&gt;isClassObject());</span><br><span class="line">    <span class="keyword">auto</span> classMetadata = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> ClassMetadata*&gt;(metadata);</span><br><span class="line">    assert(classMetadata-&gt;isTypeMetadata());</span><br><span class="line">    swift_slowDealloc(object, classMetadata-&gt;getInstanceSize(),</span><br><span class="line">                      classMetadata-&gt;getInstanceAlignMask());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（注意：如果你正在查看版本库中的代码，使用「weak」命名的地方大多数都改成了「unowned」。上面的命名是截至撰写本文时最新的快照，但开发仍在继续。你可以查看和我这对应的版本库中的 2.2 版本的快照，或者获取最新的版本但是要注意命名的变化，并且实现也有可能发生了改变。)</p>
<h3 id="整合">整合</h3><p>我们已经在层级上自上往下地看到了 Swift 中的弱引用是如何实现的。那么在高层观察 Swift 的弱引用又是如何工作的呢？</p>
<ol>
<li>弱引用只是指向目标对象的指针。</li>
<li>在 Objective-C 中是<em>没有</em>办法单独追踪弱引用的。</li>
<li>相反，每一个 Swift 对象都有一个弱引用计数，和它的强引用计数相邻。</li>
<li>Swift 将对象的析构过程（deinit）和对象的释放（dealloc）解耦。一个对象可以被析构并释放它的外部资源，但不必释放对象本身所占用的内存。</li>
<li>当一个 Swift 对象的强引用计数变成零而弱引用计数仍大于零时，那么这个对象会被析构，但是不会被释放。</li>
<li>这意味着一个被释放对象的弱指针<em>仍然是一个有效的指针</em>，它可以被反向引用而不会崩溃或者加载垃圾数据。它们只是指向一个处于僵尸状态的对象。</li>
<li>当一个弱引用被加载时，运行时会检查目标对象的状态。如果目标对象是一个僵尸对象，然后它会对弱引用进行归零，也就是减少弱引用计数并返回 <code>nil</code>。</li>
<li>当僵尸对象的所有弱引用都被归零，那么这个僵尸对象就会被释放。</li>
</ol>
<p>比起 Objective-C 中的实现，这种设计会带来一些有趣的结果：</p>
<ul>
<li>不需要维护一个弱引用列表。这样既简化代码也提高了性能。</li>
<li>在一个线程归零一个弱引用和另外一个线程加载一个弱引用之间就不会存在竞态条件了。这也意味着加载一个弱引用和销毁一个弱引用对象不需要加锁。这也提高了性能。</li>
<li>一个对象即便没有了强引用，但是弱引用任然会导致该对象被分配的内存被占用，直到所有弱引用被加载或者被丢弃。这种做法临时增加了内存使用。但是要注意的是这个影响很小，当目标对象没有被释放时，它所占的内存大小只是实例本身。当最后一个强引用变成零时，所有的外部资源（包括用于存储的 <code>Array</code> 或 <code>Dictionary</code> 属性）都会被释放。弱引用会导致被分配的单个实例不会被释放，而不是整个对象树。</li>
<li>每一个对象都需要额外的内存来存储弱引用计数。但在实际的 64 位系统中，这似乎是无关紧要的。头字段要占据所有指针大小的块的数量，并且强和弱引用计数共享一个头字段。如果没有弱引用计数，强引用计数就会占据整个 64 位。通过使用<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="external">非指针（non-pointer）</a> <code>isa</code> 可以将强引用移到 <code>isa</code> 中，但我不确定那是不是很重要或者它未来会如何发展。 对于 32 位系统，弱引用计数会将对象的大小增加四个字节。然而，32 位系统如今已经没有那么重要了.</li>
<li>因为访问一个弱指针是如此的方便，所以 <code>unowned</code> 的语义也采用了相同的机制来实现。<code>unowned</code> 和 <code>weak</code> 工作方式是一样的，只是当目标对象被释放，<code>unowned</code> 会给你一个大大的失败，而不是给你返回一个 <code>nil</code> 。在 Objective-C 中，<code>__unsafe_unretained</code> 是作为一个带有未定义行为的原始指针来实现的，你可以快速的访问它，毕竟加载一个弱指针还是有点慢。</li>
</ul>
<h3 id="总结">总结</h3><p>Swift 的弱指针通过一种有趣的方式，既保证了速度和正确性，也保证较低的内存开销。通过追踪每个对象的弱引用计数，将对象的销毁和对象的析构过程分离开来，弱引用问题被安全而又快速的得到解决。正是由于可以查看标准库的源代码，这让我们可以在源代码级别看到究竟发生了什么，而不是像我们之前通过反编译和 dump 内存来进行研究。当然，正如你上面看到的那样，我们很难完全打破这个习惯。</p>
<p>今天就这样了。下次回来会带来更多的干货。由于假期的缘故，可能需要几周，但是我会在之前发布一篇稍微短一点的文章。不管怎样，给接下来的话题提更多的建议吧。周五问答是由读者们的想法驱动的，如果你有一个你希望了解的想法，<a href="mailto:mike@mikeash.com" target="_blank" rel="external">请告知我</a>!</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html">原文链接</a>，原文日期：2015-12-11<br>译者：<a href="http://weibo.com/riven0951">riven</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即便你已经在火星的一个洞穴里，紧闭着你的双眼并且捂住你的耳朵，<a href="https://swift.org/">也避免不了 Swift 已经开源的事实</a>。正因为开源，我们能够更加方便地去探索 Swift 中的很多有趣的特性，其中之一便是 Swift 中弱引用是如何工作的问题。</p>]]>
    
    </summary>
    
      <category term="Mike Ash" scheme="http://swiftggteam.github.io/tags/Mike-Ash/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于 Swift 演变的趣味探讨]]></title>
    <link href="http://swiftggteam.github.io/2015/12/25/interesting-discussions-on-swift-evolution/"/>
    <id>http://swiftggteam.github.io/2015/12/25/interesting-discussions-on-swift-evolution/</id>
    <published>2015-12-24T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/" target="_blank" rel="external">原文链接</a>，原文日期：2015/12/15<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>记得我曾分享过一些想法和建议，比如：</p>
<h3 id="newtype">newtype</h3><p>一个是建议 Swift 推出一个 <code>newtype</code> 的关键词，它可以添加完全不同于原生的可扩展的派生类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newtype <span class="type">Currency</span> = <span class="type">NSDecimal</span></span><br></pre></td></tr></table></figure>
<p>这创建了一个拥有所有 <code>NSDecimal</code> 所有行为的 <code>Currency</code> 类型。然而，你不能让一个 <code>NSDecimal</code> 类型的元素和一个 <code>Currency</code> 类型的元素相加，因为 Swift 中有类型检测。此外，你也可以扩展 <code>Currency</code> 类型。这样看起来就更加有针对性，因为不需要子类化或者添加新的存储属性。</p>
<a id="more"></a>
<p><code>newtype</code> 的另一个特性是能够创建柯里化类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newtype <span class="type">Counter</span>&lt;<span class="type">A</span>&gt; = <span class="type">Dictionary</span>&lt;<span class="type">A</span>, <span class="type">Int</span>&gt;</span><br></pre></td></tr></table></figure>
<p>类型是部分确定的，具体行为可以在扩展中实现，从而能包含键（key）类型不相同但值类型都是 Int 的字典。</p>
<p>期待看到你们的评论。</p>
<h3 id="self">self</h3><p>另外一个提议是将 <code>self</code> 作为强制前缀，取代上下文语境推断。Greg Parker 在回复中写道：</p>
<blockquote>
<p>在 Objective-C 中 <code>self.property</code> 这种写法很不优雅。</p>
<p>第一种方法是只使用 <code>property</code>。但是同名变量（ivar）会产生歧义，Swift 没有这样的问题。</p>
<p>第二种方法是用 <code>property</code> 访问属性，用 <code>self-&gt;ivar</code> 去访问同名变量。这是不可行的，因为会和现有的大量代码冲突。Swift 也没有这样的问题。</p>
</blockquote>
<h3 id="前置条件与断言（Precondition_vs_Assert）">前置条件与断言（Precondition vs Assert）</h3><p>Dave Abrahams 提出了一个有关重命名断言和前置条件的建议，我立刻将其中的一些深刻见解记在笔记本上：</p>
<blockquote>
<p>从语言设计层面来说，这两个函数扮演不同的角色：<br>– assert：检查内部的错误代码。<br>– precondition：检查客户端给你的参数是否有效。</p>
<p>两者的区别很大，第二个要求有公共文档，第一个不需要。</p>
<p>例如：在 Swift 的标准库中，我们保证永远不会出现内存错误，除非你调用 (Obj)C 代码或者使用一个明确地标着「unsafe」的结构。我们需要去检验客户端参数，为了避免给了非法的参数引起内存泄露，我们要在参数中文档化这些需求作为前置条件，并且使用（等价的）precondition() 去检验它。我们还有一系列的内部合理检查，用以确定我们代码假定的正确性，而类型系统还不能保证这个代码的假定。由于这些原因，我们使用（等价的）assert()，因为我们不想降低<em>你的</em>代码性能（使用合理的检查）。</p>
<p>下面是几个具体的例子：</p>
</blockquote>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 一个集合，其中的元素类型为 Element</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Repeat</span>&lt;<span class="title">Element</span>&gt; : <span class="title">CollectionType</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/// 获取 `position` 位置的元素</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - 要求: `position` 是 `self` 中的有效位置并且 `position != endIndex`.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">subscript</span>(position: <span class="type">Int</span>) -&gt; <span class="type">Element</span> &#123;</span><br><span class="line">    _precondition(position &gt;= <span class="number">0</span> &amp;&amp; position &lt; <span class="built_in">count</span>, <span class="string">"Index out of range"</span>)</span><br><span class="line">    <span class="keyword">return</span> repeatedValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>.<span class="title">UTF8View</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">_encodeSomeContiguousUTF16AsUTF8</span><span class="params">(i: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">UTF8Chunk</span>) &#123;</span><br><span class="line">    _sanityCheck(elementWidth == <span class="number">2</span>)</span><br><span class="line">    _sanityCheck(!_baseAddress._isNull)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> storage = <span class="type">UnsafeBufferPointer</span>(start: startUTF16, <span class="built_in">count</span>: <span class="keyword">self</span>.<span class="built_in">count</span>)</span><br><span class="line">    <span class="keyword">return</span> _transcodeSomeUTF16AsUTF8(storage, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在第一个例子中，我们有一个判断客户的 collection 没有越界的前置条件。在这个例子中，我们其实可以不做检查，因为越界也不会导致内存错误（因为返回的都是同一个 repeatedValue），但是我们还是加上了这个检查，这样我们的用户可以快速发现他们的 bug 。</p>
<p>第二个例子中是一个私有函数，它只能在我们保证 elementWidth == 2 和 _baseAddress 不为 null 的条件下调用（_sanityCheck 在 stdlib 下等价于 assert）。因为这是私有函数，使用者就是我们自己，所以看起来这个检查可以省略。但是有时候会出意外，比如后续的开发者可能会错误地使用它，因此我们需要添加检查。因为我们在 debug 和 release 的环境下运行我们的测试，并且有较高的测试覆盖率，因此（如果错误使用函数）断言很可能在某处被触发。</p>
<p>读完上面的内容，你可能认为 assert() 只能在私有方法中使用，而 precondition() 只能在公共方法中使用。事实并非如此；你可以内联任何私有方法到继承的公有方法的方法体内，因此合理的检查依然有意义。前置条件检查也会偶尔在私有方法中使用，最简单的例子就是公有方法转私有方法，复制代码的时候可以把原来的前置条件检查提取成一个私有的辅助方法（Helper）。</p>
<p><sup>*</sup>注意，有些前置条件实际上不会被执行，所以你不能指望所有的前置条件都被执行。</p>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/15/interesting-discussions-on-swift-evolution/">原文链接</a>，原文日期：2015/12/15<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>记得我曾分享过一些想法和建议，比如：</p>
<h3 id="newtype">newtype</h3><p>一个是建议 Swift 推出一个 <code>newtype</code> 的关键词，它可以添加完全不同于原生的可扩展的派生类型。例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newtype <span class="type">Currency</span> = <span class="type">NSDecimal</span></span><br></pre></td></tr></table></figure>
<p>这创建了一个拥有所有 <code>NSDecimal</code> 所有行为的 <code>Currency</code> 类型。然而，你不能让一个 <code>NSDecimal</code> 类型的元素和一个 <code>Currency</code> 类型的元素相加，因为 Swift 中有类型检测。此外，你也可以扩展 <code>Currency</code> 类型。这样看起来就更加有针对性，因为不需要子类化或者添加新的存储属性。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Friday Q&A 2015-11-20：协变与逆变]]></title>
    <link href="http://swiftggteam.github.io/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/"/>
    <id>http://swiftggteam.github.io/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/</id>
    <published>2015-12-23T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-20<br>译者：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在现代的编程语言中，子类型（Subtypes）和超类型（Supertypes）已经成为了非常常见的一部分了。协变（Convariance）和逆变（Contravariance）则能告诉我们什么时候使用子类型或超类型会优于原来使用的类型。这在我们使用的大多数编程语言中非常的常见，但是很多开发者仍然对这些概念感到模糊不清。今天我们就来详细讨论一下。</p>
<a id="more"></a>
<h3 id="子类型（Subtypes）和超类型（Supertypes）">子类型（Subtypes）和超类型（Supertypes）</h3><p>我们都知道子类（Subclass）是什么。当你创建一个子类的时候，你就在创建一个子类型。用一个经典的例子来讲，就是用 <code>Animal</code> 的子类去创建一只 <code>Cat</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这让 <code>Cat</code> 成为了 <code>Animal</code> 的子类型，也就意味着所有的 <code>Cat</code> 都是 <code>Animal</code>。但并不意味着所有的 <code>Animal</code> 都是 <code>Cat</code>。</p>
<p>子类型通常能够替代超类型。很明显懂一点编程知识的任何程序员都知道，在 Swift 中，下面的代码的第一行能够正常的运行，然而第二行则不能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = <span class="type">Cat</span>()</span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">Cat</span> = <span class="type">Animal</span>()</span><br></pre></td></tr></table></figure>
<p>对于函数类型也是适用的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">animalF</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Animal</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">catF</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Cat</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> returnsAnimal: () -&gt; <span class="type">Animal</span> = catF  <span class="comment">//可以运行</span></span><br><span class="line"><span class="keyword">let</span> returnsCat: () -&gt; <span class="type">Cat</span> = animalF  <span class="comment">//出错</span></span><br></pre></td></tr></table></figure>
<p>这些在 Objective-C 下也能实现，只不过要用 block，而且语法上会显得比较丑。所以我坚定地使用 Swift。</p>
<p>注意，以下的代码是有问题的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">catCatF</span><span class="params">(inCat: Cat)</span></span> -&gt; <span class="type">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> inCat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animalAnimal: <span class="type">Animal</span> -&gt; <span class="type">Animal</span> = catCatF</span><br></pre></td></tr></table></figure>
<p>很困惑，不是吗？不用担心，整篇文章就是为了彻底了解为什么第一个版本是可行而第二个版本是不可行的。除此之外，我们在探索的过程中还会了解很多非常有用的东西。</p>
<h3 id="重写（Override）方法">重写（Override）方法</h3><p>类似的事情在重写方法中也能正确地执行，想象一下有这样一个类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们建立它的子类，然后重写父类的方法，并改变返回值的类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyCatLady</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做对吗？对。为什么呢？</p>
<p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="external">Liskov 替换原则</a>被用于指导何时该使用子类。简明扼要的来说，它指出任何子类的实例总是能够替代父类的实例。比如你有一个 <code>Animal</code>，你就能用 <code>Cat</code> 替代它；你也总是能够用 <code>CrazyCatLady</code> 替代 <code>Person</code>。</p>
<p>下面是使用 <code>Person</code> 作为例子写的一段代码，接下来会有解释来解释清楚：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: <span class="type">Person</span> = getAPerson()</span><br><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = person.purchaseAnimal()</span><br><span class="line">animal.pet()</span><br></pre></td></tr></table></figure>
<p>想象一下当 <code>getAPerson</code> 返回一位 <code>CrazyCatLady</code>。整段代码还可行吗？<code>CrazyCatLady.purchaseAnimal</code> 会返回一只 <code>Cat</code>。这个实例被放入了 <code>animal</code> 中。<code>Cat</code> 是 <code>Animal</code> 的一种，所以它也能够做 <code>Animal</code> 能够做的事情，包括 <code>pet</code> 方法。类似，<code>CrazyCatLady</code> 返回的 <code>Cat</code> 也是有效的。</p>
<p>我们这时把 <code>pet</code> 函数放入 <code>Person</code> 类中，所以我们能够知道一个人所养的特定的动物：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">pet</span><span class="params">(animal: Animal)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然，<code>CrazyCatLady</code> 只拥有宠物猫：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrazyCatLady</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">purchaseAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">pet</span><span class="params">(animal: Cat)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这样对吗？<em>不对！</em></p>
<p>为了理解为什么不对，我们来看一下使用这个方法的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: <span class="type">Person</span> = getAPerson()</span><br><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = getAnAnimal()</span><br><span class="line">person.pet(animal)</span><br></pre></td></tr></table></figure>
<p>假设 <code>getAPerson</code> 方法返回了一位 <code>CrazyCatLady</code>，第一行非常的正确：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person: <span class="type">Person</span> = getAPerson()</span><br></pre></td></tr></table></figure>
<p>如果 <code>getAnAnimal</code> 方法返回了一只 <code>Dog</code>，它也是 <code>Animal</code> 的子类但是和 <code>Cat</code> 有截然不同的表现。接下来的一行看上去也非常的正确：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> animal: <span class="type">Animal</span> = getAnAnimal()</span><br></pre></td></tr></table></figure>
<p>接下来我们的 <code>person</code> 变量中有一位 <code>CrazyCatLady</code>，以及在 <code>animal</code> 变量中有一只 <code>Dog</code>，然后执行了这一行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">person.pet(animal)</span><br></pre></td></tr></table></figure>
<p>爆炸了噜！<code>CrazyCatLady</code> 的 <code>pet</code> 方法期望参数是一只 <code>Cat</code>。对于这只 <code>Dog</code> 就显得无计可施。这个方法也有可能会访问其他的属性或者调用其他 <code>Dog</code> 类所不具备的方法。</p>
<p>这段代码原本是完全正确的。首先它得到 <code>Person</code> 和 <code>Animal</code>，然后调用 <code>Person</code> 中的方法让人拥有这个 <code>Animal</code>。上面的问题在于我们把 <code>CrazyCatLady.pet</code> 方法的参数类型变成了 <code>Cat</code>。这破坏了 Liskov 替换原则：此时的 <code>CrazyCatLady</code> 并不能在任意的地方替代 <code>Person</code> 的使用。</p>
<p>感谢编译器给我们留了一手。它明白使用子类型用于重写方法的参数类型是不正确的，会拒绝编译这个代码。</p>
<p>那在重写方法时使用不同的类型究竟对不对呢？对！事实上，你需要<em>超类型（Supertype）</em>。举一个例子，假设 <code>Animal</code> 是 <code>Thing</code> 的子类，那么当我们重写 <code>pet</code> 方法时，参数类型变为 <code>Thing</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">pet</span><span class="params">(thing: Thing)</span></span></span><br></pre></td></tr></table></figure>
<p>这保证了可替换性。如果是一个 <code>Person</code>，那么这个方法所传进来的参数类型始终是 <code>Animal</code>，这是 <code>Thing</code> 的一种。</p>
<p>有个重要的规则来了：函数的返回值可以换成原类型的<em>子类型</em>，在层级上<em>降</em>了一级；反之函数的参数可以换成原类型的<em>超类型</em>，在层级上<em>升</em>了一级。</p>
<h3 id="单独的函数（Standalone_functions）">单独的函数（Standalone functions）</h3><p>这种子类型和超类型的关系我们已经在类上面了解得很清楚了。它能够通过类与类之间的层级关系直接推出。那么如果是单独的函数关系呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f1: <span class="type">A</span> -&gt; <span class="type">B</span> = ...</span><br><span class="line"><span class="keyword">let</span> f2: <span class="type">C</span> -&gt; <span class="type">D</span> = f1</span><br></pre></td></tr></table></figure>
<p>这种关系什么时候是对的，什么时候又是错的呢？</p>
<p>这可以被看做是 Liskov 替换原则的一种精简版本。 事实上，你可以把函数想象成是非常小的（mini-objects）、只有一个方法的对象。当你有两个不同的对象类型时，怎么做才能够让这两个对象也遵循我们的原则呢？只有当原对象类型是后者类型的子类型就可以了。那什么时候函数是另一个函数的子类型呢？正如上面所见，当前者的参数是后者的超类型并且返回值是后者的子类型即可。</p>
<p>把这个方法应用在这儿，上面的代码当 <code>A</code> 是 <code>C</code> 的超类型且 <code>B</code> 是 <code>D</code> 的子类型时可以正常的执行。用具体的例子来说：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f1: <span class="type">Animal</span> -&gt; <span class="type">Animal</span> = ...</span><br><span class="line"><span class="keyword">let</span> f2: <span class="type">Cat</span> -&gt; <span class="type">Thing</span> = f1</span><br></pre></td></tr></table></figure>
<p>参数和返回值的类型朝着相反的方向移动。可能不是你所想的那样，但是这就是能让函数正确执行的唯一方法。</p>
<p>这又是一个重要的规则：一个函数若是另外一个函数的子类型，那么它的参数是原函数参数的<em>超类型</em>，返回值是原函数返回值的<em>子类型</em>（译者注：又叫做 <a href="http://www.wikiwand.com/en/Robustness_principle" target="_blank" rel="external">Robustness 原则</a>）。</p>
<h3 id="属性（Property）">属性（Property）</h3><p>如果是只读的属性那就很简单。子类的属性必须是父类属性的子类型。只读的属性本质上是一个不接收参数而返回成员值的函数，所以上述的规则依旧适用。</p>
<p>可读可写的属性其实也非常的简单。子类的属性必须和父类的属性类型相同。一个可读可写的属性其实由一对函数组成。<code>Getter</code> 是一个不接收参数而返回成员值的函数，<code>Setter</code> 则是一个需要传入一个参数但无需返回值的函数。看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> animal: <span class="type">Animal</span></span><br><span class="line"><span class="comment">// 这等价于：</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Animal</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">setAnimal</span><span class="params">(animal: Animal)</span></span></span><br></pre></td></tr></table></figure>
<p>正如我们之前得到的结论一样，函数的参数和返回值需要各自向上和向下改变一级。然而参数和返回值的类型却是固定的，所以它们的类型都不能被改变：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意到 animal 的类型是 Animal</span></span><br><span class="line"><span class="comment">// 这样不对（向下）</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">getAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Cat</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">setAnimal</span><span class="params">(animal: Cat)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样也不对（向上）</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">getAnimal</span><span class="params">()</span></span> -&gt; <span class="type">Thing</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">setAnimal</span><span class="params">(animal: Thing)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="泛型（Generics）">泛型（Generics）</h3><p>那如果是泛型呢？给定泛型类型的参数，什么时候又是正确的呢？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var1: <span class="type">SomeType</span>&lt;<span class="type">A</span>&gt; = ...</span><br><span class="line"><span class="keyword">let</span> var2: <span class="type">SomeType</span>&lt;<span class="type">B</span>&gt; = var1</span><br></pre></td></tr></table></figure>
<p>理论上来说，这要看泛型参数是如何使用的。一个泛型类型参数本身并不做什么事情，但是它会被用作于属性的类型、函数方法的参数类型和返回类型。</p>
<p>如果泛型参数仅仅被用作函数返回值的类型和只读属性身上，那么 <code>B</code> 需要是 <code>A</code> 的超类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var1: <span class="type">SomeType</span>&lt;<span class="type">Cat</span>&gt; = ...</span><br><span class="line"><span class="keyword">let</span> var2: <span class="type">SomeType</span>&lt;<span class="type">Animal</span>&gt; = var1</span><br></pre></td></tr></table></figure>
<p>如果泛型参数仅被用作于函数方法的参数类型，那么 <code>B</code> 需要是 <code>A</code> 的子类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> var1: <span class="type">SomeType</span>&lt;<span class="type">Animal</span>&gt; = ...</span><br><span class="line"><span class="keyword">let</span> var2: <span class="type">SomeType</span>&lt;<span class="type">Cat</span>&gt; = var1</span><br></pre></td></tr></table></figure>
<p>如果泛型参数在上述提到的两方面都被使用了，那么当且仅当 <code>A</code> 和 <code>B</code> 是相同类型的时候才是有效的。这也同样适用于当泛型参数作为可读可写属性的情况。</p>
<p>这就是理论部分，看上去有些复杂但其实很简短。与此同时，Swift 寻求到了其简便的解决之道。对于两个需要相互匹配的泛型类型，Swift 要求它们的泛型参数的类型也需要相同。子类型和超类型都是不被允许的，尽管理论上可行。</p>
<p>Objective-C 事实上比 Swift 更好一些。一个在 Objective-C 中的泛型参数可以在声明时增加 <code>__covariant</code> 关键字来表示它能够接受子类型，而在声明时增加 <code>__contravariant</code> 关键字来表示它能够接受超类型。这在 <code>NSArray</code> 和其他的类的接口中有所体现：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">@interface NSArray&#60;__covariant ObjectType&#62; : NSObject ...</span><br></pre></td></tr></table></figure>
<h3 id="协变和逆变（Convariance_and_Contravariance）">协变和逆变（Convariance and Contravariance）</h3><p>那些细心的读者会注意到：在标题中提到的两个词至今为止我通篇未提。现在我们既然了解了这些概念，那就来谈一下这几个专业术语。</p>
<p><em>协变（Convariance）</em>指可接受子类型。重写只读的属性是「协变的」。</p>
<p><em>逆变（Contravariance）</em>指可接受超类型。重写方法中的参数是「逆变的」。</p>
<p><em>不变（Invariance）</em>指既不接受子类型，又不接受超类型。Swift 中泛型是「不变的」。</p>
<p><em>双向协变（Bivariate）</em>指既接受子类型，又接受超类型。我想不到在 Objective-C 或 Swift 中的任何例子。</p>
<p>你会发现这种专业术语非常难记。那就对了，因为这并不重要。只要你懂得子类型、超类型，以及什么时候在特定位置适用一个类的子类或者超类就够了。在需要用到术语的时候看一下就够了。</p>
<h3 id="小结">小结</h3><p>协变和逆变决定了在特定位置该怎样使用子类型或超类型。通常出现在重写方法以及改变传入参数或者返回值类型的地方。这种情况下我们已经知道返回值必须是原来的子类型，而参数是原来的超类型。整个指导我们这么做的原则就叫做 Liskov 替换原则，意思是任何子类的实例总是能够使用在父类的实例所使用的地方。子类型和超类型就是从这条原则中衍生出来。</p>
<p>今天就到这儿了。记得回来探索更多有趣的事情；或者说就来探索有趣的事情。「更多」可能在这不适用，因为协变这件事并不是那么的令人激动。无论如何，我们的 Friday Q&amp;A 都会听从读者的建议，所以有什么更高的建议或者文章的话，记得<a href="mailto:mike@mikeash.com" target="_blank" rel="external">给我们写信</a>！</p>
<hr>
<p>译者注：</p>
<ol>
<li>Swift 中的泛型的确是「不变的（Invariance）」，但是 Swift 标准库中的 Collection 类型通常情况下是「协变的（Convariance）」。举个例子：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="comment">// 亦可以使用结构体 struct 声明</span></span><br><span class="line">    <span class="keyword">var</span> thing: <span class="type">T</span> </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> thing: <span class="type">T</span>) &#123; <span class="keyword">self</span>.thing = thing &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> foo: <span class="type">Thing</span>&lt;<span class="type">UIView</span>&gt; = <span class="type">Thing</span>(<span class="type">UIView</span>()) </span><br><span class="line"><span class="keyword">var</span> bar: <span class="type">Thing</span>&lt;<span class="type">UIButton</span>&gt; = <span class="type">Thing</span>(<span class="type">UIButton</span>()) </span><br><span class="line">foo = bar <span class="comment">// 报错：error: cannot assign value of type 'Thing&lt;UIButton&gt;' to type 'Thing&lt;UIView&gt;' </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 则不会报错 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> views: <span class="type">Array</span>&lt;<span class="type">UIView</span>&gt; = [<span class="type">UIView</span>()] </span><br><span class="line"><span class="keyword">var</span> buttons: <span class="type">Array</span>&lt;<span class="type">UIButton</span>&gt; = [<span class="type">UIButton</span>()] </span><br><span class="line">views = buttons</span><br></pre></td></tr></table></figure>
<ol>
<li>Swift 中的 Protocol 不支持这里的类型改变。如果某个协议是继承自另外一个协议而且尝试着「重写」父协议的方法，Swift 会把它当做是另外一个方法。举个例子：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>: <span class="title">Thing</span> </span>&#123;&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SuperP</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(animal: Animal)</span></span> -&gt; <span class="type">Animal</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SubP1</span>: <span class="title">SuperP</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(thing: Thing)</span></span> -&gt; <span class="type">Cat</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SubP2</span>: <span class="title">SuperP</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(cat: Cat)</span></span> -&gt; <span class="type">Thing</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementsSubP1</span>: <span class="title">SubP1</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(thing: Thing)</span></span> -&gt; <span class="type">Cat</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Cat</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementsSubP2</span>: <span class="title">SubP2</span> </span>&#123; </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">f</span><span class="params">(cat: Cat)</span></span> -&gt; <span class="type">Thing</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Thing</span>() </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// ImplementSubP1 和 ImplementSubP2 将不被认为遵循了 SuperP 的协议</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Mike Ash，<a href="https://mikeash.com/pyblog/friday-qa-2015-11-20-covariance-and-contravariance.html">原文链接</a>，原文日期：2015-11-20<br>译者：<a href="https://github.com/Cee">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>在现代的编程语言中，子类型（Subtypes）和超类型（Supertypes）已经成为了非常常见的一部分了。协变（Convariance）和逆变（Contravariance）则能告诉我们什么时候使用子类型或超类型会优于原来使用的类型。这在我们使用的大多数编程语言中非常的常见，但是很多开发者仍然对这些概念感到模糊不清。今天我们就来详细讨论一下。</p>]]>
    
    </summary>
    
      <category term="Mike Ash" scheme="http://swiftggteam.github.io/tags/Mike-Ash/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原创] 每周 Swift 社区问答 2015-12-23]]></title>
    <link href="http://swiftggteam.github.io/2015/12/23/swift-qa-2015-12-23/"/>
    <id>http://swiftggteam.github.io/2015/12/23/swift-qa-2015-12-23/</id>
    <published>2015-12-22T16:00:00.000Z</published>
    <updated>2015-12-23T15:15:15.447Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://codebuild.me" target="_blank" rel="external">shanks</a></p>
<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Code doesn’t work on Playground</a></li>
<li><a href="#Q2">Array cannot be bridged from Objective-C</a></li>
<li><a href="#Q3">Why do we need the keywords “let” and “var” at all ?</a></li>
<li><a href="#Q4">“If” statement with an optional value not working</a></li>
<li><a href="#Q5">Generic Random Function in Swift</a></li>
<li><a href="#Q6">Setting a variable to an operator function</a></li>
<li><a href="#Q7">Why I can’t use let in protocol in Swift?</a> </li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20151223/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420151223.playground" target="_blank" rel="external">点击下载</a></p>
<a id="more"></a>
<p><a name="Q1"></a></p>
<h2 id="Question1:_Code_doesn’t_work_on_Playground">Question1: Code doesn’t work on Playground</h2><p><a href="https://forums.developer.apple.com/thread/27995" target="_blank" rel="external">Q1链接地址</a></p>
<h3 id="问题描述">问题描述</h3><p>提问者说以下代码在 Playground 下运行， <code>range</code> 返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> telefone = <span class="string">"+42 43 23123-2221"</span>   </span><br><span class="line"><span class="keyword">let</span> range = telefone.rangeOfString(<span class="string">"\\d&#123;4,5&#125;\\-?\\d&#123;4&#125;"</span>, options:.<span class="type">RegularExpressionSearch</span>)   </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"range <span class="subst">\(range)</span>"</span>) <span class="comment">//here returns nil</span></span><br></pre></td></tr></table></figure>
<p>下面回复，实际上是可以的，亲测也是可以，也不知道提问者是不是 Xcode 版本问题，输出结果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">range <span class="type">Optional</span>(<span class="type">Range</span>(<span class="number">7</span>..&lt;<span class="number">17</span>))\n</span><br></pre></td></tr></table></figure>
<h3 id="解答">解答</h3><p>这个问题是关于正则表达式匹配的，匹配结果返回的是<code>Range</code>类型。<br>然后提问者不甘心，写出了一段很复杂的解决方案：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span>  </span><br><span class="line"><span class="keyword">var</span> telefone = <span class="string">"+55 11 11111‑1111"</span>  </span><br><span class="line"><span class="keyword">let</span> phoneNumberRegEx = <span class="string">"(?:(\\+\\d\\d\\s+)?((?:\\(\\d\\d\\)|\\d\\d)\\s+)?)(\\d&#123;4,5&#125;\\-?\\d&#123;4&#125;)"</span>;  </span><br><span class="line"><span class="keyword">let</span> <span class="type">range</span> = telefone.rangeOfString(phoneNumberRegEx,  </span><br><span class="line">    options:.<span class="type">RegularExpressionSearch</span>)  </span><br><span class="line">print(<span class="string">"range \(range)"</span>)  </span><br><span class="line"><span class="keyword">var</span> found = telefone.substringWithRange(<span class="type">range</span>!)  </span><br><span class="line">print(found)  </span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">try</span>! <span class="type">NSRegularExpression</span>(pattern: phoneNumberRegEx, options: [])  </span><br><span class="line"><span class="keyword">let</span> telephoneRange = <span class="type">NSMakeRange</span>(<span class="number">0</span>, telefone.characters.count)  </span><br><span class="line"><span class="keyword">let</span> <span class="literal">result</span> = regex.firstMatchInString(telefone, options: <span class="type">NSMatchingOptions</span>(rawValue: <span class="number">0</span>), <span class="type">range</span>: telephoneRange)  </span><br><span class="line"><span class="keyword">let</span> r1 = <span class="literal">result</span>!.rangeAtIndex(<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">let</span> r2 = <span class="literal">result</span>!.rangeAtIndex(<span class="number">2</span>)  </span><br><span class="line"><span class="keyword">let</span> r3 = <span class="literal">result</span>!.rangeAtIndex(<span class="number">3</span>)  </span><br><span class="line"><span class="keyword">if</span> (r1.length &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">let</span> phoneCountry = (telefone <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(r1)  </span><br><span class="line">    print(<span class="string">"country: \(phoneCountry)"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (r2.length &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">let</span> phoneArea = (telefone <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(r2)  </span><br><span class="line">    print(<span class="string">"area: \(phoneArea)"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (r3.length &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">let</span> phone = (telefone <span class="keyword">as</span> <span class="type">NSString</span>).substringWithRange(r3)  </span><br><span class="line">    print(<span class="string">"phone: \(phone)"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说会报错，下面大神看出了问题：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">var telefone = "+55 11 11111‑1111"  //字符'‑'和下面正则表达式的字符'-'匹配不上</span><br><span class="line">let phoneNumberRegEx = "(?:(<span class="command">\\</span>+<span class="command">\\</span>d<span class="command">\\</span>d<span class="command">\\</span>s+)?((?:<span class="command">\\</span>(<span class="command">\\</span>d<span class="command">\\</span>d<span class="command">\\</span>)|<span class="command">\\</span>d<span class="command">\\</span>d)<span class="command">\\</span>s+)?)(<span class="command">\\</span>d<span class="special">&#123;</span>4,5<span class="special">&#125;</span><span class="command">\\</span>-?<span class="command">\\</span>d<span class="special">&#123;</span>4<span class="special">&#125;</span>)";</span><br></pre></td></tr></table></figure>
<p>原来是telefone中的字符”‑”(U+002D)和正则表达式中的字符”-“(U+2011)用混了。统一改成”-“(U+2011)就好了。</p>
<p>估计第一个问题也是这样造成的。</p>
<p><a name="Q2"></a></p>
<h2 id="Question2:_Array_cannot_be_bridged_from_Objective-C">Question2: Array cannot be bridged from Objective-C</h2><p><a href="https://forums.developer.apple.com/thread/28678" target="_blank" rel="external">Q2链接地址</a></p>
<h3 id="问题描述-1">问题描述</h3><p>以下代码会在<code>testUnbridgableArrayOfPs</code>函数中报错:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PImpl</span>: <span class="title">P</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">unbridgableArrayOfPs</span><span class="params">()</span></span> -&gt; [<span class="type">P</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> pees = [<span class="type">PImpl</span>(name: <span class="string">"A"</span>), <span class="type">PImpl</span>(name: <span class="string">"B"</span>), <span class="type">PImpl</span>(name: <span class="string">"C"</span>)]</span><br><span class="line">    <span class="keyword">return</span> pees</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arrayOfPs</span><span class="params">()</span></span> -&gt; [<span class="type">P</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="type">PImpl</span>(name: <span class="string">"A"</span>), <span class="type">PImpl</span>(name: <span class="string">"B"</span>), <span class="type">PImpl</span>(name: <span class="string">"C"</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testUnbridgableArrayOfPs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = unbridgableArrayOfPs() <span class="comment">// Fails with fatal error: array cannot be bridged from Objective-C</span></span><br><span class="line">    <span class="keyword">let</span> result = p.<span class="built_in">map</span>&#123;$<span class="number">0</span>.name&#125;.joinWithSeparator(<span class="string">""</span>)</span><br><span class="line">    <span class="comment">//XCTAssertEqual(result, "ABC")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testArrayOfPs</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = arrayOfPs() <span class="comment">// We get our P's</span></span><br><span class="line">    <span class="keyword">let</span> result = p.<span class="built_in">map</span>&#123;$<span class="number">0</span>.name&#125;.joinWithSeparator(<span class="string">""</span>)</span><br><span class="line">   <span class="comment">// XCTAssertEqual(result, "ABC")</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testUnbridgableArrayOfPs()</span><br><span class="line">testArrayOfPs()</span><br></pre></td></tr></table></figure>
<p>楼主还用了<code>XCTAssertEqual</code>来进行测试，但是 Playground不支持<code>XCTest</code>测试框架，所以代码我就现注释掉了。<br>楼主吐槽，定义了变量，使用了类型推断，就会报错。直接返回就不会。。</p>
<h3 id="问题解答">问题解答</h3><p>不使用类型推断，定义时候，直接指定类型，就没有问题了：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let pees: [P] = [<span class="function"><span class="title">PImpl</span><span class="params">(name: <span class="string">"A"</span>)</span></span>, <span class="function"><span class="title">PImpl</span><span class="params">(name: <span class="string">"B"</span>)</span></span>, <span class="function"><span class="title">PImpl</span><span class="params">(name: <span class="string">"C"</span>)</span></span>]</span><br></pre></td></tr></table></figure>
<p>类型推断会把<code>pees</code> 推断为<code>PImpl</code>类型，虽然<code>PImpl</code>遵从协议<code>P</code>，目前还是需要显式做一下声明或者转换。<code>OOPer</code> 还提供了以下 2 种转换方式：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pees = [PImpl(name: <span class="string">"A"</span>), PImpl(name: <span class="string">"B"</span>), PImpl(name: <span class="string">"C"</span>)] <span class="keyword">as</span> [P] </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pees = [PImpl(name: <span class="string">"A"</span>), PImpl(name: <span class="string">"B"</span>), PImpl(name: <span class="string">"C"</span>)]  </span><br><span class="line"><span class="keyword">let</span> peesAsArrayP: [P] = pees.<span class="keyword">map</span>&#123;<span class="variable">$0</span> as P&#125;  </span><br><span class="line"><span class="keyword">return</span> peesAsArrayP</span><br></pre></td></tr></table></figure>
<p><a name="Q3"></a></p>
<h2 id="Question3:_Why_do_we_need_the_keywords_“let”_and_“var”_at_all_?">Question3: Why do we need the keywords “let” and “var” at all ?</h2><p><a href="https://forums.developer.apple.com/thread/28673" target="_blank" rel="external">Q3链接地址</a></p>
<h3 id="问题描述-2">问题描述</h3><p>这个问题没有涉及到代码，提问者写了几段文字，为了表达自己的观点：为神马会有<code>var</code>关键字的存在，完全可以去掉：</p>
<ul>
<li>定义局部变量时，如果要定义一个常量，可以直接使用<code>let</code>,然后其他非常量的情况下，完全可以省略掉<code>var</code>, 因为可以直接推断出来啊</li>
<li>类中变量定义也是可以类似的来做，<code>let</code> 定义常量，没有<code>let</code>就是变量</li>
</ul>
<p>回想一下好像是这么一回事。。。</p>
<h3 id="问题解答-1">问题解答</h3><p>这个问题引来了 Chris Lattner 的回复。。。，所以得好好说说， Chris 回复的大概意思如下：<br>首先，Chris 认为这个问题很有意思，说明 Swift 作者也应该思考过这个问题的。的确， Swift 编译器是可以基于提问者的思考，去推断出变量的可变修饰符，加<code>var</code> 和没加<code>var</code>对于编译器来讲没啥区别。主要基于2个目的来设计的<code>var</code>关键字：</p>
<ul>
<li>human factors：主要是从可读性来讲，显式的声明<code>var</code>能够让代码更加可读，有点类似于 Swift 中目前饱受诟病的类型推断一样，目前大部分指南，都推荐你显式定义类型，可读性很高，且编译器不会出错。</li>
<li>hard cases：在一些复杂的情况下，没有使用<code>var</code>和<code>let</code>，编译器会很难推断出来是变量还是常量（公共全局变量，公共实例变量等）。所以人为使用<code>var</code>和<code>let</code>表明你的态度很重要。</li>
</ul>
<p><a name="Q4"></a></p>
<h2 id="Question4:_“If”_statement_with_an_optional_value_not_working">Question4: “If” statement with an optional value not working</h2><h3 id="问题链接">问题链接</h3><p><a href="http://stackoverflow.com/questions/34389158/if-statement-with-an-optional-value-not-working" target="_blank" rel="external">Q4链接地址</a></p>
<h3 id="问题描述-3">问题描述</h3><p>此贴问题比较初级，楼主问的问题也是错误的，但是对于初学者来讲，值得一看。主要是对 Optional 类型的使用和理解。首先我们看看问题：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = Optional(<span class="string">"6"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is 6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is not 6"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>楼主说定义了一个值为 Optional(“6”) 的变量 x， 然后去和数字 6 比较，这段代码在 Playground 运行，因为 Optional(“6”) 是 Optional<string> 类型的，不能和 Int 进行比较。</string></p>
<h3 id="问题解答-2">问题解答</h3><p>上述代码改为：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = Optional(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is 6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is not 6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： x is 6</span></span><br></pre></td></tr></table></figure>
<p>x 的类型是一个可选类型，直接使用 if 去和固定值进行比较，编译器会拆包出来真正的值去比较。不过更推荐的做法是，使用 if let 去显式拆包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x1 = <span class="type">Optional</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> y = x1 <span class="keyword">where</span> y == <span class="number">6</span>  &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is 6"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x is not 6"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Q5"></a></p>
<h2 id="Question5:_Generic_Random_Function_in_Swift">Question5: Generic Random Function in Swift</h2><h3 id="问题链接-1">问题链接</h3><p><a href="http://stackoverflow.com/questions/34387250/generic-random-function-in-swift" target="_blank" rel="external">Q5链接地址</a></p>
<h3 id="问题描述-4">问题描述</h3><p>问题很简单，如何实现随机数生成的泛型表达，支持 Int， Float，Double 和 CGFloat？</p>
<h3 id="问题解答-3">问题解答</h3><p>首先，可以分部对这几种类型做扩展，来生成随机数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Int = <span class="number">0</span>, <span class="number">_</span> upper: Int = <span class="number">100</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lower + <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(upper - lower + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Double = <span class="number">0</span>, <span class="number">_</span> upper: Double = <span class="number">100</span>)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Double</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Float</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Float = <span class="number">0</span>, <span class="number">_</span> upper: Float = <span class="number">100</span>)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Float</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">CGFloat</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: CGFloat = <span class="number">0</span>, <span class="number">_</span> upper: CGFloat = <span class="number">1</span>)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="type">Float</span>(arc4random()) / <span class="type">Float</span>(<span class="type">UINT32_MAX</span>)) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Int</span>.random()</span><br></pre></td></tr></table></figure>
<p>也可以使用扩展协议来实现，不过 Int 和 Float，Double，CGFloat的协议不太一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FloatingPointArithmeticType</span>: <span class="title">FloatingPointType</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> /<span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="comment">// etc</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span>: <span class="title">FloatingPointArithmeticType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Float</span>: <span class="title">FloatingPointArithmeticType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGFloat</span>: <span class="title">FloatingPointArithmeticType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">FloatingPointArithmeticType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">rand</span><span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="type">Self</span>(arc4random())</span><br><span class="line">        <span class="keyword">let</span> denom = <span class="type">Self</span>(<span class="type">UInt32</span>.<span class="built_in">max</span>)</span><br><span class="line">        <span class="comment">// this line won’t compile:</span></span><br><span class="line">        <span class="keyword">return</span> num / denom</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// so these now work</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="type">Double</span>.rand()  <span class="comment">// etc</span></span><br></pre></td></tr></table></figure>
<p>而 Int 的随机数，直接通过<code>arc4random()</code>生成来转换，因为<code>arc4random()</code>结果是<code>UInt32</code>的,代码在第一段已经有了，直接基于 Int 去扩展。</p>
<p><a name="Q6"></a></p>
<h2 id="Question6:_Setting_a_variable_to_an_operator_function">Question6: Setting a variable to an operator function</h2><h3 id="问题链接-2">问题链接</h3><p><a href="http://stackoverflow.com/questions/34386306/setting-a-variable-to-an-operator-function" target="_blank" rel="external">Q6链接地址</a></p>
<h3 id="问题描述-5">问题描述</h3><p>楼主的问题是，既然函数可以是第一公民，那么运算符也能够是第一公民，可以当成右值赋值给一个变量。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> +<span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> op = + <span class="comment">// results in an error</span></span><br></pre></td></tr></table></figure>
<p>但是，这段代码会报错，这是为什么呢？</p>
<h3 id="问题解答-4">问题解答</h3><p>在 Swift 中，函数是第一公民，运算符也是第一公民，但是在作为右键赋值时，需要加括号包住操作符，并且要求显式定义操作符变量的类型，或者做显式转换：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">func +<span class="function"><span class="params">(lhs: Int, rhs: Int)</span> -&gt;</span> Int &#123; <span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="function"><span class="title">v</span> = <span class="params">(+)</span> <span class="title">as</span> <span class="params">(Int,Int)</span> -&gt;</span> Int</span><br><span class="line"><span class="keyword">let</span> out = v(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(out)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attribute">op</span>: <span class="function"><span class="params">(Int, Int)</span> -&gt;</span> Int = (+)</span><br><span class="line">op(<span class="number">3</span>, <span class="number">4</span>) <span class="pi">//输出1，如果去掉自定义+操作符，输出7</span></span><br></pre></td></tr></table></figure>
<p>在另外一篇post中，也是类似的提问：<br><a href="http://stackoverflow.com/questions/30017400/set-a-variable-to-the-less-than-operator-as-a-function-in-swift" target="_blank" rel="external">set-a-variable-to-the-less-than-operator-as-a-function-in-swift</a></p>
<p><a name="Q7"></a></p>
<h2 id="Question7:_Why_I_can’t_use_let_in_protocol_in_Swift?">Question7: Why I can’t use let in protocol in Swift?</h2><h3 id="问题链接-3">问题链接</h3><p><a href="http://stackoverflow.com/questions/34385897/why-i-cant-use-let-in-protocol-in-swift" target="_blank" rel="external">Q7链接地址</a></p>
<h3 id="问题描述-6">问题描述</h3><p>楼主问，为啥以下协议定义中的只读存储变量，不能使用<code>let</code>定义的常量替代？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">someProtocol</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> someProperty: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">someProtocol1</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">let</span> someProperty: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-5">问题解答</h3><p><code>let</code> 修饰的是常量，而协议里面是不能指定变量的存储方式的，也就是说，如果要在协议里面，要求遵从只读属性，只能使用var和get，也就是<code>var someProperty: String { get }</code>这种写法。<br>在具体定义的类或者结构体中，如果协议是要求只读计算属性，那么具体的实现可以使用<code>let</code>修饰，也可以实现<code>set</code>操作，也可以是一个存储属性。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someProperty: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;  <span class="comment">// abstract interface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>: <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> someProperty: <span class="type">String</span>  <span class="comment">// concrete implementation: stored property</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OtherStruct</span>: <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> someProperty: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(str)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            str = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// concrete implementation: computed property</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">MyStruct</span>(someProperty: <span class="string">""</span>)</span><br><span class="line"><span class="comment">//a.someProperty = "est" --错误，常量不能修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="type">OtherStruct</span>(str: <span class="string">"test"</span>)</span><br><span class="line">b.someProperty</span><br><span class="line">b.someProperty = <span class="string">"other test"</span></span><br><span class="line">b.str</span><br></pre></td></tr></table></figure></p>
<p>也就是说，协议要求只是一个最小化要求。如果协议是定义的<code>get</code>和<code>set</code>，那么具体实现就不能定义为只读的了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someProperty: <span class="type">String</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;  <span class="comment">// abstract interface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OtherStruct1</span>: <span class="title">MyProtocol1</span> </span>&#123; <span class="comment">//错误：candidate is not settable, but protocol requires it</span></span><br><span class="line">    <span class="keyword">var</span> str: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> someProperty: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"<span class="subst">\(str)</span>"</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;  <span class="comment">// concrete implementation: computed property</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://codebuild.me">shanks</a></p>
<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Code doesn’t work on Playground</a></li>
<li><a href="#Q2">Array cannot be bridged from Objective-C</a></li>
<li><a href="#Q3">Why do we need the keywords “let” and “var” at all ?</a></li>
<li><a href="#Q4">“If” statement with an optional value not working</a></li>
<li><a href="#Q5">Generic Random Function in Swift</a></li>
<li><a href="#Q6">Setting a variable to an operator function</a></li>
<li><a href="#Q7">Why I can’t use let in protocol in Swift?</a> </li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20151223/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420151223.playground">点击下载</a></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/tags/Swift/"/>
    
      <category term="原创" scheme="http://swiftggteam.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="社区问答" scheme="http://swiftggteam.github.io/tags/%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%94/"/>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/categories/Swift/"/>
    
      <category term="iOS开发" scheme="http://swiftggteam.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 3 及展望]]></title>
    <link href="http://swiftggteam.github.io/2015/12/23/swift-3/"/>
    <id>http://swiftggteam.github.io/2015/12/23/swift-3/</id>
    <published>2015-12-22T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-3/" target="_blank" rel="external">原文链接</a>，原文日期：2015/12/10<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<!--此处开始正文-->
<p>2015 年 12 月 3 日，Swift 正式开源。同时，官方也公布了 Swift 3 的最新消息，即 Swift 3 将会在 2016 年秋天发布。</p>
<a id="more"></a>
<h2 id="API_设计指南与_Swift_中_Objective-C_的导入">API 设计指南与 Swift 中 Objective-C 的导入</h2><p>Swift 3 的 API 设计指南将与 Objective-C 中 Cocoa 的完全不同。这就意味着 Objective-C 中的 API 映射到 Swift 时会与以往不同。<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="external">这里</a>有一个相关的例子可以研究一下。以下这行代码的方法调用是从现有的 Objective-C 中「翻译」成 Swift 的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> contentString = listItemView.stringValue.stringByTrimmingCharactersInSet(</span><br><span class="line">   <span class="type">NSCharacterSet</span>.whitespaceAndNewlineCharacterSet())</span><br></pre></td></tr></table></figure>
<p>而在 Swift 3 中同样的方法调用将会是下面这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> content = listItem.stringValue.trimming(.whitespaceAndNewlines)</span><br></pre></td></tr></table></figure>
<p>这样让语法看上去更「Swift 化」。然而，这也意味着已经导入的 Objective-C API 将会有很大变动，因此，现有的这些代码将会报错。</p>
<h2 id="彻底的泛型">彻底的泛型</h2><p>Swift 有泛型，但是这次是为了引进新的特性，就像递归协议约束（使得受限的扩展遵循新协议的能力），比如遵循 <code>Equatable</code> 的数组的元素也是遵循 <code>Equatable</code> 的。</p>
<h2 id="精简的语言">精简的语言</h2><p>对于那些「和 Swift 语法不是很配」的语言特性仍然会有一些小改动。同样的，这也会使得现有的这些代码报错。</p>
<h2 id="展望_Swift_3">展望 Swift 3</h2><ul>
<li><p>Swift 目前还没有在语言层面支持并发操作。取而代之的是使用 NSOpertion 或 dispatch queues 来处理。这种状况在 Swift 3 中仍然不会改变。但是，在未来（Swift 4？）可能会有一个语言层面上并发操作的支持。</p>
</li>
<li><p>Swift 和 C，特别是 Objective-C，现在已经有了很好的兼容。但是，却缺乏与 C++ 的兼容。虽然，这也不会在 Swift 3 上有所改变，但是这需要一个比较长期的目标来引进它。</p>
</li>
</ul>
<h2 id="小结">小结</h2><p>首先，Swift 将会在未来大规模的改善和提升，这是一个非常好的消息。另一方面，Swift 3 的发布会使得现有的 Swift 2 代码报错，因此，需要做一些代码迁移的工作才行。</p>
<h2 id="参考">参考</h2><p><a href="http://swift.org/" target="_blank" rel="external">Swift.org</a><br><a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">Swift Programming Language Evolution</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Thomas Hanning，<a href="http://www.thomashanning.com/swift-3/">原文链接</a>，原文日期：2015/12/10<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="undefined"></a></p>
</blockquote>
<!--此处开始正文-->
<p>2015 年 12 月 3 日，Swift 正式开源。同时，官方也公布了 Swift 3 的最新消息，即 Swift 3 将会在 2016 年秋天发布。</p>]]>
    
    </summary>
    
      <category term="Thomas Hanning" scheme="http://swiftggteam.github.io/tags/Thomas-Hanning/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Swift 中使用 Alamofire 进行网络编程]]></title>
    <link href="http://swiftggteam.github.io/2015/12/22/alamofire-beginner-guide/"/>
    <id>http://swiftggteam.github.io/2015/12/22/alamofire-beginner-guide/</id>
    <published>2015-12-21T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：gregg mojica，<a href="http://www.appcoda.com/alamofire-beginner-guide/" target="_blank" rel="external">原文链接</a>，原文日期：2015/11/30<br>译者：<a href="http://weibo.com/linusling" target="_blank" rel="external">小铁匠Linus</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>2014 年 6 月 Apple 发布 Swift 以来，如何在 Swift 中进行网络编程一直成为程序猿们关注的焦点。甚至就连 Swift 的作者之一 Chris Lattner 也发推说过，在 Swift 中解析 JSON 还有很长的路要走。因此，许多人开始寻求替代方案。在 Swift 中虽然有处理 JSON 解析的内建类，但是对开发者来说并不是很友好。幸运的是，Alamofire 出现了。Alamofire 是一个可以帮助我们解析 JSON 的强力网络库，它由 Objective-C 中同类网络库 AFNetworking 的作者编写。</p>
<p>在这个又臭又长、近乎 3500 多词（译者注：in English；定稿注：这是作者原话，不是译者观点）的教程中，我们将探讨一系列广泛的网络基本话题，并建立一个假日待办应用。</p>
<p>同时，你会从本教程中学到：如何使用和解析 JSON、如何自定义服务器端、如何使用 <a href="https://www.heroku.com/" target="_blank" rel="external">Heroku</a> 和 <a href="https://mongolab.com/" target="_blank" rel="external">MongoLab</a> 等工具、HTTP 的工作原理（包括 GET，POST 和 DELETE 请求）、如何使用 git 和终端（terminal）以及如何使用 Cocoapods。如果你觉得上面提到的内容太多了，那就对了，拿一杯咖啡，就让我们开始吧。</p>
<a id="more"></a>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/thangiving-app-coda-20151-1024x768.png" alt=""></p>
<p>哦，AppCoda 的所有作者祝大家节日开心！😊</p>
<p>注意：本教程是一个进阶教程，涵盖了很多东西。而且，我假设你已经对 iOS 和 Swift 有了很坚实的了解。文章中诸如 tableviews， autolayout，delegate 等话题都不会深入的解释原理。你如果不熟悉这些内容，可以先去学习我们推出的<a href="http://www.appcoda.com/ios-programming-course/" target="_blank" rel="external">优秀课程</a>，然后再回来看本教程。</p>
<h2 id="开始">开始</h2><p>为了实现本教程要实现的功能，我已用 Node.js 写了一个服务器后端。这里需要给那些对它不熟悉的人解释一下，Node.js 是一个基于 Javascript、运行在 Google Chrome 的 V8 引擎中的运行时环境。长话短说，总之它是一个特别可靠、速度特别快、特别厉害的东西，哈哈。</p>
<p>为了搞定这个后端，我同时也使用了 Restify 和 MongoDB。MongoDB 是在 Web 开发人员中很流行的一个 no-SQL 数据库。我们可以使用 MongoDB 存储所有数据。</p>
<p>我刚开始使用 Node 时，完全不知道这些东西是怎么运行的，我看到的其他博客也没有解释 Node 到底是怎么工作的。因此，尽管这是个 iOS 的博客，但我还是要介绍一下 Javascript 和 Node 服务器的工作原理。</p>
<p>我搜遍了网络，都没有一个详细的教程引导你创建一个 API 与 iOS 应用程序交互的步骤，直到本文出现。</p>
<h2 id="遇见_Node-js">遇见 Node.js</h2><p>像我之前说的那样，Node.js 是一个很强大的服务器端开发技术，它建立在 Chrome 的运行时环境上。因此，它是高度异步和非阻塞的（如果你不知道我说的是什么意思，其实很简单，大概就是：使用主线程或者应用的主要部分不会被阻塞）。多线程是一种可以防止延迟且能提高项目效率的编程技术。你可以把应用想象成一条高速公路，如果只有一条通道，却有 20 辆车要通过，那么他们就很有可能会堵车。如果一条高速公路有三条包含出入口的通道，那么堵车的可能性就很小。多线程就可以这样来理解。在一个多线程的环境里，代码执行在不同的线程就可以避免应用阻塞，从而防止程序崩溃。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/1436439824nodejs-logo.png" alt=""></p>
<p>Node 是由 Joyent 开发并维持的，Joyent 是一家位于旧金山的云计算公司。</p>
<p>如果你仍然不清楚所有这些是怎么运行的，想想后端具体干了些什么吧。下面是后端完成的工作：</p>
<ol>
<li>后端提供了 API 路由（我们现在正在为当前的应用构建 API，就和网络上其他的 API 一样，其中包括了我们在之前的 <a href="http://www.appcoda.com/tvos-introduction/" target="_blank" rel="external">tvOS 教程</a>中使用的 <a href="http://forecast.io/" target="_blank" rel="external">forecast.io</a> API）。</li>
<li>MongoDB 用来保存所有数据。当你想要 POST 一条新消息时，我们需要找个地方来存储这条消息。在本教程中，我们把这些数据存储到 MongoDB 数据库中。</li>
<li>创建一个功能完整的 REST API，它遵循 REST 协议。</li>
</ol>
<p>我们的 MongoDB 放在 MongoLab 的主机上，Node 服务器放在 Heroku 上。Heroku 由 Salesforce 提供支持，可以作为 Node、Rails、Python 等应用的主机服务商。MongoLab 也是一家可以当 MongoDB 主机的服务商。</p>
<h2 id="HTTP_请求介绍">HTTP 请求介绍</h2><p>在我们开始写代码之前，你应该了解 HTTP 请求以及如何在我们的应用里使用。</p>
<ul>
<li><p>GET 请求 - GET 请求会查询我们的数据库，然后获取内容。GET 请求可以获取一个、多个或全部的内容。事实上，每次你访问 <a href="http://google.com/" target="_blank" rel="external">google.com</a> 或浏览你的 Facebook/Twitter 主页，你都会发起 GET 请求（可能你之前都不知道这个东西）！</p>
</li>
<li><p>POST 请求 - POST 请求会发送数据到服务器，然后保存这个数据。举个例子，当你在 Facebook 或 Twitter 上写好文字，然后按 Post/Tweet 按钮的时候，你就发起了 POST 请求。</p>
</li>
<li><p>UPDATE 请求 - UPDATE 请求可以让你修改已经存在的内容。当你编辑一条 Facebook 消息时，其实使用到了 UPDATE 请求。</p>
</li>
<li><p>DELETE 请求 - DELETE 请求会删除对应的内容。当你按了删除按钮删除 Facebook 或 Twitter 消息的时候，其实是调用了 DELETE 请求。</p>
</li>
</ul>
<p>以上这四个请求类型是基于 REST 协议的。Internet 能运行就是由这些请求组成的。你可能也听说过 CRUD 这个缩写词，CRUD 是由 <strong>C</strong>reate，<strong>R</strong>ead，<strong>U</strong>pdate 和 <strong>D</strong>elete 的首字母组成的。很显然，这些单词就和 POST，GET，UPDATE 和 DELETE 是一一对应的。</p>
<p>帅气！现在我们已经对 HTTP 协议有一定的理解了，我们可以进入到这次教程的核心部分了。</p>
<h2 id="配置必要的工具">配置必要的工具</h2><p>在我们使用 MongoLab 或 Heroku 之前，我们应该要确保 Node.js 能正常使用。</p>
<p>打开 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>，按照教程下载 Node 到你的电脑上。</p>
<p>然后，到 <a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" rel="external">npm 官网</a>下载 npm。</p>
<p>为了正确配置我们的后端，需要分别在 Heroku 和 MongoLab 上注册帐号。我们先从 MongoLab 开始吧，去 <a href="https://mongolab.com/home" target="_blank" rel="external">MongoLab 官网</a>注册帐号。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Untitled-1024x640.png" alt=""></p>
<p>确保选择的是 single-node（免费），填上你数据库的名字。我这边取名为 <em>alamofire-db</em>（以 db 为后缀表示是一个数据库，这是比较普遍的命名规范）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Untitled2-1024x640.png" alt=""></p>
<p>接下来，登录你的数据库，定位好 MongoDB 数据库的 URI。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-2.35.58-PM-1024x328.png" alt=""></p>
<p>然后添加一个新的数据库帐号，输入用户名和密码。不要忘记密码。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-2.38.15-PM-1024x478.png" alt=""></p>
<p>现在返回到你设置 URI 的页面，修改成新的地址。比如：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mongodb://<span class="variable">&lt;dbuser&gt;</span>:<span class="variable">&lt;dbpassword&gt;</span><span class="comment">@ds057954.mongolab.com:57954/alamofire-db</span></span><br></pre></td></tr></table></figure>
<p>替换成：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">mongodb:</span><span class="comment">//gregg:test@ds057954.mongolab.com:57954/alamofire-db</span></span><br></pre></td></tr></table></figure>
<p>MongoLab 搞定！</p>
<p>现在去 <a href="http://heroku.com/" target="_blank" rel="external">Heroku.com</a>，免费注册后，打开 <a href="https://toolbelt.heroku.com/" target="_blank" rel="external">heroku toolbelt 页面</a>。</p>
<p>按照教程成功安装后，打开终端并登录 heroku。如果你之前从未使用过终端，不用担心。本教程会多次使用终端，这样你最终就会对终端的使用有一个清晰的认识。</p>
<p>一旦你在终端上登录 heroku，就可以使用 cd 命令（cd 代表改变目录）进到对应目录，将之前从 dropbox 下载的工程文件夹移动进去。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-3.03.13-PM-2.png" alt=""></p>
<p>按下回车键就可以执行这行命令了。干的不错，现在我们可以用 <strong>git</strong> <strong>提交（Push）</strong>东西到 heroku 了。</p>
<p>在终端中键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"First Commit"</span></span><br></pre></td></tr></table></figure>
<p>这三行命令，初始化了一个仓库（repository，简写为 repo），并添加了当前目录下的所有文件到这个仓库，最终提交并保存。</p>
<p>git 是一款很流行的版本控制软件。</p>
<p>现在你可以看到，终端里应该和下图的内容差不多：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-3.09.42-PM-2.png" alt=""></p>
<p>因为你之前已经成功安装了 heroku toolbelt，所以你现在可以在终端里键入 <em>heroku login</em>，并输入帐号密码。敲回车后继续，如果帐号密码没问题的话，你的 Email 会以蓝绿色高亮显示。</p>
<p>现在，键入 <strong>heroku create</strong> 来创建一个新的 heroku 应用。Heroku 会创建一个新的带有域名的应用给你。比如，我的就是 <a href="https://whispering-plains-1537.herokuapp.com/。" target="_blank" rel="external">https://whispering-plains-1537.herokuapp.com/。</a></p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-3.50.39-PM-2.png" alt=""></p>
<p>现在，键入 <strong>git push heroku master</strong> 来把你新建的应用发送到 heroku。</p>
<p>如果一切顺利的话，会显示如下图（其中的某一些设置可能会不同）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-5.06.08-PM-2.png" alt=""></p>
<h2 id="使用_Node-js,_Express,_MongoLab_&amp;_Mongoose">使用 Node.js, Express, MongoLab &amp; Mongoose</h2><p>让我们从下载示例工程开始，<a href="https://www.dropbox.com/sh/hvvneknq4hh7ntw/AAARljJGt3OLLjQRmIMxDsIHa?dl=0" target="_blank" rel="external">链接在这里</a>。打开你最喜欢的文本编辑器（我这边用的是 Sublime Text 2；可以在<a href="http://sublimetext.com/" target="_blank" rel="external">这里</a>下载免费版，如果你支持的话也可以购买），然后继续。</p>
<p>Javascript 在很大程度上是和 Swift 很相似的。我们之后会使用 express 和 mongoose 两个著名 node 包。请确保你已经在系统上安装 npm 和 node 包管理器。</p>
<p>Express 是 <a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a> 中的一个「快速、强大而又轻量级」的网络框架，它可以轻松解决路由（Route）问题。你问什么是路由？路由就是你与网络交互的方式。每次你打开 google.com 的时候，其实你访问的是根主页，即 google.com/。假如你访问 google.com/hello，那就是另外一个路由了。我们接下来将要定义一个能访问我们数据库的路由。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-5.11.44-PM-2-1024x576.png" alt=""></p>
<p>你可以从 expressjs.org 官网上学习更多关于 express 的知识。</p>
<p>下面是示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> app = express(); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 当一个 GET 请求访问主页的时候，会返回 hello world</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; <span class="comment">// 3</span></span><br><span class="line">  res.send(<span class="string">'hello world'</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一行代码设置了一个叫 express 的变量。第二行代码，把 express 初始化后赋值给一个叫 app 的变量。在第三行代码，app 这个变量代表了 express 环境，调用它的 get() 方法（形式类似 Swift）。当一个用户访问 / 根主页的时候，就会显示「hello world」。这是 express 作为路由的一个例子。如果需要更多信息，可以访问 <a href="http://expressjs.com/guide/routing.html" target="_blank" rel="external">express 官网</a>查看。</p>
<p>现在，我们已经配置好了 mongo 数据库的环境，接下来让我们来使用 cURL 请求测试一下功能。cURL 是一款命令行程序，它可以发送 HTTP 请求。我们将会先使用 cURL 做一下实验，然后再迁移到 Alamofire 去。</p>
<h2 id="JavaScript_介绍">JavaScript 介绍</h2><h3 id="模型">模型</h3><p>打开你的文本编辑器（再说一下，我用的是 Sublime），同时打开 app.js 文件。正如你看到的，应用被分割成了一个 model 和路由文件（就是你刚打开的 app.js 文件）。model 文件可以建立模式（schema）或数据库结构。让我们先来简单看看这个文件吧。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>),</span><br><span class="line">    Schema = mongoose.Schema;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> TodoSchema  = <span class="keyword">new</span> Schema(</span><br><span class="line">    &#123;</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">mongoose.model(<span class="string">'employees'</span>, TodoSchema);</span><br></pre></td></tr></table></figure>
<p>我们可以使用 mongoose，它是一个用在应用与 mongo 之间作为接口的 npm 包。我起初在构建一个雇工跟踪应用，并把 model 命名为 employee，但是可能会随时修改这个 model。我保留着它，是因为这个教程的接下来部分可能会用到。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-27-at-12.48.53-AM-1024x640.png" alt=""></p>
<p>Mongoose 能很方便的提供与 mongoLab 的 heroku node 应用连接并提供相应的接口。这的确非常方便。</p>
<h3 id="路由">路由</h3><p>路由文件里存的是我们将会<em>输出</em>到 app.js 文件的内容。不用太担心这个输出——它是 node 中一个比较先进的特性，也超出了本教程的范围。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-27-at-12.53.18-AM-1024x640.png" alt=""></p>
<p>注意第 26 行的 <em>newTodo</em>。正如你可能猜到的，这行代码创建了一个新的 todo。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emp = <span class="keyword">new</span> Todo(req.body);</span><br><span class="line"> </span><br><span class="line">    emp.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            res.send(<span class="string">'Error occurred'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">        res.send(emp);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们把 Todo 对象（在第四行定义了一个与 mongoose 连接的对象）赋值给一个叫 emp 的变量，并设置 req.body（req 代表请求，它会发送给我们数据，同时，res 代表回复，它会返回我们的要返回的东西）。</p>
<p>随意浏览一下文件中剩下的方法。</p>
<h3 id="就像粘稠的胶水——App-js">就像粘稠的胶水——App.js</h3><p>现在回到 app.js 文件，这里是整个应用的主要部分。接下来列出来一些这个文件里的重点部分（译者注：对照下图看）：</p>
<ul>
<li>第 13 行代码建立 express 应用</li>
<li>第 15 - 22 行代码配置该应用</li>
<li>第 33 行代码使用 mongoose 将应用连接到 mongoLab 数据库</li>
<li>第 35 行代码建立连接</li>
<li>第 41 - 45 行代码建立应用的路由文件并连接到 /routes/todo.js 文件</li>
<li>第 48 行代码创建服务器</li>
</ul>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-27-at-12.59.54-AM-1024x640.png" alt=""></p>
<p>以上这些，能让你了解到一些 Javascript 应用的基本运作知识。但是，毕竟这篇教程不是主讲 Javascript 的，我不会继续深究。当然，我还是鼓励你们去研究一下 express 和 mongoose。</p>
<h2 id="使用_cURL">使用 cURL</h2><p>在我们的 node 应用开启状态下，我们可以执行一些 cURL 请求来做测试。一旦我们做完测试，就可以迁移到 Alamofire 上去了。</p>
<h3 id="GET_请求">GET 请求</h3><p>在终端里执行下面的代码（记得将 url 修改成你自己对应的 heroku url）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -i -H <span class="string">"Accept: application/json"</span> <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span></span><br></pre></td></tr></table></figure>
<p>命令行中的 -i 和 -H 参数表示我们将要接收什么东西。我们会接收 JSON 并将 JSON url 追加到请求的末尾。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-6.00.45-PM-2.png" alt=""></p>
<p>你应该能看到有数据返回了。和下图差不多。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-6.00.49-PM-2.png" alt=""></p>
<p>正如你看到的，返回的数据就是我们想要得到的。如果你已经将 url 替换成你自己的，你可能什么也看不到，因为你的 mongodb 里现在还没数据。</p>
<h3 id="POST_请求">POST 请求</h3><p>加入你想要加一些数据到数据库里，你需要的就是下面的 POST 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">"Content-Type: application/json"</span> -X POST <span class="operator">-d</span> <span class="string">'&#123;"name":"Buy Presents"&#125;'</span> https://rocky-meadow-<span class="number">1164</span>.herokuapp.com/todo</span><br></pre></td></tr></table></figure>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-6.05.01-PM-2.png" alt=""></p>
<p>然后，你使用之前讲过的 GET 请求，就可以看到你刚才添加的「Buy Presents」的内容了。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/s.png" alt=""></p>
<h3 id="DELETE_请求">DELETE 请求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X DELETE <span class="string">'https://rocky-meadow-1164.herokuapp.com/todo/5657901fee93910900cc54ed'</span></span><br></pre></td></tr></table></figure>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-8.21.40-PM-2.png" alt=""></p>
<p>很棒！这里我们不会讲 PUT 请求，因为在这个应用里暂时还用不上。但是它和其他的请求使用起来差不多。</p>
<h2 id="使用_Alamofire_设置_iOS_应用">使用 Alamofire 设置 iOS 应用</h2><p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/alamofire.png" alt=""></p>
<p>让我们从新建一个名叫 TodoApp 的 Xcode 工程开始吧。因为假期就要到来，我们应该有一种方式来跟踪这件事情。幸运的是，我们有 node 应用来帮忙。</p>
<p>你可以手动安装 Alamofire（通过拖拽源文件到对应工程的方法），但是我们选择使用 Cocoapods。Cocoapods 是一款为 iOS 工程提供依赖管理的工具。在使用 Cocoapods 的时候，开发者可以轻松的添加框架或第三方类库。如果你之前没有使用 Cocoapods，强烈推荐你去使用。</p>
<p>接下来，在终端里运行以下命令可以确保你在接下来的步骤后成功安装 Cocoapods。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>
<p>然后，通过 cd 命令进入你工程所在的目录，键入以下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim Podfile</span><br></pre></td></tr></table></figure>
<p>Vim 是一款系统自带的命令行编辑器，与 Sublime Text 或 TextMate 类似。我们现在要新建一个 Podfile 的文件，Cocoapods 每次都会去这个文件里查询是否需要更新工程的 pod（包括各种的依赖）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-8.32.03-PM-2.png" alt=""></p>
<p>在 Podfile 这个文件里键入如下内容：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">source <span class="string">'https://github.com/CocoaPods/Specs.git'</span></span><br><span class="line"> </span><br><span class="line">platform <span class="symbol">:ios</span>, <span class="string">'8.0'</span></span><br><span class="line"> </span><br><span class="line">use_frameworks!</span><br><span class="line"> </span><br><span class="line">pod <span class="string">'Alamofire'</span>, <span class="string">'~&gt; 3.0'</span></span><br></pre></td></tr></table></figure>
<p>然后，按 ESC 键，并输入 <code>:wq</code>，再敲回车。其中，wq 表示保存并退出。</p>
<p>我们现在已经成功创建 Podfile 并且保存了，为了安装 CocoaPods，在终端里输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>敲了回车后，如果一切都设置好的话，大概会呈现下图显示的内容。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-8.38.01-PM-2.png" alt=""></p>
<p>这时候，你可以看到命令行里要求你关闭当前打开的 Xcode 并且以后都用 .xcworkspace 为后缀的文件来打开工程。</p>
<p>下面这个命令能够非常方便地打开当前目录的 finder 界面。到此为止我们在 Terminal 中的操作就那么多，看上去一天之内有那么多就够了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open .</span><br></pre></td></tr></table></figure>
<p>打开 ViewController.swift，让我们继续吧。</p>
<h3 id="Alamofire_GET_请求">Alamofire GET 请求</h3><p>在打开的 ViewController.swift 里，输入以下代码来导入 Alamofire：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Alamofire</span><br></pre></td></tr></table></figure>
<p>在 viewDidLoad() 方法里键入以下代码来使用 Alamofire。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(.<span class="type">GET</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span>) .responseJSON &#123; response <span class="keyword">in</span> <span class="comment">// 1</span></span><br><span class="line">      <span class="built_in">print</span>(response.request)  <span class="comment">// original URL request</span></span><br><span class="line">      <span class="built_in">print</span>(response.response) <span class="comment">// URL response</span></span><br><span class="line">      <span class="built_in">print</span>(response.data)     <span class="comment">// server data</span></span><br><span class="line">      <span class="built_in">print</span>(response.result)   <span class="comment">// result of response serialization</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">JSON</span> = response.result.value &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"JSON: <span class="subst">\(JSON)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一行代码中，我们声明了一个 GET 请求，并且传入了一个我们需要的 URL。运行当前的应用，看看返回的是什么。如果一切都设置正确的话，你会看到返回的是 JSON 数据。</p>
<p>现在，打开 Main.storyboard，添加一个 tableview 到 view controller，并将视图控制器嵌入到 navigation controller。你的 storyboard 现在看起来应该跟我的一样，如下图（值得注意的是，现在返回的 JSON 数据还只是显示在控制台上，我们要将其显示出来。）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-9.38.31-PM-2-1024x576.png" alt=""></p>
<p>将以下代码复制并粘帖到你的 ViewController.swift 文件里。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> Alamofire</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> tableView: <span class="type">UITableView</span>!</span><br><span class="line">    <span class="keyword">var</span> jsonArray:<span class="type">NSMutableArray</span>?</span><br><span class="line">    <span class="keyword">var</span> newArray: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; = []</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="type">Alamofire</span>.request(.<span class="type">GET</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span>) .responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(response.request)  <span class="comment">// original URL request</span></span><br><span class="line">                <span class="built_in">print</span>(response.response) <span class="comment">// URL response</span></span><br><span class="line">                <span class="built_in">print</span>(response.data)     <span class="comment">// server data</span></span><br><span class="line">                <span class="built_in">print</span>(response.result)   <span class="comment">// result of response serialization</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">JSON</span> = response.result.value &#123;</span><br><span class="line">                    <span class="keyword">self</span>.jsonArray = <span class="type">JSON</span> <span class="keyword">as</span>? <span class="type">NSMutableArray</span></span><br><span class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span>.jsonArray! &#123;</span><br><span class="line">                        <span class="built_in">print</span>(item[<span class="string">"name"</span>]!)</span><br><span class="line">                        <span class="keyword">let</span> string = item[<span class="string">"name"</span>]!</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"String is <span class="subst">\(string!)</span>"</span>)</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">self</span>.newArray.append(string! <span class="keyword">as</span>! <span class="type">String</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"New array is <span class="subst">\(<span class="keyword">self</span>.newArray)</span>"</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我初始化了两个数组 jsonArray 和 newArray，用 for 循环遍历了返回数据的那个 jsonArray，将其中的每个数据保存到 newArray 中。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-10.08.34-PM-2.png" alt=""></p>
<p>我使用 POST cURL 请求在数据库里多添加了一些数据。用法类似，不再赘述。</p>
<p>你可以试试下面代码演示的 GET 请求的极致精简写法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(.<span class="type">GET</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span>).responseJSON &#123; response <span class="keyword">in</span> <span class="built_in">debugPrint</span>(response) &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在文件顶部的 UIViewController 定义后面添加 UITableViewDelegate 和 UITableViewDataSource，并在 viewDidLoad() 方法里键入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.dataSource = <span class="keyword">self</span></span><br><span class="line"><span class="keyword">self</span>.tableView.delegate = <span class="keyword">self</span></span><br></pre></td></tr></table></figure>
<p>最后，添加 UITableView 的 delegate 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.newArray.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"Cell"</span>, forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">UITableViewCell</span></span><br><span class="line"></span><br><span class="line">    cell.textLabel?.text = <span class="keyword">self</span>.newArray[indexPath.row]</span><br><span class="line">    <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.didReceiveMemoryWarning()</span><br><span class="line">    <span class="comment">// Dispose of any resources that can be recreated.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-10.16.39-PM-2-1024x576.png" alt=""></p>
<p>正如你看到的，我们的 tableview 已经成功显示数据了。</p>
<p>现在我们来添加一个按钮，用来添加数据到列表中。首先，先在 storyboard 里添加一个叫 AddViewController 的类，并用 segue 的方式连接起来。你的 storyboard 应该和下图差不多。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/11/Screen-Shot-2015-11-26-at-11.34.59-PM-2-1024x576.png" alt=""></p>
<h3 id="Alamofire_POST_请求">Alamofire POST 请求</h3><p>在你的 AddViewController.swift 文件里，为 textfield 建立一个 IBOutlet（命名为 textView），为 Save 按钮建立一个 IBAction。在 Save 按钮代码中键入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(.<span class="type">POST</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span>, parameters: [<span class="string">"name"</span>: <span class="keyword">self</span>.textView.text!])</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.navigationController!.popViewControllerAnimated(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>如你所见，Alamofire 大大简化了发送 POST 请求的过程。</p>
<p>接下来，我们来对 ViewController.swift 文件进行重构，确保我们在保存数据后能及时更新列表。删除 viewDidLoad() 方法里 GET Alamofire 的代码，用以下的 downloadAndUpdate 方法代替。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">downloadAndUpdate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="type">Alamofire</span>.request(.<span class="type">GET</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span>) .responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(response.request)  <span class="comment">// original URL request</span></span><br><span class="line">            <span class="built_in">print</span>(response.response) <span class="comment">// URL response</span></span><br><span class="line">            <span class="built_in">print</span>(response.data)     <span class="comment">// server data</span></span><br><span class="line">            <span class="built_in">print</span>(response.result)   <span class="comment">// result of response serialization</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">JSON</span> = response.result.value &#123;</span><br><span class="line">                <span class="keyword">self</span>.jsonArray = <span class="type">JSON</span> <span class="keyword">as</span>? <span class="type">NSMutableArray</span></span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span>.jsonArray! &#123;</span><br><span class="line">                    <span class="built_in">print</span>(item[<span class="string">"name"</span>]!)</span><br><span class="line">                    <span class="keyword">let</span> string = item[<span class="string">"name"</span>]!</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"String is <span class="subst">\(string!)</span>"</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.newArray.append(string! <span class="keyword">as</span>! <span class="type">String</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"New array is <span class="subst">\(<span class="keyword">self</span>.newArray)</span>"</span>)</span><br><span class="line">                <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在，在 viewWillAppear() 方法里调用这个方法，如下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">   <span class="keyword">self</span>.downloadAndUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你再次编译并运行这个应用，就会发现每次添加新的 todo 后都会重新加载。这是为什么呢？</p>
<p>这就关系到 view controller 的生命周期，这里我简单介绍一下。viewDidLoad() 会在 view 初始化后并且所有控件都结束加载后被调用。问题出现了，当你从已经加载的 ViewController 上加载另外一个 view（比如 AppViewController）时，viewDidLoad 方法不会被调用（之前已经初始化过）。viewWillAppear 方法会在每次 view 在屏幕上显示时调用。因为我们需要在再次显示 ViewController.swift 时候显示，所以这个方法刚好可用。</p>
<h3 id="Alamofire_DELETE_请求">Alamofire DELETE 请求</h3><p>现在在刚才的 newArray 下面添加一个 IDArray。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="type">IDArray</span>: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; = []</span><br></pre></td></tr></table></figure>
<p>接下来，更新 downloadAndUpdate 方法的相应部分，代码如下。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.newArray.removeAll() <span class="comment">// NEW</span></span><br><span class="line"><span class="keyword">self</span>.<span class="type">IDArray</span>.removeAll() <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line"><span class="type">Alamofire</span>.request(.<span class="type">GET</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo"</span>) .responseJSON &#123; response <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(response.request)  <span class="comment">// original URL request</span></span><br><span class="line">            <span class="built_in">print</span>(response.response) <span class="comment">// URL response</span></span><br><span class="line">            <span class="built_in">print</span>(response.data)     <span class="comment">// server data</span></span><br><span class="line">            <span class="built_in">print</span>(response.result)   <span class="comment">// result of response serialization</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="type">JSON</span> = response.result.value &#123;</span><br><span class="line">                <span class="keyword">self</span>.jsonArray = <span class="type">JSON</span> <span class="keyword">as</span>? <span class="type">NSMutableArray</span></span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span>.jsonArray! &#123;</span><br><span class="line">                    <span class="built_in">print</span>(item[<span class="string">"name"</span>]!)</span><br><span class="line">                    <span class="keyword">let</span> string = item[<span class="string">"name"</span>]!</span><br><span class="line">                    <span class="keyword">let</span> <span class="type">ID</span> = item[<span class="string">"_id"</span>]! <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.newArray.append(string! <span class="keyword">as</span>! <span class="type">String</span>)</span><br><span class="line">                    <span class="keyword">self</span>.<span class="type">IDArray</span>.append(<span class="type">ID</span>! <span class="keyword">as</span>! <span class="type">String</span>) <span class="comment">// NEW</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"New array is <span class="subst">\(<span class="keyword">self</span>.newArray)</span>"</span>)</span><br><span class="line">                <span class="keyword">self</span>.tableView.reloadData()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>两行带有 NEW 注释的代码是新添加的。从代码的本质上来说，我们在循环中获得对应的 ID 并保存到数组 IDArray 中。同样，我们也需要将不需要的数据从列表中删除并重置。</p>
<p>添加 commitEditingStyle 方法，以调用 DELETE 请求来删除对应的不需要数据。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> editingStyle == .<span class="type">Delete</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"ID is <span class="subst">\(<span class="keyword">self</span>.IDArray[indexPath.row])</span>"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">Alamofire</span>.request(.<span class="type">DELETE</span>, <span class="string">"https://rocky-meadow-1164.herokuapp.com/todo/<span class="subst">\(<span class="keyword">self</span>.IDArray[indexPath.row])</span>"</span>)</span><br><span class="line">            <span class="keyword">self</span>.downloadAndUpdate()</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> editingStyle == .<span class="type">Insert</span> &#123;</span><br><span class="line">            <span class="comment">// Create a new instance of the appropriate class, insert it into the array, and add a new row to the table view</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>正如你看到的，以上代码遵循了我们应用的 API，即通过传入 /todo/ID 来调用 DELETE 请求删除对应的数据。</p>
<p>同时，我们用比较简单的 Alamofire 方法来调用 DELETE 请求并删除了对应的数据。</p>
<p>至此，你现在已经拥有了一个功能完备的 todo 应用了。因此，让我们来总结一下本次教程吧。</p>
<h2 id="小结">小结</h2><p>本教程探索了很多东西。从 Javascript 的 node 到 express，从 MongoDB 到 cURL，从终端到 Cocoapods，以及最后的 Alamofire，我们深入了解了 REST API 的创建过程和网络的工作流程。你通过本次教程应该已经坚实的掌握了以下内容：</p>
<ul>
<li>构建 API</li>
<li>部署 API</li>
<li>写客户端应用</li>
<li>使用 HTTP 请求</li>
<li>使用 Cocoapods</li>
<li>使用 cURL</li>
<li>使用 node 和 MongoDB/Express</li>
<li>使用 Express 做路由</li>
<li>使用 Alamofire</li>
</ul>
<p>这真是一个大教程，我感谢你坚持和我走到这里。所有的源代码可以在<a href="https://www.dropbox.com/sh/axho3cgfvinz9lc/AADXjhAPwATsbZBA-z9mVLn4a?dl=0" target="_blank" rel="external">这里</a>下载，其中包含了 node 应用和 iOS 应用。</p>
<p>有任何问题和想法都可以在教程下面留言评论。下次见！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：gregg mojica，<a href="http://www.appcoda.com/alamofire-beginner-guide/">原文链接</a>，原文日期：2015/11/30<br>译者：<a href="http://weibo.com/linusling">小铁匠Linus</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>2014 年 6 月 Apple 发布 Swift 以来，如何在 Swift 中进行网络编程一直成为程序猿们关注的焦点。甚至就连 Swift 的作者之一 Chris Lattner 也发推说过，在 Swift 中解析 JSON 还有很长的路要走。因此，许多人开始寻求替代方案。在 Swift 中虽然有处理 JSON 解析的内建类，但是对开发者来说并不是很友好。幸运的是，Alamofire 出现了。Alamofire 是一个可以帮助我们解析 JSON 的强力网络库，它由 Objective-C 中同类网络库 AFNetworking 的作者编写。</p>
<p>在这个又臭又长、近乎 3500 多词（译者注：in English；定稿注：这是作者原话，不是译者观点）的教程中，我们将探讨一系列广泛的网络基本话题，并建立一个假日待办应用。</p>
<p>同时，你会从本教程中学到：如何使用和解析 JSON、如何自定义服务器端、如何使用 <a href="https://www.heroku.com/">Heroku</a> 和 <a href="https://mongolab.com/">MongoLab</a> 等工具、HTTP 的工作原理（包括 GET，POST 和 DELETE 请求）、如何使用 git 和终端（terminal）以及如何使用 Cocoapods。如果你觉得上面提到的内容太多了，那就对了，拿一杯咖啡，就让我们开始吧。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 3.0 和 Foundation]]></title>
    <link href="http://swiftggteam.github.io/2015/12/21/swift-3-0-and-foundation/"/>
    <id>http://swiftggteam.github.io/2015/12/21/swift-3-0-and-foundation/</id>
    <published>2015-12-20T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/03/swift-3-0-and-foundation/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-03<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>我将尽量避免那些看上去很尴尬的笑话，直接介绍 <a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="external">Swift CoreLibs Foundation</a>。</p>
<p>以下引自 Apple：</p>
<blockquote>
<p>本项目提供了各个平台下 Foundation API 的具体实现，但并未使用 Objective-C runtime 机制。在 OS X、iOS 以及其他 Apple 平台下，应用程序都应该使用指定操作系统下的 Foundation 进行开发。我们希望尽可能地抽象出具体的底层平台…<br>我们最主要的目标是在 Apple 平台下使用 Foundation implementation parity。这将有助于整个 Swift 3 完成<strong>可移植性</strong>的目标。</p>
</blockquote>
<a id="more"></a>
<p>正如在上篇更新的文章所述，Foundation 将使用新的 API 指导方针、摒弃 NS 前缀、精简文本并避免整体过度冗余。</p>
<p>具体实现文章在<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Docs/Status.md" target="_blank" rel="external">这里</a>。显然<em>有很多</em>要做的事。苹果的主要目标是使用一套标准工具类来实现跨平台开发，能够在各个平台之间保持相对高的独立性和可移植性。</p>
<p>开发者们更关注核心语言功能（比如 Swift 中的数组和字典）在标准库、功能（比如正则表达式中）以及 Foundation 基础库中有哪些不同。NSArray/NSDictionary/NSSet/NSString 的更新版本将成为 Foundation 的一部分，与标准库中对应的类稍有不同。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/03/swift-3-0-and-foundation/">原文链接</a>，原文日期：2015-12-03<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<!--此处开始正文-->
<p>我将尽量避免那些看上去很尴尬的笑话，直接介绍 <a href="https://github.com/apple/swift-corelibs-foundation">Swift CoreLibs Foundation</a>。</p>
<p>以下引自 Apple：</p>
<blockquote>
<p>本项目提供了各个平台下 Foundation API 的具体实现，但并未使用 Objective-C runtime 机制。在 OS X、iOS 以及其他 Apple 平台下，应用程序都应该使用指定操作系统下的 Foundation 进行开发。我们希望尽可能地抽象出具体的底层平台…<br>我们最主要的目标是在 Apple 平台下使用 Foundation implementation parity。这将有助于整个 Swift 3 完成<strong>可移植性</strong>的目标。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 的变化：从 2.2 到 3.0 会带来什么]]></title>
    <link href="http://swiftggteam.github.io/2015/12/18/changing-swift-whats-coming-up-in-2-2-and-3-0/"/>
    <id>http://swiftggteam.github.io/2015/12/18/changing-swift-whats-coming-up-in-2-2-and-3-0/</id>
    <published>2015-12-17T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/03/changing-swift-whats-coming-up-in-2-2-and-3-0/" target="_blank" rel="external">原文链接</a>，原文日期：2015-12-03<br>译者：<a href="undefined">Channe</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>如果你还没看过 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="external">Swift 发展路线图</a>，我建议你要好好看一看。目前为止，有四个针对 <code>Swift 3</code> 和一个针对 <code>Swift 2.2</code> 的提议已经被接受，也许其中的某些能让你会心一笑。</p>
<p>显然，这些提议中最令人振奋的是 API 翻译的改进，旨在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md" target="_blank" rel="external">废除冗长的 <code>Objective-C</code> 式的风格</a>，形成调用简洁且易读的 <code>Swift</code> 风格。</p>
<a id="more"></a>
<p>看上去显而易见我们将要和<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md" target="_blank" rel="external">函数柯里化声明</a>说再见了，虽然这是没有语法糖语言共有的特性。这是我能忍受的东西，但是这点改变并不会让我开心起来 — 除此之外似乎有迫切的原因去降低语言的复杂度。</p>
<p><code>++</code> 和 <code>--</code>（<strong>这是两个减号，不是破折号</strong>）运算符也在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md" target="_blank" rel="external">移除的部分</a>中。它们最初是为了和 C 语言一致而引入的，但它们的结果值通常不会被检查。对大部分开发者来说，很容易可以用 <code>+=</code> 和 <code>-=</code> 替代它们。</p>
<p>最后，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters-patterns.md" target="_blank" rel="external">var 形式的函数参数</a>将会被移除，因为它们现在的实现是从复制和修改步骤中抽象出来，而这造成了困惑。我觉得这不是一个大损失，只是需要你声明一个函数内 var 变量赋值来替代它。</p>
<p>十分有趣是，除了 <code>++</code> 和 <code>--</code> 的改变，几乎所有的变更点我都在<a href="http://ericasadun.com/2015/11/19/swift-developers-cookbook-status-update-mark-december-17-on-your-calendars/" target="_blank" rel="external">新书</a>中提到了。</p>
<p>已经被接受的 <code>Swift 2.2</code> 提案允许你<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0001-keywords-as-argument-labels.md" target="_blank" rel="external">用关键字作为参数标签</a>，这使得现在可以这样声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">touchesMatching</span><span class="params">(phase: NSTouchPhase, <span class="keyword">in</span> view: NSView?)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">NSTouch</span>&gt;</span><br></pre></td></tr></table></figure>
<p><code>Swift 3.0</code> 承诺会保持 <code>ABI（Application Binary Interface）</code>的稳定性：「成功保持 ABI 稳定性意味着，即便源代码语言发生了变化，用以后版本的 Swift 开发的应用程序和编译库能在二进制层次上和 Swift 3.0 版本的应用程序和编译库相互调用。」</p>
<p>开发团队利用这个机会做个类型系统清理，包括所有语言的小改良，同时「完整完成」基类系统。代码迁移者将把项目从 2.x 版迁到 3.x 版。基础代码或多或少能保证与这次大更新没关系。</p>
<p>最终的 API 设计指导原则发布在<a href="https://swift.org/documentation/api-design-guidelines.html" target="_blank" rel="external">这个网址</a>。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/12/03/changing-swift-whats-coming-up-in-2-2-and-3-0/">原文链接</a>，原文日期：2015-12-03<br>译者：<a href="undefined">Channe</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>如果你还没看过 <a href="https://github.com/apple/swift-evolution">Swift 发展路线图</a>，我建议你要好好看一看。目前为止，有四个针对 <code>Swift 3</code> 和一个针对 <code>Swift 2.2</code> 的提议已经被接受，也许其中的某些能让你会心一笑。</p>
<p>显然，这些提议中最令人振奋的是 API 翻译的改进，旨在<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md">废除冗长的 <code>Objective-C</code> 式的风格</a>，形成调用简洁且易读的 <code>Swift</code> 风格。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在 iOS8 和 iOS9 中锁定视图自动旋转]]></title>
    <link href="http://swiftggteam.github.io/2015/12/17/per-view-auto-rotation-locking-made-easy-for-ios-8-and-9/"/>
    <id>http://swiftggteam.github.io/2015/12/17/per-view-auto-rotation-locking-made-easy-for-ios-8-and-9/</id>
    <published>2015-12-16T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Weston Hanners，<a href="http://www.alloc-init.com/2015/11/per-view-auto-rotation-locking-made-easy-for-ios-8-and-9/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-18<br>译者：<a href="undefined">littledogboy</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>这周我在开发一个 App，客户想要此 App 在某些情况下锁定竖屏，某些情况下锁定横屏。幸运的是，我已经在自动布局下创建了所有的视图，因此它们已经支持所需的约束，我仅需要锁定视图旋转。<br><a id="more"></a></p>
<p>旋转 API 属于 UIKit 中经常被弃用的内容，因此当我开始旋转工作时，不得不查一下。我还想说，弃用和替换相关的 API 太麻烦了。经过一个小时左右的研究和两个小时的实践，我终于整出了两部分。（译者注：=W=，我当时也搞了好久）</p>
<ul>
<li>选中 <code>Info.plist</code> 文件中所有你想要支持的旋转方向。</li>
</ul>
<p><img src="/img/articles/per-view-auto-rotation-locking-made-easy-for-ios-8-and-9/InterfaceOrientation.png1450312516.562497" alt=""></p>
<ul>
<li>然后我们仅需要实现一个方法。</li>
</ul>
<p>Swift 1.2</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">supportedInterfaceOrientations</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Int</span>(<span class="type">UIInterfaceOrientationMask</span>.<span class="type">Portrait</span>.rawValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 2.0</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">supportedInterfaceOrientations</span><span class="params">()</span></span> -&gt; <span class="type">UIInterfaceOrientationMask</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">UIInterfaceOrientationMask</span>.<span class="type">Portrait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确保选中你想要锁定的方向是横屏还是竖屏。</p>
<p>这可能是我最近看到过的最乱的接口改动，并且我花了好长时间才意识到我在 Swift 1.2 中犯下的错误。（那个 Int cast 太丑了）</p>
<p><a href="http://www.alloc-init.com/wp-content/uploads/2015/11/RotationTest.zip" target="_blank" rel="external">Sample Code</a> (Swift 1.2 Project)</p>
<p><strong>Update 11/18/2015:</strong></p>
<p>我刚刚意识到,我标题有点词不达意。</p>
<p><strong>“使用一个小技巧锁定视图控制器”</strong></p>
<p>好吧，下不为例。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Weston Hanners，<a href="http://www.alloc-init.com/2015/11/per-view-auto-rotation-locking-made-easy-for-ios-8-and-9/">原文链接</a>，原文日期：2015-11-18<br>译者：<a href="undefined">littledogboy</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>这周我在开发一个 App，客户想要此 App 在某些情况下锁定竖屏，某些情况下锁定横屏。幸运的是，我已经在自动布局下创建了所有的视图，因此它们已经支持所需的约束，我仅需要锁定视图旋转。<br>]]>
    
    </summary>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/tags/Swift-%E5%85%A5%E9%97%A8/"/>
    
      <category term="alloc-init" scheme="http://swiftggteam.github.io/categories/alloc-init/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原创] 每周 Swift 社区问答 2015-12-16]]></title>
    <link href="http://swiftggteam.github.io/2015/12/16/swift-qa-2015-12-16/"/>
    <id>http://swiftggteam.github.io/2015/12/16/swift-qa-2015-12-16/</id>
    <published>2015-12-15T16:00:00.000Z</published>
    <updated>2015-12-23T09:10:13.904Z</updated>
    <content type="html"><![CDATA[<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Unwrapping NSNumber works fine in iOS Simulator but unexpectedly found nil on iPhone</a></li>
<li><a href="#Q2">Why my code is working in playground but not in my project?</a></li>
<li><a href="#Q3">Failable initialisers and unbound instance vars</a></li>
<li><a href="#Q4">Read-only property</a></li>
<li><a href="#Q5">Why? insert a new element into array and it always crash!</a></li>
<li><a href="#Q6">binary operator ‘??’ cannot be applied to functions?</a></li>
<li><a href="#Q7">Filter array on type</a> </li>
<li><a href="#Q8">Numbers in swift</a></li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20151216/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420151216.playground" target="_blank" rel="external">点击下载</a></p>
<a id="more"></a>
<p><a name="Q1"></a></p>
<h2 id="Q1:_Unwrapping_NSNumber_works_fine_in_iOS_Simulator_but_unexpectedly_found_nil_on_iPhone">Q1: Unwrapping NSNumber works fine in iOS Simulator but unexpectedly found nil on iPhone</h2><p><a href="https://forums.developer.apple.com/thread/27726" target="_blank" rel="external">Q1链接地址</a></p>
<h3 id="问题描述">问题描述</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()  </span><br><span class="line">stack.append(<span class="string">"2.3"</span>)  </span><br><span class="line"><span class="keyword">let</span> lastElement = stack.popLast()!  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Popped last element: <span class="subst">\(lastElement)</span>"</span>)  </span><br><span class="line"><span class="keyword">let</span> number = <span class="type">NSNumberFormatter</span>().numberFromString(lastElement)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"NSNumber gives us: <span class="subst">\(lastElement)</span>"</span>)  </span><br><span class="line"><span class="keyword">let</span> doubleValue = number!.doubleValue  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Double value of this element is: <span class="subst">\(doubleValue)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码在Playground 以及iOS 模拟器中执行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Popped</span> last element: <span class="number">2.3</span>  </span><br><span class="line"><span class="type">NSNumber</span> gives us: <span class="number">2.3</span>  </span><br><span class="line"><span class="type">Double</span> value of this element <span class="keyword">is</span>: <span class="number">2.3</span></span><br></pre></td></tr></table></figure>
<p>但是在真机里是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Popped</span> last element: <span class="number">2.3</span>  </span><br><span class="line"><span class="type">NSNumber</span> gives us: <span class="number">2.3</span>  </span><br><span class="line">fatal error: unexpectedly found <span class="literal">nil</span> <span class="keyword">while</span> unwrapping an <span class="type">Optional</span> value  </span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
<p>所以提问者修改了一行代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doubleValue = number?.doubleValue</span><br></pre></td></tr></table></figure>
<p>再次执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Popped</span> last element: <span class="number">2.3</span>  </span><br><span class="line"><span class="type">NSNumber</span> gives us: <span class="number">2.3</span>  </span><br><span class="line"><span class="type">Double</span> value of this element <span class="keyword">is</span>: <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>发现解包失败，值为 nil，那么问题出在那里呢？</p>
<h3 id="解答">解答</h3><p>由<a href="https://forums.developer.apple.com/people/junkpile" target="_blank" rel="external">junkpile</a>解答：</p>
<p>你的手机所处国家可能对小数分隔符的定义是一个逗号‘,’，而不是句号‘.’ 看到这个回答我也是醉了，最后提问者现身说法，确实他设置的德国是使用逗号作为小数分隔符的，所以解包失败。</p>
<p>junkpile 还给出了一个小建议：</p>
<p>在需要对数字字符串进行格式化的地方，比如输入数字的用户控件，你就需要显式的指定数字格式的本地化属性。反之在接收用户输入的数字时，你应该判断本地化属性，让一切尽在掌握中。</p>
<p><a name="Q2"></a></p>
<h2 id="Q2:Why_my_code_is_working_in_playground_but_not_in_my_project?">Q2:Why my code is working in playground but not in my project?</h2><p><a href="https://forums.developer.apple.com/thread/27764" target="_blank" rel="external">Q2链接地址</a></p>
<h3 id="问题描述-1">问题描述</h3><p>使用 NSDateFormater 解析一个字符串日期，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit  </span><br><span class="line"><span class="keyword">let</span> lTs = <span class="type">String</span>(<span class="string">"Mon, 07 Dec 2015 3:58 pm EST"</span>)  </span><br><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">NSDateFormatter</span>()  </span><br><span class="line">dateFormatter.dateFormat = <span class="string">"EEE, dd MMM yyyy h:mm a zzz"</span>  </span><br><span class="line"><span class="keyword">let</span> lDate = dateFormatter.dateFromString(lTs)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(lDate!)</span>"</span>)</span><br><span class="line"><span class="comment">// 输出The result is "2015-12-07 20:58:00 +0000\n"</span></span><br></pre></td></tr></table></figure>
<p>不过当提问者复制这段代码到项目中时（原来在playground）,居然crash掉了，问题出在对<code>lDate!</code>解包过程。</p>
<h3 id="问题解答">问题解答</h3><p>由苹果员工<a href="https://forums.developer.apple.com/people/eskimo" target="_blank" rel="external">eskimo</a>解答：</p>
<p>如果是对固定格式的字符串日期解析，你需要确定用户所在地域的local。</p>
<p>增加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.locale = <span class="type">NSLocale</span>(localeIdentifier: <span class="string">"en_US_POSIX"</span>)</span><br></pre></td></tr></table></figure>
<p>最近 swift.gg 也有一篇文章详解了 NSDate 的正确使用姿势，包含了日期格式的一些知识点，有兴趣的同学可以看看：<a href="http://swift.gg/2015/12/14/a-beginners-guide-to-nsdate-in-swift/" target="_blank" rel="external">Swift 的 NSDate 初学者指南</a></p>
<p><a name="Q3"></a></p>
<h2 id="Q3:Failable_initialisers_and_unbound_instance_vars">Q3:Failable initialisers and unbound instance vars</h2><p><a href="https://forums.developer.apple.com/thread/27743" target="_blank" rel="external">Q3链接地址</a></p>
<h3 id="问题描述-2">问题描述</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">let</span> a :<span class="type">Int</span>  </span><br><span class="line">    <span class="keyword">let</span> b : <span class="type">Int</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, m: <span class="type">Int</span>, n: <span class="type">Int</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span> name != <span class="string">"fistro"</span> &#123;  </span><br><span class="line">            a = m  </span><br><span class="line">            b = n  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器报错在 else{} 内并未对 a,b 进行变量初始化，但是其实提问者是想说，既然是一个可失败的构造器，为什么一定要对 a,b进行赋值才能返回 nil 呢？</p>
<h3 id="问题解答-1">问题解答</h3><p><a href="https://forums.developer.apple.com/people/Jessy" target="_blank" rel="external">Jessy</a>提供了这么一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> a :<span class="type">Int</span></span><br><span class="line">	<span class="keyword">let</span> b : <span class="type">Int</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">init</span>?(name: <span class="type">String</span>, m: <span class="type">Int</span>, n: <span class="type">Int</span>)&#123;</span><br><span class="line">		a = m</span><br><span class="line">		b = n</span><br><span class="line">		<span class="keyword">guard</span> name == <span class="string">"fistro"</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<a href="https://forums.developer.apple.com/people/ChrisLattner" target="_blank" rel="external">ChrisLattner</a>大神(swift之父)站出来了，明确说了：</p>
<p>这是 Swift 2.1 版本的限制，在即将发布的 Swift 2.2 中已经修复啦。</p>
<p>这里给个stackoverflow类似的问题链接：<a href="http://stackoverflow.com/questions/26495586/best-practice-to-implement-a-failable-initializer-in-swift" target="_blank" rel="external">http://stackoverflow.com/questions/26495586/best-practice-to-implement-a-failable-initializer-in-swift</a></p>
<p><a name="Q4"></a></p>
<h2 id="Q4:Read-only_property">Q4:Read-only property</h2><h3 id="问题链接">问题链接</h3><p><a href="https://forums.developer.apple.com/thread/27892" target="_blank" rel="external">Q4链接地址</a></p>
<h3 id="问题描述-3">问题描述</h3><p>日常项目开发中，我们会遇到一些 Access Control 的问题。譬如，我想要在类中实现一个属性对外是readonly(可读)，对内是write and read(可读写)。那么如何实现是最好的呢？下面提供一个简单的思路。</p>
<h3 id="代码实现">代码实现</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line"><span class="comment">// 对内可修改属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> gip: <span class="type">Bool</span> = <span class="literal">false</span>  </span><br><span class="line"><span class="comment">// 这是一个对外的可读属性</span></span><br><span class="line"><span class="keyword">var</span> gameInProgress: <span class="type">Bool</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> gip  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这并不是一个最佳的选择，希望有知道的小伙伴可以私信咱们。</p>
<p><a name="Q5"></a></p>
<h2 id="Q5:_Why?_insert_a_new_element_into_array_and_it_always_crash!">Q5: Why? insert a new element into array and it always crash!</h2><h3 id="问题链接-1">问题链接</h3><p><a href="https://forums.developer.apple.com/thread/27803" target="_blank" rel="external">Q5链接地址</a></p>
<h3 id="问题描述-4">问题描述</h3><p>以下代码会在第三行崩溃：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldNums: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ,<span class="number">6</span> , <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">var</span> newArray = oldNums[<span class="number">1</span>..&lt;<span class="number">4</span>]</span><br><span class="line">newArray.insert(<span class="number">99</span>, atIndex: <span class="number">0</span>) <span class="comment">// &lt;-- crash here</span></span><br><span class="line">newArray.insert(<span class="number">99</span>, atIndex: <span class="number">1</span>) <span class="comment">// &lt;-- work very well</span></span><br></pre></td></tr></table></figure>
<h3 id="问题解答-2">问题解答</h3><p>先看下 newArray 的类型以及其他一些属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(newArray.<span class="keyword">dynamicType</span>) <span class="comment">//-&gt;ArraySlice&lt;Int&gt;  </span></span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="built_in">indices</span>) <span class="comment">//-&gt;1..&lt;4</span></span><br></pre></td></tr></table></figure>
<p>显然 newArray 并不是一个数组，而是一个SliceArray，它的 StartIndex 是从 1 开始的，也就是通过 [1..&lt;4] 截取的下标开始的，所以插入下标为 0 的位置，就会报错。</p>
<p>修改如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">newArray.insert(<span class="number">99</span>, atIndex: newArray.startIndex)</span><br></pre></td></tr></table></figure>
<p>当然如果你还是偏执地想要从0开始 那么不妨重新搞一个数组喽，要知道 Array 有个sliceArray 的构造方法。所以改动如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldNums: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ,<span class="number">6</span> , <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">var</span> sliceArray = oldNums[<span class="number">1</span>..&lt;<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> newArray = <span class="type">Array</span>(oldNums[<span class="number">1</span>..&lt;<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="keyword">dynamicType</span>)	<span class="comment">//array</span></span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="built_in">indices</span>)			<span class="comment">//0..&lt;3 数组下标为0 1 2</span></span><br><span class="line">newArray.insert(<span class="number">99</span>, atIndex: <span class="number">0</span>) <span class="comment">//在0位置插入一个元素</span></span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="keyword">dynamicType</span>)          <span class="comment">//array</span></span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="built_in">indices</span>)                  <span class="comment">//0..&lt;4 数组下标为0 1 2 3</span></span><br><span class="line">newArray.insert(<span class="number">99</span>, atIndex: <span class="number">1</span>) <span class="comment">//在1位置插入一个元素</span></span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="keyword">dynamicType</span>)</span><br><span class="line"><span class="built_in">print</span>(newArray.<span class="built_in">indices</span>)                  <span class="comment">//0..&lt;5 数组下标为0 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p><a name="Q6"></a></p>
<h2 id="Q6:binary_operator_‘??’_cannot_be_applied_to_functions?">Q6:binary operator ‘??’ cannot be applied to functions?</h2><h3 id="问题链接-2">问题链接</h3><p><a href="https://forums.developer.apple.com/thread/28099" target="_blank" rel="external">Q6链接地址</a></p>
<h3 id="问题描述-5">问题描述</h3><p>在 Playground 中运行以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> f2:(()-&gt;())?  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f3 = f2 ?? f1</span><br></pre></td></tr></table></figure>
<p>直接报错：binary operator ‘??’ cannot be applied to operands of type ‘(() -&gt; ())?’ and ‘() -&gt; ()’</p>
<h3 id="问题解答-3">问题解答</h3><p>其实Chris Lattner 大神说了：这就是个已知的 BUG ! 处理 autoclosure 和 function 时已经有人 report 过了。</p>
<p>不过呢<a href="https://forums.developer.apple.com/people/OOPer" target="_blank" rel="external">OOPer</a>还是提供了他自己的解决方式。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = f1  </span><br><span class="line"><span class="keyword">let</span> f3 = f2 ?? f  <span class="comment">//不再报错</span></span><br></pre></td></tr></table></figure>
<p>注意倘若把 var 变成 let 常量定义的话就报错了!</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f = f1  </span><br><span class="line"><span class="keyword">let</span> f3 = f2 ?? f  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>亲测在 swift2 中依然存在这个BUG！希望大家引起注意。</p>
<p><a name="Q7"></a></p>
<h2 id="Q7:_Filter_array_on_type">Q7: Filter array on type</h2><h3 id="问题链接-3">问题链接</h3><p><a href="https://forums.developer.apple.com/thread/28185" target="_blank" rel="external">Q7链接地址</a></p>
<h3 id="问题描述-6">问题描述</h3><p>请看下面问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明了一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v:<span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(<span class="number">_</span> v:<span class="type">Int</span>)&#123;<span class="keyword">self</span>.v = v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自X</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X1</span>:<span class="title">X</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承自X</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span>:<span class="title">X</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a :[<span class="type">X</span>]</span><br><span class="line"><span class="keyword">var</span> a1:[<span class="type">X1</span>]</span><br><span class="line"><span class="comment">// 注意这里有些是用X1初始化 有些是用X2初始化</span></span><br><span class="line"><span class="comment">// 但是a数组的类型切记是[X],之所以能这么干的原因在于</span></span><br><span class="line"><span class="comment">// X1 X2都是X的子类，严格意义上来说，说X1 X2是X也是OK的</span></span><br><span class="line">a=[<span class="type">X1</span>(<span class="number">1</span>),<span class="type">X1</span>(<span class="number">2</span>),<span class="type">X2</span>(<span class="number">3</span>),<span class="type">X2</span>(<span class="number">4</span>),<span class="type">X1</span>(<span class="number">5</span>)]</span><br><span class="line">a[<span class="number">0</span>].v  <span class="comment">//输出1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误来了</span></span><br><span class="line">a1 = a.<span class="built_in">filter</span> &#123; $<span class="number">0</span> <span class="keyword">is</span> <span class="type">X1</span> &#125; <span class="comment">// ERROR</span></span><br><span class="line">a1[<span class="number">2</span>].v</span><br></pre></td></tr></table></figure>
<blockquote>
<p>is 关键字就是用来判断某个实例的所属类，注意说的是实例。</p>
</blockquote>
<p>报错：    </p>
<p><code>Playground execution failed: playground78.swift:15:8: error: cannot invoke &#39;filter&#39; with an argument list of type &#39;(@noescape (X) throws -&gt; Bool)&#39;</code></p>
<p>然后提问者就想可能是自己闭包格式没写全，于是又这么改：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a1 = a.<span class="built_in">filter</span> &#123; (p:<span class="type">X</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> p <span class="keyword">is</span> <span class="type">X1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>不出意外，还是挂了。</p>
<h3 id="问题解答-4">问题解答</h3><p>首先我们要明白 <code>filter</code> 方法的用法，filter 函数接收一个闭包作为筛选数组元素的过滤器，闭包一次处理一个元素，符合返回<code>true</code>，反之<code>false</code>。只有那些<code>true</code>的元素才会被<code>append</code>到结果数组中返回。更多filter函数请点击<a href="http://www.jianshu.com/notebooks/1752038/latest" target="_blank" rel="external">这里</a>。</p>
<p>现在来看看问题代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a1 = a.<span class="built_in">filter</span> &#123; $<span class="number">0</span> <span class="keyword">is</span> <span class="type">X1</span> &#125;</span><br></pre></td></tr></table></figure>
<p>先看式子右边<code>a.filter { $0 is X1 }</code>传入了一个简化版闭包<code>$0 is X1</code>，其实就是作为筛选条件，一旦a中元素的类型为<code>X1</code>，即我们想要的元素，不过这里的元素类型依旧是<code>X</code>，而非<code>X1</code>，不难得出最后返回的是<code>[X]</code>结果数组； 在看式子左边<code>a1</code>，这货的类型是<code>[X1]</code>。原因找到了！就是因为<code>[X1]≠[X]</code>造成的，修改方式嘛，自然就是<code>as</code>喽。所以最后修改代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a1 = a.<span class="built_in">filter</span>&#123; $<span class="number">0</span> <span class="keyword">is</span> <span class="type">X1</span>&#125; <span class="keyword">as</span>! [<span class="type">X1</span>]</span><br><span class="line">a1.<span class="built_in">map</span>&#123;<span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>.v)</span>"</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>其实吧，我更推荐第二种方式，使用 flatMap 实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a1 = a.flatMap&#123;$<span class="number">0</span> <span class="keyword">as</span>? <span class="type">X1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们对a数组中的元素进行遍历，每个都执行<code>$0 as? X1</code>类型转换，倘若成功就将元素转换为<code>X1</code>类型，失败则返回<code>nil</code>，最后<code>flapMap</code>会为我们剔除<code>nil</code>值。</p>
<h3 id="思考">思考</h3><p>现在有个问题:倘若我们使用面向对象编程呢？上述两种方法还适用吗？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自X</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X1</span>:<span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v:<span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(<span class="number">_</span> v:<span class="type">Int</span>)&#123;<span class="keyword">self</span>.v = v&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承自X</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span>:<span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v:<span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(<span class="number">_</span> v:<span class="type">Int</span>)&#123;<span class="keyword">self</span>.v = v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a :[<span class="type">X</span>]</span><br><span class="line"><span class="keyword">var</span> a1:[<span class="type">X1</span>]</span><br><span class="line"><span class="comment">// 注意这里有些是用X1初始化 有些是用X2初始化</span></span><br><span class="line">a=[<span class="type">X1</span>(<span class="number">1</span>),<span class="type">X1</span>(<span class="number">2</span>),<span class="type">X2</span>(<span class="number">3</span>),<span class="type">X2</span>(<span class="number">4</span>),<span class="type">X1</span>(<span class="number">5</span>)]</span><br><span class="line">a[<span class="number">0</span>].v</span><br><span class="line">a1 = a.<span class="built_in">filter</span>&#123; $<span class="number">0</span> <span class="keyword">is</span> <span class="type">X1</span>&#125; <span class="keyword">as</span>! [<span class="type">X1</span>] <span class="comment">//报错：fatal error: array element cannot be bridged to Objective-C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 = a.flatMap&#123; $<span class="number">0</span> <span class="keyword">as</span>? <span class="type">X1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>看来只有<code>flatMap</code>依旧坚挺！如果想要使用<code>filter</code>的话，可以这么实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(a.<span class="built_in">filter</span> &#123; $<span class="number">0</span> <span class="keyword">is</span> <span class="type">XValue</span> &#125;).<span class="built_in">map</span> &#123; $<span class="number">0</span> <span class="keyword">as</span>! <span class="type">XValue</span> &#125;</span><br></pre></td></tr></table></figure>
<p>画蛇添足的赶脚。有木有更好的方法呢？报错说我们没有桥接到OC,让我想到了<code>@objc</code>，于是我尝试了下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> v:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自X</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X1</span>:<span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="preprocessor">@objc</span> <span class="keyword">var</span> v:<span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(<span class="number">_</span> v:<span class="type">Int</span>)&#123;<span class="keyword">self</span>.v = v&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承自X</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span>:<span class="title">X</span></span>&#123;</span><br><span class="line">	<span class="preprocessor">@objc</span> <span class="keyword">var</span> v:<span class="type">Int</span></span><br><span class="line">	<span class="keyword">init</span>(<span class="number">_</span> v:<span class="type">Int</span>)&#123;<span class="keyword">self</span>.v = v&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a :[<span class="type">X</span>]</span><br><span class="line"><span class="keyword">var</span> a1:[<span class="type">X1</span>]</span><br><span class="line"><span class="comment">// 注意这里有些是用X1初始化 有些是用X2初始化</span></span><br><span class="line">a=[<span class="type">X1</span>(<span class="number">1</span>),<span class="type">X1</span>(<span class="number">2</span>),<span class="type">X2</span>(<span class="number">3</span>),<span class="type">X2</span>(<span class="number">4</span>),<span class="type">X1</span>(<span class="number">5</span>)]</span><br><span class="line">a[<span class="number">0</span>].v</span><br><span class="line"><span class="keyword">var</span> a2 = a.<span class="built_in">filter</span>&#123; $<span class="number">0</span> <span class="keyword">is</span> <span class="type">X1</span>&#125; <span class="keyword">as</span>! [<span class="type">X1</span>]</span><br></pre></td></tr></table></figure>
<p>这样是ok的。</p>
<h2 id="Q8、Numbers_in_swift">Q8、Numbers in swift</h2><h3 id="问题链接-4">问题链接</h3><p><a href="https://forums.developer.apple.com/thread/28056" target="_blank" rel="external">Q8链接地址</a></p>
<h3 id="问题描述-7">问题描述</h3><p>提问者吐槽，以下代码会出现编译错误：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Double</span> = <span class="number">2.0</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> z</span>: <span class="typename">Double</span> = y / x</span><br></pre></td></tr></table></figure>
<p>然后又表示，下面代码也是错的，让人难以接受这是 Swift 干的事情：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="tag">var</span> k: Double</span><br><span class="line">k = <span class="function"><span class="title">Double</span><span class="params">(x)</span></span></span><br><span class="line">k = <span class="function"><span class="title">Double</span><span class="params">(x.value)</span></span></span><br><span class="line">k = (Double) x</span><br><span class="line">k = (Double) x.value</span><br></pre></td></tr></table></figure>
<h3 id="问题解答-5">问题解答</h3><p><a href="https://forums.developer.apple.com/people/OOPer" target="_blank" rel="external">OOPer</a> 大神在回帖中写到，其实<code>k = Double(x)</code> 是可以执行的， Swift 是强调强类型的语言，不过也提供了不同类型的转换方式。对不同类型进行运算, Swift 是不允许的。以下代码是可以运行的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span>: <span class="typename">Int</span> = <span class="number">2</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> y</span>: <span class="typename">Double</span> = <span class="number">2.0</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> z</span>: <span class="typename">Double</span> = y / <span class="typename">Double</span>(x)</span><br></pre></td></tr></table></figure>
<p>另外，回帖中还提供了一种使用协议和代码的方式来解决这个问题：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">protocol DoubleBOWEMOJI &#123;  </span><br><span class="line">  <span class="variable"><span class="keyword">var</span> Double</span>: Swift.<span class="typename">Double</span> &#123;<span class="keyword">get</span>&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">extension <span class="typename">Int</span>: DoubleBOWEMOJI &#123;  </span><br><span class="line">   <span class="variable"><span class="keyword">var</span> Double</span>: Swift.<span class="typename">Double</span> &#123;<span class="keyword">return</span> Swift.<span class="typename">Double</span>(self)&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> z</span> = y / x.<span class="typename">Double</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本周整理问题如下：</p>
<ul>
<li><a href="#Q1">Unwrapping NSNumber works fine in iOS Simulator but unexpectedly found nil on iPhone</a></li>
<li><a href="#Q2">Why my code is working in playground but not in my project?</a></li>
<li><a href="#Q3">Failable initialisers and unbound instance vars</a></li>
<li><a href="#Q4">Read-only property</a></li>
<li><a href="#Q5">Why? insert a new element into array and it always crash!</a></li>
<li><a href="#Q6">binary operator ‘??’ cannot be applied to functions?</a></li>
<li><a href="#Q7">Filter array on type</a> </li>
<li><a href="#Q8">Numbers in swift</a></li>
</ul>
<p>对应的代码都放到了 github 上，有兴趣的同学可以下载下来研究：<a href="https://github.com/SwiftGGTeam/SwiftCommunityWeeklyQA/tree/master/20151216/%E6%AF%8F%E5%91%A8%20Swift%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%9420151216.playground">点击下载</a></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://swiftggteam.github.io/tags/Swift/"/>
    
      <category term="原创" scheme="http://swiftggteam.github.io/tags/%E5%8E%9F%E5%88%9B/"/>
    
      <category term="社区问答" scheme="http://swiftggteam.github.io/tags/%E7%A4%BE%E5%8C%BA%E9%97%AE%E7%AD%94/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="iOS开发" scheme="http://swiftggteam.github.io/categories/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Beta 2 更新：Swift 2.1 Playground 使用值放置方法]]></title>
    <link href="http://swiftggteam.github.io/2015/12/16/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/12/16/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/</id>
    <published>2015-12-15T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/09/23/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-09-23<br>译者：<a href="http://weibo.com/u/2916092907" target="_blank" rel="external">天才175</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a></p>
</blockquote>
<p><img src="/img/articles/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/Color-AppScreenSnapz001.png1450226715.996496" alt=""></p>
<p>Beta 2 的新特性允许你拖放颜色、图片以及文件。在截图中虽然看不到，但如果你打开文本赋值的历史记录，就会显示文件的文本内容（是我的购物清单，好奇的家伙们）。文本常量的类型为<code>NSURL</code>。颜色是<code>UIColor</code>，图片是<code>UIImage</code>。谢天谢地，希望你们对这些没有任何疑问。</p>
<a id="more"></a>
<ul>
<li>非常有趣的是，你可以在 playground 里拖动它们。所以如果你不小心把一张图片放在了颜色那一行，直接拖到 图片赋值那里就行。</li>
<li>你也可以选择将拖动的物品进行复制。</li>
<li>双击颜色可以打开颜色选择器（耶！），双击图片可以打开资源文件夹来选取其他资源。双击 URLS 我没发现可以干神马。</li>
<li>你不能调整代码中占位符的大小，但是你可以调整它们历史记录界面的大小，和其他值一样。</li>
<li>你还不能通过调用<code>UIColor</code>来生成颜色预览，比如，<code>UIColor.blueColor()</code>就不能生成预览。我发现最简单的方法就是从外部拖进来或者复制/拖另一个颜色，然后用色轮赋值。</li>
<li>如果代码中占位符是蓝色，别输入。单击关闭它或者直接用键盘输入内容替换它。蓝色意味着可以选取并且可以被改写。简单吧。</li>
</ul>
<p>聪明人的做法：<strong>不要把 playground 拖入它自身</strong>。我是认真的，我已经踩过坑了。</p>
<p><img src="/img/articles/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/Screen-Shot-2015-09-23-at-8.30.41-PM.png1450226717.1296368" alt=""></p>
<p>由于文件可以随意复制到资源文件夹。所以：</p>
<ul>
<li>不要通过拖动复制同样的文件两次。Xcode 不喜欢那样。</li>
<li>不要指望编辑源文件可以自动同步修改，你需要修改添加后的文件。</li>
<li>颜色不能复制到资源里，它们只能是值项。</li>
<li>目前有很多事情还不能做。比如，你不能从 Safari “复制” URLS 过来。它们需要进行转义，不然会被当作纯文本。虽然可以期待之后可以拖放的词汇会越来越多，但目前只有颜色、图片和本地文件的 NSURL。</li>
<li>如前所述，不要把 playground 拖入它自身。</li>
</ul>
<h2 id="其他新的东西">其他新的东西</h2><p>Swift 关于如何响应引入的 enums，unions, NSNumbers 等有很大的变化。如果你从事大量跨语言编码，值得认真读一读更新说明。</p>
<p>Swift 2.1 现在可以在字符串插值中使用双引号。</p>
<blockquote>
<p>表达式字符串插值现在可以包含字符串了。比如，“My name is \ (attributes[“name”]!)” 现在是有效的。（14050788）</p>
</blockquote>
<p>编译器性能有一些提升。没有任何依赖的项（即标记为私有的）不会再触发其他文件的重编译。</p>
<p>更加宽泛的函数类型。你可以这样赋值了，从<code>任何类型-&gt;Int 闭包</code>到<code>字符串-&gt;任何变量</code>。这种方式到底好还是不好，我仍在思考中。</p>
<blockquote>
<p>现在支持函数类型的转换，展现了函数结果类型的协变和函数参数类型的逆变。比如，现在这样的函数类型赋值方式是合法的，从<code>任何类型-&gt;Int 闭包</code>到<code>字符串-&gt;任何变量</code>。（19517003）</p>
</blockquote>
<p>下面，抛开 playground, 对于我来说，有一个最重大的改变。那就是 map 闭包（_-&gt;_ 是不是很眼熟？）的错误提示“更加有用了”。我都等不及要试一试了!</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/09/23/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/">原文链接</a>，原文日期：2015-09-23<br>译者：<a href="http://weibo.com/u/2916092907">天才175</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/numbbbbb">numbbbbb</a></p>
</blockquote>
<p><img src="/img/articles/new-to-beta-2-swift-2-1-playground-value-drops-swiftlang/Color-AppScreenSnapz001.png1450226715.996496" alt=""></p>
<p>Beta 2 的新特性允许你拖放颜色、图片以及文件。在截图中虽然看不到，但如果你打开文本赋值的历史记录，就会显示文件的文本内容（是我的购物清单，好奇的家伙们）。文本常量的类型为<code>NSURL</code>。颜色是<code>UIColor</code>，图片是<code>UIImage</code>。谢天谢地，希望你们对这些没有任何疑问。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mixins 比继承更好]]></title>
    <link href="http://swiftggteam.github.io/2015/12/15/mixins-over-inheritance/"/>
    <id>http://swiftggteam.github.io/2015/12/15/mixins-over-inheritance/</id>
    <published>2015-12-15T02:30:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-08<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>译者注：<a href="https://en.wikipedia.org/wiki/Mixin" target="_blank" rel="external">Mixin</a> 和 <a href="https://en.wikipedia.org/wiki/Trait_\(computer_programming\" target="_blank" rel="external">Trait</a> 是面向对象编程语言中的术语，本文中作者并未明确指出两者之间的区别。这两个单词在本译文中也不做翻译。</p>
<p>从面向对象的编程语言的角度来说，继承（Inheritence）总被用来在多个类之间共享代码。但这并不总是一个最佳的解决方案，而且它本身还有些问题。在今天写的这篇文章中，我们会看到 Swift 中的协议扩展（Protocol Extensions），并将其以「Mixins」的形式去使用是怎样解决这个问题的。<br><a id="more"></a></p>
<blockquote>
<p>你可以从这里下载<a href="http://alisoftware.github.io/assets/Mixins.playground.zip" target="_blank" rel="external">包含本篇文章所有代码的 Swift Playground</a>。</p>
</blockquote>
<h3 id="继承本身存在的问题">继承本身存在的问题</h3><p>假设你有个 app，里面有很多包含相同行为的 <code>UIViewController</code> 类，例如它们都有汉堡菜单。你当然不想在 app 中的每一个 View Controller 里都反复实现这个汉堡菜单的逻辑（例如设置 <code>leftBarButtonItem</code> 按钮，点击这个按钮时打开或者关闭这个菜单，等等）。</p>
<p>解决方案很简单，你只需要创建一个负责实现所有特定行为、而且是 <code>UIViewController</code> 的子类 <code>CommonViewController</code>。然后让你所有的 ViewController 都直接继承 <code>CommonViewController</code> 而不是 <code>UIViewController</code> 就可以了，没错吧？通过使用这种方式，这些类都继承了父类的方法，且具有了相同的行为，你也不用每次重复实现这些东西了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="keyword">var</span> burgerMenuIsOpen: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123; … &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">CommonViewController</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在随后的开发阶段，你会意识到自己需要一个 <code>UITableViewController</code> 或者一个 <code>UICollectionViewController</code>……晕死，<code>CommonViewController</code> 不能用了，因为它是继承自 <code>UIViewController</code> 而不是 <code>UITableViewController</code>！</p>
<p>你会怎么做，是实现和 <code>CommonViewController</code> 一样的事情却继承于 <code>UITableViewController</code> 的 <code>CommonTableViewController</code> 吗？这会产生很多重复的代码，而且是个十分糟糕的设计哦。</p>
<h3 id="组合（Composition）是救命稻草">组合（Composition）是救命稻草</h3><p>诚然，解决这个问题，有句具有代表性并且正确的话是这么说的：</p>
<blockquote>
<p>多用组合，少用继承。</p>
</blockquote>
<p>这意味着我们不使用继承的方式，而是让我们的 <code>UIViewController</code> 包含一些提供相应行为的内部类（Inner class）。</p>
<p>在这个例子中，我们可以假定 <code>BurgerMenuManager</code> 类能提供创建汉堡菜单图标、以及与这些图标交互逻辑的所有必要的方法。那些各式各样的 <code>UIViewController</code> 就会有一个 <code>BurgerMenuManager</code> 类型的<em>属性</em>，可以用来与汉堡餐单做交互。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurgerMenuManager</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; burgerMenuIsOpen = !burgerMenuisOpen &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">burgerMenuIsOpen</span>: <span class="title">Bool</span> </span>&#123; <span class="keyword">didSet</span> &#123; … &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> menuManager: <span class="type">BurgerMenuManager</span>()</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    menuManager.setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherViewController</span>: <span class="title">UITableViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> menuManager: <span class="type">BurgerMenuManager</span>()</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    menuManager.setupBurgerMenu()</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而你能看出来这种解决方案会变得很臃肿。每次你都得去明确引用那个中间对象 <code>menuManager</code>。</p>
<h3 id="多继承（Multiple_inheritance）">多继承（Multiple inheritance）</h3><p>继承的另一个问题就是很多面向对象的编程语言都不支持<em>多继承</em>（这儿有个很好的解释，是关于<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="external">菱形缺陷（Diamond problem）</a>的）。</p>
<p>这就意味着一个类不能继承自多个父类。</p>
<p>假如说你要创建一些科幻小说中的人物的对象模型。显然，你得展现出 <code>DocEmmettBrown</code>，<code>DoctorWho</code>，<code>TimeLord</code>，<code>IronMan</code> 还有 <code>Superman</code> 的能力……这些角色的相互关系是什么？有些能时间旅行，有些能空间穿越，还有些两种能力都会；有些能飞，而有些不能飞；有些是人类，而有些不是……</p>
<p><code>IronMan</code> 和 <code>Superman</code> 这个两个类都能飞，于是我们就会设想有个 <code>Flyer</code> 类能提供一个实现 <code>fly()</code> 的方法。但是 <code>IronMan</code> 和 <code>DocEmmettBrown</code> 都是人类，我们还会设想要有个 <code>Human</code> 父类；而 <code>Superman</code> 和 <code>TimeLord</code> 又得是 <code>Alien</code> 的子类。哦，等会儿…… 那 <code>IronMan</code> 得同时继承 <code>Flyer</code> 和 <code>Human</code> 两个类吗？这在 Swift 中是不可能的实现的（在很多其他的面向对象的语言中也不能这么实现）。</p>
<p>我们应该从所有父类中选择出符合子类属性最好的一个么？但是假如我们让 <code>IronMan</code> 继承 <code>Human</code>，那么怎么去实现 <code>fly()</code> 这个方法？很显然我们不能在 <code>Human</code> 这个类中实现，因为并不是每个人都会飞，但是 <code>Superman</code> 却需要这个方法，然而我们并不想重复写两次。</p>
<p>所以，我们在这里会使用组合（Composition）方法，让 <code>var flyingEngine: Flyer</code> 成为 <code>Superman</code> 类中的一个属性。</p>
<p>但是调用时你必须写成 <code>superman.flyingEngine.fly()</code> 而不是优雅地写成 <code>superman.fly()</code>。</p>
<h3 id="Mixins_&amp;_Traits">Mixins &amp; Traits</h3><p><img src="/img/articles/mixins-over-inheritance/12401450145416.541825" alt="生生不息，Mixin 繁荣"></p>
<p>Mixins 和 Traits 的概念<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>由此引入。</p>
<ul>
<li>通过继承，你定义你的类是什么。例如每条 <code>Dog</code> 都<em>是</em>一个 <code>Animal</code>。</li>
<li>通过 Traits，你定义你的类<em>能做什么</em>。例如每个 <code>Animal</code> 都<em>能</em> <code>eat()</code>，但是人类也可以吃，而且<a href="https://www.youtube.com/watch?v=Oo2RKAHu-kI" target="_blank" rel="external">异世奇人（Doctor Who）也能吃鱼条和蛋挞</a>，甚至即使是位 Gallifreyan（既不是人类也不是动物）。</li>
</ul>
<p>使用 Traits，重要的不是「是什么」，而是能「做什么」。</p>
<blockquote>
<p>继承描述了一个对象是什么，而 Traits 描述了这个对象能做什么。</p>
</blockquote>
<p>最棒的事情就是一个类可以选用多个 <code>Traits</code> 来做多个事情，而这个类还只是一种事物（只从一个父类继承）。</p>
<p>那么如何应用到 Swift 中呢？</p>
<h3 id="有默认实现的协议">有默认实现的协议</h3><p>Swift 2.0 中定义一个<code>协议（Protocol）</code>的时候，还可以使用这个协议的<code>扩展（Extension）</code>给它的部分或是所有的方法做默认实现。看上去是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I believe I can flyyyyy ♬"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面的代码，当你创建一个遵从 <code>Flyer</code> 协议的类或者是结构体时，就能很顺利地获得 <code>fly()</code> 方法！</p>
<p>这只是一个<em>默认的实现方式</em>。因此你可以在需要的时候不受约束地重新定义这个方法；如果不重新定义的话，会使用你默认的那个方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span>: <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里我们没有实现 fly() 方法，因此能够听到 Clark 唱歌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span>: <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果需要我们也可以给出单独的实现</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    thrusters.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于很多事情来说，协议的默认实现这个特性非常的有用。其中一种自然就是如你所想的那样，把「Traits」概念引入到了 Swift 中。</p>
<h3 id="一种身份，多种能力">一种身份，多种能力</h3><p>Traits 很赞的一点就是它们并不依赖于使用到它们的对象本身的身份。Traits 并不关心类是什么，亦或是类是从哪里继承的：Traits 仅仅在类上定义了一些函数。</p>
<p>这就解决了我们的问题：异世奇人（Doctor Who）可以既是一位时间旅行者，同时还是一个外星人；而爱默·布朗博士（Dr Emmett Brown）既是一位时间旅行者，同时还属于人类；钢铁侠（Iron Man）是一个能飞的人，而超人（Superman）是一个能飞的外星人。</p>
<blockquote>
<p>你是什么并不限制你能够做什么</p>
</blockquote>
<p>现在我们利用 Traits 的优点来实现一下我们的模板类。</p>
<p>首先定义不同的 Traits：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TimeTraveler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentDate: <span class="type">NSDate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(date: NSDate)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后给它们一些默认的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I believe I can flyyyyy ♬"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimeTraveler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(date: NSDate)</span></span> &#123;</span><br><span class="line">    currentDate = date</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这点上，我们还是用继承去定义我们英雄角色的身份（他们是什么），先定义一些父类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> countryOfOrigin: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, countryOfOrigin: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.countryOfOrigin = countryOfOrigin</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, species: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.species = species</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就能通过他们的身份（通过继承）和能力（Traits/协议遵循）来定义英雄角色了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeLord</span>: <span class="title">Alien</span>, <span class="title">TimeTraveler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentDate = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"I'm the Doctor"</span>, species: <span class="string">"Gallifreyan"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DocEmmettBrown</span>: <span class="title">Human</span>, <span class="title">TimeTraveler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentDate = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Emmett Brown"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superman</span>: <span class="title">Alien</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Clark Kent"</span>, species: <span class="string">"Kryptonian"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span>: <span class="title">Human</span>, <span class="title">Flyer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Tony Stark"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 <code>Superman</code> 和 <code>IronMan</code> 都使用了相同的 <code>fly()</code> 实现，即使他们分别继承自不同的父类（一个继承自 <code>Alien</code>，另一个继承自 <code>Human</code>）。而且这两位博士都知道怎么做时间旅行了，即使一个是人类，另外一个来自 Gallifrey 星。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tony = <span class="type">IronMan</span>()</span><br><span class="line">tony.fly() <span class="comment">// 输出 "I believe I can flyyyyy ♬"</span></span><br><span class="line">tony.name  <span class="comment">// 返回 "Tony Stark"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clark = <span class="type">Superman</span>()</span><br><span class="line">clark.fly() <span class="comment">// 输出 "I believe I can flyyyyy ♬"</span></span><br><span class="line">clark.species  <span class="comment">// 返回 "Kryptonian"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docBrown = <span class="type">DocEmmettBrown</span>()</span><br><span class="line">docBrown.travelTo(<span class="type">NSDate</span>(timeIntervalSince1970: <span class="number">499161600</span>))</span><br><span class="line">docBrown.name <span class="comment">// "Emmett Brown"</span></span><br><span class="line">docBrown.countryOfOrigin <span class="comment">// "USA"</span></span><br><span class="line">docBrown.currentDate <span class="comment">// Oct 26, 1985, 9:00 AM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doctorWho = <span class="type">TimeLord</span>()</span><br><span class="line">doctorWho.travelTo(<span class="type">NSDate</span>(timeIntervalSince1970: <span class="number">1303484520</span>))</span><br><span class="line">doctorWho.species <span class="comment">// "Gallifreyan"</span></span><br><span class="line">doctorWho.currentDate <span class="comment">// Apr 22, 2011, 5:02 PM</span></span><br></pre></td></tr></table></figure>
<h3 id="时空大冒险">时空大冒险</h3><p>现在我们引入一个新的空间穿越的能力/trait：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SpaceTraveler</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(location: String)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并给它一个默认的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SpaceTraveler</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(location: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Let's go to <span class="subst">\(location)</span>!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 Swift 的<code>扩展（Extension）</code>方式<strong>让现有的一个类遵循一个协议</strong>，把这些能力加到我们定义的角色身上去。如果忽略掉钢铁侠之前跑到纽约城上面随后短暂飞到太空中去的那次情景，那只有博士和超人是真正能做空间穿越的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimeLord</span>: <span class="title">SpaceTraveler</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Superman</span>: <span class="title">SpaceTraveler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/articles/mixins-over-inheritance/great-scott.gif1450145417.1893744" alt="天哪！"></p>
<p>没错，这就是给已有类添加能力/trait 仅需的步骤！就这样，他们可以 <code>travelTo()</code> 任何的地方了！很简洁，是吧？</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">doctorWho.travelTo(<span class="string">"Trenzalore"</span>) <span class="comment">// prints "Let's go to Trenzalore!"</span></span><br></pre></td></tr></table></figure>
<h3 id="邀请更多的人来参加这场聚会！">邀请更多的人来参加这场聚会！</h3><p>现在我们再让更多的人加入进来吧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来吧，Pond！</span></span><br><span class="line"><span class="keyword">let</span> amy = <span class="type">Human</span>(name: <span class="string">"Amelia Pond"</span>, countryOfOrigin: <span class="string">"UK"</span>)</span><br><span class="line"><span class="comment">// 该死，她是一个时间和空间旅行者，但是却不是 TimeLord！</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Astraunaut</span>: <span class="title">Human</span>, <span class="title">SpaceTraveler</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> neilArmstrong = <span class="type">Astraunaut</span>(name: <span class="string">"Neil Armstrong"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line"><span class="keyword">let</span> laika = <span class="type">Astraunaut</span>(name: <span class="string">"Laïka"</span>, countryOfOrigin: <span class="string">"Russia"</span>)</span><br><span class="line"><span class="comment">// 等等，Leïka 是一只狗，不是吗？</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilleniumFalconPilot</span>: <span class="title">Human</span>, <span class="title">SpaceTraveler</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> hanSolo = <span class="type">MilleniumFalconPilot</span>(name: <span class="string">"Han Solo"</span>)</span><br><span class="line"><span class="keyword">let</span> chewbacca = <span class="type">MilleniumFalconPilot</span>(name: <span class="string">"Chewie"</span>)</span><br><span class="line"><span class="comment">// 等等，MilleniumFalconPilot 不该定义成「人类」吧！</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spock</span>: <span class="title">Alien</span>, <span class="title">SpaceTraveler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Spock"</span>, species: <span class="string">"Vulcan"</span>)</span><br><span class="line">    <span class="comment">// 并不是 100% 正确</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Huston，我们有麻烦了（译注：原文 “Huston, we have a problem here”，是星际迷航中的梗）。Laika 不是一个人，Chewie 也不是，Spock 算半个人、半个瓦肯（Vulcan）人，所以上面的代码定义错的离谱！</p>
<p>你看出来什么问题了么？我们又一次被继承摆了一道，理所应当地认为 <code>Human</code> 和 <code>Alien</code>是身份。在这里一些类必须属于某种类型，或是必须继承自某个父类，而实际情况中不总是这样，尤其对科幻故事来说。</p>
<p>这也是为什么要在 Swift 中使用协议，以及协议的默认扩展。这能够帮助我们把因使用继承而强加到类上的这些限制移除。</p>
<p>如果 <code>Human</code> 和 <code>Alien</code> 不是<code>类</code>而是<code>协议</code>，那就会有很多的好处：</p>
<ul>
<li>我们可以定义一个 <code>MilleniumFalconPilot</code> 类型，不必让它是一个 <code>Human</code> ，这样就可以让 Chewie 驾驶它了；</li>
<li>我们可以把 Laïka 定义成一个 <code>Astronaut</code>，即使她不是人类；</li>
<li>我们可以将 <code>Spock</code> 定义成 <code>Human</code> 和 <code>Alien</code> 的结合体；</li>
<li>我们甚至可以在这个例子中完全摒弃继承，并将我们的类型从<code>类（Classes）</code>转换成<code>结构体（Structs）</code>。<code>结构体</code>不支持继承，但可以遵循你想要遵循的协议，想遵循多少协议就能遵循多少协议！</li>
</ul>
<h3 id="无处不在的协议！">无处不在的协议！</h3><p>因此，我们的一个解决方案是彻底弃用继承，将所有的东西都变成协议。毕竟我们不在乎我们的角色<em>是什么</em>，能够定义英雄本身的是他们拥有的<em>能力</em>！</p>
<p><img src="/img/articles/mixins-over-inheritance/12401450145417.8855546" alt="终结掉继承！"></p>
<p>我在这里附上了一个<a href="http://alisoftware.github.io/assets/Mixins.playground.zip" target="_blank" rel="external">可下载的 Swift Playground 文件</a>，包含这篇文章里的所有代码，并在 Playground 的第二页放上了一个全部用协议和结构体的解决方案，完全不用继承。快去看看吧！</p>
<p>这当然并不意味着你必须不惜一切代价放弃对继承的使用（别听那个 Dalek 讲太多，机器人毕竟没感情的😉）。继承依然有用，而且依然有意义——很符合逻辑的一个说法就是 <code>UILabel</code> 是 <code>UIView</code> 的一个<em>子类</em>。但我们提供的方法能让你能感受到 Mixins 和协议带给你的不同体验。</p>
<h3 id="小结">小结</h3><p>实践 Swift 的时候，你会意识到它实质上是一个面向协议的语言（Protocols-Oriented language），而且在 Swift 中使用协议和在 Objective-C 中使用相比更加常见和有效。毕竟，那些类似于 <code>Equatable</code>，<code>CustomStringConvertible</code> 的协议以及 Swift 标准库中其它所有以 <code>-able</code> 结尾的协议都可以被看做是 Mixins！</p>
<p>有了 Swift 的协议和协议的默认实现，你就能实现 Mixins 和 Traits，而且你还可以实现类似于抽象类<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>以及更多的一些东西，这让你的代码变得更加灵活。</p>
<p>Mixins 和 Traits 的方式可以让你描述你的类型<strong>能够做什么</strong>，而不是描述<strong>它们是什么</strong>。更重要的是，它们能够为你的类型增加各种能力。这就像购物那样，<strong>无论你的类是从哪个父类继承的（如果有），你都能为它们选择你想要它们具有的那些能力</strong>。</p>
<p>回到第一个例子，你可以创建一个 <code>BurgerMenuManager 协议</code>且该协议有一个默认实现，然后可以简单地将 View Controllers（不论是 <code>UIViewController</code>，<code>UITableViewController</code> 还是其他的类）都遵循这个协议，它们都能自动获得 <code>BurgerMenuManager</code> 所具有的能力和特性，你也根本不用去为父类 <code>UIViewController</code> 操心！</p>
<p><img src="/img/articles/mixins-over-inheritance/i-dont-wanna-go.gif1450145418.0677123" alt="我不想离开"></p>
<p>关于协议扩展还有很多要说的，我还想在文章中继续告诉你关于它更多的事情，因为它能够通过很多方式提高你的代码质量。嘿，但是，这篇文章已经挺长的了，同时也为以后的博客文章留一些空间吧，希望你到时还会再来看！</p>
<p>与此同时，生生不息，繁荣昌盛，杰罗尼莫（译注：跳伞时老兵鼓励新兵的一句话）！</p>
<hr>
<p><a id="fn1" href="#fnref1" rev="footnote">1.我不会深入去讲 Mixin 和 Traits 这两个概念之间的区别。由于这两个词的意思很接近，为简单起见，在本篇文章中它俩可以互相替换使用。</a><br><a id="fn2" href="#fnref2" rev="footnote">2.在以后的博文中会作为一个专题去讲解。</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Olivier Halligon，<a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/">原文链接</a>，原文日期：2015-11-08<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>译者注：<a href="https://en.wikipedia.org/wiki/Mixin">Mixin</a> 和 <a href="https://en.wikipedia.org/wiki/Trait_\(computer_programming\">Trait</a> 是面向对象编程语言中的术语，本文中作者并未明确指出两者之间的区别。这两个单词在本译文中也不做翻译。</p>
<p>从面向对象的编程语言的角度来说，继承（Inheritence）总被用来在多个类之间共享代码。但这并不总是一个最佳的解决方案，而且它本身还有些问题。在今天写的这篇文章中，我们会看到 Swift 中的协议扩展（Protocol Extensions），并将其以「Mixins」的形式去使用是怎样解决这个问题的。<br>]]>
    
    </summary>
    
      <category term="Crunchy Development" scheme="http://swiftggteam.github.io/tags/Crunchy-Development/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 的 NSDate 初学者指南]]></title>
    <link href="http://swiftggteam.github.io/2015/12/14/a-beginners-guide-to-nsdate-in-swift/"/>
    <id>http://swiftggteam.github.io/2015/12/14/a-beginners-guide-to-nsdate-in-swift/</id>
    <published>2015-12-14T01:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.994Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：gabriel theodoropoulos，<a href="http://www.appcoda.com/nsdate/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-18<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles" target="_blank" rel="external">ray16897188</a>；校对：<a href="https://github.com/numbbbbb" target="_blank" rel="external">numbbbbb</a>；定稿：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a></p>
</blockquote>
<p>如果问我在做过的所有项目中做的最多的事情，那处理日期绝对是榜上有名（译注：本文中的「日期」是指代 NSDate 对象，同时包含「日（date）」 和「时（time）」这两个元素）。毋庸置疑，无论工作量是多是少，开发者迟早需要「玩」一下 NSDate 类，去按某种方式处理一下日期。从简单的将一个日期转换成一个字符串到对日期做计算，总会有一个不变的事实：开发者必须在 iOS 编程中学会这个知识点。这并不难掌握，而且可以为以后更重要任务节省时间。在新手看来，对日期的操作很麻烦；然而事实并非如此。你需要做的就是掌握它。</p>
<a id="more"></a>
<p>在应用中对日期（<em>NSDate</em>）对象最常见的操作就是把它转换成一个字符串对象，这样就可以用正确的格式把它展示给用户。反向操作也很常见：把字符串转换成日期对象。然而日期的操作并不只有这些。下面是一个简单的列表，列出了除上述操作之外可以对日期进行的其他操作：</p>
<ul>
<li>日期之间的比较。</li>
<li>计算未来或者过去的日期，很简单：用一个参考日期（比如当前日期）加上或者减去一段时间（天、月、年等等）。</li>
<li>计算不同日期之间的差值（比如算出两个特定日期之间的时间间隔有多久）。</li>
<li>将一个日期按其<em>组成元素（components）</em>做分解，并对每个部分做分别访问（天、月等等）。</li>
</ul>
<p>上面列出的所有内容，包括日期和字符串之间的相互转换，都是这篇教程要讨论的主题。在接下来的各个小节中，你会发现只要你知道该用什么工具以及如何使用它们，你就能随心所欲的对日期进行操作。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/09/nsdate-featured.jpg" alt=""></p>
<p>下面的链接清单里有很多重要的文章，供参考。如果需要深入了解某些特定知识点，别忘了点击访问一下：</p>
<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDate_Class/" target="_blank" rel="external">NSDate</a></li>
<li><a href="https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDateFormatter_Class/index.html" target="_blank" rel="external">NSDateFormetter</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDateComponents_Class/" target="_blank" rel="external">NSDateComponents</a></li>
<li><a href="https://developer.apple.com/library/watchos/documentation/Foundation/Reference/NSDateComponentsFormatter_class/index.html" target="_blank" rel="external">NSDateComponentFormatter</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/" target="_blank" rel="external">NSCalendar</a></li>
</ul>
<h3 id="关于_Demo_App">关于 Demo App</h3><p>嗯，这个教程我们不使用 demo 应用（是的，你没看错）。取而代之，我们这次用一个 <em>Playground</em> 来展示你将要看到的所有例子。我是特意这么做的，因为我的目的是给你提供丰富的、能更好的展示出关于 <em>NSDate</em> 方方面面的代码。</p>
<p>你可以下载并在 Xcode 中打开<a href="https://www.dropbox.com/s/s54ko81l5mvxg5s/PlayingWithDates.playground.zip?dl=0" target="_blank" rel="external">这个写好的 playground 文件</a>，但我还是强烈建议你新建一个 Playground 文件，并测试下面章节中的每一个新代码段。这样会让你更容易的去理解每个示例是如何工作的，除此之外你还可以修改代码，实时观察你的修改会如何影响生成的结果。</p>
<p>我给你的 playground 文件名是 <em>PlayingWithDates</em>，里面包含了所有的代码。你自己的文件可以用相同的文件名，或者换一个，都无所谓。</p>
<h3 id="基本概念">基本概念</h3><p>在我们开始查看日期相关的技术细节并思考能用它们做什么之前，先要确保每个人都已经掌握一些基本概念，这很重要。先从一个最简单的开始：<em>NSDate</em> 对象。从程序角度来说这种对象包含了对<em>日（date）</em>和<em>时（time）</em>两者的描述，所以它不仅仅可以帮我们处理「日」，还可以帮我们处理「时」。对于 <em>NSDate</em> 对象本身来说是没有<em>格式（formatting）</em>这个概念的；和其他类中的所有属性一样，可以把日和时看做是<em>属性（properties）</em>。只有在将一个日期对象转换成一个字符串时，格式这个概念才会派上用场，下面的内容里我们会看到很多关于这个的细节。通常来讲，记住你所需要的就是 <em>NSDate</em> 这个类，无论你只关心「日」、「时」或者两者。</p>
<p>接下来我们会遇到的另一个类是 <em>NSDateComponents</em>。可以把这个类看做 <em>NSDate</em> 的「姊妹」类，因为这个类给开发者提供了一些极为有用的特性和操作。这个类的第一个要点是它可以将「日」部分或者「时」部分作为一个单独的属性显示出来，所以我们可以直接访问「日」或者「时」，然后在其他的任务中使用（比如对「日」或「时」的计算）。例如，一个 <em>NSDateComponents</em> 实例中的天和月在下面的代码中表示为 <em>day</em> 和 <em>month</em> 属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateComponents = <span class="type">NSDateComponents</span>()</span><br><span class="line"><span class="keyword">let</span> day = dateComponents.day</span><br><span class="line"><span class="keyword">let</span> month = dateComponents.month</span><br></pre></td></tr></table></figure>
<p>就这么简单。当然访问日期元素并将该日期的值传递给一个 <em>NSDateComponents</em> 对象需要先做一些强制转换，这些我们之后再讨论。</p>
<p>除上所述之外，<em>NSDateComponents</em> 这个类在用于计算未来或者过去的日期时也非常有用。当你想得到一个在某个特定日期之后或之前的那个日期时，你要做的就是加上或者减去合适的那一部分，最终就能转换成一个新的日期。另外 <em>NSDateComponents</em> 也适合计算日期之间的差值。现在无需深入研究这两个内容，我们一会儿会看到细节。</p>
<p>对于 <em>NSCalendar</em> 类，虽然它不会派上大用场，而且我们仅需要用它来实现 <em>NSDate</em> 和 <em>NSDateComponents</em> 相互转换，但它在我们的日期游戏中也是重要的一员。关于它所支持的特性，本文不会再进行介绍。将日期从 <em>NSDate</em> 转换成 <em>NSDateComponents</em>（或者反过来）的任务属于 <em>NSCalendar</em> 类，按照惯例，做转换需要一个特定的 c alendar（日历）对象。实际上系统在做任何转换之前都需要知道要用一个怎样的 calendar 对象，从而才可能给出正确的结果（别忘了满世界有太多不同的 calendar 对象，转换出来的「天」、「月」等值会千差万别）。你可以读一些和 calendar 有关的文章（参考简介里的链接），而在这里为图简便，我们会用 <em>NSCalendar</em> 的类方法 <em>currentCalendar()</em> 来得到用户设置中指定的 calendar。</p>
<p>此外，在下一节中我们会使用一个特别好的工具，它就是 <em>NSDateFormatter</em> 类。它能够实现 <em>NSDate</em> 对象到字符串、以及字符串到 <em>NSDate</em> 对象的转换。它还可以使用预定义的<em>日期样式（date styles）</em>来给最终的日期字符串制定格式，或是通过给出期望格式的<em>描述</em>来实现高度格式样式定制。下面会有一些相关的例子，其中一些例子示范了双向转换。一个 <em>NSDateFormatter</em> 对象同样也支持本地化（localization）；我们所需要的就是给它提供一个有效的 <em>NSLocale</em> 对象，基于该给定的位置（locale）设置最终转换出的对象就会正确显示出来。 </p>
<p>还有个类似的 <em>NSDateComponentsFormatter</em> 类，它可以将「日」和「时」部分作为输入，输出人类可读的、有特定格式的日期字符串。对此这个类包含了很多方法（methods），在此教程的最后一部分我们会看见其中几个；我们只讨论在教程的例子中用到的那些知识点。</p>
<p>上面已经说了那么多，我们可以开始编程了，具体学习上面提到的每个类的用法。再说一次，建议你创建一个新的 playground 文件，然后把我介绍的每一条都试一下。没有什么学习方法比亲手做更有效果。</p>
<h3 id="NSDate_和_String_之间的转换">NSDate 和 String 之间的转换</h3><p>首先，我们使用 <em>NSDate</em> 获得当前日期，并将它赋给一个常量以便访问。和其他一些语言所要求的不同，获得当前的日期并不需要调用类似 <em>now()</em> 或者 <em>today()</em> 的特殊方法。你所要做的就是初始化一个 <em>NSDate</em> 对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> currentDate = <span class="type">NSDate</span>()</span><br></pre></td></tr></table></figure>
<p>在 Xcode 的 playground 里敲入上面的语句，你会看到：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058093.7960339" alt=""></p>
<p>注意我们会在下面的代码中多次使用到上面的这个值。现在初始化一个 <em>NSDateFormatter</em> 对象。它用来在 dates 和 strings 之间做转换。如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateFormatter = <span class="type">NSDateFormatter</span>()</span><br></pre></td></tr></table></figure>
<p>除非是有其他明确的设定，否则 <em>dateFormatter</em> 会默认采用设备中的位置（locale）设置。尽管系统并不要求你去手动设置当前的位置，但如果需要的话你可以这么做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.locale = <span class="type">NSLocale</span>.currentLocale()</span><br></pre></td></tr></table></figure>
<p>设一个不同的位置很容易：你仅需要知道与位置（locale）相匹配的<em>位置标识符（locale identifier）</em>是什么，然后指定给 locale 属性即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.locale = <span class="type">NSLocale</span>(localeIdentifier: <span class="string">"el_GR"</span>)</span><br><span class="line">dateFormatter.locale = <span class="type">NSLocale</span>(localeIdentifier: <span class="string">"fr_FR"</span>)</span><br></pre></td></tr></table></figure>
<p>这两行代码展示了如何给 date formatter 去设置一个不同的位置（例子里分别是希腊和法国地区）。当然设置多个位置的值没有意义，因为能起作用的仅仅是最后一个。你是不是想知道 locale 是怎么影响日期和字符串之间的转换的呢？过会儿你就会得到答案。</p>
<h3 id="用_Date_formatter_styles_为输出结果设置格式">用 Date formatter styles 为输出结果设置格式</h3><p>把一个日期对象（<em>NSDate</em>）转换成一个字符串之前，你需要「告诉」date formatter 你要得到的字符串结果的格式是怎样的。这里有两种方法。第一种是使用预定义的 <em>date formatter styles</em>，第二种是使用某些特定的<em>分类符（specifier）</em>来手动指定最终输出结果的格式。</p>
<p>先用第一种方法，我们需要使用 <em>NSDateFormatterStyle enum</em>。这个枚举类型的每一个枚举值都代表一种不同的格式样式类型。第一个样式是 <em>FullStyle</em>，下面的图片是使用它的效果：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058094.232729" alt=""></p>
<p>下面是上面代码的文本，想复制的话随意：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateStyle = <span class="type">NSDateFormatterStyle</span>.<span class="type">FullStyle</span></span><br><span class="line"><span class="keyword">var</span> convertedDate = dateFormatter.stringFromDate(currentDate)</span><br></pre></td></tr></table></figure>
<p>除了日期样式（date style）之外，上面两行代码中的 <em>stringFromDate:</em> 方法也同等重要，这个方法实现了真正的转换。当谈及转换时，我们实际上说的是这个方法，其余的只不过是自定义结果格式过程中所需的一些步骤。如果你想要在你的项目里做日期的转换，那么这个方法对你来说肯定非常方便。</p>
<p>好，来看下一个样式，<em>Long Style</em>：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058094.629814" alt=""></p>
<p>文本形式的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateStyle = <span class="type">NSDateFormatterStyle</span>.<span class="type">LongStyle</span></span><br><span class="line">convertedDate = dateFormatter.stringFromDate(currentDate)</span><br></pre></td></tr></table></figure>
<p>可以看到这种类型的样式中不包含星期几（和 Full Style 相比而言）。下面是 <em>Medium Style</em>：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058094.9355278" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateStyle = <span class="type">NSDateFormatterStyle</span>.<span class="type">MediumStyle</span></span><br><span class="line">convertedDate = dateFormatter.stringFromDate(currentDate)</span><br></pre></td></tr></table></figure>
<p>最后是 <em>Short Style</em>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateStyle = <span class="type">NSDateFormatterStyle</span>.<span class="type">ShortStyle</span></span><br><span class="line">convertedDate = dateFormatter.stringFromDate(currentDate)</span><br></pre></td></tr></table></figure>
<p>现在你已经知道可用的 date formatter styles 都是什么了，你可以根据项目需求去使用它们。每种样式的设置都会产生出一个不同的结果，可能其中有一种会适合你。</p>
<p>之前我说过 date formatter 的 locale 可以被设置成非默认值。现在我们已经看到如何使用 date formatter styles 做转换，我们再来看看不同的 locale 值如何改变初始日期的字符串转换结果。下面的例子中我会使用 Full Style，以及前面提到的两个 locale identifier（希腊和法国）。</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058095.0969288" alt=""></p>
<p>我想现在 locale 能做什么你已经很清楚了，好好使用它吧。</p>
<h3 id="使用_Date_format_specifier">使用 Date format specifier</h3><p>上面的 date formatter style 足以应对多数情况，但是我们无法通过修改这些格式来获得不同于预设格式的结果。这种情况下我们还有另一个选择，一个能设置<em>自定义 date format</em> 的能力，这个自定义的 date format 能够正确描述你理想中的 date formatter 对象的的格式样式。一般来说设置一个自定义的 date format 对以下两种情况很适用：当 date formatter style 实现不了你所期望的输出结果的样式时（显然），还有当你需要把一个复杂的日期字符串（比如“Thu, 08 Oct 2015 09:22:33 GMT”）转换成一个日期对象时。</p>
<p>为了正确的设置一个 date format，一定要用一组<em>分类符（specifier）</em> 。Specifier 不过是一些简单的字符，这些字符对 date formatter 对象来说有着特定的意义。在我给你具体的例子之前，先列出来一些在接下来的代码中会使用到的format specifier：</p>
<ul>
<li>EEEE：表示星期几（如 Monday）。使用 1-3 个字母表示周几的缩略写法。</li>
<li>MMMM：月份的全写（如 October）。使用 1-3 个字母表示月份的缩略写法。</li>
<li>dd：表示一个月里面日期的数字（如 09 或 15）。</li>
<li>yyyy：4 个数字表示的年（如 2015）。</li>
<li>HH：2 个数字表示的小时（如 08 或 19）。</li>
<li>mm：2 个数字表示的分钟（如 05 或者 54）。</li>
<li>ss：2 个数字表示的秒。</li>
<li>zzz：3 个字母表示的时区（如 GMT）。</li>
<li>GGG：BC 或者 AD。</li>
</ul>
<p>如果想查看 date format specifiers 的参考内容，建议访问<a href="http://unicode.org/reports/tr35/tr35-6.html#Date_Format_Patterns" target="_blank" rel="external">官方技术规范</a>，你可以找到上面给出的 specifier 的使用方法，以及那些没有列出的 specifier。</p>
<p>继续我们的例子，看一下 format specifier 具体怎么用。这回我们把当前日期转换成一个字符串，显示成具有星期名称、月的全写，日期数字和年份的格式：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058095.2924576" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateFormat = <span class="string">"EEEE, MMMM dd, yyyy"</span></span><br><span class="line">convertedDate = dateFormatter.stringFromDate(currentDate)</span><br></pre></td></tr></table></figure>
<p>我想怎么用自定义的 date format 已经不需要额外的讲解了，用法十分简单。再来一个例子，转换一下时间：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058095.4972548" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateFormat = <span class="string">"HH:mm:ss"</span></span><br><span class="line">convertedDate = dateFormatter.stringFromDate(currentDate)</span><br></pre></td></tr></table></figure>
<p>到现在为止我们看到的所有转换都是从 <em>NSDate</em> 对象变成一个有特定格式的字符串。相反的操作也很有意思，之前关于 date formatter styles 和 format specifiers 的也同样适用。把有既定格式的字符串转换成一个 <em>NSDate</em> 对象的关键是要对 date formatter 的 <em>dateFormat</em> 属性做出正确设置，然后调用 <em>dateFromString:</em> 方法。我们再看几个例子：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058095.7241263" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dateAsString = <span class="string">"24-12-2015 23:59"</span></span><br><span class="line">dateFormatter.dateFormat = <span class="string">"dd-MM-yyyy HH:mm"</span></span><br><span class="line"><span class="keyword">var</span> newDate = dateFormatter.dateFromString(dateAsString)</span><br></pre></td></tr></table></figure>
<p>再看一个更复杂的字符串，还包含了时区：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058095.9686637" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateAsString = <span class="string">"Thu, 08 Oct 2015 09:22:33 GMT"</span></span><br><span class="line">dateFormatter.dateFormat = <span class="string">"EEE, dd MMM yyyy HH:mm:ss zzz"</span></span><br><span class="line">newDate = dateFormatter.dateFromString(dateAsString)</span><br></pre></td></tr></table></figure>
<p>注意一下时间（09:22）是如何通过简单的、在日期字符串中引入了一个时区而发生改变的（变成了 12:22）。这里没有任何实际上的变化，仅仅是我所在的时区（EFT）的时间在 GMT 时区中的表示，基于上面的代码，根据你自己的情况自由发挥吧。</p>
<p>到这里你已经基本上看到了为实现日期和字符串之间的转换你所需要的所有知识点。你可以敲敲自己的代码，试试你在上面所看到的那些，深入感受一下这些东西是如何工作的。</p>
<h3 id="使用_NSDateComponents">使用 NSDateComponents</h3><p>很多时候你需要在项目里拆分一个日期对象，然后从中获得特定组成元素的值。例如你可能会从一个日期对象中获取它的日和月的值，或者从时间中获得小时和分钟的值。此种情况下你需要用到的工具就是 <em>NSDateComponents</em> 这个类。</p>
<p><em>NSDateComponents</em> 类通常和 <em>NSCalendar</em> 类相结合来使用。具体点说，<em>NSCalendar</em> 方法实现了真正的从 <em>NSDate</em> 到 <em>NSDateComponents</em> 对象的转换；以及我们待会儿会看到的，从日期的组成元素到日期对象的转换。记好了这一点，这一节中我们首先要做的就是获取当前的 calendar，把它赋给一个常量以便访问：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> calendar = <span class="type">NSCalendar</span>.currentCalendar()</span><br></pre></td></tr></table></figure>
<p>现在我们看一个典型例子，一个 <em>NSDate</em> 对象是怎样被转换成一个 <em>NSDateComponents</em> 对象，之后我会做些讲解：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058096.3074582" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateComponents = calendar.components([<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Month</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Year</span>, <span class="type">NSCalendarUnit</span>.<span class="type">WeekOfYear</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Hour</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Minute</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Second</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Nanosecond</span>], fromDate: currentDate)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"day = <span class="subst">\(dateComponents.day)</span>"</span>, <span class="string">"month = <span class="subst">\(dateComponents.month)</span>"</span>, <span class="string">"year = <span class="subst">\(dateComponents.year)</span>"</span>, <span class="string">"week of year = <span class="subst">\(dateComponents.weekOfYear)</span>"</span>, <span class="string">"hour = <span class="subst">\(dateComponents.hour)</span>"</span>, <span class="string">"minute = <span class="subst">\(dateComponents.minute)</span>"</span>, <span class="string">"second = <span class="subst">\(dateComponents.second)</span>"</span>, <span class="string">"nanosecond = <span class="subst">\(dateComponents.nanosecond)</span>"</span> , separator: <span class="string">", "</span>, terminator: <span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<p>上面第一行代码用的方法是 <em>NSCalendar</em> 类的 <em>components(_:fromDate:)</em> 。该方法接受两个参数：第二个参数是原日期对象，我们要从中获得它的组成元素。但有意思是第一个参数，该方法要求第一个参数是一个元素为 <em>NSCalendarUnit</em> 属性的数组，这些属性对要从日期对象中抽取出的元素做出了描述。</p>
<p><em>NSCalendarUnit</em> 是一个结构体，你可以从<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/#//apple_ref/swift/struct/c:@E@NSCalendarUnit" target="_blank" rel="external">这里</a>看到所有可用的属性。上面的例子中，在你看到的代码段截图中给定的这些 calendar unit 值返回如下构成部分：</p>
<ul>
<li>Day</li>
<li>Month</li>
<li>Year</li>
<li>Week of year</li>
<li>Hour</li>
<li>Minute</li>
<li>Second</li>
<li>Nanosecond</li>
</ul>
<p>注意到在第一个参数数组中那些没有列出的 calendar unit（日历单元）在调用方法之后是不可用的。例如由于我们没有将 <em>NSCalendarUnit.TimeZone</em> 这个单元包括进去，所以在剩下获取到的元素中是访问不到时区（timezone）的（比如用 <em>print(dateComponents.timezone)</em>）。这么做的话会得到一个运行时错误。如果你需要额外的部分，你就必须再调用一次该方法，指定你想要的额外的calendar units。</p>
<p>从 date components 转换到日期对象也很容易。这回不会涉及到对 calendar unit 的使用。所需要的就是初始化一个新的<em>NSDateComponents</em>对象，然后明确指定出所有需要的components元素（当然是根据你app的需要），然后调用 <em>NSCalendar</em> 类的 <em>dateFromComponents</em> 方法实现转换。来看一下：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058096.656447" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> components = <span class="type">NSDateComponents</span>()</span><br><span class="line">components.day = <span class="number">5</span></span><br><span class="line">components.month = <span class="number">01</span></span><br><span class="line">components.year = <span class="number">2016</span></span><br><span class="line">components.hour = <span class="number">19</span></span><br><span class="line">components.minute = <span class="number">30</span></span><br><span class="line">newDate = calendar.dateFromComponents(components)</span><br></pre></td></tr></table></figure>
<p>前面的部分我们看过一个在把某特定格式的字符串转换成一个日期对象时使用了 timezone 的例子。如果你足够好奇想看看对一个日期对象设置不同 timezone 的结果，我们就将上面的代码稍稍扩展一下，看看 timezone 的多种取值：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058715.7602158" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">components.timeZone = <span class="type">NSTimeZone</span>(abbreviation: <span class="string">"GMT"</span>)</span><br><span class="line">newDate = calendar.dateFromComponents(components)</span><br><span class="line"> </span><br><span class="line">components.timeZone = <span class="type">NSTimeZone</span>(abbreviation: <span class="string">"CST"</span>)</span><br><span class="line">newDate = calendar.dateFromComponents(components)</span><br><span class="line"> </span><br><span class="line">components.timeZone = <span class="type">NSTimeZone</span>(abbreviation: <span class="string">"CET"</span>)</span><br><span class="line">newDate = calendar.dateFromComponents(components)</span><br></pre></td></tr></table></figure>
<p>GMT = 格林威治标准时间<br>CST = 中国标准时间<br>CET = 欧洲中部时间</p>
<p>你可以在<a href="http://www.timeanddate.com/time/zones/" target="_blank" rel="external">这里</a>找到所有 timezone 的缩写，还有一些很棒的在线工具。</p>
<p>现在你也知道如何去处理 <em>NSDateComponents</em> 对象了，那么咱们继续来研究另一个有意思的东西。</p>
<h3 id="比较日期和时间">比较日期和时间</h3><p>处理日期的另外一个常见情况是需要对两个日期对象进行比较，判断哪一个代表着更早或者更晚，甚至比较这两个是否为同一日期。概括来说我在下面会告诉你三种不同的比较日期对象的方式，但我不希望让你有种哪个是最好或者最坏的观点。很明显这取决于你在你的应用中想要干什么，而每种方式和其他两种都有些不同，哪种方法对你帮助最有效就选哪种。</p>
<p>在比较日期对象的方法给出之前，我们先创建两个日期对象，在本节的例子中使用。首先设定日期格式（date formatter 的 <em>dateFormat</em> 属性），然后把两个日期格式的字符串转换成两个日期对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateFormat = <span class="string">"MMM dd, yyyy zzz"</span></span><br><span class="line">dateAsString = <span class="string">"Oct 08, 2015 GMT"</span></span><br><span class="line"><span class="keyword">var</span> date1 = dateFormatter.dateFromString(dateAsString)!</span><br><span class="line"> </span><br><span class="line">dateAsString = <span class="string">"Oct 10, 2015 GMT"</span></span><br><span class="line"><span class="keyword">var</span> date2 = dateFormatter.dateFromString(dateAsString)!</span><br></pre></td></tr></table></figure>
<p>先看看用来比较日期的第一个方式。如果你想要比较两个日期中比较早的那一个，那么 <em>NSDate</em> 类会给你提供较大帮助，它分别提供了两个方法，<em>earlierDate:</em> 和 <em>laterDate:</em>。这两个方法的语法很简单：</p>
<p><em>date1.earlierDate(date2)</em></p>
<p>原理如下：</p>
<ul>
<li>如果 <em>date1</em> 对象比 <em>date2</em> 更早，那么上面的方法会返回 <em>date1</em> 的值。</li>
<li>如果 <em>date2</em> 对象比 <em>date1</em> 更早，那么上面的方法会返回 <em>date2</em> 的值。</li>
<li>如果两者相等，则返回 <em>date1</em>。</li>
</ul>
<p>同样道理也使用于 <em>laterDate:</em> 方法。</p>
<p>现在来看我们的例子，使用我们之前创建的那两个日期对象。下面的两条指令分别使用了刚才提到的那两个方法，为我们显示出更早的和更晚的日期：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058154.212341" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparing dates - Method #1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Earlier date is: <span class="subst">\(date1.earlierDate(date2)</span>)"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Later date is: <span class="subst">\(date1.laterDate(date2)</span>)"</span>)</span><br></pre></td></tr></table></figure>
<p>第二种比较两个 <em>NSDate</em> 对象的方式使用的是 <em>NSDate</em> 类的 <em>compare:</em> 方法，以及 <em>NSComparisonResult</em> 枚举类型。看下面的例子就会明白我的意思，但是我先提一下这种方式的语法和我上面例子中的很像。比较日期所得的结果是和所有的可能值作比较，用这种方式可以很容易的判断出两个日期是否相等、哪一个更早或者更晚。不说了，下面的代码已经足够明了：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058154.3666584" alt=""></p>
<p>Playground 中的结果如下：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058154.5087793" alt=""></p>
<p>可复制的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparing dates - Method #2</span></span><br><span class="line"><span class="keyword">if</span> date1.compare(date2) == <span class="type">NSComparisonResult</span>.<span class="type">OrderedDescending</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Date1 is Later than Date2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> date1.compare(date2) == <span class="type">NSComparisonResult</span>.<span class="type">OrderedAscending</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Date1 is Earlier than Date2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> date1.compare(date2) == <span class="type">NSComparisonResult</span>.<span class="type">OrderedSame</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Same dates"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较两个日期对象的第三种方式多少有些不同，因为这种方式引入了对 <em>time intervals</em> 的使用。实际上这种方式很简单，它做的就是获得自每个日期以来的时间间隔（每个日期和<em>现在</em>的时间间隔），然后做比较：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058154.791958" alt=""><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparing dates - Method #3</span></span><br><span class="line"><span class="keyword">if</span> date1.timeIntervalSinceReferenceDate &gt; date2.timeIntervalSinceReferenceDate &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Date1 is Later than Date2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> date1.timeIntervalSinceReferenceDate &lt;  date2.timeIntervalSinceReferenceDate &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Date1 is Earlier than Date2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Same dates"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码也可以应用到对时间的比较。下面我给你最后一个例子，而这次 <em>date1</em> 和 <em>date2</em> 对象包含了对时间的表示。我再次使用 <em>earlierDate:</em> 方法，但另外还有一个，<em>idEqualToDate:</em>，很明显，看名字就知道它是干什么的：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058155.0071487" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparing time.</span></span><br><span class="line">dateFormatter.dateFormat = <span class="string">"HH:mm:ss zzz"</span></span><br><span class="line">dateAsString = <span class="string">"14:28:16 GMT"</span></span><br><span class="line">date1 = dateFormatter.dateFromString(dateAsString)!</span><br><span class="line"> </span><br><span class="line">dateAsString = <span class="string">"19:53:12 GMT"</span></span><br><span class="line">date2 = dateFormatter.dateFromString(dateAsString)!</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> date1.earlierDate(date2) == date1 &#123;</span><br><span class="line">    <span class="keyword">if</span> date1.isEqualToDate(date2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Same time"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(date1)</span> is earlier than <span class="subst">\(date2)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(date2)</span> is earlier than <span class="subst">\(date1)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果看到上面代码中「2000-01-01」这个日期之后你感觉好奇或疑惑的话，不用担心。<em>NSDate</em> 如果在没有给定任何特定日期来做转换的情况下会默认将其添加，它不会影响到这个日期中其他的元素（例子中其他的元素是时间）。</p>
<p>好了，到这里你也会怎么对日期做比较了。</p>
<h3 id="计算出未来或过去的日期">计算出未来或过去的日期</h3><p>处理日期另一个有趣的方面就是计算出一个将来或者过去的日期。我们之前看到的那些用法在这里会变得很方便，比如 <em>NSCalendarUnit</em> 结构体，或者 <em>NSDateComponents</em> 类。实际上，我会给你展示两种不同的计算出其他日期的方式，第一种使用的就是 <em>NSCalendar</em> 类和 <em>NSCalendarUnit</em> 结构体，第二种使用的是 <em>NSDateComponents</em> 类。最后我会给出第三种方式，但是一般情况我不推荐使用（到那部分我会解释为什么）。</p>
<p>一开始我们先记一下当前日期（是我写这篇教程的日期），它会被用作我们的参考日期：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058155.1251872" alt=""></p>
<p>现在假设我们想把当前日期加上两个月零五天，实际上还是写下来比较好：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> monthsToAdd = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> daysToAdd = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>我们现在就可以看一下第一种方式了，来得到想要的新日期吧。先给代码，马上解释：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> calculatedDate = <span class="type">NSCalendar</span>.currentCalendar().dateByAddingUnit(<span class="type">NSCalendarUnit</span>.<span class="type">Month</span>, value: monthsToAdd, toDate: currentDate, options: <span class="type">NSCalendarOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">calculatedDate = <span class="type">NSCalendar</span>.currentCalendar().dateByAddingUnit(<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, value: daysToAdd, toDate: calculatedDate!, options: <span class="type">NSCalendarOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>如你所见，这里用到的方法是 <em>NSCalendar</em> 类的 <em>dateByAddingUnit:value:toDate:options:</em> 方法。这个方法的任务就是给一个现有的日期加上一个特定的 calendar unit（由第一个参数指定），并将这个加法的结果做为一个新的日期返回。我们开始想的是在当前日期的基础上同时加两个不同的 calendar unit，但很显然这不现实。所以这里问题的关键是就要连续的调用该方法，每次设置其中的一个 calendar unit，从而得到最终结果。</p>
<p>下面是每次叠加之后 playground 显示的结果：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058716.3939843" alt=""></p>
<p>上面的方式不错，但是仅限于你要加的只有 1~2 个 calendar units，否则你得连续多次调用上面那个方法才行。</p>
<p>当需要叠加更多的 units 时，第二个，也是更倾向的方式是使用 <em>NSDateComponents</em> 这个类。为了演示，我们不会再引入其他的组成元素，除上面已经定好的月和日之外。在这儿要做的事情很简单：首先初始化一个新的 <em>NSDateComponents</em> 对象，并给它设置之前定好的月和日。然后调用 <em>NSCalendar</em> 类的另一个叫做 <em>dateByAddingComponents:toDate:options:</em> 的方法，我们会立即得到一个新的 <em>NSDate</em> 对象，这个新对象即代表了最终想要的日期。</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058158.1788666" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newDateComponents = <span class="type">NSDateComponents</span>()</span><br><span class="line">newDateComponents.month = monthsToAdd</span><br><span class="line">newDateComponents.day = daysToAdd</span><br><span class="line"></span><br><span class="line">calculatedDate = <span class="type">NSCalendar</span>.currentCalendar().dateByAddingComponents(newDateComponents, toDate: currentDate, options: <span class="type">NSCalendarOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>注意到上面的两个代码段中，我都没给这两个新介绍方法的最后一个参数做任何设置。而如果你想对这个可设选项了解更多的话，就去参考<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSCalendar_Class/" target="_blank" rel="external"> <em>NSCalendar</em> 类的官方文档</a>。</p>
<p>第三种计算另一个日期方式不推荐对时间跨度大的情况使用，因为由于闰秒，闰年，夏令时等等会导致这种方式产生出错误结果。该方式的想法是给当前日期加上一个特定的时间间隔。我们会使用 <em>NSDate</em> 类的 <em>dateByAddingTimeInterval:</em> 方法来实现这个目的。下面的例子中我们算出来一个相当于是 1.5 小时的时间间隔，然后把它加到当前日期上：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hoursToAddInSeconds: <span class="type">NSTimeInterval</span> = <span class="number">90</span> * <span class="number">60</span></span><br><span class="line">calculatedDate = currentDate.dateByAddingTimeInterval(hoursToAddInSeconds)</span><br></pre></td></tr></table></figure>
<p>再强调一下，要做任何类型的日期计算的话，还是使用前两种方式更安全。但这还是取决于你，选择你更喜欢的那一种。</p>
<p>上面的三个例子都是给当前日期加上某些个组成元素。那现在用同样方式给当前日期减去几天，算出来那个过去的日期该怎么做？</p>
<p>下面的代码示范了该怎么做。首先给当前日期加上一个特定天数的<em>负</em>值，这就可以得到一个属于过去的日期了。然后把结果转换成一个有适当格式的字符串，最后的结果…很有意思：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058716.4647555" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberOfDays = -<span class="number">5684718</span></span><br><span class="line">calculatedDate = <span class="type">NSCalendar</span>.currentCalendar().dateByAddingUnit(<span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, value: numberOfDays, toDate: currentDate, options: <span class="type">NSCalendarOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line">dateFormatter.dateFormat = <span class="string">"EEEE, MMM dd, yyyy GGG"</span></span><br><span class="line">dateAsString = dateFormatter.stringFromDate(calculatedDate!)</span><br></pre></td></tr></table></figure>
<p>以上所有的小代码段示例可以完全给你讲明白怎样通过给某个参考日期加上或正或负的 calendar unit 来算出一个新的日期。自己随便扩展一下上面的代码吧，写下你自己的代码，你就会对这些技巧更加熟悉。</p>
<h3 id="计算出日期的差值">计算出日期的差值</h3><p>和标题的意思一样，这节讲的是计算出两个日期之间的差值，它是在你编程生涯中某个时间肯定要做的一个任务，显然需要做不止一次。在这（教程的最后）一部分，我会告诉你计算出两个 <em>NSDate</em> 对象之间差值的三种方式，你可以根据需要选出最适合你的那一种。</p>
<p>开始之前先定义两个 <em>NSDate</em> 对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateFormatter.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span></span><br><span class="line">dateAsString = <span class="string">"2015-10-08 14:25:37"</span></span><br><span class="line">date1 = dateFormatter.dateFromString(dateAsString)!</span><br><span class="line"> </span><br><span class="line">dateAsString = <span class="string">"2018-03-05 08:14:19"</span></span><br><span class="line">date2 = dateFormatter.dateFromString(dateAsString)!</span><br></pre></td></tr></table></figure>
<p>有了上面的日期对象，我们再来看一下如何获取日期组成元素（date components）形式的日期差值（date difference ）。我们会再次用到 <em>NSCalendar</em> 类，还有它的一个之前我们没见过的方法。最后把日期组成元素打印出来看一下结果。很明显当有了它，这个代表了日期差值的元素之后，想怎么做都取决于你了。来看下示范：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058716.5368817" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> diffDateComponents = <span class="type">NSCalendar</span>.currentCalendar().components([<span class="type">NSCalendarUnit</span>.<span class="type">Year</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Month</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Hour</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Minute</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Second</span>], fromDate: date1, toDate: date2, options: <span class="type">NSCalendarOptions</span>.<span class="keyword">init</span>(rawValue: <span class="number">0</span>))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The difference between dates is: <span class="subst">\(diffDateComponents.year)</span> years, <span class="subst">\(diffDateComponents.month)</span> months, <span class="subst">\(diffDateComponents.day)</span> days, <span class="subst">\(diffDateComponents.hour)</span> hours, <span class="subst">\(diffDateComponents.minute)</span> minutes, <span class="subst">\(diffDateComponents.second)</span> seconds"</span>)</span><br></pre></td></tr></table></figure>
<p>这种新方式就是使用 <em>components:fromDate:toDate:options:</em> 方法，同样它的第一个参数是一个 <em>NSCalendarUnit</em> 的数组。注意下如果第一个日期比第二个晚的话，返回值就会是负数。</p>
<p>在计算日期差值的另外两种方式中，我们会第一次用到 <em>NSDateComponentsFormatter</em> 类，这个类有很多方法，能自动做出差值计算，然后返回一个带有特定格式的字符串。先生成一个对象，并先指定它的一个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dateComponentsFormatter = <span class="type">NSDateComponentsFormatter</span>()</span><br><span class="line">dateComponentsFormatter.unitsStyle = <span class="type">NSDateComponentsFormatterUnitsStyle</span>.<span class="type">Full</span></span><br></pre></td></tr></table></figure>
<p><em>unitsStyle</em> 属性告诉 <em>dateComponentsFormatter</em> 描述日期差值的那个字符串的格式应该是什么样的，显示出的日期组成元素应该是怎样的样式。比如用 <em>Full</em> 这个样式，星期几、月份等等就会显示成常规的全写（full-length）单词。而如果我们用了 <em>Abbreviated</em> 样式的话，则会显示这些信息的缩写。从<a href="https://developer.apple.com/library/prerelease/ios/documentation/Foundation/Reference/NSDateComponentsFormatter_class/index.html#//apple_ref/c/tdef/NSDateComponentsFormatterUnitsStyle" target="_blank" rel="external">这里</a>你能看到关于单元样式（units style）的全说明列表。</p>
<p>回到日期差值中来，这次我们要先算出两个日期之间的时间间隔。然后这个间隔本身会作为一个参数传递给 <em>NSDateComponentFormatter</em> 类的 <em>stringFromTimeInterval:</em> 方法，结果就会以一个格式化好了的字符串形式返回。</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058159.4423432" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> interval = date2.timeIntervalSinceDate(date1)</span><br><span class="line">dateComponentsFormatter.stringFromTimeInterval(interval)</span><br></pre></td></tr></table></figure>
<p>最后，在计算日期差值的最后一个方式中，两个日期需要作为参数传递给 <em>NSDateComponentsFormatter</em> 类的 <em>stringFromDate:toDate:</em> 方法。然而用这个方法之前需要先满足一个条件：<em>allowedUnits</em> 属性必须要设置一个 calendar unit，否则该方法会返回一个 nil。所以我们就「告诉」这个方法我们想要怎样的 unit，之后就等它给我们差值结果：</p>
<p><img src="/img/articles/a-beginners-guide-to-nsdate-in-swift/12401450058716.6109412" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dateComponentsFormatter.allowedUnits = [<span class="type">NSCalendarUnit</span>.<span class="type">Year</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Month</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Day</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Hour</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Minute</span>, <span class="type">NSCalendarUnit</span>.<span class="type">Second</span>]</span><br><span class="line"><span class="keyword">let</span> autoFormattedDifference = dateComponentsFormatter.stringFromDate(date1, toDate: date2)</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>简介部分中我说过，处理 <em>NSDate</em> 对象这件事在你项目中非常常见，而且肯定无法避免。不可否认它并不是程序员最喜欢讨论的话题，所以我就写了前面的那些，在小例子中告诉你其实处理日期是很容易的。这篇教程中 <em>NSDate</em> 的方方面面，以及其他相关的类都有一个共同目标：教你小巧高效的用法，两三行代码就让你把活儿搞定。希望这篇文章能给你做个指南，尤其如果你是一个新开发者。下篇文章出来之前，好好练习吧。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：gabriel theodoropoulos，<a href="http://www.appcoda.com/nsdate/">原文链接</a>，原文日期：2015-10-18<br>译者：<a href="http://www.jianshu.com/users/97c49dfd1f9f/latest_articles">ray16897188</a>；校对：<a href="https://github.com/numbbbbb">numbbbbb</a>；定稿：<a href="https://github.com/Cee">Cee</a></p>
</blockquote>
<p>如果问我在做过的所有项目中做的最多的事情，那处理日期绝对是榜上有名（译注：本文中的「日期」是指代 NSDate 对象，同时包含「日（date）」 和「时（time）」这两个元素）。毋庸置疑，无论工作量是多是少，开发者迟早需要「玩」一下 NSDate 类，去按某种方式处理一下日期。从简单的将一个日期转换成一个字符串到对日期做计算，总会有一个不变的事实：开发者必须在 iOS 编程中学会这个知识点。这并不难掌握，而且可以为以后更重要任务节省时间。在新手看来，对日期的操作很麻烦；然而事实并非如此。你需要做的就是掌握它。</p>]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIAlertController 测试的修正]]></title>
    <link href="http://swiftggteam.github.io/2015/12/11/correction-on-testing-uialertcontroller/"/>
    <id>http://swiftggteam.github.io/2015/12/11/correction-on-testing-uialertcontroller/</id>
    <published>2015-12-10T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.990Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/correction-on-testing-uialertcontroller/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-25<br>译者：<a href="http://daizi.me" target="_blank" rel="external">小袋子</a>；校对：<a href="http://weibo.com/lfbWb" target="_blank" rel="external">lfb_CD</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>两个月前，我曾发布了一篇<a href="http://swiftandpainless.com/how-to-test-uialertcontroller-in-swift/" target="_blank" rel="external">如何测试 UIAlertController</a>的文章。一个读者发现测试没有如期地起作用：</p>
<a id="more"></a>
<blockquote>
<p><a href="https://twitter.com/dasdom" target="_blank" rel="external">@dasdom</a> 你的测试是正常的，但是在 <code>MockUIAction</code> 中的简便 <code>init</code> 方法没有被调用。你不能重写 <code>init</code> 方法，看起来像是 iOS 的bug。<br> — Larhythimx (@Larhythmix) <a href="https://twitter.com/Larhythmix/status/669456137041915905" target="_blank" rel="external">25. November 2015</a></p>
</blockquote>
<p>Larhythimx 说的完全正确。模拟程序的初始化方法从来没有调用。为什么我在写这个测试用例的时候没有发觉呢？那是因为 handler 确实被调用了，看起来就像 <code>UIAlertAction</code> 真的把 handler 作为内部变量去存储动作的 handler 闭包。这是非常脆弱的，并且 Larhythimx 在另一个 tweet 指出在他的测试程序中 handler 是 <code>nil</code>。</p>
<p>所以作为黄金通道（即编写不需要改变实现的测试）走不通，那就退而求其次用别的方法。</p>
<p>首先，我们在 <code>UIAlertAction</code> 中添加一个类方法去创建 action 。在 <code>ViewController.swift</code> 中增加如下扩展：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIAlertAction</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeActionWithTitle</span>(<span class="title">title</span>: <span class="title">String</span>?, <span class="title">style</span>: <span class="title">UIAlertActionStyle</span>, <span class="title">handler</span>: ((<span class="title">UIAlertAction</span>) -&gt; <span class="title">Void</span>)?) -&gt; <span class="title">UIAlertAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">UIAlertAction</span>(title: title, style: style, handler: handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>MockAlertAction</code> 中增加这个重写方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">makeActionWithTitle</span>(<span class="title">title</span>: <span class="title">String</span>?, <span class="title">style</span>: <span class="title">UIAlertActionStyle</span>, <span class="title">handler</span>: ((<span class="title">UIAlertAction</span>) -&gt; <span class="title">Void</span>)?) -&gt; <span class="title">MockAlertAction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">MockAlertAction</span>(title: title, style: style, handler: handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现代码中，我们现在可以使用类方法去创建 alert 动作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> okAction = <span class="type">Action</span>.makeActionWithTitle(<span class="string">"OK"</span>, style: .<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.actionString = <span class="string">"OK"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cancelAction = <span class="type">Action</span>.makeActionWithTitle(<span class="string">"Cancel"</span>, style: .<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.actionString = <span class="string">"Cancel"</span></span><br><span class="line">&#125;</span><br><span class="line">alertViewController.addAction(cancelAction)</span><br></pre></td></tr></table></figure>
<p>为了确保我们的测试用例正常，如我们预期地工作，将 <code>MockAlertAction</code> 的 <code>handler</code> 属性重命名为 <code>mockHandler</code>： </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mockHandler: <span class="type">Handler</span>?</span><br></pre></td></tr></table></figure>
<p>此外，我们为动作的模拟标题添加测试。取消动作的测试应该像这样： </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">testAlert_FirstActionStoresCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">  sut.<span class="type">Action</span> = <span class="type">MockAlertAction</span>.<span class="keyword">self</span></span><br><span class="line">  </span><br><span class="line">  sut.showAlert(<span class="type">UIButton</span>())</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> alertController = sut.presentedViewController <span class="keyword">as</span>! <span class="type">UIAlertController</span></span><br><span class="line">  <span class="keyword">let</span> action = alertController.actions.first <span class="keyword">as</span>! <span class="type">MockAlertAction</span></span><br><span class="line">  action.mockHandler!(action)</span><br><span class="line">  </span><br><span class="line">  <span class="type">XCTAssertEqual</span>(sut.actionString, <span class="string">"Cancel"</span>)</span><br><span class="line">  <span class="type">XCTAssertEqual</span>(action.mockTitle, <span class="string">"Cancel"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试在此前的版本将会失败，因为初始化方法没有被调用，因此模拟标题也没有得到设置。</p>
<p>你可以在 <a href="https://github.com/dasdom/TestingAlertExperiment" target="_blank" rel="external">github</a> 上找到修正的版本。</p>
<p>再次感谢 Larhythimx 的推特！</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：dom，<a href="http://swiftandpainless.com/correction-on-testing-uialertcontroller/">原文链接</a>，原文日期：2015-11-25<br>译者：<a href="http://daizi.me">小袋子</a>；校对：<a href="http://weibo.com/lfbWb">lfb_CD</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>两个月前，我曾发布了一篇<a href="http://swiftandpainless.com/how-to-test-uialertcontroller-in-swift/">如何测试 UIAlertController</a>的文章。一个读者发现测试没有如期地起作用：</p>]]>
    
    </summary>
    
      <category term="Swift and Painless" scheme="http://swiftggteam.github.io/tags/Swift-and-Painless/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[化零为整：Reduce 详解]]></title>
    <link href="http://swiftggteam.github.io/2015/12/10/reduce-all-the-things/"/>
    <id>http://swiftggteam.github.io/2015/12/10/reduce-all-the-things/</id>
    <published>2015-12-09T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.990Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/11/30/reduce-all-the-things/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-30<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles" target="_blank" rel="external">pmst</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即使早在 Swift 正式发布之前，iOS / Cocoa 开发者都可以使用诸如 ObjectiveSugar 或者 ReactiveCocoa 第三方库，实现类似 <code>map</code>、<code>flatMap</code> 或 <code>filter</code> 等函数式编程的构建。而在 Swift 中，这些家伙（<code>map</code> 等几个函数）已经入驻成为「头等公民」了。比起标准的 <code>for</code> 循环，使用函数式编程有很多优势。它们通常能够更好地表达你的意图，减少代码的行数，以及使用链式结构构建复杂的逻辑，更显清爽。</p>
<a id="more"></a>
<p>本文中，我将介绍附加于 Swift 中的一个非常酷的函数：「Reduce」。相对于 <code>map</code> / <code>filter</code> 函数，<code>reduce</code> 有时不失为一个更好的解决方案。</p>
<h3 id="一个简单的问题">一个简单的问题</h3><p>思考这么一个问题：你从 JSON 中获取到一个 persons 列表，意图计算所有来自 California 的居民的平均年龄。需要解析的数据如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> persons: [[<span class="type">String</span>: <span class="type">AnyObject</span>]] = [[<span class="string">"name"</span>: <span class="string">"Carl Saxon"</span>, <span class="string">"city"</span>: <span class="string">"New York, NY"</span>, <span class="string">"age"</span>: <span class="number">44</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Travis Downing"</span>, <span class="string">"city"</span>: <span class="string">"El Segundo, CA"</span>, <span class="string">"age"</span>: <span class="number">34</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Liz Parker"</span>, <span class="string">"city"</span>: <span class="string">"San Francisco, CA"</span>, <span class="string">"age"</span>: <span class="number">32</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"John Newden"</span>, <span class="string">"city"</span>: <span class="string">"New Jersey, NY"</span>, <span class="string">"age"</span>: <span class="number">21</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Hector Simons"</span>, <span class="string">"city"</span>: <span class="string">"San Diego, CA"</span>, <span class="string">"age"</span>: <span class="number">37</span>],</span><br><span class="line"> [<span class="string">"name"</span>: <span class="string">"Brian Neo"</span>, <span class="string">"age"</span>: <span class="number">27</span>]] <span class="comment">//注意这家伙没有 city 键值</span></span><br></pre></td></tr></table></figure>
<p>注意最后一个记录，它遗漏了问题中 person 的居住地 city 。对于这些情况，默默忽略即可…</p>
<p>本例中，我们期望的结果是那三位来自 California 的居民。让我们尝试在 Swift 中使用 <code>flatMap</code> 和 <code>filter</code> 来实现这个任务。使用 <code>flatMap</code> 函数替代 <code>map</code> 函数的原因在于前者能够忽略可选值为 nil 的情况。例如 <code>flatMap([0,nil,1,2,nil])</code> 的结果是 <code>[0,1,2]</code>。处理那些没有 city 属性的情况这会非常有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">infoFromState</span><span class="params">(state state: String, persons: [[String: AnyObject]])</span></span> </span><br><span class="line">     -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	   <span class="comment">// 先进行 flatMap 后进行 filter 筛选</span></span><br><span class="line">     <span class="comment">// $0["city"] 是一个可选值，对于那些没有 city 属性的项返回 nil</span></span><br><span class="line">     <span class="comment">// componentsSeparatedByString 处理键值，例如 "New York, NY" </span></span><br><span class="line">     <span class="comment">// 最后返回的 ["New York","NY"]，last 取到最后的 NY</span></span><br><span class="line">    <span class="keyword">return</span> persons.flatMap( &#123; $<span class="number">0</span>[<span class="string">"city"</span>]?.componentsSeparatedByString(<span class="string">", "</span>).last &#125;)</span><br><span class="line">	   .<span class="built_in">filter</span>(&#123;$<span class="number">0</span> == state&#125;)</span><br><span class="line">	   .<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">infoFromState(state: <span class="string">"CA"</span>, persons: persons)</span><br><span class="line"><span class="comment">//#+RESULTS:</span></span><br><span class="line"><span class="comment">//: 3</span></span><br></pre></td></tr></table></figure>
<p>这非常简单。</p>
<p>不过，现在来思考另外一个难题：你想要获悉居住在 California 的人口数，接着计算他们的平均年龄。如果我们想要在上面函数的基础上尝试做修改，立马会发现难度不小。解决方法倒是有几种，不过大都看起来不适用函数式结构解决方案。倒是通过循环的方式能简单的解决这个问题。</p>
<p>这时候我们要琢磨为啥不适用了，原因很简单：数据的形式（Shape）改变了。而 <code>map</code>、<code>flatMap</code> 和 <code>filter</code> 函数能够始终保持数据形式的相似性。数组传入，数组返回。当然数组的元素个数和内容可以改变，不过始终是数组形式（Array-shape）。但是，上面所描述的问题要求我们最后转换成的结果是个结构体（Struct），或者说是以元组（Tuple）的形式包含<strong>一个整型平均值（平均年龄）</strong>和<strong>一个整型总和（人口数）</strong>。</p>
<p>对于这种类型的问题，我们可以使用 <code>reduce</code> 来救场。</p>
<h3 id="Reduce">Reduce</h3><p>Reduce 是 <code>map</code>、<code>flatMap</code> 或 <code>filter</code> 的一种扩展的形式（译者注：后三个函数能干嘛，reduce 就能用另外一种方式实现）。<strong>Reduce</strong> 的基础思想是将一个序列转换为一个不同类型的数据，期间通过一个<strong>累加器（Accumulator）</strong>来持续记录递增状态。为了实现这个方法，我们会向 reduce 方法中传入一个用于处理序列中每个元素的<strong>结合（Combinator）</strong>闭包 / 函数 / 方法。这听起来有点复杂，不过通过几个例子练手，你就会发现这相当简单。</p>
<p>它是 <code>SequenceType</code> 中的一个方法，看起来是这样的（简化版本）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">reduce</span><span class="generics">&lt;T&gt;</span><span class="params">(initial: T, combine: <span class="params">(T, <span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span></span><br></pre></td></tr></table></figure>
<p>此刻，我们拥有一个初始值（Initial value）以及一个闭包（返回值类型和初始值类型一致）。函数最后的返回值同样和初始值类型一致，为 <code>T</code>。</p>
<p>假设我们现在要实现一个 reduce 操作 — 对一个整数列表值做累加运算，方案如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">combinator</span><span class="params">(accumulator: Int, current: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> accumulator + current</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: combinator)</span><br><span class="line"><span class="comment">// 执行步骤如下</span></span><br><span class="line">combinator(<span class="number">0</span>, <span class="number">1</span>) &#123; <span class="keyword">return</span> <span class="number">0</span> + <span class="number">1</span> &#125; = <span class="number">1</span></span><br><span class="line">combinator(<span class="number">1</span>, <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> &#125; = <span class="number">3</span></span><br><span class="line">combinator(<span class="number">3</span>, <span class="number">3</span>) &#123; <span class="keyword">return</span> <span class="number">3</span> + <span class="number">3</span> &#125; = <span class="number">6</span></span><br><span class="line">= <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p><code>[1, 2, 3]</code> 中的每个元素都将调用一次<strong>结合（Combinator）</strong>函数进行处理。同时我们使用<strong>累加器（Accumulator）</strong>变量实时记录递增状态（递增并非是指加法），这里是一个整型值。</p>
<p>接下来，我们重新实现那些函数式编程的「伙伴」（自己来写 map、flatMap 和 filter 函数）。简便起见，所有这些方法都是对 <code>Int</code> 或 <code>Optional&lt;Int&gt;</code> 进行操作的；换言之，我们此刻不考虑泛型。另外牢记下面的实现只是为了展示 <code>reduce</code> 的实现过程。原生的 Swift 实现相比较下面 reduce 的版本，速度要快很多<a href="#1">1</a>。不过，Reduce 能在不同的问题中表现得很好，之后会进一步地详述。</p>
<h3 id="Map">Map</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新定义一个 map 函数</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; (<span class="keyword">var</span> acc: [<span class="type">Int</span>], obj: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line">       acc.append(transform(obj))</span><br><span class="line">       <span class="keyword">return</span> acc</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rmap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], transform: &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>这个例子能够很好地帮助你理解 <code>reduce</code> 的基础知识。</p>
<ul>
<li>首先，elements 序列调用 reduce 方法：<code>elements.reduce...</code>。</li>
<li>然后，我们传入初始值给累加器（Accumulator），即一个 Int 类型空数组（<code>[Int]()</code>）。</li>
<li>接着，我们传入 <code>combinator</code> 闭包，它接收两个参数：第一个参数为 accumulator，即 <code>acc: [Int]</code>；第二个参数为从序列中取得的当前对象 <code>obj: Int</code>（译者注：对序列进行遍历，每次取到其中的一个对象 obj）。</li>
<li><code>combinator</code> 闭包体中的实现代码非常简单。我们对 obj 做变换处理，然后添加到累加器 accumulator 中。最后返回 accumulator 对象。</li>
</ul>
<p>相比较调用 <code>map</code> 方法，这种实现代码看起来有点冗余。的确如此！但是，上面这个版本相当详细地解释了 <code>reduce</code> 方法是怎么工作的。我们可以对此进行简化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">	<span class="comment">// $0 表示第一个传入参数，$1 表示第二个传入参数，依次类推...</span></span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123;$<span class="number">0</span> + [transform($<span class="number">1</span>)]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rmap([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], transform: &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>依旧能够正常运行。这个版本都有哪些不同呢？实际上，我们使用了 Swift 中的小技巧，<code>+</code> 运算符能够对两个序列进行加法操作。因此 <code>[0, 1, 2] + [transform(4)]</code> 表达式将左序列和右序列进行相加，其中右序列由转换后的元素构成。</p>
<p>这里有个地方需要引起注意：<code>[0, 1, 2] + [4]</code> 执行速度要慢于 <code>[0, 1, 2].append(4)</code>。倘若你正在处理庞大的列表，应取代集合 + 集合的方式，转而使用一个可变的 accumulator 变量进行递增：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; (<span class="keyword">var</span> ac: [<span class="type">Int</span>], b: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span> </span><br><span class="line">	<span class="comment">// 作者提倡使用这种，因为执行速度更快</span></span><br><span class="line">	ac.append(transform(b))</span><br><span class="line">	<span class="keyword">return</span> ac</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了进一步加深对 <code>reduce</code> 的理解，我们将继续重新实现 <code>flatMap</code> 和 <code>filter</code> 方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rflatMap</span><span class="params">(elements: [Int], transform: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Int</span>?) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), </span><br><span class="line">       combine: &#123; <span class="keyword">guard</span> <span class="keyword">let</span> m = transform($<span class="number">1</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> $<span class="number">0</span> &#125; </span><br><span class="line">		  <span class="keyword">return</span> $<span class="number">0</span> + [m]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rflatMap([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], transform: &#123; <span class="keyword">guard</span> $<span class="number">0</span> != <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;; <span class="keyword">return</span> $<span class="number">0</span> * <span class="number">2</span>&#125;))</span><br><span class="line"><span class="comment">// [2, 8]</span></span><br></pre></td></tr></table></figure>
<p>这里 rflatMap 和 rmap 主要差异在于，前者增加了一个 <code>guard</code> 表达式确保可选类型始终有值（换言之，摒弃那些 nil 的情况）。</p>
<h3 id="Filter">Filter</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rFilter</span><span class="params">(elements: [Int], <span class="built_in">filter</span>: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> elements.<span class="built_in">reduce</span>([<span class="type">Int</span>](), </span><br><span class="line">       combine: &#123; <span class="keyword">guard</span> <span class="built_in">filter</span>($<span class="number">1</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> $<span class="number">0</span> &#125; </span><br><span class="line">		  <span class="keyword">return</span> $<span class="number">0</span> + [$<span class="number">1</span>]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(rFilter([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>], <span class="built_in">filter</span>: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;))</span><br><span class="line"><span class="comment">// [4, 6]</span></span><br></pre></td></tr></table></figure>
<p>依旧难度不大。我们再次使用 guard 表达式确保满足筛选条件。</p>
<p>到目前为止，<code>reduce</code> 方法看起来更像是 <code>map</code> 或 <code>filter</code> 的复杂版本，除此之外然并卵。不过，所结合的内容不需要是一个数组，它可以是其他任何类型。这使得我们依靠一种简单的方式，就可以轻松地实现各种 reduction 操作。</p>
<h3 id="Reduce_范例">Reduce 范例</h3><p>首先介绍我最喜欢的数组元素求和范例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值 initial 为 0，每次遍历数组元素，执行 + 操作</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>仅传入 <code>+</code> 作为一个 <code>combinator</code> 函数是有效的，它仅仅是对 <code>lhs（Left-hand side，等式左侧）</code> 和 <code>rhs（Right-hand side，等式右侧）</code> 做加法处理，最后返回结果值，这完全满足 <code>reduce</code> 函数的要求。</p>
<p>另外一个范例：通过一组数字计算他们的乘积：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值 initial 为 1，每次遍历数组元素，执行 * 操作</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">1</span>, combine: *)</span><br><span class="line"><span class="comment">// 24</span></span><br></pre></td></tr></table></figure>
<p>甚至我们可以反转数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $0 指累加器（accumulator），$1 指遍历数组得到的一个元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; [$<span class="number">1</span>] + $<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 5, 4, 3, 2, 1</span></span><br></pre></td></tr></table></figure>
<p>最后，来点有难度的任务。我们想要基于某个标准对列表做划分（Partition）处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为元组定义个别名，此外 Acc 也是闭包传入的 accumulator 的类型</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Acc</span> = (l: [<span class="type">Int</span>], r: [<span class="type">Int</span>])</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(lst: [Int], criteria: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Acc</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> lst.<span class="built_in">reduce</span>((l: [<span class="type">Int</span>](), r: [<span class="type">Int</span>]()), combine: &#123; (ac: <span class="type">Acc</span>, o: <span class="type">Int</span>) -&gt; <span class="type">Acc</span> <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">if</span> criteria(o) &#123;</span><br><span class="line">	<span class="keyword">return</span> (l: ac.l + [o], r: ac.r)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (r: ac.r + [o], l: ac.l)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">partition</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], criteria: &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">//: ([2, 4, 6, 8], [1, 3, 5, 7, 9])</span></span><br></pre></td></tr></table></figure>
<p>上面实现中最有意思的莫过于我们使用 <code>tuple</code> 作为 accumulator。你会渐渐发现，一旦你尝试将 <code>reduce</code> 进入到日常工作流中，<code>tuple</code> 是一个不错的选择，它能够将数据与 reduce 操作快速挂钩起来。</p>
<h3 id="执行效率对比：Reduce_vs-_链式结构">执行效率对比：Reduce vs. 链式结构</h3><p><code>reduce</code> 除了较强的灵活性之外，还具有另一个优势：通常情况下，<code>map</code> 和 <code>filter</code> 所组成的链式结构会引入性能上的问题，因为它们需要多次遍历你的集合才能最终得到结果值，这种操作往往伴随着性能损失，比如以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">map</span>(&#123; $<span class="number">0</span> + <span class="number">3</span>&#125;).<span class="built_in">filter</span>(&#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span>&#125;).<span class="built_in">reduce</span>(<span class="number">0</span>, combine: +)</span><br></pre></td></tr></table></figure>
<p>除了毫无意义之外，它还浪费了 CPU 周期。初始序列（即 [0, 1, 2, 3, 4]）被重复访问了三次之多。首先是 map，接着 filter，最后对数组内容求和。其实，所有这一切操作我们能够使用 <code>reduce</code> 完全替换实现，极大提高执行效率：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里只需要遍历 1 次序列足矣</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="number">0</span>, combine: &#123; (ac: <span class="type">Int</span>, r: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span> </span><br><span class="line">   <span class="keyword">if</span> (r + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ac + r + <span class="number">3</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> ac</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这里给出一个快速的基准运行测试，使用以上两个版本以及 for-loop 方式对一个容量为 100000 的列表做处理操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for-loop 版本</span></span><br><span class="line"><span class="keyword">var</span> ux = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="type">Array</span>(<span class="number">0</span>...<span class="number">100000</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">3</span>) % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">	ux += (i + <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xiol9.com1.z0.glb.clouddn.com/pic测试结果.png" alt="测试结果"></p>
<p>正如你所看见的，<code>reduce</code> 版本的执行效率和 <code>for-loop</code> 操作非常相近，且是链式操作的一半时间。</p>
<p>不过，在某些情况中，链式操作是优于 <code>reduce</code> 的。思考如下范例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">0</span>...<span class="number">100000</span>).<span class="built_in">map</span>(&#123; $<span class="number">0</span> + <span class="number">3</span>&#125;).<span class="built_in">reverse</span>().<span class="keyword">prefix</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 0.027 Seconds</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">0</span>...<span class="number">100000</span>).<span class="built_in">reduce</span>([], combine: &#123; (<span class="keyword">var</span> ac: [<span class="type">Int</span>], r: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line">    ac.insert(r + <span class="number">3</span>, atIndex: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ac</span><br><span class="line">&#125;).<span class="keyword">prefix</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 2.927 Seconds</span></span><br></pre></td></tr></table></figure>
<p>这里，注意到使用链式操作花费 0.027s，这与 reduce 操作的 2.927s 形成了鲜明的反差，这究竟是怎么回事呢？<a href="#2">2</a></p>
<p>Reddit 网站的搜索结果指出，从 reduce 的语义上来说，传入闭包的参数（如果可变的话，即 mutated），会对底层序列的每个元素都产生一份 copy 。在我们的案例中，这意味着 <strong>accumulator</strong> 参数 <code>ac</code> 将为 0…100000 范围内的每个元素都执行一次复制操作。有关对此更好、更详细的解释请看这篇 <a href="http://airspeedvelocity.net/2015/08/03/arrays-linked-lists-and-performance/" target="_blank" rel="external">Airspeedvelocity</a> 博客文章。</p>
<p>因此，当我们试图使用 <code>reduce</code> 来替换掉一组操作时，请时刻保持清醒，问问自己：reduction 在问题中的情形下是否确实是最合适的方式。</p>
<p>现在，可以回到我们的初始问题：计算人口总数和平均年龄。请试着用 <code>reduce</code> 来解决吧。</p>
<h3 id="再一次尝试来写_infoFromState_函数">再一次尝试来写 infoFromState 函数</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">infoFromState</span><span class="params">(state state: String, persons: [[String: AnyObject]])</span></span> </span><br><span class="line">      -&gt; (<span class="built_in">count</span>: <span class="type">Int</span>, age: <span class="type">Float</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在函数内定义别名让函数更加简洁</span></span><br><span class="line">      <span class="keyword">typealias</span> <span class="type">Acc</span> = (<span class="built_in">count</span>: <span class="type">Int</span>, age: <span class="type">Float</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// reduce 结果暂存为临时的变量</span></span><br><span class="line">      <span class="keyword">let</span> u = persons.<span class="built_in">reduce</span>((<span class="built_in">count</span>: <span class="number">0</span>, age: <span class="number">0.0</span>)) &#123;</span><br><span class="line">	  (ac: <span class="type">Acc</span>, p) -&gt; <span class="type">Acc</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 获取地区和年龄</span></span><br><span class="line">	  <span class="keyword">guard</span> <span class="keyword">let</span> personState = (p[<span class="string">"city"</span>] <span class="keyword">as</span>? <span class="type">String</span>)?.componentsSeparatedByString(<span class="string">", "</span>).last,</span><br><span class="line">		personAge = p[<span class="string">"age"</span>] <span class="keyword">as</span>? <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 确保选出来的是来自正确的洲</span></span><br><span class="line">	    <span class="keyword">where</span> personState == state</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 如果缺失年龄或者地区，又或者上者比较结果不等，返回</span></span><br><span class="line">	    <span class="keyword">else</span> &#123; <span class="keyword">return</span> ac &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 最终累加计算人数和年龄</span></span><br><span class="line">	  <span class="keyword">return</span> (<span class="built_in">count</span>: ac.<span class="built_in">count</span> + <span class="number">1</span>, age: ac.age + <span class="type">Float</span>(personAge))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们的结果就是上面的人数和除以人数后的平均年龄</span></span><br><span class="line">  <span class="keyword">return</span> (age: u.age / <span class="type">Float</span>(u.<span class="built_in">count</span>), <span class="built_in">count</span>: u.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(infoFromState(state: <span class="string">"CA"</span>, persons: persons))</span><br><span class="line"><span class="comment">// prints: (count: 3, age: 34.3333)</span></span><br></pre></td></tr></table></figure>
<p>和早前的范例一样，我们再次使用了 <code>tuple</code> 作为 accumulator 记录状态值。除此之外，代码读起来简明易懂。</p>
<p>同时，我们在函数体中定义了一个别名 <strong>Acc</strong>：<code>typealias Acc = (count: Int, age: Float)</code>，起到了简化类型注释的作用。</p>
<h3 id="总结">总结</h3><p>本文是对 <code>reduce</code> 方法的一个简短概述。倘若你不想将过多函数式方法通过链式结构串联起来调用，<strong>亦或</strong>是数据的输出形式与传入数据的形式不一致时，reduce 就相当有用了。最后，我将向你展示通过使用 reduce 的各种范例来结束本文，希望能为你带来些许灵感。</p>
<h3 id="更多范例">更多范例</h3><p>以下范例展示了 <code>reduce</code> 的其他使用案例。请记住例子只作为展示教学使用，即它们更多地强调 reduce 的使用方式，而非为你的代码库提供通用的解决方法。大多数范例都可以通过其他更好、更快的方式来编写（即通过 extension 或 generics）。并且这些实现方式已经在许多 Swift 库中都有实现，诸如 <a href="https://github.com/oisdk/SwiftSequence" target="_blank" rel="external">SwiftSequence</a> 以及 <a href="https://github.com/ankurp/Dollar.swift" target="_blank" rel="external">Dollar.swift</a></p>
<h3 id="Minimum">Minimum</h3><p>返回列表中的最小项。显然，<code>[1, 5, 2, 9, 4].minElement()</code> 方法更胜一筹。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始值为 Int.max，传入闭包为 min：求两个数的最小值</span></span><br><span class="line"><span class="comment">// min 闭包传入两个参数：1. 初始值 2. 遍历列表时的当前元素</span></span><br><span class="line"><span class="comment">// 倘若当前元素小于初始值，初始值就会替换成当前元素</span></span><br><span class="line"><span class="comment">// 示意写法： initial = min(initial, elem)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>].<span class="built_in">reduce</span>(<span class="type">Int</span>.<span class="built_in">max</span>, combine: <span class="built_in">min</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Unique">Unique</h3><p>剔除列表中重复的元素。当然，最好的解决方式是使用<code>集合（Set）</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">7</span>].<span class="built_in">reduce</span>([], combine: &#123; (a: [<span class="type">Int</span>], b: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line"><span class="keyword">if</span> a.<span class="built_in">contains</span>(b) &#123;</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + [b]</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// prints: 1, 2, 5, 7</span></span><br></pre></td></tr></table></figure>
<h3 id="Group_By">Group By</h3><p>遍历整个列表，通过一个鉴别函数对列表中元素进行分组，将分组后的列表作为结果值返回。问题中的鉴别函数返回值类型需要遵循 <code>Hashable</code> 协议，这样我们才能拥有不同的键值。此外保留元素的排序，而组内元素排序则不一定被保留下来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">groupby</span><span class="generics">&lt;T, H: Hashable&gt;</span><span class="params">(items: [T], f: <span class="params">(T)</span></span></span> -&gt; <span class="type">H</span>) -&gt; [<span class="type">H</span>: [<span class="type">T</span>]] &#123;</span><br><span class="line">   <span class="keyword">return</span> items.<span class="built_in">reduce</span>([:], combine: &#123; (<span class="keyword">var</span> ac: [<span class="type">H</span>: [<span class="type">T</span>]], o: <span class="type">T</span>) -&gt; [<span class="type">H</span>: [<span class="type">T</span>]] <span class="keyword">in</span> </span><br><span class="line">	   <span class="comment">// o 为遍历序列的当前元素</span></span><br><span class="line">       <span class="keyword">let</span> h = f(o) <span class="comment">// 通过 f 函数得到 o 对应的键值</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">var</span> <span class="built_in">c</span> = ac[h] &#123; <span class="comment">// 说明 o 对应的键值已经存在，只需要更新键值对应的数组元素即可</span></span><br><span class="line">	   <span class="built_in">c</span>.append(o)</span><br><span class="line">	   ac.updateValue(<span class="built_in">c</span>, forKey: h)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明 o 对应的键值不存在，需要为字典新增一个键值，对应值为 [o]</span></span><br><span class="line">	   ac.updateValue([o], forKey: h)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ac</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(groupby([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], f: &#123; $<span class="number">0</span> % <span class="number">3</span> &#125;))</span><br><span class="line"><span class="comment">// prints: [2: [2, 5, 8, 11], 0: [3, 6, 9, 12], 1: [1, 4, 7, 10]]</span></span><br><span class="line"><span class="built_in">print</span>(groupby([<span class="string">"Carl"</span>, <span class="string">"Cozy"</span>, <span class="string">"Bethlehem"</span>, <span class="string">"Belem"</span>, <span class="string">"Brand"</span>, <span class="string">"Zara"</span>], f: &#123; $<span class="number">0</span>.characters.first! &#125;))</span><br><span class="line"><span class="comment">// prints: ["C" : ["Carl" , "Cozy"] , "B" : ["Bethlehem" , "Belem" , "Brand"] , "Z" : ["Zara"]]</span></span><br></pre></td></tr></table></figure>
<h3 id="Interpose">Interpose</h3><p>函数给定一个 <code>items</code> 数组，每隔 <code>count</code> 个元素插入 <code>element</code> 元素，返回结果值。下面的实现确保了 element 仅在中间插入，而不会添加到数组尾部。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">interpose</span><span class="generics">&lt;T&gt;</span><span class="params">(items: [T], element: T, <span class="built_in">count</span>: Int = <span class="number">1</span>)</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">   <span class="comment">// cur 为当前遍历元素的索引值 cnt 为计数器，当值等于 count 时又重新置 1</span></span><br><span class="line">   <span class="keyword">typealias</span> <span class="type">Acc</span> = (ac: [<span class="type">T</span>], cur: <span class="type">Int</span>, cnt: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">return</span> items.<span class="built_in">reduce</span>((ac: [], cur: <span class="number">0</span>, cnt: <span class="number">1</span>), combine: &#123; (a: <span class="type">Acc</span>, o: <span class="type">T</span>) -&gt; <span class="type">Acc</span> <span class="keyword">in</span> </span><br><span class="line">       <span class="keyword">switch</span> a &#123;</span><br><span class="line">	  <span class="comment">// 此时遍历的当前元素为序列中的最后一个元素</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="keyword">let</span> (ac, cur, <span class="number">_</span>) <span class="keyword">where</span> (cur+<span class="number">1</span>) == items.<span class="built_in">count</span>: <span class="keyword">return</span> (ac + [o], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	  <span class="comment">// 满足插入条件</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="keyword">let</span> (ac, cur, <span class="built_in">c</span>) <span class="keyword">where</span> <span class="built_in">c</span> == <span class="built_in">count</span>:</span><br><span class="line">	     <span class="keyword">return</span> (ac + [o, element], cur + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">	  <span class="comment">// 执行下一步</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="keyword">let</span> (ac, cur, <span class="built_in">c</span>):</span><br><span class="line">	     <span class="keyword">return</span> (ac + [o], cur + <span class="number">1</span>, <span class="built_in">c</span> + <span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).ac</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(interpose([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], element: <span class="number">9</span>))</span><br><span class="line"><span class="comment">// : [1, 9, 2, 9, 3, 9, 4, 9, 5]</span></span><br><span class="line"><span class="built_in">print</span>(interpose([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], element: <span class="number">9</span>, <span class="built_in">count</span>: <span class="number">2</span>))</span><br><span class="line"><span class="comment">// : [1, 2, 9, 3, 4, 9, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="Interdig">Interdig</h3><p>该函数允许你有选择从两个序列中挑选元素合并成为一个新序列返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">interdig</span><span class="generics">&lt;T&gt;</span><span class="params">(list1: [T], list2: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">   <span class="comment">// Zip2Sequence 返回 [(list1, list2)] 是一个数组，类型为元组</span></span><br><span class="line">   <span class="comment">// 也就解释了为什么 combinator 闭包的类型是 (ac: [T], o: (T, T)) -&gt; [T]</span></span><br><span class="line">   <span class="keyword">return</span> <span class="type">Zip2Sequence</span>(list1, list2).<span class="built_in">reduce</span>([], combine: &#123; (ac: [<span class="type">T</span>], o: (<span class="type">T</span>, <span class="type">T</span>)) -&gt; [<span class="type">T</span>] <span class="keyword">in</span> </span><br><span class="line">	<span class="keyword">return</span> ac + [o.<span class="number">0</span>, o.<span class="number">1</span>]</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(interdig([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], list2: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]))</span><br><span class="line"><span class="comment">// : [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h3 id="Chunk">Chunk</h3><p>该函数返回原数组分解成长度为 <code>n</code> 后的多个数组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chunk</span><span class="generics">&lt;T&gt;</span><span class="params">(list: [T], length: Int)</span></span> -&gt; [[<span class="type">T</span>]] &#123;</span><br><span class="line">   <span class="keyword">typealias</span> <span class="type">Acc</span> = (stack: [[<span class="type">T</span>]], cur: [<span class="type">T</span>], cnt: <span class="type">Int</span>)</span><br><span class="line">   <span class="keyword">let</span> l = list.<span class="built_in">reduce</span>((stack: [], cur: [], cnt: <span class="number">0</span>), combine: &#123; (ac: <span class="type">Acc</span>, o: <span class="type">T</span>) -&gt; <span class="type">Acc</span> <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">if</span> ac.cnt == length &#123;</span><br><span class="line">	  <span class="keyword">return</span> (stack: ac.stack + [ac.cur], cur: [o], cnt: <span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="keyword">return</span> (stack: ac.stack, cur: ac.cur + [o], cnt: ac.cnt + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> l.stack + [l.cur]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(chunk([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], length: <span class="number">2</span>))</span><br><span class="line"><span class="comment">// : [[1, 2], [3, 4], [5, 6], [7]]</span></span><br></pre></td></tr></table></figure>
<p>函数中使用一个更为复杂的 <code>accumulator</code>，包含了 stack、current list 以及 count 。</p>
<p>译者注：有关 Reduce 底层实现，请看<a href="http://www.jianshu.com/p/06c90c0470b2" target="_blank" rel="external">这篇文章</a>。</p>
<p>2015/12/01 改动：</p>
<ol>
<li>修复 <code>rFlatMap</code> 类型签名</li>
<li>为代码范例新增注解</li>
<li>修复了变量属性为 lazy 时执行效率不一致的问题</li>
</ol>
<hr>
<p><a name="1">1、这么做的原因来看<a href="http://airspeedvelocity.net/2015/08/03/arrays-linked-lists-and-performance/" target="_blank" rel="external">这篇博文</a>。<br><a name="2">2、这篇文章的早期版本中，我错误地认为 Swift 的懒惰特性是造成这种差异的罪魁祸首。<a href="https://www.reddit.com/r/swift/comments/3uv1hy/reduce_all_the_things_alternatives_to_mapfilter/" target="_blank" rel="external">感谢 Reddit 的这个讨论指出了我的错误</a>。</a></a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Benedikt Terhechte，<a href="http://appventure.me/2015/11/30/reduce-all-the-things/">原文链接</a>，原文日期：2015-11-30<br>译者：<a href="http://www.jianshu.com/users/596f2ba91ce9/latest_articles">pmst</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>即使早在 Swift 正式发布之前，iOS / Cocoa 开发者都可以使用诸如 ObjectiveSugar 或者 ReactiveCocoa 第三方库，实现类似 <code>map</code>、<code>flatMap</code> 或 <code>filter</code> 等函数式编程的构建。而在 Swift 中，这些家伙（<code>map</code> 等几个函数）已经入驻成为「头等公民」了。比起标准的 <code>for</code> 循环，使用函数式编程有很多优势。它们通常能够更好地表达你的意图，减少代码的行数，以及使用链式结构构建复杂的逻辑，更显清爽。</p>]]>
    
    </summary>
    
      <category term="Benedikt Terhechte" scheme="http://swiftggteam.github.io/tags/Benedikt-Terhechte/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 Realm 和 Swift 创建 ToDo 应用]]></title>
    <link href="http://swiftggteam.github.io/2015/12/08/building-a-todo-app-using-realm-and-swift/"/>
    <id>http://swiftggteam.github.io/2015/12/08/building-a-todo-app-using-realm-and-swift/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.990Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Hossam Ghareeb，<a href="http://www.appcoda.com/realm-database-swift/" target="_blank" rel="external">原文链接</a>，原文日期：2015-10-28<br>译者：<a href="http://www.futantan.com" target="_blank" rel="external">Prayer</a>；校对：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>智能手机的快速发展的同时，涌现出了很多对开发者友好的开发工具。这些工具不仅使得开发变得更加简单和容易，同时也保证了性能和产品质量。如今想要在 App Store 中占据一席之地，并非易事。而且想要使得应用易于扩展就更加困难了。当你成功获得百万量级的用户时，应用中的每一个细节都不能放过，并且需要在很短的时间完成对细节的打磨。所以和数据库打交道，是很多开发者都会面临的一个问题。<a id="more"></a>相信我们每个人都会因为数据库引起的各种问题而头疼不已，对于数据库，我想如今我们只有两种选择：<a href="http://www.appcoda.com/sqlite-database-ios-app-tutorial/" target="_blank" rel="external">SQLite</a> 和 <a href="http://www.appcoda.com/introduction-to-core-data/" target="_blank" rel="external">Core Data</a>。我是 Core Data 的忠实粉丝，它对记录（records）的处理和持久化数据的能力非常强大，但是我意识到，在开发应用的过程中，我在 Core Data 上浪费了太多的时间。最近，我无意中发现了 Realm，一个可以替代 SQLite 和 Core Data 的更好的解决方案。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-db-1024x683.jpg" alt=""></p>
<!--more-->
<h2 id="Realm_是什么？">Realm 是什么？</h2><p>Realm 是一个跨平台的移动终端数据库，支持 iOS（Swift 和 Objective-C 语言都支持）和 Android。Realm 的目的就是提供比 SQLite 和 Core Data 更好更快的数据库支持。它不仅仅是更好和更快，而且更加易于使用，短短几行代码就可以完成很多操作。Realm 完全免费，你可以随意使用它。Realm 是为移动设备而生的，因为在过去的十年中，移动终端的数据库技术没有任何的革新。现在如果和移动终端的数据库打交道，你只有一种选择，使用 SQLite 或者是底层封装了 SQLite 的技术比如 Core Data。Realm 的目的是更加易用，它并不是一个建立在 SQLite 之上的 ORM，而是一个基于自己的持久化引擎，简单并且快速的面向对象移动数据库。</p>
<h2 id="为什么选择_Realm？">为什么选择 Realm？</h2><p><a href="https://realm.io/cn/" target="_blank" rel="external">Realm</a>拥有令人难以置信的速度并且使用起来非常简单，你会发现，无论是想完成数据库的读还是写操作，都只需要短短的几行代码。下面我会列出它的所有优势，并说明为什么 Realm 是你在移动应用上数据库的不二选择：</p>
<ul>
<li><p><strong>安装简单</strong>：在下一个章节 — 如何使用 Realm 中你会了解到，安装 Realm 会比你想象的更为简单。使用简单的 Cocoapods 命令，你就可以完成所有的安装工作。</p>
</li>
<li><p><strong>速度更快</strong>：使用 Realm 库操作数据库的速度非常快。它比 SQLite 和 CoreData 都更加快速，<a href="https://realm.io/news/introducing-realm/#fast" target="_blank" rel="external">这里</a>有它们之间的比较指标作为证据。</p>
</li>
<li><p><strong>跨平台</strong>：Realm 的数据库文件是跨平台的，可以在 iOS 和 Android 间共享。无论你是使用 Java、Objective-C 或者 Swift，都可以使用相同的抽象模型访问。</p>
</li>
<li><p><strong>易于扩展</strong>：如果你的移动应用需要处理大量的用户数据记录，数据库的可扩展性就显得十分重要。在开始着手开发应用之前，这一点就应该被考虑在内。Realm 提供很好的可扩展性，在操作大量的数据时，速度也非常之快。选择使用 Realm 可以为你的应用带来更快的速度和更加流畅的用户体验。</p>
</li>
<li><p><strong>规范的文档和很好的支持</strong>：Realm 提供了丰富的大量条理清晰、易于阅读的文档。如果你有任何的问题，你也可以通过 Twitter、Github 或 Stackoverflow 来获得帮助。</p>
</li>
<li><p><strong>可信任</strong>：Realm 已经被大量的初创公司和大公司用于它们的移动应用中，像 Pinterest、Dubsmash 和 Hipmunk。</p>
</li>
<li><p><strong>免费</strong>：除了以上这些极好的优点以外，它还是完！全！免！费！的！</p>
</li>
</ul>
<h2 id="让我们开始动手吧">让我们开始动手吧</h2><p>让我们开始学习 Realm，使用它来构建一个简单的使用 Swift 语言的 iPhone 应用。所完成的 demo 程序是一个简单的 Todo 应用。用户可以增加任务清单，每个任务清单都能够包含多个任务。任务拥有名称、备注、到期日期，可以添加图片，并且拥有一个布尔值来表示该任务是否已经完成。在开始创建 Xcode 项目之前，我们需要先配置好 Xcode，安装使用 Realm 所需的工具。</p>
<h2 id="环境要求">环境要求</h2><p>请注意需要满足下列要求</p>
<ul>
<li>iOS 8 及更高的版本，OS X 10.9 及更高的版本</li>
<li>Xcode 6.3 及更高版本</li>
<li>Realm 有两个发行版，一个针对 Swift 2.0，另一个针对 Swift 1.2。我们推荐您使用 Swift 2.0 的版本。当然你也可以使用针对 Swift 1.2 的版本，但是以后这个版本 Realm 不会再进行更新支持，所以为了保险起见，使用 Swift 2.0 对应的版本，是个更好的选择。</li>
</ul>
<h2 id="配置_Xcode_和所需的工具">配置 Xcode 和所需的工具</h2><p>在开始配置 Xcode 项目之前，请确保运行环境已经正确安装了 CocoaPods，我们将使用它来为项目安装 Realm。如果对 <a href="https://cocoapods.org/" target="_blank" rel="external">CocoaPods</a> 不熟悉，你可以查看在线的教程，这些教程的材料足够让你明白如何开始使用它。</p>
<p>现在，使用 <code>Single View Application</code> 项目模板创建一个 Xcode 工程，命名为 <code>RealmTasks</code> 或者其他你喜欢的名字。请确保选择 Swift 作为开发语言。之后在终端中进入到该工程目录，使用如下命令来初始化 CocoaPods：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure>
<p>然后使用 Xcode 打开生成的 Podfile 文件，在 target 之后，添加 <code>pod &#39;RealmSwift&#39;</code>，修改完之后，应该是下面这个样子：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-podfile-1024x430.png" alt=""></p>
<p>下面运行 <code>pod install</code> 命令来把 Realm 下载安装到项目中。完成之后，你会在你的工程文件目录发现一个新生成的 Xcode 工作空间。请确保打开 <strong>RealmTasks.xcworkspace</strong> 而不是 xcodeproj。打开工作空间后，你会看到像下面这样的情形：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-pod-folder-1024x446.png" alt=""></p>
<p>现在就可以在 Xcode 中使用 Realm 啦，但是我们将安装下面的小工具来让使用 Realm 的过程更加容易。</p>
<h2 id="在_Xcode_中安装_Realm_插件">在 Xcode 中安装 Realm 插件</h2><p>Realm 开发团队提供了一个生成 Realm 模型非常有用的插件。为了安装这个插件，我们要使用 <a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a>。如果你不知道 Alcatraz 是什么的话，这里解释一下，它是一个简单有用的开源包管理工具，它可以让你无需任何配置，自动地为 Xcode 安装插件、文件模板和颜色主题。为了安装 Alcatraz，你只需将以下代码复制到终端中执行，之后重启 Xcode：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>然后在 Xcode 中，选择 <code>Window</code> -&gt; <code>Package Manager</code>，如下图：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-package-manager-1024x334.png" alt=""></p>
<p>然后在弹出的窗口中，你可以选择安装你喜欢的插件或者文件模板，在搜索框中你可以搜索你喜欢的插件、配色。在搜索框输入「Realm」，在出现的结果中选择「RealmPlugin」，点击 <code>Install</code> 按钮</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-plugin-1024x996.png" alt=""></p>
<h2 id="Realm_浏览器">Realm 浏览器</h2><p>给大家介绍的最后一个工具是 Realm 浏览器。这个浏览器可以帮助你阅读和编辑你的 <code>.realm</code> 数据库文件。这些文件在应用程序中被创建，在数据库表中保存了所有的数据实体（entities）、属性（attributes）和记录（records）。之前我们说过，这些数据库文件可以在像 iOS 和 Android 这样不同的平台间共享。想要下载最新版本的 Realm 浏览器，请访问 <a href="https://itunes.apple.com/app/realm-browser/id1007457278" target="_blank" rel="external">iTunes store</a>。打开 Realm 浏览器，选择 <code>Tools</code> -&gt; <code>Generate demo database</code>。它会帮你生成 realm 数据库测试文件，你可以使用该浏览器打开和编辑它的内容。当你打开的时候，你会看到像下面的内容：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/browser.png" alt=""></p>
<p>正如你所见，在 RealmTestClass1 中，它拥有 1000 条记录，显示了多种不同的参数类型（即「列」）。我们会在下节介绍支持的属性类型。</p>
<p>现在，Realm 的所有准备工作都已就绪，那我们开始动手吧！</p>
<h2 id="数据模型类">数据模型类</h2><p>好戏才刚刚开始。首先我们来创建模型类或者说我们的数据库。为了创建 Realm 数据模型类，你只需要简单地新建一个普通的 Swift 类继承自 Object 就可以了。因为 Realm 数据模型类的基类是 Object，所以 Object 的子类都可以扩展为 Realm 的模型类。一旦创建类后，就可以添加属性了。Realm 支持以下多种数据类型：</p>
<p>– Int，Int8，Int16，Int32 和 Int64<br>– Boolean<br>– Float<br>– String<br>– NSDate<br>– NSData<br>– 继承自 Object 的类 =&gt; 作为一对一关系（Used for One-to-one relations）<br>– List<object> =&gt; 作为一对多关系（Used for one-to-many relations）</object></p>
<p>Realm 中的 List 可以包含多个 Object 实例，参考上面 demo 数据库的截图，最后一列表示在其他数据表中的存在的一组引用。在和 Realm 模型类打交道的时候，使用的方式和其他 Swift 类一样。例如，你可以添加方法或者遵循指定的协议。</p>
<p>多说无益，来看代码 😂</p>
<p>现在让我们使用之前在 Xcode 中安装的 Realm 插件来新建一个 Realm 类。打开 Xcode，新建文件，在右边的侧边栏选择 Realm：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm_model.png" alt=""></p>
<p>然后选择 Swift 语言，类名我们输入 Task。会得到如下结果：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Task_swift.png" alt=""></p>
<p>现在，可以向 Task 数据模型中添加属性了。</p>
<h2 id="属性">属性</h2><p>我们需要在数据模型中添加需要的属性。该例子中，Task 需要有 name（String），createdAt（NSDate)），notes（String），和 isCompleted（Bool）这些属性。添加这些之后，代码应该像下面这样子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> createdAt = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> notes = <span class="string">""</span></span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> isCompleted = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明让 Realm 忽略的属性（Realm 将不持有这些属性）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  override static func ignoredProperties() -&gt; [String] &#123;</span></span><br><span class="line"><span class="comment">//    return []</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经为 Task 模型类添加了属性，所有的属性前面都加了 <code>dynamic var</code> 前缀，这使得属性可以被数据库读写。</p>
<p>接下来，我们要创建 TaskList 模型类，用来存储 Task 实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskList</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> createdAt = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">let</span> tasks = <span class="type">List</span>&lt;<span class="type">Task</span>&gt;()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 声明让 Realm 忽略的属性（Realm 将不持有这些属性）</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//  override static func ignoredProperties() -&gt; [String] &#123;</span></span><br><span class="line"><span class="comment">//    return []</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TaskList 模型类拥有 name，createAt 和一个包含 Task 的 List 属性。需要注意的是：</p>
<ol>
<li>List<object> 用来表示一对多的关系：一个 TaskList 中拥有多个 Task。</object></li>
<li>List 和 Array 在使用上非常相似，所用的方法和访问数据的方式（索引和下标）都相同。正如你所见的一样，List 后标明了数据类型，所包含的所有对象都应该是相同类型的。</li>
<li>List<t> 是泛型，这也是为什么我们没有在声明前面加上 dynamic 的原因，因为在 Objective-C 运行时无法表示泛型属性。</t></li>
</ol>
<p>就像在之前实现中你看到的一对多关系那样，在 Realm 中创建数据关系非常简单。在使用一对一的关系时，我们不使用 List<t> 而是使用 Object 类型，来看下面的例子：</t></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">Object</span></span>&#123;</span><br><span class="line">  <span class="keyword">dynamic</span> <span class="keyword">var</span> owner:<span class="type">Person</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，owner 属性表示 Car 和 Person 之间的一对一数据关系。</p>
<p>现在基本的数据模型都已经创建好了。接下来我们会通过创建一个 ToDo 应用的过程，来讨论 Realm。首先，<a href="https://github.com/hossamghareeb/realmtasks" target="_blank" rel="external">从这里下载 app</a> 并且一窥究竟。在 Xcode 7 或更高的版本中运行，就像下面这样：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-todo-list-app-1024x661.png" alt=""></p>
<p>在项目中，我添加了两个视图控制器：TasksViewController 和 TaskListViewController。第一个视图控制器用来显示单个 task，第二个视图控制器用来显示所有的 TaskList。在 list 视图中，点击 + 按钮来添加一个任务清单。选择一个任务清单将会详情视图。你可以在这里添加多个 task。</p>
<p>了解了 demo 的大体思路之后，现在让我们来看看如何向 Realm 数据库中添加一个新的任务清单。为了实现这个功能，需要如下处理：</p>
<ol>
<li>创建 TaskList 实例对象，并将其保存到 Realm 数据库中。</li>
<li>向数据库中查询 list 数据，并更新 UI。</li>
</ol>
<p>为了在 Realm 中保存数据，你只需要实例化继承自 Object 的数据模型类，然后将对象写入到 Realm 中，下面是示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taskListA = <span class="type">TaskList</span>()</span><br><span class="line">taskListA.name = <span class="string">"Wishlist"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> wish1 = <span class="type">Task</span>()</span><br><span class="line">wish1.name = <span class="string">"iPhone6s"</span></span><br><span class="line">wish1.notes = <span class="string">"64 GB, Gold"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> wish2 = <span class="type">Task</span>(value: [<span class="string">"name"</span>: <span class="string">"Game Console"</span>, <span class="string">"notes"</span>: <span class="string">"Playstation 4, 1 TB"</span>])</span><br><span class="line"><span class="keyword">let</span> wish3 = <span class="type">Task</span>(value: [<span class="string">"Car"</span>, <span class="type">NSDate</span>(), <span class="string">"Auto R8"</span>, <span class="literal">false</span>])</span><br><span class="line"> </span><br><span class="line">taskListA.tasks.appendContentsOf([wish1, wish2, wish3])</span><br></pre></td></tr></table></figure>
<p>通过实例化 TaskList 类，我们创建了一个任务清单，之后设置了它的属性。随后我们创建了 3 个 Task 类型的对象（即 wish1，wish2 和 wish3）。这里我们演示了创建 Realm 对象的三种途径：</p>
<ol>
<li>wish1 的实例化方式：简单的实例化 Realm 类，然后设置属性。</li>
<li>wish2 的实例化方式：传入一个字典，字典中的 key 为属性名，值为要设置的值。</li>
<li>wish3 的实例化方式：使用数组传入的方式。数组中值的顺序需要和模型类中的声明顺序一致。</li>
</ol>
<h3 id="嵌套对象">嵌套对象</h3><p>在 Realm 中还可以是使用嵌套的方式来创建对象。在一对一关系和一对多关系的时候，你可以使用这种方式，这时候，一个类型对象的初始化需要一个 Object 或多个另一个类型的对象 List<object>。面临这种情况的时候，你可以选择上面的第二或者第三种方法，使用一个字典或者一个数组来表示一个对象。下面是嵌套对象的一个例子：</object></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taskListB = <span class="type">TaskList</span>(value: [<span class="string">"MoviesList"</span>, <span class="type">NSDate</span>(), [[<span class="string">"The Martian"</span>, <span class="type">NSDate</span>(), <span class="string">""</span>, <span class="literal">false</span>], [<span class="string">"The Maze Runner"</span>, <span class="type">NSDate</span>(), <span class="string">""</span>, <span class="literal">true</span>]]])</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了一个电影清单，并设置了清单名称、创建时间和清单内容，清单内容包括多个 task。每个 task 使用数组的方式来创建，例如 <code>[&quot;The Maze Runner&quot;, NSDate(), &quot;&quot;, true]</code> 表示一个 task，内容分别对应了名称、创建时间、备注和是否已经完成。</p>
<h2 id="使用_Realm_持久化对象">使用 Realm 持久化对象</h2><p>现在你应该知道了如何在 Realm 中创建和使用对象，但是为了能够在应用程序重新启动的时候使用这些数据，需要使用写事务将它们持久化到 Realm 的数据库中。当使用 Realm 来持久化数据的时候，只要这些对象已经存储成功，你可以在任何线程中获取这些对象。一个 Realm 实例表示一个 Realm 数据库。可以像下面一样实例化它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uiRealm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br></pre></td></tr></table></figure>
<p>我们常常将上面这行代码写在 <code>AppDelegate.swift</code> 文件的顶端（译者注：类之外，全局变量），这样就可以在整个项目中获得该对象的引用。之后便可以很方便地调用它的读和写方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uiRealm.write &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">  uiRealm.add([taskListA, taskListB])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，uiRealm 对象已经在 AppDelegate 中创建，在整个 app 中都可以使用。Realm 对象在每个线程中都应该只被创建一次，因为它不是线程安全的，不能在不同的线程中共享。如果你想要在另一个线程中执行写操作，那么就需要创建一个新的 Realm 对象。我将这个实例命名为 <code>uiRealm</code>，就是因为它应该只在 UI 线程中被使用。</p>
<p>现在让我们回到我们的 app 中，我们需要在用户点击 Create 按钮的时候保存任务列表。在 <code>TasksViewController</code> 的 <code>displayAlertToAddTask</code>方法中，我们有一个 <code>createAction</code> 对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createAction = <span class="type">UIAlertAction</span>(title: doneTitle, style: <span class="type">UIAlertActionStyle</span>.<span class="type">Default</span>) &#123; (action) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> taskName = alertController.textFields?.first?.text</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> updatedTask != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="comment">// update mode</span></span><br><span class="line">        uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            updatedTask.name = taskName!</span><br><span class="line">            <span class="keyword">self</span>.readTasksAndUpateUI()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> newTask = <span class="type">Task</span>()</span><br><span class="line">        newTask.name = taskName!</span><br><span class="line">        </span><br><span class="line">        uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.selectedList.tasks.append(newTask)</span><br><span class="line">            <span class="keyword">self</span>.readTasksAndUpateUI()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们从 TextField 中获取到任务名称，调用 Realm 的写方法来保存任务列表。</p>
<p><em>请注意，当你同时进行多个写操作的时候，他们会相互阻塞，阻塞住他们所运行的线程。所以应当考虑在 UI 之外的线程中来进行操作。另外需要注意的是，在进行写事务的时候，读操作并不会造成阻塞。这非常有用，尤其是当你在后台进行写操作的时候，用户可能会在不同界面切换，而这时候可以进行读操作。</em></p>
<h2 id="检索数据">检索数据</h2><p>现在你已经学会了如何在 Realm 中写数据，下面我们来看看如何检索数据。在 Realm 中检索数据的方式非常直观。Realm 提供了很多选项来过滤出你想要的数据。在 Realm 中进行查找操作的时候，它将会返回一个 Results 对象。可以把 Results 简单地当做是 Swift 的数组，因为它们的接口非常类似。</p>
<p>当得到 Results 实例的时候，这代表你已经从磁盘中直接获取到了数据。对这些数据的任何操作（使用事务）将会影响到磁盘上的数据。在 Realm 中来检索数据，只需要调用对象的方法，并将类名作为参数传进去。让我们看看如何使用这种方式来读取 TaskLists 并更新 UI：</p>
<p>我们在 <code>TasksListsViewController</code> 中定义了该属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lists : <span class="type">Results</span>&lt;<span class="type">TaskList</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>然后实现了 <code>readTasksAndUpdateUI</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">readTasksAndUpdateUI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    lists = uiRealm.objects(<span class="type">TaskList</span>)</span><br><span class="line">    <span class="keyword">self</span>.taskListsTableView.setEditing(<span class="literal">false</span>, animated: <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">self</span>.taskListsTableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>tableView(_:cellForRowAtIndexPath:_)</code> 方法中，我们将显示列表的名称，还有每个列表内的任务个数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"listCell"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> list = lists[indexPath.row]</span><br><span class="line">    </span><br><span class="line">    cell?.textLabel?.text = list.name</span><br><span class="line">    cell?.detailTextLabel?.text = <span class="string">"<span class="subst">\(list.tasks.<span class="built_in">count</span>)</span> Tasks"</span></span><br><span class="line">    <span class="keyword">return</span> cell!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑非常直观吧。最后需要做的就是在 <code>viewWillAppear</code> 中调用 <code>readTasksAndUpdateUI</code> 方法，来确保总是显示数据更新之后的视图。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">    readTasksAndUpdateUI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面展示了如何使用 Realm 来进行任务列表的读写操作。接下来，我们来看看如何进行数据更新和删除操作。在开始之前，先来看看项目模板中的修改和删除部分的相关代码。</p>
<p>首先在 <code>TaskListsViewController</code> 中，我们用一个布尔值 <code>isEditingMode</code> 来表示是在正常状态还是编辑状态：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEditingMode = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>当 Edit 按钮被点击的时候，将会调用 <code>didClickOnEditButton</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didClickOnEditButton</span><span class="params">(sender: UIBarButtonItem)</span></span> &#123;</span><br><span class="line">    isEditingMode = !isEditingMode</span><br><span class="line">    <span class="keyword">self</span>.taskListsTableView.setEditing(isEditingMode, animated: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会使用 table view 的 <code>setEditing</code> 方法来启用或禁用 UITableView 的编辑模式。在表格视图中，默认的编辑操作是删除，但是从 iOS 8.0 开始，增加了一个 <code>editActionsForRowAtIndexPath</code> 方法来自定义一些操作，这些操作在在用户滑动表格 cell 的时候出现。</p>
<p>我们将使用该方法来添加两个功能 — 删除和编辑，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, editActionsForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; [<span class="type">UITableViewRowAction</span>]? &#123;</span><br><span class="line">    <span class="keyword">let</span> deleteAction = <span class="type">UITableViewRowAction</span>(style: <span class="type">UITableViewRowActionStyle</span>.<span class="type">Destructive</span>, title: <span class="string">"Delete"</span>) &#123; (deleteAction, indexPath) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里开始是删除</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> listToBeDeleted = <span class="keyword">self</span>.lists[indexPath.row]</span><br><span class="line">        uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            uiRealm.delete(listToBeDeleted)</span><br><span class="line">            <span class="keyword">self</span>.readTasksAndUpdateUI()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> editAction = <span class="type">UITableViewRowAction</span>(style: <span class="type">UITableViewRowActionStyle</span>.<span class="type">Normal</span>, title: <span class="string">"Edit"</span>) &#123; (editAction, indexPath) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里开始是编辑</span></span><br><span class="line">        <span class="keyword">let</span> listToBeUpdated = <span class="keyword">self</span>.lists[indexPath.row]</span><br><span class="line">        <span class="keyword">self</span>.displayAlertToAddTaskList(listToBeUpdated)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [deleteAction, editAction]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用 <code>UITableViewRowAction</code> 添加了两个操作，方法中定义了操作的 <code>style</code>，<code>title</code> 和 <code>handler</code>。当在滑动 cell 或者以其他方式进入编辑模式的时候，会像下面这样：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/edit-mode-576x1024.png" alt=""></p>
<p>以上就是在进行删除和更新操作时候的 UI 代码逻辑。</p>
<h2 id="删除对象">删除对象</h2><p>想要从 Realm 数据库中删除对象或者数据，你只需要调用 Realm 对象的 <code>delete</code> 方法，同时将该对象作为参数传入。当然，这些操作会在写事务中完成。来看一下下面的代码的工作方式，我们从 Realm 数据库中删除了一个任务列表：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> listToBeDeleted = <span class="keyword">self</span>.lists[indexPath.row]</span><br><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">           uiRealm.delete(listToBeDeleted)</span><br><span class="line">           <span class="keyword">self</span>.readTasksAndUpdateUI()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在删除之后，我们调用了 <code>readTasksAndUpdateUI</code> 方法来读取数据并更新 UI。</p>
<p>除了删除单个数据，在 Realm 中，还有一个方法叫做 <code>deleteAll</code>，它允许你删除数据库中所有 class 的所有数据。如果你想为当前用户持久化数据，但是在他退出登录的时候抹掉所有的相关数据，这个方法将会十分有用。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    uiRealm.deleteAll()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="更新_Objects">更新 Objects</h2><p>在 Realm 中有多种方式可以来更新 object，但是这些方法都应该在写事务中完成。下面我们来看一些更新对象的方式。</p>
<h3 id="使用属性（Property）">使用属性（Property）</h3><p>你可以通过直接在 Realm 的写闭包中设置属性的值来更新数据。例如，在 <code>TasksViewController</code> 中，我们可以简单地设置属性值来更新任务的状态信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    task.isCompleted = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用主键（Primary_Key）">使用主键（Primary Key）</h3><p>Realm 支持将某个 string 或 int 类型的属性设置为主键。当使用 <code>add()</code> 方法来创建 Realm 对象时，如果有相同主键的对象存在，就会更新这个对象的值。下面是示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="type">User</span>()</span><br><span class="line">user.firstName = <span class="string">"John"</span></span><br><span class="line">user.lastName = <span class="string">"Smith"</span></span><br><span class="line">user.email = <span class="string">"example@example.com"</span></span><br><span class="line">user.id = <span class="number">1</span></span><br><span class="line"><span class="comment">// 更新 id 是 1 的用户</span></span><br><span class="line">realm.write &#123;</span><br><span class="line">            realm.add(user, update: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里的 id 属性为主键。如果 id 为 1 的用户存在，Realm 会更新相应的对象。如果不存在，Realm 将会把该对象存入数据库中。</p>
<h3 id="使用_KVC（Key-Value_Coding）">使用 KVC（Key-Value Coding）</h3><p>如果你是 iOS 开发的老手，那么对 Key-Value Coding 肯定不会陌生。Realm 的类型，像是 Object、Results 和 List，都可以使用 Key-Value Coding。该特性可以帮助你在运行时设置或更新属性值。另外一个在 List 和 Results 中支持 KVC 的好处是，可以在无需遍历每个对象的情况下，批量更新对象数据。这么说你可能不是很理解，我们来看个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tasks = uiRealm.objects(<span class="type">Task</span>)</span><br><span class="line">uiRealm.write &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    tasks.setValue(<span class="literal">true</span>, forKeyPath: <span class="string">"isCompleted"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用查询语句来请求所有的 Task 对象，之后将所有得到的对象的 <code>isCompleted</code> 属性设置为 true。可以看出，将 Realm 中的所有 tasks 标记为已完成，仅仅只用了一行代码。</p>
<p>让我们回过头来看看我们的 ToDo 应用。如果仔细观察 <code>displayAlertToAddTaskList</code> 方法，你会看到如下代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 更新状态</span></span><br><span class="line">uiRealm.write(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">          updatedList.name = listName!</span><br><span class="line">          <span class="keyword">self</span>.readTasksAndUpdateUI()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当用户遍历列表名称的时候，上面的代码会被调用。通过设置 name 属性的方式，就更新了数据库中的内容。</p>
<h2 id="显示任务项">显示任务项</h2><p>我们已经一起看过了 <code>TaskListViewController</code> 的绝大部分代码。现在让我们打开 <code>TasksViewController</code> 来看看，这个视图控制器用来显示任务清单中的任务项。视图控制器拥有一个 UITableView, 该视图有两个 section：完成的任务和未完成的任务。在 <code>TasksViewController</code> 中，有如下属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> selectedList : <span class="type">TaskList</span>!</span><br><span class="line"><span class="keyword">var</span> openTasks : <span class="type">Results</span>&lt;<span class="type">Task</span>&gt;!</span><br><span class="line"><span class="keyword">var</span> completedTasks : <span class="type">Results</span>&lt;<span class="type">Task</span>&gt;!</span><br></pre></td></tr></table></figure>
<p><code>selectedList</code> 用来存储 <code>TaskListsViewController</code> 传递过来的选中的任务列表。为了将完成和未完成的任务分开，声明了两个属性，<code>openTasks</code> 和 <code>completedTasks</code>。为了过滤出不同的任务完成状态，我们将使用 Realm 的方法 <code>filter()</code>。在解释该函数如何工作之前，让我们先来看看如何在代码中使用它：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">readTasksAndUpateUI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    completedTasks = <span class="keyword">self</span>.selectedList.tasks.<span class="built_in">filter</span>(<span class="string">"isCompleted = true"</span>)</span><br><span class="line">    openTasks = <span class="keyword">self</span>.selectedList.tasks.<span class="built_in">filter</span>(<span class="string">"isCompleted = false"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.tasksTableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的方法中，我们使用 <code>filter</code> 方法来过滤 <code>results</code>。Realm 提供了 <code>filter()</code> 方法来过滤数据。该方法可以被 List、Result 和 Object 对象调用。方法会返回过满足滤条件参数的特定对象。你可以把 <code>filter</code> 当做 <code>NSPredicate</code>。基本上来说，你可以认为这两者差不多。就像上面的代码一样，你同样可以使用 string 作为参数创建一个 <code>NSPredicate</code> 对象，并把它作为参数传给 <code>filter</code> 方法。</p>
<p>让我们来看另外一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用断言字符串</span></span><br><span class="line"><span class="keyword">var</span> redCars = realm.objects(<span class="type">Car</span>).<span class="built_in">filter</span>(<span class="string">"color = 'red' AND name BEGINSWITH 'BMW'"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用 NSPredicate</span></span><br><span class="line"><span class="keyword">let</span> aPredicate = <span class="type">NSPredicate</span>(format: <span class="string">"color = %@ AND name BEGINSWITH %@"</span>, <span class="string">"red"</span>, <span class="string">"BMW"</span>)</span><br><span class="line">redCars = realm.objects(<span class="type">Car</span>).<span class="built_in">filter</span>(aPredicate)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用 <code>filter</code> 方法来过滤 <code>color</code> 为 red，并且 <code>name</code> 以 “BMW” 开头的对象。第一行代码使用 string 作为参数来进行过滤。另外，你也可以使用 NSPredicate 获得同样的效果。下面的表格总结了 filter 方法的大部分常用操作：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/realm-database-info-1024x675.png" alt=""></p>
<h2 id="排序">排序</h2><p>既然我们谈到了 Realm 数据库的基本操作，在本教程结束之前，我还想给大家介绍另外一个特性。排序功能，这是 Realm 提供了另一个特别有用的特性。对于 List 和 Result 对象，你可以调用方法 <code>sorted（「排序标准」）</code> 来将一组数据进行排序。让我们来看看如何在任务列表中使用该方法让任务列表以字母表或者创建时间先后顺序排序。首先，在 UI 中，我们增加了一个 segment control，将会根据选择的情况来进行对应的排序。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/10/Simulator-Screen-Shot-Oct-24-2015-8.47.06-PM-576x1024.png" alt=""></p>
<p>根据不同的选择来进行排序，代码逻辑如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">didSelectSortCriteria</span><span class="params">(sender: UISegmentedControl)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sender.selectedSegmentIndex == <span class="number">0</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 按 A-Z 排序</span></span><br><span class="line">            <span class="keyword">self</span>.lists = <span class="keyword">self</span>.lists.sorted(<span class="string">"name"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 按日期排序</span></span><br><span class="line">            <span class="keyword">self</span>.lists = <span class="keyword">self</span>.lists.sorted(<span class="string">"createdAt"</span>, ascending:<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.taskListsTableView.reloadData()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>Realm 是一个非常简单易用，直观的本地数据库解决方案。Realm 提供了很好的可扩展性，只用很少的几行代码就可完成操作。对于大部分的应用甚至是游戏来说，我觉得如果需要使用数据库的话，Realm 值得尝试。</p>
<h2 id="下一步？">下一步？</h2><p>学习了本教程，你应该可以在项目中使用 Realm 来进行增删改查等基本的操作。Realm 还具有一些高阶特性，值得深入学习。最好的学习资料就是 Realm 网站的官方文档，Realm 的小伙伴把文档写得非常赞！</p>
<p>如果想要教程 ToDo 应用的的完整代码，你可以在<a href="https://github.com/hossamghareeb/realmtasks" target="_blank" rel="external">这里下载</a>。</p>
<p>如果对代码有任何的问题，都欢迎留言反馈，我们会很乐意帮助到您。</p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Hossam Ghareeb，<a href="http://www.appcoda.com/realm-database-swift/">原文链接</a>，原文日期：2015-10-28<br>译者：<a href="http://www.futantan.com">Prayer</a>；校对：<a href="https://github.com/Cee">Cee</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<p>智能手机的快速发展的同时，涌现出了很多对开发者友好的开发工具。这些工具不仅使得开发变得更加简单和容易，同时也保证了性能和产品质量。如今想要在 App Store 中占据一席之地，并非易事。而且想要使得应用易于扩展就更加困难了。当你成功获得百万量级的用户时，应用中的每一个细节都不能放过，并且需要在很短的时间完成对细节的打磨。所以和数据库打交道，是很多开发者都会面临的一个问题。]]>
    
    </summary>
    
      <category term="AppCoda" scheme="http://swiftggteam.github.io/tags/AppCoda/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS：选择 Realm 而不是 CoreData]]></title>
    <link href="http://swiftggteam.github.io/2015/12/08/ios-realm-instead-of-coredata/"/>
    <id>http://swiftggteam.github.io/2015/12/08/ios-realm-instead-of-coredata/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.990Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-realm-instead-of-coredata/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-29<br>译者：<a href="https://github.com/Cee" target="_blank" rel="external">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao" target="_blank" rel="external">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>我已在网上多次看到「Realm」这个词。我甚至曾在十月时有机会参加由 Swift 用户组组织的 Realm 聚会。最终，我有机会用上了 Realm 这个框架。</p>
</blockquote>
<a id="more"></a>
<h2 id="案例">案例</h2><p>现在我正在节食。我需要减一些体重因为在加利福尼亚的时候胖了好多 – 好吃的食物实在是太多了:)！我浏览了一下 iTunes Store 中的那些能够追踪喝水记录的应用，但是在我看来这些应用要么看上去很糟糕，要么交互实在是很烂。我想：如果我决定做一个应用，岂不是一箭双雕吗 – 我又能写一个我想要的应用，又能选择使用 Realm 而不是 Core Data。所以我开工了。</p>
<p>你知道当我看完文档、开始使用 Realm 框架的第一感觉是什么吗？<strong>哇，这简直真是太棒了！这些开发的家伙做的简直超棒！</strong></p>
<p><strong>免责声明：</strong>接下来所写的仅仅只覆盖了 Realm 框架中最基本的一部分。我建议你们接下来可以去阅读<a href="https://realm.io/docs/swift/latest/" target="_blank" rel="external">官方文档</a>来获取更多的信息。在这儿我并不想向你们展示关于 Realm 框架的全部内容，因为这篇文章不可能像文档一样又臭又长，并且我自己也会避免这样的问题发生。官方的文档非常的棒，你在开工前可以先读一下它。</p>
<p>我的这个案例并不是很复杂而是非常简单的。整个 app 只有两个抽象模型（Model）类： <code>Day</code> 和 <code>DrinkLogEntry</code> 。此外，这个 app 也需要这些功能：添加、更新、筛选和排序存储的数据。正如我所说这是个简单的 app 。接下来我会呈现 app 中的一些代码片段。</p>
<h2 id="抽象模型（Model）">抽象模型（Model）</h2><p>Realm 中没有像 xcdatamodel-like 这样的文件。抽象模型仅仅是继承自 <code>Object</code> 类的文件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> 表示了用户一天的生活。 Day 这个类的信息包含用户所喝的水和他们的每天喝水的目标。</span><br><span class="line">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Day</span>: <span class="title">Object</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> identifier: <span class="type">String</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 表示一天的开始的时间戳（UTC+0 时区）</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> timestamp: <span class="type">NSTimeInterval</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 用户所喝的水的量（毫升）</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> waterDrank: <span class="type">Float</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 用户每天喝水的目标（毫升）</span></span><br><span class="line">    <span class="keyword">dynamic</span> <span class="keyword">var</span> dailyGoal: <span class="type">Float</span> = <span class="number">0</span> <span class="comment">// ml</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> drinkLogs = <span class="type">List</span>&lt;<span class="type">DrinkLogEntry</span>&gt;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(timestamp: <span class="type">NSTimeInterval</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.timestamp = timestamp</span><br><span class="line">        <span class="keyword">self</span>.identifier = <span class="type">Day</span>.convertTimestampIntoIdentifier(timestamp)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">primaryKey</span>() -&gt; <span class="title">String</span>? </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"identifier"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">indexedProperties</span>() -&gt; [<span class="title">String</span>] </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"identifier"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">convertTimestampIntoIdentifier</span>(<span class="title">timestamp</span>: <span class="title">NSTimeInterval</span>) -&gt; <span class="title">String</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: <span class="string">"%.0f"</span>, arguments: [timestamp])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有前有 <code>dynamic</code> 关键字的属性都会被转化成数据抽象层的一部分。Realm 也支持关系型数据。在这个例子中 Day 这个类中存在 drinkLogs 的一对多关系。一对一的关系就仅是类中的特定属性了。</p>
<p>Realm 也支持从 Core Data 中迁移数据。当你需要迁移的时候，可以定义一个闭包并且执行它，然后你就能顺利地执行迁移属性的所有步骤了（译者注：<a href="https://realm.io/news/migrating-from-core-data-to-realm/" target="_blank" rel="external">如何从 Core Data 迁移到 Realm</a>）。</p>
<h2 id="索引属性（Indexed_properties）和主键（Primary_keys）">索引属性（Indexed properties）和主键（Primary keys）</h2><p>Realm 框架有很多 Core Data 中没有的新特性（也有可能是我没找到，或者说我就是想提一下这点😊）。第一点就是「索引属性」了。你可以定义需要被索引的属性集合。当属性个数比较小的时候，搜索会变得很快。这有助于性能的提升。</p>
<p>接下来不得不提一下「主键」。你可以定义抽象模型中的一个属性作为它的主键。这能保证更加有效地更新数据以及保证数据的唯一性。</p>
<p>在我使用的这个例子中，主键和索引属性将作为「标识符」，被用于搜索和更新数据。</p>
<p>数据中也可以有被忽略的属性，那些属性将不被持久化保存。</p>
<h2 id="创建、更新并写入数据">创建、更新并写入数据</h2><p>你可以使用未被持久化过的抽象模型，而且这些数据可以被持久化时，你可以将它们写入 Realm 中。比起 Core Data，这就是我为什么喜欢 Realm 更多一点 – 因为它能够很好地解决一些临时数据的问题。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> day = <span class="type">Day</span>(timestamp: timestamp)</span><br><span class="line">day.dailyGoal = <span class="type">MenuSettings</span>().dailyGoal</span><br></pre></td></tr></table></figure>
<p>为了能够写入 Realm 或者从 Realm 中读取，你需要创建 <code>Realm</code> 实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br></pre></td></tr></table></figure>
<p>这是如何将数据添加到数据库的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>! realm.write &#123;</span><br><span class="line">    realm.add(day)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我特别喜欢 Realm 中更新数据的方式。我们假设一下有一部分数据是从网络上下载的，并且他们被映射过而且已经加进了数据库。在数据库中已经存在的数据仅需要更新而不是再次添加。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fetchAll</span><span class="params">(completion: [Day] -&gt; Void)</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     假设请求返回了 JSON 并且数据已经映射到了抽象数据层的 Day 类型。</span><br><span class="line">          </span><br><span class="line">     创建的数据还没有存入数据库 Realm 中。</span><br><span class="line">     数据的标识符是相等的时间戳。</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">let</span> day1 = <span class="type">Day</span>(timestamp: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> day2 = <span class="type">Day</span>(timestamp: <span class="number">86400</span>)</span><br><span class="line">    <span class="keyword">let</span> day3 = <span class="type">Day</span>(timestamp: <span class="number">172800</span>)</span><br><span class="line">    </span><br><span class="line">    completion([day1, day2, day3])</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fetchAll &#123; (days) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> realm = <span class="keyword">try</span>! <span class="type">Realm</span>()</span><br><span class="line">        <span class="keyword">try</span>! realm.write &#123;</span><br><span class="line">            <span class="comment">/// 如果有相同的标识符，那么它将会被更新。</span></span><br><span class="line">            realm.add(days, update: <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种比手动查询带有相同标识符然后更新值域更好的方法。</p>
<p>如果更新的参数被置为 false，那么新的数据将具有和在数据库中存在的数据相同的主键。异常会被抛出。</p>
<p>还有其他一些方法来更新数据，在这篇文章中我就不涉及了。</p>
<p>这是如何得到所有 Day 类型数据的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> days = realm.objects(<span class="type">Day</span>.<span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<p>筛选数据也很简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">realm.objects(<span class="type">Day</span>.<span class="keyword">self</span>).<span class="built_in">filter</span>(<span class="string">"identifier == %@"</span>, dayIdentifier)</span><br></pre></td></tr></table></figure>
<p>按照时间戳升序排列这些数据：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> days = realm.objects(<span class="type">Day</span>.<span class="keyword">self</span>).sorted(<span class="string">"timestamp"</span>, ascending: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>当你每次执行 <code>object()</code>、<code>sorted()</code> 和 <code>filter()</code> 后均会得到一个 <code>Results&lt;T&gt;</code> 类型的数据。这能让你对结果进行额外的筛选排序等操作 - 这功能非常的强大而且非常好使。</p>
<h2 id="小结">小结</h2><p>在下一个有更加复杂的数据模型的 app 中<strong>我还会使用</strong> Realm 吗？答案是<strong>肯定</strong>的。因为整个框架使用起来非常的简单、集成起来非常的快速，而且 Realm 提供了非常多而且强大的功能特性。</p>
<p>P.S. 这个 app 正在等待过审 :)</p>
<p>2015/12/06更新<br>这个应用上架了 - <a href="https://itunes.apple.com/pl/app/water-intake-drink-more-water/id1062053347?mt=8" target="_blank" rel="external">Water Intake</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Tomasz Szulc，<a href="http://szulctomasz.com/ios-realm-instead-of-coredata/">原文链接</a>，原文日期：2015-11-29<br>译者：<a href="https://github.com/Cee">Cee</a>；校对：<a href="http://weibo.com/xiaoxxiao">千叶知风</a>；定稿：<a href="http://weibo.com/xiaoxxiao">千叶知风</a></p>
</blockquote>
<!--此处开始正文-->
<blockquote>
<p>我已在网上多次看到「Realm」这个词。我甚至曾在十月时有机会参加由 Swift 用户组组织的 Realm 聚会。最终，我有机会用上了 Realm 这个框架。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Tomasz Szulc" scheme="http://swiftggteam.github.io/tags/Tomasz-Szulc/"/>
    
      <category term="Swift 入门" scheme="http://swiftggteam.github.io/categories/Swift-%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[几个 Swift 代码规范]]></title>
    <link href="http://swiftggteam.github.io/2015/12/07/a-handful-of-swift-style-rules-swiftlang/"/>
    <id>http://swiftggteam.github.io/2015/12/07/a-handful-of-swift-style-rules-swiftlang/</id>
    <published>2015-12-06T16:00:00.000Z</published>
    <updated>2015-12-29T13:05:21.990Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/17/a-handful-of-swift-style-rules-swiftlang/" target="_blank" rel="external">原文链接</a>，原文日期：2015-11-17<br>译者：<a href="http://blog.csdn.net/mmoaay" target="_blank" rel="external">mmoaay</a>；校对：<a href="http://weibo.com/lfbWb" target="_blank" rel="external">lfb_CD</a>；定稿：<a href="http://codebuild.me/" target="_blank" rel="external">shanks</a></p>
</blockquote>
<p>我们需要经常带着新问题来重新审视一下以前的代码规范。</p>
<a id="more"></a>
<p><strong><a href="http://twitter.com/Eridius" target="_blank" rel="external">Kevin</a> 提供的一套规范</strong>：“如果尾部的闭包参数是函数式的就用圆括号。如果是程序式的就用花括号。”</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="tag">myCollection</span><span class="class">.map</span>(&#123;<span class="tag">blah</span>&#125;)<span class="class">.filter</span>(&#123;<span class="tag">blah</span>&#125;)<span class="class">.etc</span></span><br><span class="line"><span class="tag">myCollection</span><span class="class">.forEach</span> &#123;&#125; <span class="comment">// 或者 </span></span><br><span class="line"><span class="function">dispatch_after</span>(when, queue) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>样式一致性与闭包是否有返回值相关。目前存在的争议是我们是否应该在尾部花括号的左边留空格。</p>
<p><strong><code>self</code> 的使用规范</strong>：“当<a href="http://ericasadun.com/2015/04/21/swift-occams-code-razor/" target="_blank" rel="external">编译器可以自动推断</a>成员类型时，你就可以在使用隐式成员表达式时省略 <code>self</code>。但无论何时，只要一个方法调用会反射到一个实例，就要使用 <code>self</code>。“</p>
<p>仔细考虑下面 <code>for</code> 循环语句中的 <code>where</code> 分支。<code>contains</code> 方法就是在没有明确对象的情况下调用的。那是谁做了 <code>contains</code> 操作呢? 因为方法参数中没有传入容器对象，所以这个对象只能是调用这个方法的实例。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (flagLessOne, <span class="type">string</span>) <span class="keyword">in</span> strings.enumerate() </span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">contains</span>(</span><br><span class="line">        Features(rawValue: <span class="number">1</span>&lt;&lt;(flagLessOne + <span class="number">1</span>))) &#123;</span><br><span class="line">    nameArray.append(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全合格的调用明确指出了原本模糊不清的对象，同时极大滴提高了代码的可读性：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (flagLessOne, <span class="type">string</span>) <span class="keyword">in</span> strings.enumerate() </span><br><span class="line">    <span class="keyword">where</span> self.<span class="keyword">contains</span>(</span><br><span class="line">        Features(rawValue: <span class="number">1</span>&lt;&lt;(flagLessOne + <span class="number">1</span>))) &#123;</span><br><span class="line">    nameArray.append(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件级联绑定的规范</strong>：“除非你做的是 <code>var</code> 和 <code>let</code> 混合的条件绑定，只用一个 <code>if let</code> 或者 <code>if var</code> 就可以了，需要的话可以自由添加空格。“</p>
<p>不要使用下面的方式：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = x, <span class="keyword">let</span> y = y, <span class="keyword">let</span> z = z &#123;blah&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> x = x, y = y, z = z &#123;blah&#125;</span><br></pre></td></tr></table></figure>
<p>省略多余的 <code>let</code> 关键字可以让级联绑定更加简洁，而且 Xcode 会帮你对这些代码的格式进行很好的调整：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span></span><br><span class="line">    x = x,</span><br><span class="line">    y = y,</span><br><span class="line">    z = z &#123;</span><br><span class="line">    <span class="attribute">...</span>blah<span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管级联绑定避免了 pre-Swift 2 中的“鞭尸金字塔(pyramids of doom)“，但它们又导致了“恐怖便秘块(constipated blocks of horror)“的问题。这种问题主要出现在下面两种情况：</p>
<ul>
<li>存在大量的串行绑定，再加上空行和注释时（就像下面的代码）</li>
<li>使用了一系列 <code>guard</code> 语句时。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span></span><br><span class="line">    <span class="comment">// 以字典的方式访问 JSON </span></span><br><span class="line">    json = json <span class="keyword">as</span>? NSDictionary,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查结果数组</span></span><br><span class="line">    resultsList = json[<span class="string">"results"</span>] <span class="keyword">as</span>? NSArray,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取第一项</span></span><br><span class="line">    results = resultsList.firstObject <span class="keyword">as</span>? NSDictionary,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取名字和价格</span></span><br><span class="line">    name = results[<span class="string">"trackName"</span>] <span class="keyword">as</span>? <span class="built_in">String</span>, </span><br><span class="line">    price = results[<span class="string">"price"</span>] <span class="keyword">as</span>? NSNumber &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... blah blah ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>模式匹配关键字的规范</strong>：“如果都是绑定，那就要把绑定组合起来。”</p>
<p>通过把关键字移动到元组外面的方式来把多模式匹配绑定组合起来。将下面的代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> (<span class="built_in">let</span> x?, <span class="built_in">let</span> y?) = myOptionalTuple &#123;</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="built_in">let</span> (x?, y?) = myOptionalTuple &#123;</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>isEmpty</code> 的使用规范</strong>：“如果你在检测一个集合元素的个数，你可能就是在犯错。”用 <code>isEmpty</code> 替换 <code>count == 0</code>。</p>
<p><strong><code>void</code> 的使用规范</strong>：“使用 <code>void</code> 返回类型，而不是 <code>()</code>。”下面是一个返回 <code>-&gt; Void</code> 而不是 <code>-&gt; ()</code> 的方法。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doThis</span><span class="params">()</span> -&gt; <span class="title">Void</span> </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notThis</span><span class="params">()</span> -&gt; <span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong><code>!</code> 的使用规范</strong>：“每当你在 Swift 中用惊叹号的时候，一只小猫就会死。”尽可能的避免使用强制转换和强制解包。</p>
<p><strong>创建集合的规范</strong>：“使用显式类型和空集合。”类型在赋值操作符的左边，空实例在赋值操作符的右边。</p>
<p>把下面的代码：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">var x = [<span class="link_label">String: Int</span>](<span class="link_url"></span>) // 以及</span><br><span class="line">var y = [<span class="link_label">Double</span>](<span class="link_url"></span>)</span><br><span class="line">var z = Set<span class="xml"><span class="tag">&lt;<span class="title">String</span>&gt;</span></span>()</span><br><span class="line">var mySet = MyOptionSet()</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> x</span>: [String: <span class="typename">Int</span>] = [:]</span><br><span class="line"><span class="variable"><span class="keyword">var</span> y</span>: [<span class="typename">Double</span>] = []</span><br><span class="line"><span class="variable"><span class="keyword">var</span> z</span>: Set<span class="type">&lt;String&gt;</span> = []</span><br><span class="line"><span class="variable"><span class="keyword">var</span> mySet</span>: MyOptionSet = []</span><br></pre></td></tr></table></figure>
<p><a href="https://twitter.com/_jackhl/status/646723367576276992" target="_blank" rel="external">引用</a></p>
<p>“<a href="http://mikeash.com/" target="_blank" rel="external">Mike Ash</a>”的冒号规范：“右侧加上空格，而左侧不需要。”Or no soup for you!</p>
<p>应该使用：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">[key: <span class="keyword">value</span>] <span class="comment">// 以及</span></span><br><span class="line"><span class="keyword">struct</span> Foo: MyProtocol</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">[key : value]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> : <span class="title">MyProtocol</span></span></span><br></pre></td></tr></table></figure>
<p><strong>从 Objective-C 过来的规范</strong>：</p>
<ul>
<li>不要在 if 和 switch 条件两边或者 return 关键词上加 Objective-C 样式的圆括号。</li>
<li>为所有常量使用“骆驼拼写法”，如 allTheConstants 而不是 ALL_CAPS</li>
<li>用 Swift 的构造器替代传统的，例如：用 <code>CGPoint(x: 1, y:1)</code> 替代 <code>CGPointMake(1, 1)</code></li>
<li>避免使用行尾分号，尽管这样是可以编译通过的。但是它们会让你的代码看起来很糟糕，而且用起来体验也很差。</li>
</ul>
<p><strong>更新</strong></p>
<p>当然，这不是说说而已，我已经在代码中进行了实践：</p>
<p><img src="/img/articles/a-handful-of-swift-style-rules-swiftlang/Screen-Shot-2015-11-18-at-10.31.13-AM.png1449449055.5795417" alt="这里写图片描述"></p>
<p>github <a href="https://github.com/erica/testlint" target="_blank" rel="external">代码地址</a></p>
<blockquote>
<p>本文由 SwiftGG 翻译组翻译，已经获得作者翻译授权，最新文章请访问 <a href="http://swift.gg" target="_blank" rel="external">http://swift.gg</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>作者：Erica Sadun，<a href="http://ericasadun.com/2015/11/17/a-handful-of-swift-style-rules-swiftlang/">原文链接</a>，原文日期：2015-11-17<br>译者：<a href="http://blog.csdn.net/mmoaay">mmoaay</a>；校对：<a href="http://weibo.com/lfbWb">lfb_CD</a>；定稿：<a href="http://codebuild.me/">shanks</a></p>
</blockquote>
<p>我们需要经常带着新问题来重新审视一下以前的代码规范。</p>]]>
    
    </summary>
    
      <category term="Erica Sadun" scheme="http://swiftggteam.github.io/tags/Erica-Sadun/"/>
    
      <category term="Swift 进阶" scheme="http://swiftggteam.github.io/categories/Swift-%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
</feed>
